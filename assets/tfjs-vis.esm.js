var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module4) => () => {
  if (!module4) {
    module4 = {exports: {}};
    callback(module4.exports, module4);
  }
  return module4.exports;
};
var __export = (target, all) => {
  for (var name4 in all)
    __defProp(target, name4, {get: all[name4], enumerable: true});
};
var __exportStar = (target, module4, desc) => {
  if (module4 && typeof module4 === "object" || typeof module4 === "function") {
    for (let key2 of __getOwnPropNames(module4))
      if (!__hasOwnProp.call(target, key2) && key2 !== "default")
        __defProp(target, key2, {get: () => module4[key2], enumerable: !(desc = __getOwnPropDesc(module4, key2)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module4) => {
  if (module4 && module4.__esModule)
    return module4;
  return __exportStar(__markAsModule(__defProp(module4 != null ? __create(__getProtoOf(module4)) : {}, "default", {value: module4, enumerable: true})), module4);
};

// node_modules/json-stringify-pretty-compact/index.js
var require_json_stringify_pretty_compact = __commonJS((exports, module4) => {
  "use strict";
  var stringOrChar = /("(?:[^\\"]|\\.)*")|[:,]/g;
  module4.exports = function stringify5(passedObj, options2) {
    var indent, maxLength, replacer2;
    options2 = options2 || {};
    indent = JSON.stringify([1], void 0, options2.indent === void 0 ? 2 : options2.indent).slice(2, -3);
    maxLength = indent === "" ? Infinity : options2.maxLength === void 0 ? 80 : options2.maxLength;
    replacer2 = options2.replacer;
    return function _stringify(obj, currentIndent, reserved) {
      var end, index4, items2, key2, keyPart, keys4, length3, nextIndent, prettified, start, string, value3;
      if (obj && typeof obj.toJSON === "function") {
        obj = obj.toJSON();
      }
      string = JSON.stringify(obj, replacer2);
      if (string === void 0) {
        return string;
      }
      length3 = maxLength - currentIndent.length - reserved;
      if (string.length <= length3) {
        prettified = string.replace(stringOrChar, function(match3, stringLiteral) {
          return stringLiteral || match3 + " ";
        });
        if (prettified.length <= length3) {
          return prettified;
        }
      }
      if (replacer2 != null) {
        obj = JSON.parse(string);
        replacer2 = void 0;
      }
      if (typeof obj === "object" && obj !== null) {
        nextIndent = currentIndent + indent;
        items2 = [];
        index4 = 0;
        if (Array.isArray(obj)) {
          start = "[";
          end = "]";
          length3 = obj.length;
          for (; index4 < length3; index4++) {
            items2.push(_stringify(obj[index4], nextIndent, index4 === length3 - 1 ? 0 : 1) || "null");
          }
        } else {
          start = "{";
          end = "}";
          keys4 = Object.keys(obj);
          length3 = keys4.length;
          for (; index4 < length3; index4++) {
            key2 = keys4[index4];
            keyPart = JSON.stringify(key2) + ": ";
            value3 = _stringify(obj[key2], nextIndent, keyPart.length + (index4 === length3 - 1 ? 0 : 1));
            if (value3 !== void 0) {
              items2.push(keyPart + value3);
            }
          }
        }
        if (items2.length > 0) {
          return [start, indent + items2.join(",\n" + nextIndent), end].join("\n" + currentIndent);
        }
      }
      return string;
    }(passedObj, "", 0);
  };
});

// node_modules/vega-embed/node_modules/semver/internal/constants.js
var require_constants = __commonJS((exports, module4) => {
  var SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  module4.exports = {
    SEMVER_SPEC_VERSION,
    MAX_LENGTH,
    MAX_SAFE_INTEGER,
    MAX_SAFE_COMPONENT_LENGTH
  };
});

// node_modules/vega-embed/node_modules/semver/internal/debug.js
var require_debug = __commonJS((exports, module4) => {
  var debug4 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
  };
  module4.exports = debug4;
});

// node_modules/vega-embed/node_modules/semver/internal/re.js
var require_re = __commonJS((exports, module4) => {
  var {MAX_SAFE_COMPONENT_LENGTH} = require_constants();
  var debug4 = require_debug();
  exports = module4.exports = {};
  var re4 = exports.re = [];
  var src = exports.src = [];
  var t = exports.t = {};
  var R = 0;
  var createToken = (name4, value3, isGlobal) => {
    const index4 = R++;
    debug4(index4, value3);
    t[name4] = index4;
    src[index4] = value3;
    re4[index4] = new RegExp(value3, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
  createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
  createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
  createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
  createToken("FULL", `^${src[t.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
  createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
  createToken("COERCERTL", src[t.COERCE], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
});

// node_modules/vega-embed/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS((exports, module4) => {
  var opts = ["includePrerelease", "loose", "rtl"];
  var parseOptions = (options2) => !options2 ? {} : typeof options2 !== "object" ? {loose: true} : opts.filter((k) => options2[k]).reduce((options3, k) => {
    options3[k] = true;
    return options3;
  }, {});
  module4.exports = parseOptions;
});

// node_modules/vega-embed/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS((exports, module4) => {
  var numeric = /^[0-9]+$/;
  var compareIdentifiers = (a2, b2) => {
    const anum = numeric.test(a2);
    const bnum = numeric.test(b2);
    if (anum && bnum) {
      a2 = +a2;
      b2 = +b2;
    }
    return a2 === b2 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a2 < b2 ? -1 : 1;
  };
  var rcompareIdentifiers = (a2, b2) => compareIdentifiers(b2, a2);
  module4.exports = {
    compareIdentifiers,
    rcompareIdentifiers
  };
});

// node_modules/vega-embed/node_modules/semver/classes/semver.js
var require_semver = __commonJS((exports, module4) => {
  var debug4 = require_debug();
  var {MAX_LENGTH, MAX_SAFE_INTEGER} = require_constants();
  var {re: re4, t} = require_re();
  var parseOptions = require_parse_options();
  var {compareIdentifiers} = require_identifiers();
  var SemVer = class {
    constructor(version8, options2) {
      options2 = parseOptions(options2);
      if (version8 instanceof SemVer) {
        if (version8.loose === !!options2.loose && version8.includePrerelease === !!options2.includePrerelease) {
          return version8;
        } else {
          version8 = version8.version;
        }
      } else if (typeof version8 !== "string") {
        throw new TypeError(`Invalid Version: ${version8}`);
      }
      if (version8.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      }
      debug4("SemVer", version8, options2);
      this.options = options2;
      this.loose = !!options2.loose;
      this.includePrerelease = !!options2.includePrerelease;
      const m2 = version8.trim().match(options2.loose ? re4[t.LOOSE] : re4[t.FULL]);
      if (!m2) {
        throw new TypeError(`Invalid Version: ${version8}`);
      }
      this.raw = version8;
      this.major = +m2[1];
      this.minor = +m2[2];
      this.patch = +m2[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m2[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m2[4].split(".").map((id4) => {
          if (/^[0-9]+$/.test(id4)) {
            const num = +id4;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id4;
        });
      }
      this.build = m2[5] ? m2[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug4("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a2 = this.prerelease[i];
        const b2 = other.prerelease[i];
        debug4("prerelease compare", i, a2, b2);
        if (a2 === void 0 && b2 === void 0) {
          return 0;
        } else if (b2 === void 0) {
          return 1;
        } else if (a2 === void 0) {
          return -1;
        } else if (a2 === b2) {
          continue;
        } else {
          return compareIdentifiers(a2, b2);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a2 = this.build[i];
        const b2 = other.build[i];
        debug4("prerelease compare", i, a2, b2);
        if (a2 === void 0 && b2 === void 0) {
          return 0;
        } else if (b2 === void 0) {
          return 1;
        } else if (a2 === void 0) {
          return -1;
        } else if (a2 === b2) {
          continue;
        } else {
          return compareIdentifiers(a2, b2);
        }
      } while (++i);
    }
    inc(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.format();
      this.raw = this.version;
      return this;
    }
  };
  module4.exports = SemVer;
});

// node_modules/vega-embed/node_modules/semver/functions/parse.js
var require_parse = __commonJS((exports, module4) => {
  var {MAX_LENGTH} = require_constants();
  var {re: re4, t} = require_re();
  var SemVer = require_semver();
  var parseOptions = require_parse_options();
  var parse6 = (version8, options2) => {
    options2 = parseOptions(options2);
    if (version8 instanceof SemVer) {
      return version8;
    }
    if (typeof version8 !== "string") {
      return null;
    }
    if (version8.length > MAX_LENGTH) {
      return null;
    }
    const r2 = options2.loose ? re4[t.LOOSE] : re4[t.FULL];
    if (!r2.test(version8)) {
      return null;
    }
    try {
      return new SemVer(version8, options2);
    } catch (er) {
      return null;
    }
  };
  module4.exports = parse6;
});

// node_modules/vega-embed/node_modules/semver/functions/valid.js
var require_valid = __commonJS((exports, module4) => {
  var parse6 = require_parse();
  var valid = (version8, options2) => {
    const v = parse6(version8, options2);
    return v ? v.version : null;
  };
  module4.exports = valid;
});

// node_modules/vega-embed/node_modules/semver/functions/clean.js
var require_clean = __commonJS((exports, module4) => {
  var parse6 = require_parse();
  var clean = (version8, options2) => {
    const s = parse6(version8.trim().replace(/^[=v]+/, ""), options2);
    return s ? s.version : null;
  };
  module4.exports = clean;
});

// node_modules/vega-embed/node_modules/semver/functions/inc.js
var require_inc = __commonJS((exports, module4) => {
  var SemVer = require_semver();
  var inc = (version8, release, options2, identifier) => {
    if (typeof options2 === "string") {
      identifier = options2;
      options2 = void 0;
    }
    try {
      return new SemVer(version8, options2).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  };
  module4.exports = inc;
});

// node_modules/vega-embed/node_modules/semver/functions/compare.js
var require_compare = __commonJS((exports, module4) => {
  var SemVer = require_semver();
  var compare4 = (a2, b2, loose) => new SemVer(a2, loose).compare(new SemVer(b2, loose));
  module4.exports = compare4;
});

// node_modules/vega-embed/node_modules/semver/functions/eq.js
var require_eq = __commonJS((exports, module4) => {
  var compare4 = require_compare();
  var eq = (a2, b2, loose) => compare4(a2, b2, loose) === 0;
  module4.exports = eq;
});

// node_modules/vega-embed/node_modules/semver/functions/diff.js
var require_diff = __commonJS((exports, module4) => {
  var parse6 = require_parse();
  var eq = require_eq();
  var diff2 = (version1, version22) => {
    if (eq(version1, version22)) {
      return null;
    } else {
      const v1 = parse6(version1);
      const v2 = parse6(version22);
      const hasPre = v1.prerelease.length || v2.prerelease.length;
      const prefix = hasPre ? "pre" : "";
      const defaultResult = hasPre ? "prerelease" : "";
      for (const key2 in v1) {
        if (key2 === "major" || key2 === "minor" || key2 === "patch") {
          if (v1[key2] !== v2[key2]) {
            return prefix + key2;
          }
        }
      }
      return defaultResult;
    }
  };
  module4.exports = diff2;
});

// node_modules/vega-embed/node_modules/semver/functions/major.js
var require_major = __commonJS((exports, module4) => {
  var SemVer = require_semver();
  var major = (a2, loose) => new SemVer(a2, loose).major;
  module4.exports = major;
});

// node_modules/vega-embed/node_modules/semver/functions/minor.js
var require_minor = __commonJS((exports, module4) => {
  var SemVer = require_semver();
  var minor = (a2, loose) => new SemVer(a2, loose).minor;
  module4.exports = minor;
});

// node_modules/vega-embed/node_modules/semver/functions/patch.js
var require_patch = __commonJS((exports, module4) => {
  var SemVer = require_semver();
  var patch2 = (a2, loose) => new SemVer(a2, loose).patch;
  module4.exports = patch2;
});

// node_modules/vega-embed/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS((exports, module4) => {
  var parse6 = require_parse();
  var prerelease = (version8, options2) => {
    const parsed = parse6(version8, options2);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  module4.exports = prerelease;
});

// node_modules/vega-embed/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS((exports, module4) => {
  var compare4 = require_compare();
  var rcompare = (a2, b2, loose) => compare4(b2, a2, loose);
  module4.exports = rcompare;
});

// node_modules/vega-embed/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS((exports, module4) => {
  var compare4 = require_compare();
  var compareLoose = (a2, b2) => compare4(a2, b2, true);
  module4.exports = compareLoose;
});

// node_modules/vega-embed/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS((exports, module4) => {
  var SemVer = require_semver();
  var compareBuild = (a2, b2, loose) => {
    const versionA = new SemVer(a2, loose);
    const versionB = new SemVer(b2, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  module4.exports = compareBuild;
});

// node_modules/vega-embed/node_modules/semver/functions/sort.js
var require_sort = __commonJS((exports, module4) => {
  var compareBuild = require_compare_build();
  var sort2 = (list, loose) => list.sort((a2, b2) => compareBuild(a2, b2, loose));
  module4.exports = sort2;
});

// node_modules/vega-embed/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS((exports, module4) => {
  var compareBuild = require_compare_build();
  var rsort = (list, loose) => list.sort((a2, b2) => compareBuild(b2, a2, loose));
  module4.exports = rsort;
});

// node_modules/vega-embed/node_modules/semver/functions/gt.js
var require_gt = __commonJS((exports, module4) => {
  var compare4 = require_compare();
  var gt = (a2, b2, loose) => compare4(a2, b2, loose) > 0;
  module4.exports = gt;
});

// node_modules/vega-embed/node_modules/semver/functions/lt.js
var require_lt = __commonJS((exports, module4) => {
  var compare4 = require_compare();
  var lt = (a2, b2, loose) => compare4(a2, b2, loose) < 0;
  module4.exports = lt;
});

// node_modules/vega-embed/node_modules/semver/functions/neq.js
var require_neq = __commonJS((exports, module4) => {
  var compare4 = require_compare();
  var neq = (a2, b2, loose) => compare4(a2, b2, loose) !== 0;
  module4.exports = neq;
});

// node_modules/vega-embed/node_modules/semver/functions/gte.js
var require_gte = __commonJS((exports, module4) => {
  var compare4 = require_compare();
  var gte = (a2, b2, loose) => compare4(a2, b2, loose) >= 0;
  module4.exports = gte;
});

// node_modules/vega-embed/node_modules/semver/functions/lte.js
var require_lte = __commonJS((exports, module4) => {
  var compare4 = require_compare();
  var lte = (a2, b2, loose) => compare4(a2, b2, loose) <= 0;
  module4.exports = lte;
});

// node_modules/vega-embed/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS((exports, module4) => {
  var eq = require_eq();
  var neq = require_neq();
  var gt = require_gt();
  var gte = require_gte();
  var lt = require_lt();
  var lte = require_lte();
  var cmp = (a2, op, b2, loose) => {
    switch (op) {
      case "===":
        if (typeof a2 === "object")
          a2 = a2.version;
        if (typeof b2 === "object")
          b2 = b2.version;
        return a2 === b2;
      case "!==":
        if (typeof a2 === "object")
          a2 = a2.version;
        if (typeof b2 === "object")
          b2 = b2.version;
        return a2 !== b2;
      case "":
      case "=":
      case "==":
        return eq(a2, b2, loose);
      case "!=":
        return neq(a2, b2, loose);
      case ">":
        return gt(a2, b2, loose);
      case ">=":
        return gte(a2, b2, loose);
      case "<":
        return lt(a2, b2, loose);
      case "<=":
        return lte(a2, b2, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  module4.exports = cmp;
});

// node_modules/vega-embed/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS((exports, module4) => {
  var SemVer = require_semver();
  var parse6 = require_parse();
  var {re: re4, t} = require_re();
  var coerce = (version8, options2) => {
    if (version8 instanceof SemVer) {
      return version8;
    }
    if (typeof version8 === "number") {
      version8 = String(version8);
    }
    if (typeof version8 !== "string") {
      return null;
    }
    options2 = options2 || {};
    let match3 = null;
    if (!options2.rtl) {
      match3 = version8.match(re4[t.COERCE]);
    } else {
      let next;
      while ((next = re4[t.COERCERTL].exec(version8)) && (!match3 || match3.index + match3[0].length !== version8.length)) {
        if (!match3 || next.index + next[0].length !== match3.index + match3[0].length) {
          match3 = next;
        }
        re4[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }
      re4[t.COERCERTL].lastIndex = -1;
    }
    if (match3 === null)
      return null;
    return parse6(`${match3[2]}.${match3[3] || "0"}.${match3[4] || "0"}`, options2);
  };
  module4.exports = coerce;
});

// node_modules/vega-embed/node_modules/yallist/iterator.js
var require_iterator = __commonJS((exports, module4) => {
  "use strict";
  module4.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
});

// node_modules/vega-embed/node_modules/yallist/yallist.js
var require_yallist = __commonJS((exports, module4) => {
  "use strict";
  module4.exports = Yallist;
  Yallist.Node = Node3;
  Yallist.create = Yallist;
  function Yallist(list) {
    var self = this;
    if (!(self instanceof Yallist)) {
      self = new Yallist();
    }
    self.tail = null;
    self.head = null;
    self.length = 0;
    if (list && typeof list.forEach === "function") {
      list.forEach(function(item) {
        self.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length; i < l; i++) {
        self.push(arguments[i]);
      }
    }
    return self;
  }
  Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }
    var next = node.next;
    var prev = node.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    if (node === this.head) {
      this.head = next;
    }
    if (node === this.tail) {
      this.tail = prev;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
  };
  Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
      head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
      this.tail = node;
    }
    this.length++;
  };
  Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
      tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
      this.head = node;
    }
    this.length++;
  };
  Yallist.prototype.push = function() {
    for (var i = 0, l = arguments.length; i < l; i++) {
      push(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.unshift = function() {
    for (var i = 0, l = arguments.length; i < l; i++) {
      unshift(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.pop = function() {
    if (!this.tail) {
      return void 0;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.shift = function() {
    if (!this.head) {
      return void 0;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0; walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };
  Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };
  Yallist.prototype.get = function(n) {
    for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
      walker = walker.next;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.getReverse = function(n) {
    for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
      walker = walker.prev;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for (var walker = this.head; walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  };
  Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for (var walker = this.tail; walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  };
  Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = 0; walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }
    return acc;
  };
  Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = this.length - 1; walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }
    return acc;
  };
  Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.head; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr;
  };
  Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.tail; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr;
  };
  Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
      walker = walker.next;
    }
    for (; walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
      walker = walker.prev;
    }
    for (; walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) {
      start = this.length - 1;
    }
    if (start < 0) {
      start = this.length + start;
    }
    for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
      walker = walker.next;
    }
    var ret = [];
    for (var i = 0; walker && i < deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (walker === null) {
      walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }
    for (var i = 0; i < nodes.length; i++) {
      walker = insert2(this, walker, nodes[i]);
    }
    return ret;
  };
  Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for (var walker = head; walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
  };
  function insert2(self, node, value3) {
    var inserted = node === self.head ? new Node3(value3, null, node, self) : new Node3(value3, node, node.next, self);
    if (inserted.next === null) {
      self.tail = inserted;
    }
    if (inserted.prev === null) {
      self.head = inserted;
    }
    self.length++;
    return inserted;
  }
  function push(self, item) {
    self.tail = new Node3(item, self.tail, null, self);
    if (!self.head) {
      self.head = self.tail;
    }
    self.length++;
  }
  function unshift(self, item) {
    self.head = new Node3(item, null, self.head, self);
    if (!self.tail) {
      self.tail = self.head;
    }
    self.length++;
  }
  function Node3(value3, prev, next, list) {
    if (!(this instanceof Node3)) {
      return new Node3(value3, prev, next, list);
    }
    this.list = list;
    this.value = value3;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  }
  try {
    require_iterator()(Yallist);
  } catch (er) {
  }
});

// node_modules/vega-embed/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS((exports, module4) => {
  "use strict";
  var Yallist = require_yallist();
  var MAX = Symbol("max");
  var LENGTH = Symbol("length");
  var LENGTH_CALCULATOR = Symbol("lengthCalculator");
  var ALLOW_STALE = Symbol("allowStale");
  var MAX_AGE = Symbol("maxAge");
  var DISPOSE = Symbol("dispose");
  var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
  var LRU_LIST = Symbol("lruList");
  var CACHE2 = Symbol("cache");
  var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
  var naiveLength = () => 1;
  var LRUCache = class {
    constructor(options2) {
      if (typeof options2 === "number")
        options2 = {max: options2};
      if (!options2)
        options2 = {};
      if (options2.max && (typeof options2.max !== "number" || options2.max < 0))
        throw new TypeError("max must be a non-negative number");
      const max4 = this[MAX] = options2.max || Infinity;
      const lc = options2.length || naiveLength;
      this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
      this[ALLOW_STALE] = options2.stale || false;
      if (options2.maxAge && typeof options2.maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      this[MAX_AGE] = options2.maxAge || 0;
      this[DISPOSE] = options2.dispose;
      this[NO_DISPOSE_ON_SET] = options2.noDisposeOnSet || false;
      this[UPDATE_AGE_ON_GET] = options2.updateAgeOnGet || false;
      this.reset();
    }
    set max(mL) {
      if (typeof mL !== "number" || mL < 0)
        throw new TypeError("max must be a non-negative number");
      this[MAX] = mL || Infinity;
      trim(this);
    }
    get max() {
      return this[MAX];
    }
    set allowStale(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
      return this[ALLOW_STALE];
    }
    set maxAge(mA) {
      if (typeof mA !== "number")
        throw new TypeError("maxAge must be a non-negative number");
      this[MAX_AGE] = mA;
      trim(this);
    }
    get maxAge() {
      return this[MAX_AGE];
    }
    set lengthCalculator(lC) {
      if (typeof lC !== "function")
        lC = naiveLength;
      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach((hit2) => {
          hit2.length = this[LENGTH_CALCULATOR](hit2.value, hit2.key);
          this[LENGTH] += hit2.length;
        });
      }
      trim(this);
    }
    get lengthCalculator() {
      return this[LENGTH_CALCULATOR];
    }
    get length() {
      return this[LENGTH];
    }
    get itemCount() {
      return this[LRU_LIST].length;
    }
    rforEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].tail; walker !== null; ) {
        const prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    }
    forEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].head; walker !== null; ) {
        const next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    }
    keys() {
      return this[LRU_LIST].toArray().map((k) => k.key);
    }
    values() {
      return this[LRU_LIST].toArray().map((k) => k.value);
    }
    reset() {
      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach((hit2) => this[DISPOSE](hit2.key, hit2.value));
      }
      this[CACHE2] = new Map();
      this[LRU_LIST] = new Yallist();
      this[LENGTH] = 0;
    }
    dump() {
      return this[LRU_LIST].map((hit2) => isStale(this, hit2) ? false : {
        k: hit2.key,
        v: hit2.value,
        e: hit2.now + (hit2.maxAge || 0)
      }).toArray().filter((h3) => h3);
    }
    dumpLru() {
      return this[LRU_LIST];
    }
    set(key2, value3, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      const now2 = maxAge ? Date.now() : 0;
      const len = this[LENGTH_CALCULATOR](value3, key2);
      if (this[CACHE2].has(key2)) {
        if (len > this[MAX]) {
          del(this, this[CACHE2].get(key2));
          return false;
        }
        const node = this[CACHE2].get(key2);
        const item = node.value;
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET])
            this[DISPOSE](key2, item.value);
        }
        item.now = now2;
        item.maxAge = maxAge;
        item.value = value3;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key2);
        trim(this);
        return true;
      }
      const hit2 = new Entry2(key2, value3, len, now2, maxAge);
      if (hit2.length > this[MAX]) {
        if (this[DISPOSE])
          this[DISPOSE](key2, value3);
        return false;
      }
      this[LENGTH] += hit2.length;
      this[LRU_LIST].unshift(hit2);
      this[CACHE2].set(key2, this[LRU_LIST].head);
      trim(this);
      return true;
    }
    has(key2) {
      if (!this[CACHE2].has(key2))
        return false;
      const hit2 = this[CACHE2].get(key2).value;
      return !isStale(this, hit2);
    }
    get(key2) {
      return get6(this, key2, true);
    }
    peek(key2) {
      return get6(this, key2, false);
    }
    pop() {
      const node = this[LRU_LIST].tail;
      if (!node)
        return null;
      del(this, node);
      return node.value;
    }
    del(key2) {
      del(this, this[CACHE2].get(key2));
    }
    load(arr) {
      this.reset();
      const now2 = Date.now();
      for (let l = arr.length - 1; l >= 0; l--) {
        const hit2 = arr[l];
        const expiresAt = hit2.e || 0;
        if (expiresAt === 0)
          this.set(hit2.k, hit2.v);
        else {
          const maxAge = expiresAt - now2;
          if (maxAge > 0) {
            this.set(hit2.k, hit2.v, maxAge);
          }
        }
      }
    }
    prune() {
      this[CACHE2].forEach((value3, key2) => get6(this, key2, false));
    }
  };
  var get6 = (self, key2, doUse) => {
    const node = self[CACHE2].get(key2);
    if (node) {
      const hit2 = node.value;
      if (isStale(self, hit2)) {
        del(self, node);
        if (!self[ALLOW_STALE])
          return void 0;
      } else {
        if (doUse) {
          if (self[UPDATE_AGE_ON_GET])
            node.value.now = Date.now();
          self[LRU_LIST].unshiftNode(node);
        }
      }
      return hit2.value;
    }
  };
  var isStale = (self, hit2) => {
    if (!hit2 || !hit2.maxAge && !self[MAX_AGE])
      return false;
    const diff2 = Date.now() - hit2.now;
    return hit2.maxAge ? diff2 > hit2.maxAge : self[MAX_AGE] && diff2 > self[MAX_AGE];
  };
  var trim = (self) => {
    if (self[LENGTH] > self[MAX]) {
      for (let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null; ) {
        const prev = walker.prev;
        del(self, walker);
        walker = prev;
      }
    }
  };
  var del = (self, node) => {
    if (node) {
      const hit2 = node.value;
      if (self[DISPOSE])
        self[DISPOSE](hit2.key, hit2.value);
      self[LENGTH] -= hit2.length;
      self[CACHE2].delete(hit2.key);
      self[LRU_LIST].removeNode(node);
    }
  };
  var Entry2 = class {
    constructor(key2, value3, length3, now2, maxAge) {
      this.key = key2;
      this.value = value3;
      this.length = length3;
      this.now = now2;
      this.maxAge = maxAge || 0;
    }
  };
  var forEachStep = (self, fn, node, thisp) => {
    let hit2 = node.value;
    if (isStale(self, hit2)) {
      del(self, node);
      if (!self[ALLOW_STALE])
        hit2 = void 0;
    }
    if (hit2)
      fn.call(thisp, hit2.value, hit2.key, self);
  };
  module4.exports = LRUCache;
});

// node_modules/vega-embed/node_modules/semver/classes/range.js
var require_range = __commonJS((exports, module4) => {
  var Range = class {
    constructor(range5, options2) {
      options2 = parseOptions(options2);
      if (range5 instanceof Range) {
        if (range5.loose === !!options2.loose && range5.includePrerelease === !!options2.includePrerelease) {
          return range5;
        } else {
          return new Range(range5.raw, options2);
        }
      }
      if (range5 instanceof Comparator) {
        this.raw = range5.value;
        this.set = [[range5]];
        this.format();
        return this;
      }
      this.options = options2;
      this.loose = !!options2.loose;
      this.includePrerelease = !!options2.includePrerelease;
      this.raw = range5;
      this.set = range5.split(/\s*\|\|\s*/).map((range6) => this.parseRange(range6.trim())).filter((c2) => c2.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${range5}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c2) => !isNullSet(c2[0]));
        if (this.set.length === 0)
          this.set = [first];
        else if (this.set.length > 1) {
          for (const c2 of this.set) {
            if (c2.length === 1 && isAny(c2[0])) {
              this.set = [c2];
              break;
            }
          }
        }
      }
      this.format();
    }
    format() {
      this.range = this.set.map((comps) => {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range5) {
      range5 = range5.trim();
      const memoOpts = Object.keys(this.options).join(",");
      const memoKey = `parseRange:${memoOpts}:${range5}`;
      const cached = cache2.get(memoKey);
      if (cached)
        return cached;
      const loose = this.options.loose;
      const hr = loose ? re4[t.HYPHENRANGELOOSE] : re4[t.HYPHENRANGE];
      range5 = range5.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug4("hyphen replace", range5);
      range5 = range5.replace(re4[t.COMPARATORTRIM], comparatorTrimReplace);
      debug4("comparator trim", range5, re4[t.COMPARATORTRIM]);
      range5 = range5.replace(re4[t.TILDETRIM], tildeTrimReplace);
      range5 = range5.replace(re4[t.CARETTRIM], caretTrimReplace);
      range5 = range5.split(/\s+/).join(" ");
      const compRe = loose ? re4[t.COMPARATORLOOSE] : re4[t.COMPARATOR];
      const rangeList = range5.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator(comp, this.options));
      const l = rangeList.length;
      const rangeMap = new Map();
      for (const comp of rangeList) {
        if (isNullSet(comp))
          return [comp];
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has(""))
        rangeMap.delete("");
      const result = [...rangeMap.values()];
      cache2.set(memoKey, result);
      return result;
    }
    intersects(range5, options2) {
      if (!(range5 instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options2) && range5.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options2) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options2);
            });
          });
        });
      });
    }
    test(version8) {
      if (!version8) {
        return false;
      }
      if (typeof version8 === "string") {
        try {
          version8 = new SemVer(version8, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version8, this.options)) {
          return true;
        }
      }
      return false;
    }
  };
  module4.exports = Range;
  var LRU = require_lru_cache();
  var cache2 = new LRU({max: 1e3});
  var parseOptions = require_parse_options();
  var Comparator = require_comparator();
  var debug4 = require_debug();
  var SemVer = require_semver();
  var {
    re: re4,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = require_re();
  var isNullSet = (c2) => c2.value === "<0.0.0-0";
  var isAny = (c2) => c2.value === "";
  var isSatisfiable = (comparators, options2) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options2);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var parseComparator = (comp, options2) => {
    debug4("comp", comp, options2);
    comp = replaceCarets(comp, options2);
    debug4("caret", comp);
    comp = replaceTildes(comp, options2);
    debug4("tildes", comp);
    comp = replaceXRanges(comp, options2);
    debug4("xrange", comp);
    comp = replaceStars(comp, options2);
    debug4("stars", comp);
    return comp;
  };
  var isX2 = (id4) => !id4 || id4.toLowerCase() === "x" || id4 === "*";
  var replaceTildes = (comp, options2) => comp.trim().split(/\s+/).map((comp2) => {
    return replaceTilde(comp2, options2);
  }).join(" ");
  var replaceTilde = (comp, options2) => {
    const r2 = options2.loose ? re4[t.TILDELOOSE] : re4[t.TILDE];
    return comp.replace(r2, (_, M2, m2, p, pr) => {
      debug4("tilde", comp, _, M2, m2, p, pr);
      let ret;
      if (isX2(M2)) {
        ret = "";
      } else if (isX2(m2)) {
        ret = `>=${M2}.0.0 <${+M2 + 1}.0.0-0`;
      } else if (isX2(p)) {
        ret = `>=${M2}.${m2}.0 <${M2}.${+m2 + 1}.0-0`;
      } else if (pr) {
        debug4("replaceTilde pr", pr);
        ret = `>=${M2}.${m2}.${p}-${pr} <${M2}.${+m2 + 1}.0-0`;
      } else {
        ret = `>=${M2}.${m2}.${p} <${M2}.${+m2 + 1}.0-0`;
      }
      debug4("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = (comp, options2) => comp.trim().split(/\s+/).map((comp2) => {
    return replaceCaret(comp2, options2);
  }).join(" ");
  var replaceCaret = (comp, options2) => {
    debug4("caret", comp, options2);
    const r2 = options2.loose ? re4[t.CARETLOOSE] : re4[t.CARET];
    const z = options2.includePrerelease ? "-0" : "";
    return comp.replace(r2, (_, M2, m2, p, pr) => {
      debug4("caret", comp, _, M2, m2, p, pr);
      let ret;
      if (isX2(M2)) {
        ret = "";
      } else if (isX2(m2)) {
        ret = `>=${M2}.0.0${z} <${+M2 + 1}.0.0-0`;
      } else if (isX2(p)) {
        if (M2 === "0") {
          ret = `>=${M2}.${m2}.0${z} <${M2}.${+m2 + 1}.0-0`;
        } else {
          ret = `>=${M2}.${m2}.0${z} <${+M2 + 1}.0.0-0`;
        }
      } else if (pr) {
        debug4("replaceCaret pr", pr);
        if (M2 === "0") {
          if (m2 === "0") {
            ret = `>=${M2}.${m2}.${p}-${pr} <${M2}.${m2}.${+p + 1}-0`;
          } else {
            ret = `>=${M2}.${m2}.${p}-${pr} <${M2}.${+m2 + 1}.0-0`;
          }
        } else {
          ret = `>=${M2}.${m2}.${p}-${pr} <${+M2 + 1}.0.0-0`;
        }
      } else {
        debug4("no pr");
        if (M2 === "0") {
          if (m2 === "0") {
            ret = `>=${M2}.${m2}.${p}${z} <${M2}.${m2}.${+p + 1}-0`;
          } else {
            ret = `>=${M2}.${m2}.${p}${z} <${M2}.${+m2 + 1}.0-0`;
          }
        } else {
          ret = `>=${M2}.${m2}.${p} <${+M2 + 1}.0.0-0`;
        }
      }
      debug4("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = (comp, options2) => {
    debug4("replaceXRanges", comp, options2);
    return comp.split(/\s+/).map((comp2) => {
      return replaceXRange(comp2, options2);
    }).join(" ");
  };
  var replaceXRange = (comp, options2) => {
    comp = comp.trim();
    const r2 = options2.loose ? re4[t.XRANGELOOSE] : re4[t.XRANGE];
    return comp.replace(r2, (ret, gtlt, M2, m2, p, pr) => {
      debug4("xRange", comp, ret, gtlt, M2, m2, p, pr);
      const xM = isX2(M2);
      const xm = xM || isX2(m2);
      const xp = xm || isX2(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options2.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m2 = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M2 = +M2 + 1;
            m2 = 0;
            p = 0;
          } else {
            m2 = +m2 + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M2 = +M2 + 1;
          } else {
            m2 = +m2 + 1;
          }
        }
        if (gtlt === "<")
          pr = "-0";
        ret = `${gtlt + M2}.${m2}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M2}.0.0${pr} <${+M2 + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M2}.${m2}.0${pr} <${M2}.${+m2 + 1}.0-0`;
      }
      debug4("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = (comp, options2) => {
    debug4("replaceStars", comp, options2);
    return comp.trim().replace(re4[t.STAR], "");
  };
  var replaceGTE0 = (comp, options2) => {
    debug4("replaceGTE0", comp, options2);
    return comp.trim().replace(re4[options2.includePrerelease ? t.GTE0PRE : t.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
    if (isX2(fM)) {
      from = "";
    } else if (isX2(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX2(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX2(tM)) {
      to = "";
    } else if (isX2(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX2(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  var testSet = (set6, version8, options2) => {
    for (let i = 0; i < set6.length; i++) {
      if (!set6[i].test(version8)) {
        return false;
      }
    }
    if (version8.prerelease.length && !options2.includePrerelease) {
      for (let i = 0; i < set6.length; i++) {
        debug4(set6[i].semver);
        if (set6[i].semver === Comparator.ANY) {
          continue;
        }
        if (set6[i].semver.prerelease.length > 0) {
          const allowed = set6[i].semver;
          if (allowed.major === version8.major && allowed.minor === version8.minor && allowed.patch === version8.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
});

// node_modules/vega-embed/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS((exports, module4) => {
  var ANY = Symbol("SemVer ANY");
  var Comparator = class {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options2) {
      options2 = parseOptions(options2);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options2.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      debug4("comparator", comp, options2);
      this.options = options2;
      this.loose = !!options2.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug4("comp", this);
    }
    parse(comp) {
      const r2 = this.options.loose ? re4[t.COMPARATORLOOSE] : re4[t.COMPARATOR];
      const m2 = comp.match(r2);
      if (!m2) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m2[1] !== void 0 ? m2[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m2[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m2[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version8) {
      debug4("Comparator.test", version8, this.options.loose);
      if (this.semver === ANY || version8 === ANY) {
        return true;
      }
      if (typeof version8 === "string") {
        try {
          version8 = new SemVer(version8, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version8, this.operator, this.semver, this.options);
    }
    intersects(comp, options2) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options2).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options2).test(comp.semver);
      }
      const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      const sameSemVer = this.semver.version === comp.semver.version;
      const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options2) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
      const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options2) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    }
  };
  module4.exports = Comparator;
  var parseOptions = require_parse_options();
  var {re: re4, t} = require_re();
  var cmp = require_cmp();
  var debug4 = require_debug();
  var SemVer = require_semver();
  var Range = require_range();
});

// node_modules/vega-embed/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS((exports, module4) => {
  var Range = require_range();
  var satisfies2 = (version8, range5, options2) => {
    try {
      range5 = new Range(range5, options2);
    } catch (er) {
      return false;
    }
    return range5.test(version8);
  };
  module4.exports = satisfies2;
});

// node_modules/vega-embed/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS((exports, module4) => {
  var Range = require_range();
  var toComparators = (range5, options2) => new Range(range5, options2).set.map((comp) => comp.map((c2) => c2.value).join(" ").trim().split(" "));
  module4.exports = toComparators;
});

// node_modules/vega-embed/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS((exports, module4) => {
  var SemVer = require_semver();
  var Range = require_range();
  var maxSatisfying = (versions, range5, options2) => {
    let max4 = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range5, options2);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!max4 || maxSV.compare(v) === -1) {
          max4 = v;
          maxSV = new SemVer(max4, options2);
        }
      }
    });
    return max4;
  };
  module4.exports = maxSatisfying;
});

// node_modules/vega-embed/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS((exports, module4) => {
  var SemVer = require_semver();
  var Range = require_range();
  var minSatisfying = (versions, range5, options2) => {
    let min4 = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range5, options2);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!min4 || minSV.compare(v) === 1) {
          min4 = v;
          minSV = new SemVer(min4, options2);
        }
      }
    });
    return min4;
  };
  module4.exports = minSatisfying;
});

// node_modules/vega-embed/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS((exports, module4) => {
  var SemVer = require_semver();
  var Range = require_range();
  var gt = require_gt();
  var minVersion = (range5, loose) => {
    range5 = new Range(range5, loose);
    let minver = new SemVer("0.0.0");
    if (range5.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range5.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i = 0; i < range5.set.length; ++i) {
      const comparators = range5.set[i];
      let setMin = null;
      comparators.forEach((comparator2) => {
        const compver = new SemVer(comparator2.semver.version);
        switch (comparator2.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!setMin || gt(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${comparator2.operator}`);
        }
      });
      if (setMin && (!minver || gt(minver, setMin)))
        minver = setMin;
    }
    if (minver && range5.test(minver)) {
      return minver;
    }
    return null;
  };
  module4.exports = minVersion;
});

// node_modules/vega-embed/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS((exports, module4) => {
  var Range = require_range();
  var validRange = (range5, options2) => {
    try {
      return new Range(range5, options2).range || "*";
    } catch (er) {
      return null;
    }
  };
  module4.exports = validRange;
});

// node_modules/vega-embed/node_modules/semver/ranges/outside.js
var require_outside = __commonJS((exports, module4) => {
  var SemVer = require_semver();
  var Comparator = require_comparator();
  var {ANY} = Comparator;
  var Range = require_range();
  var satisfies2 = require_satisfies();
  var gt = require_gt();
  var lt = require_lt();
  var lte = require_lte();
  var gte = require_gte();
  var outside = (version8, range5, hilo, options2) => {
    version8 = new SemVer(version8, options2);
    range5 = new Range(range5, options2);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies2(version8, range5, options2)) {
      return false;
    }
    for (let i = 0; i < range5.set.length; ++i) {
      const comparators = range5.set[i];
      let high = null;
      let low = null;
      comparators.forEach((comparator2) => {
        if (comparator2.semver === ANY) {
          comparator2 = new Comparator(">=0.0.0");
        }
        high = high || comparator2;
        low = low || comparator2;
        if (gtfn(comparator2.semver, high.semver, options2)) {
          high = comparator2;
        } else if (ltfn(comparator2.semver, low.semver, options2)) {
          low = comparator2;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version8, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version8, low.semver)) {
        return false;
      }
    }
    return true;
  };
  module4.exports = outside;
});

// node_modules/vega-embed/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS((exports, module4) => {
  var outside = require_outside();
  var gtr = (version8, range5, options2) => outside(version8, range5, ">", options2);
  module4.exports = gtr;
});

// node_modules/vega-embed/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS((exports, module4) => {
  var outside = require_outside();
  var ltr = (version8, range5, options2) => outside(version8, range5, "<", options2);
  module4.exports = ltr;
});

// node_modules/vega-embed/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS((exports, module4) => {
  var Range = require_range();
  var intersects2 = (r1, r2, options2) => {
    r1 = new Range(r1, options2);
    r2 = new Range(r2, options2);
    return r1.intersects(r2);
  };
  module4.exports = intersects2;
});

// node_modules/vega-embed/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS((exports, module4) => {
  var satisfies2 = require_satisfies();
  var compare4 = require_compare();
  module4.exports = (versions, range5, options2) => {
    const set6 = [];
    let min4 = null;
    let prev = null;
    const v = versions.sort((a2, b2) => compare4(a2, b2, options2));
    for (const version8 of v) {
      const included = satisfies2(version8, range5, options2);
      if (included) {
        prev = version8;
        if (!min4)
          min4 = version8;
      } else {
        if (prev) {
          set6.push([min4, prev]);
        }
        prev = null;
        min4 = null;
      }
    }
    if (min4)
      set6.push([min4, null]);
    const ranges2 = [];
    for (const [min5, max4] of set6) {
      if (min5 === max4)
        ranges2.push(min5);
      else if (!max4 && min5 === v[0])
        ranges2.push("*");
      else if (!max4)
        ranges2.push(`>=${min5}`);
      else if (min5 === v[0])
        ranges2.push(`<=${max4}`);
      else
        ranges2.push(`${min5} - ${max4}`);
    }
    const simplified = ranges2.join(" || ");
    const original = typeof range5.raw === "string" ? range5.raw : String(range5);
    return simplified.length < original.length ? simplified : range5;
  };
});

// node_modules/vega-embed/node_modules/semver/ranges/subset.js
var require_subset = __commonJS((exports, module4) => {
  var Range = require_range();
  var {ANY} = require_comparator();
  var satisfies2 = require_satisfies();
  var compare4 = require_compare();
  var subset = (sub, dom, options2) => {
    if (sub === dom)
      return true;
    sub = new Range(sub, options2);
    dom = new Range(dom, options2);
    let sawNonNull = false;
    OUTER:
      for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options2);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub)
            continue OUTER;
        }
        if (sawNonNull)
          return false;
      }
    return true;
  };
  var simpleSubset = (sub, dom, options2) => {
    if (sub === dom)
      return true;
    if (sub.length === 1 && sub[0].semver === ANY)
      return dom.length === 1 && dom[0].semver === ANY;
    const eqSet = new Set();
    let gt, lt;
    for (const c2 of sub) {
      if (c2.operator === ">" || c2.operator === ">=")
        gt = higherGT(gt, c2, options2);
      else if (c2.operator === "<" || c2.operator === "<=")
        lt = lowerLT(lt, c2, options2);
      else
        eqSet.add(c2.semver);
    }
    if (eqSet.size > 1)
      return null;
    let gtltComp;
    if (gt && lt) {
      gtltComp = compare4(gt.semver, lt.semver, options2);
      if (gtltComp > 0)
        return null;
      else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<="))
        return null;
    }
    for (const eq of eqSet) {
      if (gt && !satisfies2(eq, String(gt), options2))
        return null;
      if (lt && !satisfies2(eq, String(lt), options2))
        return null;
      for (const c2 of dom) {
        if (!satisfies2(eq, String(c2), options2))
          return false;
      }
      return true;
    }
    let higher, lower2;
    let hasDomLT, hasDomGT;
    for (const c2 of dom) {
      hasDomGT = hasDomGT || c2.operator === ">" || c2.operator === ">=";
      hasDomLT = hasDomLT || c2.operator === "<" || c2.operator === "<=";
      if (gt) {
        if (c2.operator === ">" || c2.operator === ">=") {
          higher = higherGT(gt, c2, options2);
          if (higher === c2 && higher !== gt)
            return false;
        } else if (gt.operator === ">=" && !satisfies2(gt.semver, String(c2), options2))
          return false;
      }
      if (lt) {
        if (c2.operator === "<" || c2.operator === "<=") {
          lower2 = lowerLT(lt, c2, options2);
          if (lower2 === c2 && lower2 !== lt)
            return false;
        } else if (lt.operator === "<=" && !satisfies2(lt.semver, String(c2), options2))
          return false;
      }
      if (!c2.operator && (lt || gt) && gtltComp !== 0)
        return false;
    }
    if (gt && hasDomLT && !lt && gtltComp !== 0)
      return false;
    if (lt && hasDomGT && !gt && gtltComp !== 0)
      return false;
    return true;
  };
  var higherGT = (a2, b2, options2) => {
    if (!a2)
      return b2;
    const comp = compare4(a2.semver, b2.semver, options2);
    return comp > 0 ? a2 : comp < 0 ? b2 : b2.operator === ">" && a2.operator === ">=" ? b2 : a2;
  };
  var lowerLT = (a2, b2, options2) => {
    if (!a2)
      return b2;
    const comp = compare4(a2.semver, b2.semver, options2);
    return comp < 0 ? a2 : comp > 0 ? b2 : b2.operator === "<" && a2.operator === "<=" ? b2 : a2;
  };
  module4.exports = subset;
});

// node_modules/vega-embed/node_modules/semver/index.js
var require_semver2 = __commonJS((exports, module4) => {
  var internalRe = require_re();
  module4.exports = {
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: require_constants().SEMVER_SPEC_VERSION,
    SemVer: require_semver(),
    compareIdentifiers: require_identifiers().compareIdentifiers,
    rcompareIdentifiers: require_identifiers().rcompareIdentifiers,
    parse: require_parse(),
    valid: require_valid(),
    clean: require_clean(),
    inc: require_inc(),
    diff: require_diff(),
    major: require_major(),
    minor: require_minor(),
    patch: require_patch(),
    prerelease: require_prerelease(),
    compare: require_compare(),
    rcompare: require_rcompare(),
    compareLoose: require_compare_loose(),
    compareBuild: require_compare_build(),
    sort: require_sort(),
    rsort: require_rsort(),
    gt: require_gt(),
    lt: require_lt(),
    eq: require_eq(),
    neq: require_neq(),
    gte: require_gte(),
    lte: require_lte(),
    cmp: require_cmp(),
    coerce: require_coerce(),
    Comparator: require_comparator(),
    Range: require_range(),
    satisfies: require_satisfies(),
    toComparators: require_to_comparators(),
    maxSatisfying: require_max_satisfying(),
    minSatisfying: require_min_satisfying(),
    minVersion: require_min_version(),
    validRange: require_valid2(),
    outside: require_outside(),
    gtr: require_gtr(),
    ltr: require_ltr(),
    intersects: require_intersects(),
    simplifyRange: require_simplify(),
    subset: require_subset()
  };
});

// node_modules/clone/clone.js
var require_clone = __commonJS((exports, module4) => {
  var clone = function() {
    "use strict";
    function _instanceof(obj, type2) {
      return type2 != null && obj instanceof type2;
    }
    var nativeMap;
    try {
      nativeMap = Map;
    } catch (_) {
      nativeMap = function() {
      };
    }
    var nativeSet;
    try {
      nativeSet = Set;
    } catch (_) {
      nativeSet = function() {
      };
    }
    var nativePromise;
    try {
      nativePromise = Promise;
    } catch (_) {
      nativePromise = function() {
      };
    }
    function clone2(parent, circular, depth, prototype2, includeNonEnumerable) {
      if (typeof circular === "object") {
        depth = circular.depth;
        prototype2 = circular.prototype;
        includeNonEnumerable = circular.includeNonEnumerable;
        circular = circular.circular;
      }
      var allParents = [];
      var allChildren = [];
      var useBuffer = typeof Buffer != "undefined";
      if (typeof circular == "undefined")
        circular = true;
      if (typeof depth == "undefined")
        depth = Infinity;
      function _clone(parent2, depth2) {
        if (parent2 === null)
          return null;
        if (depth2 === 0)
          return parent2;
        var child;
        var proto;
        if (typeof parent2 != "object") {
          return parent2;
        }
        if (_instanceof(parent2, nativeMap)) {
          child = new nativeMap();
        } else if (_instanceof(parent2, nativeSet)) {
          child = new nativeSet();
        } else if (_instanceof(parent2, nativePromise)) {
          child = new nativePromise(function(resolve2, reject) {
            parent2.then(function(value3) {
              resolve2(_clone(value3, depth2 - 1));
            }, function(err) {
              reject(_clone(err, depth2 - 1));
            });
          });
        } else if (clone2.__isArray(parent2)) {
          child = [];
        } else if (clone2.__isRegExp(parent2)) {
          child = new RegExp(parent2.source, __getRegExpFlags(parent2));
          if (parent2.lastIndex)
            child.lastIndex = parent2.lastIndex;
        } else if (clone2.__isDate(parent2)) {
          child = new Date(parent2.getTime());
        } else if (useBuffer && Buffer.isBuffer(parent2)) {
          if (Buffer.allocUnsafe) {
            child = Buffer.allocUnsafe(parent2.length);
          } else {
            child = new Buffer(parent2.length);
          }
          parent2.copy(child);
          return child;
        } else if (_instanceof(parent2, Error)) {
          child = Object.create(parent2);
        } else {
          if (typeof prototype2 == "undefined") {
            proto = Object.getPrototypeOf(parent2);
            child = Object.create(proto);
          } else {
            child = Object.create(prototype2);
            proto = prototype2;
          }
        }
        if (circular) {
          var index4 = allParents.indexOf(parent2);
          if (index4 != -1) {
            return allChildren[index4];
          }
          allParents.push(parent2);
          allChildren.push(child);
        }
        if (_instanceof(parent2, nativeMap)) {
          parent2.forEach(function(value3, key2) {
            var keyChild = _clone(key2, depth2 - 1);
            var valueChild = _clone(value3, depth2 - 1);
            child.set(keyChild, valueChild);
          });
        }
        if (_instanceof(parent2, nativeSet)) {
          parent2.forEach(function(value3) {
            var entryChild = _clone(value3, depth2 - 1);
            child.add(entryChild);
          });
        }
        for (var i in parent2) {
          var attrs;
          if (proto) {
            attrs = Object.getOwnPropertyDescriptor(proto, i);
          }
          if (attrs && attrs.set == null) {
            continue;
          }
          child[i] = _clone(parent2[i], depth2 - 1);
        }
        if (Object.getOwnPropertySymbols) {
          var symbols4 = Object.getOwnPropertySymbols(parent2);
          for (var i = 0; i < symbols4.length; i++) {
            var symbol2 = symbols4[i];
            var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol2);
            if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
              continue;
            }
            child[symbol2] = _clone(parent2[symbol2], depth2 - 1);
            if (!descriptor.enumerable) {
              Object.defineProperty(child, symbol2, {
                enumerable: false
              });
            }
          }
        }
        if (includeNonEnumerable) {
          var allPropertyNames = Object.getOwnPropertyNames(parent2);
          for (var i = 0; i < allPropertyNames.length; i++) {
            var propertyName = allPropertyNames[i];
            var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
            if (descriptor && descriptor.enumerable) {
              continue;
            }
            child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
            Object.defineProperty(child, propertyName, {
              enumerable: false
            });
          }
        }
        return child;
      }
      return _clone(parent, depth);
    }
    clone2.clonePrototype = function clonePrototype(parent) {
      if (parent === null)
        return null;
      var c2 = function() {
      };
      c2.prototype = parent;
      return new c2();
    };
    function __objToStr(o) {
      return Object.prototype.toString.call(o);
    }
    clone2.__objToStr = __objToStr;
    function __isDate(o) {
      return typeof o === "object" && __objToStr(o) === "[object Date]";
    }
    clone2.__isDate = __isDate;
    function __isArray(o) {
      return typeof o === "object" && __objToStr(o) === "[object Array]";
    }
    clone2.__isArray = __isArray;
    function __isRegExp(o) {
      return typeof o === "object" && __objToStr(o) === "[object RegExp]";
    }
    clone2.__isRegExp = __isRegExp;
    function __getRegExpFlags(re4) {
      var flags = "";
      if (re4.global)
        flags += "g";
      if (re4.ignoreCase)
        flags += "i";
      if (re4.multiline)
        flags += "m";
      return flags;
    }
    clone2.__getRegExpFlags = __getRegExpFlags;
    return clone2;
  }();
  if (typeof module4 === "object" && module4.exports) {
    module4.exports = clone;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS((exports, module4) => {
  "use strict";
  module4.exports = function equal3(a2, b2) {
    if (a2 === b2)
      return true;
    if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
      if (a2.constructor !== b2.constructor)
        return false;
      var length3, i, keys4;
      if (Array.isArray(a2)) {
        length3 = a2.length;
        if (length3 != b2.length)
          return false;
        for (i = length3; i-- !== 0; )
          if (!equal3(a2[i], b2[i]))
            return false;
        return true;
      }
      if (a2.constructor === RegExp)
        return a2.source === b2.source && a2.flags === b2.flags;
      if (a2.valueOf !== Object.prototype.valueOf)
        return a2.valueOf() === b2.valueOf();
      if (a2.toString !== Object.prototype.toString)
        return a2.toString() === b2.toString();
      keys4 = Object.keys(a2);
      length3 = keys4.length;
      if (length3 !== Object.keys(b2).length)
        return false;
      for (i = length3; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b2, keys4[i]))
          return false;
      for (i = length3; i-- !== 0; ) {
        var key2 = keys4[i];
        if (!equal3(a2[key2], b2[key2]))
          return false;
      }
      return true;
    }
    return a2 !== a2 && b2 !== b2;
  };
});

// node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS((exports, module4) => {
  "use strict";
  module4.exports = function(data4, opts) {
    if (!opts)
      opts = {};
    if (typeof opts === "function")
      opts = {cmp: opts};
    var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
    var cmp = opts.cmp && function(f) {
      return function(node) {
        return function(a2, b2) {
          var aobj = {key: a2, value: node[a2]};
          var bobj = {key: b2, value: node[b2]};
          return f(aobj, bobj);
        };
      };
    }(opts.cmp);
    var seen = [];
    return function stringify5(node) {
      if (node && node.toJSON && typeof node.toJSON === "function") {
        node = node.toJSON();
      }
      if (node === void 0)
        return;
      if (typeof node == "number")
        return isFinite(node) ? "" + node : "null";
      if (typeof node !== "object")
        return JSON.stringify(node);
      var i, out;
      if (Array.isArray(node)) {
        out = "[";
        for (i = 0; i < node.length; i++) {
          if (i)
            out += ",";
          out += stringify5(node[i]) || "null";
        }
        return out + "]";
      }
      if (node === null)
        return "null";
      if (seen.indexOf(node) !== -1) {
        if (cycles)
          return JSON.stringify("__cycle__");
        throw new TypeError("Converting circular structure to JSON");
      }
      var seenIndex = seen.push(node) - 1;
      var keys4 = Object.keys(node).sort(cmp && cmp(node));
      out = "";
      for (i = 0; i < keys4.length; i++) {
        var key2 = keys4[i];
        var value3 = stringify5(node[key2]);
        if (!value3)
          continue;
        if (out)
          out += ",";
        out += JSON.stringify(key2) + ":" + value3;
      }
      seen.splice(seenIndex, 1);
      return "{" + out + "}";
    }(data4);
  };
});

// node_modules/vega-schema-url-parser/index.js
var require_vega_schema_url_parser = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  function default_1(url) {
    var regex = /\/schema\/([\w-]+)\/([\w\.\-]+)\.json$/g;
    var _a2 = regex.exec(url).slice(1, 3), library = _a2[0], version8 = _a2[1];
    return {library, version: version8};
  }
  exports.default = default_1;
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS((exports, module4) => {
  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  "use strict";
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val) {
    if (val === null || val === void 0) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i = 0; i < 10; i++) {
        test2["_" + String.fromCharCode(i)] = i;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
        return test2[n];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  module4.exports = shouldUseNative() ? Object.assign : function(target, source4) {
    var from;
    var to = toObject(target);
    var symbols4;
    for (var s = 1; s < arguments.length; s++) {
      from = Object(arguments[s]);
      for (var key2 in from) {
        if (hasOwnProperty2.call(from, key2)) {
          to[key2] = from[key2];
        }
      }
      if (getOwnPropertySymbols) {
        symbols4 = getOwnPropertySymbols(from);
        for (var i = 0; i < symbols4.length; i++) {
          if (propIsEnumerable.call(from, symbols4[i])) {
            to[symbols4[i]] = from[symbols4[i]];
          }
        }
      }
    }
    return to;
  };
});

// node_modules/glamor/lib/sheet.js
var require_sheet = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.StyleSheet = StyleSheet;
  var _objectAssign = require_object_assign();
  var _objectAssign2 = _interopRequireDefault(_objectAssign);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    } else {
      return Array.from(arr);
    }
  }
  function last(arr) {
    return arr[arr.length - 1];
  }
  function sheetForTag(tag) {
    if (tag.sheet) {
      return tag.sheet;
    }
    for (var i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].ownerNode === tag) {
        return document.styleSheets[i];
      }
    }
  }
  var isBrowser = typeof window !== "undefined";
  var isDev = false;
  var isTest = false;
  var oldIE = function() {
    if (isBrowser) {
      var div = document.createElement("div");
      div.innerHTML = "<!--[if lt IE 10]><i></i><![endif]-->";
      return div.getElementsByTagName("i").length === 1;
    }
  }();
  function makeStyleTag() {
    var tag = document.createElement("style");
    tag.type = "text/css";
    tag.setAttribute("data-glamor", "");
    tag.appendChild(document.createTextNode(""));
    (document.head || document.getElementsByTagName("head")[0]).appendChild(tag);
    return tag;
  }
  function StyleSheet() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$speedy = _ref.speedy, speedy = _ref$speedy === void 0 ? !isDev && !isTest : _ref$speedy, _ref$maxLength = _ref.maxLength, maxLength = _ref$maxLength === void 0 ? isBrowser && oldIE ? 4e3 : 65e3 : _ref$maxLength;
    this.isSpeedy = speedy;
    this.sheet = void 0;
    this.tags = [];
    this.maxLength = maxLength;
    this.ctr = 0;
  }
  (0, _objectAssign2.default)(StyleSheet.prototype, {
    getSheet: function getSheet() {
      return sheetForTag(last(this.tags));
    },
    inject: function inject() {
      var _this = this;
      if (this.injected) {
        throw new Error("already injected stylesheet!");
      }
      if (isBrowser) {
        this.tags[0] = makeStyleTag();
      } else {
        this.sheet = {
          cssRules: [],
          insertRule: function insertRule(rule4) {
            _this.sheet.cssRules.push({cssText: rule4});
          }
        };
      }
      this.injected = true;
    },
    speedy: function speedy(bool) {
      if (this.ctr !== 0) {
        throw new Error("cannot change speedy mode after inserting any rule to sheet. Either call speedy(" + bool + ") earlier in your app, or call flush() before speedy(" + bool + ")");
      }
      this.isSpeedy = !!bool;
    },
    _insert: function _insert(rule4) {
      try {
        var sheet = this.getSheet();
        sheet.insertRule(rule4, rule4.indexOf("@import") !== -1 ? 0 : sheet.cssRules.length);
      } catch (e) {
        if (isDev) {
          console.warn("whoops, illegal rule inserted", rule4);
        }
      }
    },
    insert: function insert2(rule4) {
      if (isBrowser) {
        if (this.isSpeedy && this.getSheet().insertRule) {
          this._insert(rule4);
        } else {
          if (rule4.indexOf("@import") !== -1) {
            var tag = last(this.tags);
            tag.insertBefore(document.createTextNode(rule4), tag.firstChild);
          } else {
            last(this.tags).appendChild(document.createTextNode(rule4));
          }
        }
      } else {
        this.sheet.insertRule(rule4, rule4.indexOf("@import") !== -1 ? 0 : this.sheet.cssRules.length);
      }
      this.ctr++;
      if (isBrowser && this.ctr % this.maxLength === 0) {
        this.tags.push(makeStyleTag());
      }
      return this.ctr - 1;
    },
    delete: function _delete(index4) {
      return this.replace(index4, "");
    },
    flush: function flush2() {
      if (isBrowser) {
        this.tags.forEach(function(tag) {
          return tag.parentNode.removeChild(tag);
        });
        this.tags = [];
        this.sheet = null;
        this.ctr = 0;
      } else {
        this.sheet.cssRules = [];
      }
      this.injected = false;
    },
    rules: function rules() {
      if (!isBrowser) {
        return this.sheet.cssRules;
      }
      var arr = [];
      this.tags.forEach(function(tag) {
        return arr.splice.apply(arr, [arr.length, 0].concat(_toConsumableArray(Array.from(sheetForTag(tag).cssRules))));
      });
      return arr;
    }
  });
});

// node_modules/fbjs/lib/camelize.js
var require_camelize = __commonJS((exports, module4) => {
  "use strict";
  var _hyphenPattern = /-(.)/g;
  function camelize(string) {
    return string.replace(_hyphenPattern, function(_, character) {
      return character.toUpperCase();
    });
  }
  module4.exports = camelize;
});

// node_modules/fbjs/lib/camelizeStyleName.js
var require_camelizeStyleName = __commonJS((exports, module4) => {
  "use strict";
  var camelize = require_camelize();
  var msPattern = /^-ms-/;
  function camelizeStyleName(string) {
    return camelize(string.replace(msPattern, "ms-"));
  }
  module4.exports = camelizeStyleName;
});

// node_modules/glamor/lib/CSSPropertyOperations/CSSProperty.js
var require_CSSProperty = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var isUnitlessNumber = {
    animationIterationCount: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridRow: true,
    gridRowStart: true,
    gridRowEnd: true,
    gridColumn: true,
    gridColumnStart: true,
    gridColumnEnd: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  function prefixKey(prefix, key2) {
    return prefix + key2.charAt(0).toUpperCase() + key2.substring(1);
  }
  var prefixes4 = ["Webkit", "ms", "Moz", "O"];
  Object.keys(isUnitlessNumber).forEach(function(prop) {
    prefixes4.forEach(function(prefix) {
      isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
    });
  });
  var shorthandPropertyExpansions = {
    background: {
      backgroundAttachment: true,
      backgroundColor: true,
      backgroundImage: true,
      backgroundPositionX: true,
      backgroundPositionY: true,
      backgroundRepeat: true
    },
    backgroundPosition: {
      backgroundPositionX: true,
      backgroundPositionY: true
    },
    border: {
      borderWidth: true,
      borderStyle: true,
      borderColor: true
    },
    borderBottom: {
      borderBottomWidth: true,
      borderBottomStyle: true,
      borderBottomColor: true
    },
    borderLeft: {
      borderLeftWidth: true,
      borderLeftStyle: true,
      borderLeftColor: true
    },
    borderRight: {
      borderRightWidth: true,
      borderRightStyle: true,
      borderRightColor: true
    },
    borderTop: {
      borderTopWidth: true,
      borderTopStyle: true,
      borderTopColor: true
    },
    font: {
      fontStyle: true,
      fontVariant: true,
      fontWeight: true,
      fontSize: true,
      lineHeight: true,
      fontFamily: true
    },
    outline: {
      outlineWidth: true,
      outlineStyle: true,
      outlineColor: true
    }
  };
  var CSSProperty = {
    isUnitlessNumber,
    shorthandPropertyExpansions
  };
  exports.default = CSSProperty;
});

// node_modules/fbjs/lib/emptyFunction.js
var require_emptyFunction = __commonJS((exports, module4) => {
  "use strict";
  function makeEmptyFunction(arg) {
    return function() {
      return arg;
    };
  }
  var emptyFunction = function emptyFunction2() {
  };
  emptyFunction.thatReturns = makeEmptyFunction;
  emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
  emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
  emptyFunction.thatReturnsNull = makeEmptyFunction(null);
  emptyFunction.thatReturnsThis = function() {
    return this;
  };
  emptyFunction.thatReturnsArgument = function(arg) {
    return arg;
  };
  module4.exports = emptyFunction;
});

// node_modules/fbjs/lib/warning.js
var require_warning = __commonJS((exports, module4) => {
  "use strict";
  var emptyFunction = require_emptyFunction();
  var warning = emptyFunction;
  if (false) {
    printWarning = function printWarning2(format8) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var argIndex = 0;
      var message = "Warning: " + format8.replace(/%s/g, function() {
        return args[argIndex++];
      });
      if (typeof console !== "undefined") {
        console.error(message);
      }
      try {
        throw new Error(message);
      } catch (x5) {
      }
    };
    warning = function warning2(condition, format8) {
      if (format8 === void 0) {
        throw new Error("`warning(condition, format, ...args)` requires a warning message argument");
      }
      if (format8.indexOf("Failed Composite propType: ") === 0) {
        return;
      }
      if (!condition) {
        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          args[_key2 - 2] = arguments[_key2];
        }
        printWarning.apply(void 0, [format8].concat(args));
      }
    };
  }
  var printWarning;
  module4.exports = warning;
});

// node_modules/glamor/lib/CSSPropertyOperations/dangerousStyleValue.js
var require_dangerousStyleValue = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _CSSProperty = require_CSSProperty();
  var _CSSProperty2 = _interopRequireDefault(_CSSProperty);
  var _warning = require_warning();
  var _warning2 = _interopRequireDefault(_warning);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var isUnitlessNumber = _CSSProperty2.default.isUnitlessNumber;
  function dangerousStyleValue(name4, value3, component) {
    var isEmpty2 = value3 == null || typeof value3 === "boolean" || value3 === "";
    if (isEmpty2) {
      return "";
    }
    var isNonNumeric = isNaN(value3);
    if (isNonNumeric || value3 === 0 || isUnitlessNumber.hasOwnProperty(name4) && isUnitlessNumber[name4]) {
      return "" + value3;
    }
    if (typeof value3 === "string") {
      if (false) {
        if (component && value3 !== "0") {
          var owner = component._currentElement._owner;
          var ownerName = owner ? owner.getName() : null;
          if (ownerName && !styleWarnings[ownerName]) {
            styleWarnings[ownerName] = {};
          }
          var warned = false;
          if (ownerName) {
            var warnings = styleWarnings[ownerName];
            warned = warnings[name4];
            if (!warned) {
              warnings[name4] = true;
            }
          }
          if (!warned) {
            false ? (0, _warning2.default)(false, "a `%s` tag (owner: `%s`) was passed a numeric string value for CSS property `%s` (value: `%s`) which will be treated as a unitless number in a future version of React.", component._currentElement.type, ownerName || "unknown", name4, value3) : void 0;
          }
        }
      }
      value3 = value3.trim();
    }
    return value3 + "px";
  }
  exports.default = dangerousStyleValue;
});

// node_modules/fbjs/lib/hyphenate.js
var require_hyphenate = __commonJS((exports, module4) => {
  "use strict";
  var _uppercasePattern = /([A-Z])/g;
  function hyphenate(string) {
    return string.replace(_uppercasePattern, "-$1").toLowerCase();
  }
  module4.exports = hyphenate;
});

// node_modules/fbjs/lib/hyphenateStyleName.js
var require_hyphenateStyleName = __commonJS((exports, module4) => {
  "use strict";
  var hyphenate = require_hyphenate();
  var msPattern = /^ms-/;
  function hyphenateStyleName(string) {
    return hyphenate(string).replace(msPattern, "-ms-");
  }
  module4.exports = hyphenateStyleName;
});

// node_modules/fbjs/lib/memoizeStringOnly.js
var require_memoizeStringOnly = __commonJS((exports, module4) => {
  "use strict";
  function memoizeStringOnly(callback) {
    var cache2 = {};
    return function(string) {
      if (!cache2.hasOwnProperty(string)) {
        cache2[string] = callback.call(this, string);
      }
      return cache2[string];
    };
  }
  module4.exports = memoizeStringOnly;
});

// node_modules/glamor/lib/CSSPropertyOperations/index.js
var require_CSSPropertyOperations = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.processStyleName = void 0;
  exports.createMarkupForStyles = createMarkupForStyles;
  var _camelizeStyleName = require_camelizeStyleName();
  var _camelizeStyleName2 = _interopRequireDefault(_camelizeStyleName);
  var _dangerousStyleValue = require_dangerousStyleValue();
  var _dangerousStyleValue2 = _interopRequireDefault(_dangerousStyleValue);
  var _hyphenateStyleName = require_hyphenateStyleName();
  var _hyphenateStyleName2 = _interopRequireDefault(_hyphenateStyleName);
  var _memoizeStringOnly = require_memoizeStringOnly();
  var _memoizeStringOnly2 = _interopRequireDefault(_memoizeStringOnly);
  var _warning = require_warning();
  var _warning2 = _interopRequireDefault(_warning);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var processStyleName = exports.processStyleName = (0, _memoizeStringOnly2.default)(_hyphenateStyleName2.default);
  if (false) {
    badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
    badStyleValueWithSemicolonPattern = /;\s*$/;
    warnedStyleNames = {};
    warnedStyleValues = {};
    warnedForNaNValue = false;
    warnHyphenatedStyleName = function warnHyphenatedStyleName2(name4, owner) {
      if (warnedStyleNames.hasOwnProperty(name4) && warnedStyleNames[name4]) {
        return;
      }
      warnedStyleNames[name4] = true;
      false ? (0, _warning2.default)(false, "Unsupported style property %s. Did you mean %s?%s", name4, (0, _camelizeStyleName2.default)(name4), checkRenderMessage(owner)) : void 0;
    };
    warnBadVendoredStyleName = function warnBadVendoredStyleName2(name4, owner) {
      if (warnedStyleNames.hasOwnProperty(name4) && warnedStyleNames[name4]) {
        return;
      }
      warnedStyleNames[name4] = true;
      false ? (0, _warning2.default)(false, "Unsupported vendor-prefixed style property %s. Did you mean %s?%s", name4, name4.charAt(0).toUpperCase() + name4.slice(1), checkRenderMessage(owner)) : void 0;
    };
    warnStyleValueWithSemicolon = function warnStyleValueWithSemicolon2(name4, value3, owner) {
      if (warnedStyleValues.hasOwnProperty(value3) && warnedStyleValues[value3]) {
        return;
      }
      warnedStyleValues[value3] = true;
      false ? (0, _warning2.default)(false, `Style property values shouldn't contain a semicolon.%s Try "%s: %s" instead.`, checkRenderMessage(owner), name4, value3.replace(badStyleValueWithSemicolonPattern, "")) : void 0;
    };
    warnStyleValueIsNaN = function warnStyleValueIsNaN2(name4, value3, owner) {
      if (warnedForNaNValue) {
        return;
      }
      warnedForNaNValue = true;
      false ? (0, _warning2.default)(false, "`NaN` is an invalid value for the `%s` css style property.%s", name4, checkRenderMessage(owner)) : void 0;
    };
    checkRenderMessage = function checkRenderMessage2(owner) {
      if (owner) {
        var name4 = owner.getName();
        if (name4) {
          return " Check the render method of `" + name4 + "`.";
        }
      }
      return "";
    };
    warnValidStyle = function warnValidStyle2(name4, value3, component) {
      var owner = void 0;
      if (component) {
        owner = component._currentElement._owner;
      }
      if (name4.indexOf("-") > -1) {
        warnHyphenatedStyleName(name4, owner);
      } else if (badVendoredStyleNamePattern.test(name4)) {
        warnBadVendoredStyleName(name4, owner);
      } else if (badStyleValueWithSemicolonPattern.test(value3)) {
        warnStyleValueWithSemicolon(name4, value3, owner);
      }
      if (typeof value3 === "number" && isNaN(value3)) {
        warnStyleValueIsNaN(name4, value3, owner);
      }
    };
  }
  var badVendoredStyleNamePattern;
  var badStyleValueWithSemicolonPattern;
  var warnedStyleNames;
  var warnedStyleValues;
  var warnedForNaNValue;
  var warnHyphenatedStyleName;
  var warnBadVendoredStyleName;
  var warnStyleValueWithSemicolon;
  var warnStyleValueIsNaN;
  var checkRenderMessage;
  var warnValidStyle;
  function createMarkupForStyles(styles2, component) {
    var serialized = "";
    for (var styleName in styles2) {
      var isCustomProp = styleName.indexOf("--") === 0;
      if (!styles2.hasOwnProperty(styleName)) {
        continue;
      }
      if (styleName === "label") {
        continue;
      }
      var styleValue2 = styles2[styleName];
      if (false) {
        warnValidStyle(styleName, styleValue2, component);
      }
      if (styleValue2 != null) {
        if (isCustomProp) {
          serialized += styleName + ":" + styleValue2 + ";";
        } else {
          serialized += processStyleName(styleName) + ":";
          serialized += (0, _dangerousStyleValue2.default)(styleName, styleValue2, component) + ";";
        }
      }
    }
    return serialized || null;
  }
});

// node_modules/glamor/lib/clean.js
var require_clean2 = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  exports.default = clean;
  function isFalsy(value3) {
    return value3 === null || value3 === void 0 || value3 === false || (typeof value3 === "undefined" ? "undefined" : _typeof(value3)) === "object" && Object.keys(value3).length === 0;
  }
  function cleanObject(object2) {
    if (isFalsy(object2))
      return null;
    if ((typeof object2 === "undefined" ? "undefined" : _typeof(object2)) !== "object")
      return object2;
    var acc = {}, keys4 = Object.keys(object2), hasFalsy = false;
    for (var i = 0; i < keys4.length; i++) {
      var value3 = object2[keys4[i]];
      var filteredValue = clean(value3);
      if (filteredValue === null || filteredValue !== value3) {
        hasFalsy = true;
      }
      if (filteredValue !== null) {
        acc[keys4[i]] = filteredValue;
      }
    }
    return Object.keys(acc).length === 0 ? null : hasFalsy ? acc : object2;
  }
  function cleanArray(rules) {
    var hasFalsy = false;
    var filtered = [];
    rules.forEach(function(rule4) {
      var filteredRule = clean(rule4);
      if (filteredRule === null || filteredRule !== rule4) {
        hasFalsy = true;
      }
      if (filteredRule !== null) {
        filtered.push(filteredRule);
      }
    });
    return filtered.length == 0 ? null : hasFalsy ? filtered : rules;
  }
  function clean(input) {
    return Array.isArray(input) ? cleanArray(input) : cleanObject(input);
  }
});

// node_modules/inline-style-prefixer/static/staticData.js
var require_staticData = __commonJS((exports, module4) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var w3 = ["Webkit"];
  var m2 = ["Moz"];
  var ms = ["ms"];
  var wm = ["Webkit", "Moz"];
  var wms = ["Webkit", "ms"];
  var wmms = ["Webkit", "Moz", "ms"];
  exports.default = {
    plugins: [],
    prefixMap: {appearance: wm, userSelect: wmms, textEmphasisPosition: w3, textEmphasis: w3, textEmphasisStyle: w3, textEmphasisColor: w3, boxDecorationBreak: w3, clipPath: w3, maskImage: w3, maskMode: w3, maskRepeat: w3, maskPosition: w3, maskClip: w3, maskOrigin: w3, maskSize: w3, maskComposite: w3, mask: w3, maskBorderSource: w3, maskBorderMode: w3, maskBorderSlice: w3, maskBorderWidth: w3, maskBorderOutset: w3, maskBorderRepeat: w3, maskBorder: w3, maskType: w3, textDecorationStyle: w3, textDecorationSkip: w3, textDecorationLine: w3, textDecorationColor: w3, filter: w3, fontFeatureSettings: w3, breakAfter: wmms, breakBefore: wmms, breakInside: wmms, columnCount: wm, columnFill: wm, columnGap: wm, columnRule: wm, columnRuleColor: wm, columnRuleStyle: wm, columnRuleWidth: wm, columns: wm, columnSpan: wm, columnWidth: wm, writingMode: wms, flex: w3, flexBasis: w3, flexDirection: w3, flexGrow: w3, flexFlow: w3, flexShrink: w3, flexWrap: w3, alignContent: w3, alignItems: w3, alignSelf: w3, justifyContent: w3, order: w3, transform: w3, transformOrigin: w3, transformOriginX: w3, transformOriginY: w3, backfaceVisibility: w3, perspective: w3, perspectiveOrigin: w3, transformStyle: w3, transformOriginZ: w3, animation: w3, animationDelay: w3, animationDirection: w3, animationFillMode: w3, animationDuration: w3, animationIterationCount: w3, animationName: w3, animationPlayState: w3, animationTimingFunction: w3, backdropFilter: w3, fontKerning: w3, scrollSnapType: wms, scrollSnapPointsX: wms, scrollSnapPointsY: wms, scrollSnapDestination: wms, scrollSnapCoordinate: wms, shapeImageThreshold: w3, shapeImageMargin: w3, shapeImageOutside: w3, hyphens: wmms, flowInto: wms, flowFrom: wms, regionFragment: wms, textAlignLast: m2, tabSize: m2, wrapFlow: ms, wrapThrough: ms, wrapMargin: ms, gridTemplateColumns: ms, gridTemplateRows: ms, gridTemplateAreas: ms, gridTemplate: ms, gridAutoColumns: ms, gridAutoRows: ms, gridAutoFlow: ms, grid: ms, gridRowStart: ms, gridColumnStart: ms, gridRowEnd: ms, gridRow: ms, gridColumn: ms, gridColumnEnd: ms, gridColumnGap: ms, gridRowGap: ms, gridArea: ms, gridGap: ms, textSizeAdjust: wms, borderImage: w3, borderImageOutset: w3, borderImageRepeat: w3, borderImageSlice: w3, borderImageSource: w3, borderImageWidth: w3, transitionDelay: w3, transitionDuration: w3, transitionProperty: w3, transitionTimingFunction: w3}
  };
  module4.exports = exports["default"];
});

// node_modules/inline-style-prefixer/utils/capitalizeString.js
var require_capitalizeString = __commonJS((exports, module4) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = capitalizeString;
  function capitalizeString(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  module4.exports = exports["default"];
});

// node_modules/inline-style-prefixer/utils/prefixProperty.js
var require_prefixProperty = __commonJS((exports, module4) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = prefixProperty;
  var _capitalizeString = require_capitalizeString();
  var _capitalizeString2 = _interopRequireDefault(_capitalizeString);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function prefixProperty(prefixProperties, property2, style2) {
    if (prefixProperties.hasOwnProperty(property2)) {
      var requiredPrefixes = prefixProperties[property2];
      for (var i = 0, len = requiredPrefixes.length; i < len; ++i) {
        style2[requiredPrefixes[i] + (0, _capitalizeString2.default)(property2)] = style2[property2];
      }
    }
  }
  module4.exports = exports["default"];
});

// node_modules/inline-style-prefixer/utils/prefixValue.js
var require_prefixValue = __commonJS((exports, module4) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = prefixValue;
  function prefixValue(plugins, property2, value3, style2, metaData) {
    for (var i = 0, len = plugins.length; i < len; ++i) {
      var processedValue = plugins[i](property2, value3, style2, metaData);
      if (processedValue) {
        return processedValue;
      }
    }
  }
  module4.exports = exports["default"];
});

// node_modules/inline-style-prefixer/static/plugins/cursor.js
var require_cursor = __commonJS((exports, module4) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = cursor3;
  var prefixes4 = ["-webkit-", "-moz-", ""];
  var values4 = {
    "zoom-in": true,
    "zoom-out": true,
    grab: true,
    grabbing: true
  };
  function cursor3(property2, value3) {
    if (property2 === "cursor" && values4.hasOwnProperty(value3)) {
      return prefixes4.map(function(prefix) {
        return prefix + value3;
      });
    }
  }
  module4.exports = exports["default"];
});

// node_modules/css-in-js-utils/lib/isPrefixedValue.js
var require_isPrefixedValue = __commonJS((exports, module4) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isPrefixedValue;
  var regex = /-webkit-|-moz-|-ms-/;
  function isPrefixedValue(value3) {
    return typeof value3 === "string" && regex.test(value3);
  }
  module4.exports = exports["default"];
});

// node_modules/inline-style-prefixer/static/plugins/crossFade.js
var require_crossFade = __commonJS((exports, module4) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = crossFade;
  var _isPrefixedValue = require_isPrefixedValue();
  var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var prefixes4 = ["-webkit-", ""];
  function crossFade(property2, value3) {
    if (typeof value3 === "string" && !(0, _isPrefixedValue2.default)(value3) && value3.indexOf("cross-fade(") > -1) {
      return prefixes4.map(function(prefix) {
        return value3.replace(/cross-fade\(/g, prefix + "cross-fade(");
      });
    }
  }
  module4.exports = exports["default"];
});

// node_modules/inline-style-prefixer/static/plugins/filter.js
var require_filter = __commonJS((exports, module4) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = filter4;
  var _isPrefixedValue = require_isPrefixedValue();
  var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var prefixes4 = ["-webkit-", ""];
  function filter4(property2, value3) {
    if (typeof value3 === "string" && !(0, _isPrefixedValue2.default)(value3) && value3.indexOf("filter(") > -1) {
      return prefixes4.map(function(prefix) {
        return value3.replace(/filter\(/g, prefix + "filter(");
      });
    }
  }
  module4.exports = exports["default"];
});

// node_modules/inline-style-prefixer/static/plugins/flex.js
var require_flex = __commonJS((exports, module4) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = flex;
  var values4 = {
    flex: ["-webkit-box", "-moz-box", "-ms-flexbox", "-webkit-flex", "flex"],
    "inline-flex": ["-webkit-inline-box", "-moz-inline-box", "-ms-inline-flexbox", "-webkit-inline-flex", "inline-flex"]
  };
  function flex(property2, value3) {
    if (property2 === "display" && values4.hasOwnProperty(value3)) {
      return values4[value3];
    }
  }
  module4.exports = exports["default"];
});

// node_modules/inline-style-prefixer/static/plugins/flexboxOld.js
var require_flexboxOld = __commonJS((exports, module4) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = flexboxOld;
  var alternativeValues = {
    "space-around": "justify",
    "space-between": "justify",
    "flex-start": "start",
    "flex-end": "end",
    "wrap-reverse": "multiple",
    wrap: "multiple"
  };
  var alternativeProps = {
    alignItems: "WebkitBoxAlign",
    justifyContent: "WebkitBoxPack",
    flexWrap: "WebkitBoxLines"
  };
  function flexboxOld(property2, value3, style2) {
    if (property2 === "flexDirection" && typeof value3 === "string") {
      if (value3.indexOf("column") > -1) {
        style2.WebkitBoxOrient = "vertical";
      } else {
        style2.WebkitBoxOrient = "horizontal";
      }
      if (value3.indexOf("reverse") > -1) {
        style2.WebkitBoxDirection = "reverse";
      } else {
        style2.WebkitBoxDirection = "normal";
      }
    }
    if (alternativeProps.hasOwnProperty(property2)) {
      style2[alternativeProps[property2]] = alternativeValues[value3] || value3;
    }
  }
  module4.exports = exports["default"];
});

// node_modules/inline-style-prefixer/static/plugins/gradient.js
var require_gradient = __commonJS((exports, module4) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = gradient4;
  var _isPrefixedValue = require_isPrefixedValue();
  var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var prefixes4 = ["-webkit-", "-moz-", ""];
  var values4 = /linear-gradient|radial-gradient|repeating-linear-gradient|repeating-radial-gradient/;
  function gradient4(property2, value3) {
    if (typeof value3 === "string" && !(0, _isPrefixedValue2.default)(value3) && values4.test(value3)) {
      return prefixes4.map(function(prefix) {
        return prefix + value3;
      });
    }
  }
  module4.exports = exports["default"];
});

// node_modules/inline-style-prefixer/static/plugins/imageSet.js
var require_imageSet = __commonJS((exports, module4) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = imageSet;
  var _isPrefixedValue = require_isPrefixedValue();
  var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var prefixes4 = ["-webkit-", ""];
  function imageSet(property2, value3) {
    if (typeof value3 === "string" && !(0, _isPrefixedValue2.default)(value3) && value3.indexOf("image-set(") > -1) {
      return prefixes4.map(function(prefix) {
        return value3.replace(/image-set\(/g, prefix + "image-set(");
      });
    }
  }
  module4.exports = exports["default"];
});

// node_modules/inline-style-prefixer/static/plugins/position.js
var require_position = __commonJS((exports, module4) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = position2;
  function position2(property2, value3) {
    if (property2 === "position" && value3 === "sticky") {
      return ["-webkit-sticky", "sticky"];
    }
  }
  module4.exports = exports["default"];
});

// node_modules/inline-style-prefixer/static/plugins/sizing.js
var require_sizing = __commonJS((exports, module4) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = sizing;
  var prefixes4 = ["-webkit-", "-moz-", ""];
  var properties = {
    maxHeight: true,
    maxWidth: true,
    width: true,
    height: true,
    columnWidth: true,
    minWidth: true,
    minHeight: true
  };
  var values4 = {
    "min-content": true,
    "max-content": true,
    "fill-available": true,
    "fit-content": true,
    "contain-floats": true
  };
  function sizing(property2, value3) {
    if (properties.hasOwnProperty(property2) && values4.hasOwnProperty(value3)) {
      return prefixes4.map(function(prefix) {
        return prefix + value3;
      });
    }
  }
  module4.exports = exports["default"];
});

// node_modules/hyphenate-style-name/index.cjs.js
var require_index_cjs = __commonJS((exports, module4) => {
  "use strict";
  var uppercasePattern = /[A-Z]/g;
  var msPattern = /^ms-/;
  var cache2 = {};
  function toHyphenLower(match3) {
    return "-" + match3.toLowerCase();
  }
  function hyphenateStyleName(name4) {
    if (cache2.hasOwnProperty(name4)) {
      return cache2[name4];
    }
    var hName = name4.replace(uppercasePattern, toHyphenLower);
    return cache2[name4] = msPattern.test(hName) ? "-" + hName : hName;
  }
  module4.exports = hyphenateStyleName;
});

// node_modules/css-in-js-utils/lib/hyphenateProperty.js
var require_hyphenateProperty = __commonJS((exports, module4) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = hyphenateProperty;
  var _hyphenateStyleName = require_index_cjs();
  var _hyphenateStyleName2 = _interopRequireDefault(_hyphenateStyleName);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function hyphenateProperty(property2) {
    return (0, _hyphenateStyleName2.default)(property2);
  }
  module4.exports = exports["default"];
});

// node_modules/inline-style-prefixer/static/plugins/transition.js
var require_transition = __commonJS((exports, module4) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = transition;
  var _hyphenateProperty = require_hyphenateProperty();
  var _hyphenateProperty2 = _interopRequireDefault(_hyphenateProperty);
  var _isPrefixedValue = require_isPrefixedValue();
  var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);
  var _capitalizeString = require_capitalizeString();
  var _capitalizeString2 = _interopRequireDefault(_capitalizeString);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var properties = {
    transition: true,
    transitionProperty: true,
    WebkitTransition: true,
    WebkitTransitionProperty: true,
    MozTransition: true,
    MozTransitionProperty: true
  };
  var prefixMapping = {
    Webkit: "-webkit-",
    Moz: "-moz-",
    ms: "-ms-"
  };
  function prefixValue(value3, propertyPrefixMap) {
    if ((0, _isPrefixedValue2.default)(value3)) {
      return value3;
    }
    var multipleValues = value3.split(/,(?![^()]*(?:\([^()]*\))?\))/g);
    for (var i = 0, len = multipleValues.length; i < len; ++i) {
      var singleValue = multipleValues[i];
      var values4 = [singleValue];
      for (var property2 in propertyPrefixMap) {
        var dashCaseProperty = (0, _hyphenateProperty2.default)(property2);
        if (singleValue.indexOf(dashCaseProperty) > -1 && dashCaseProperty !== "order") {
          var prefixes4 = propertyPrefixMap[property2];
          for (var j = 0, pLen = prefixes4.length; j < pLen; ++j) {
            values4.unshift(singleValue.replace(dashCaseProperty, prefixMapping[prefixes4[j]] + dashCaseProperty));
          }
        }
      }
      multipleValues[i] = values4.join(",");
    }
    return multipleValues.join(",");
  }
  function transition(property2, value3, style2, propertyPrefixMap) {
    if (typeof value3 === "string" && properties.hasOwnProperty(property2)) {
      var outputValue = prefixValue(value3, propertyPrefixMap);
      var webkitOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function(val) {
        return !/-moz-|-ms-/.test(val);
      }).join(",");
      if (property2.indexOf("Webkit") > -1) {
        return webkitOutput;
      }
      var mozOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function(val) {
        return !/-webkit-|-ms-/.test(val);
      }).join(",");
      if (property2.indexOf("Moz") > -1) {
        return mozOutput;
      }
      style2["Webkit" + (0, _capitalizeString2.default)(property2)] = webkitOutput;
      style2["Moz" + (0, _capitalizeString2.default)(property2)] = mozOutput;
      return outputValue;
    }
  }
  module4.exports = exports["default"];
});

// node_modules/glamor/lib/prefixer.js
var require_prefixer = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = prefixer;
  var _staticData = require_staticData();
  var _staticData2 = _interopRequireDefault(_staticData);
  var _prefixProperty = require_prefixProperty();
  var _prefixProperty2 = _interopRequireDefault(_prefixProperty);
  var _prefixValue = require_prefixValue();
  var _prefixValue2 = _interopRequireDefault(_prefixValue);
  var _cursor = require_cursor();
  var _cursor2 = _interopRequireDefault(_cursor);
  var _crossFade = require_crossFade();
  var _crossFade2 = _interopRequireDefault(_crossFade);
  var _filter = require_filter();
  var _filter2 = _interopRequireDefault(_filter);
  var _flex = require_flex();
  var _flex2 = _interopRequireDefault(_flex);
  var _flexboxOld = require_flexboxOld();
  var _flexboxOld2 = _interopRequireDefault(_flexboxOld);
  var _gradient = require_gradient();
  var _gradient2 = _interopRequireDefault(_gradient);
  var _imageSet = require_imageSet();
  var _imageSet2 = _interopRequireDefault(_imageSet);
  var _position = require_position();
  var _position2 = _interopRequireDefault(_position);
  var _sizing = require_sizing();
  var _sizing2 = _interopRequireDefault(_sizing);
  var _transition = require_transition();
  var _transition2 = _interopRequireDefault(_transition);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var plugins = [_crossFade2.default, _cursor2.default, _filter2.default, _flexboxOld2.default, _gradient2.default, _imageSet2.default, _position2.default, _sizing2.default, _transition2.default, _flex2.default];
  var prefixMap = _staticData2.default.prefixMap;
  function prefixer(style2) {
    for (var property2 in style2) {
      var value3 = style2[property2];
      var processedValue = (0, _prefixValue2.default)(plugins, property2, value3, style2, prefixMap);
      if (processedValue) {
        style2[property2] = processedValue;
      }
      (0, _prefixProperty2.default)(prefixMap, property2, style2);
    }
    return style2;
  }
});

// node_modules/glamor/lib/plugins.js
var require_plugins = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source4 = arguments[i];
      for (var key2 in source4) {
        if (Object.prototype.hasOwnProperty.call(source4, key2)) {
          target[key2] = source4[key2];
        }
      }
    }
    return target;
  };
  exports.PluginSet = PluginSet;
  exports.fallbacks = fallbacks;
  exports.contentWrap = contentWrap;
  exports.prefixes = prefixes4;
  var _objectAssign = require_object_assign();
  var _objectAssign2 = _interopRequireDefault(_objectAssign);
  var _CSSPropertyOperations = require_CSSPropertyOperations();
  var _prefixer = require_prefixer();
  var _prefixer2 = _interopRequireDefault(_prefixer);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var isDev = function(x5) {
    return x5 === "development" || !x5;
  }("production");
  function PluginSet(initial) {
    this.fns = initial || [];
  }
  (0, _objectAssign2.default)(PluginSet.prototype, {
    add: function add6() {
      var _this = this;
      for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {
        fns[_key] = arguments[_key];
      }
      fns.forEach(function(fn) {
        if (_this.fns.indexOf(fn) >= 0) {
          if (isDev) {
            console.warn("adding the same plugin again, ignoring");
          }
        } else {
          _this.fns = [fn].concat(_this.fns);
        }
      });
    },
    remove: function remove3(fn) {
      this.fns = this.fns.filter(function(x5) {
        return x5 !== fn;
      });
    },
    clear: function clear2() {
      this.fns = [];
    },
    transform: function transform4(o) {
      return this.fns.reduce(function(o2, fn) {
        return fn(o2);
      }, o);
    }
  });
  function fallbacks(node) {
    var hasArray = Object.keys(node.style).map(function(x5) {
      return Array.isArray(node.style[x5]);
    }).indexOf(true) >= 0;
    if (hasArray) {
      var style2 = node.style;
      var flattened = Object.keys(style2).reduce(function(o, key2) {
        o[key2] = Array.isArray(style2[key2]) ? style2[key2].join("; " + (0, _CSSPropertyOperations.processStyleName)(key2) + ": ") : style2[key2];
        return o;
      }, {});
      return (0, _objectAssign2.default)({}, node, {style: flattened});
    }
    return node;
  }
  var contentValues = ["normal", "none", "counter", "open-quote", "close-quote", "no-open-quote", "no-close-quote", "initial", "inherit"];
  function contentWrap(node) {
    if (node.style.content) {
      var cont = node.style.content;
      if (contentValues.indexOf(cont) >= 0) {
        return node;
      }
      if (/^(attr|calc|counters?|url)\(/.test(cont)) {
        return node;
      }
      if (cont.charAt(0) === cont.charAt(cont.length - 1) && (cont.charAt(0) === '"' || cont.charAt(0) === "'")) {
        return node;
      }
      return _extends({}, node, {style: _extends({}, node.style, {content: '"' + cont + '"'})});
    }
    return node;
  }
  function prefixes4(node) {
    return (0, _objectAssign2.default)({}, node, {style: (0, _prefixer2.default)(_extends({}, node.style))});
  }
});

// node_modules/glamor/lib/hash.js
var require_hash = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = doHash;
  function doHash(str, seed) {
    var m2 = 1540483477;
    var r2 = 24;
    var h3 = seed ^ str.length;
    var length3 = str.length;
    var currentIndex = 0;
    while (length3 >= 4) {
      var k = UInt32(str, currentIndex);
      k = Umul32(k, m2);
      k ^= k >>> r2;
      k = Umul32(k, m2);
      h3 = Umul32(h3, m2);
      h3 ^= k;
      currentIndex += 4;
      length3 -= 4;
    }
    switch (length3) {
      case 3:
        h3 ^= UInt16(str, currentIndex);
        h3 ^= str.charCodeAt(currentIndex + 2) << 16;
        h3 = Umul32(h3, m2);
        break;
      case 2:
        h3 ^= UInt16(str, currentIndex);
        h3 = Umul32(h3, m2);
        break;
      case 1:
        h3 ^= str.charCodeAt(currentIndex);
        h3 = Umul32(h3, m2);
        break;
    }
    h3 ^= h3 >>> 13;
    h3 = Umul32(h3, m2);
    h3 ^= h3 >>> 15;
    return h3 >>> 0;
  }
  function UInt32(str, pos) {
    return str.charCodeAt(pos++) + (str.charCodeAt(pos++) << 8) + (str.charCodeAt(pos++) << 16) + (str.charCodeAt(pos) << 24);
  }
  function UInt16(str, pos) {
    return str.charCodeAt(pos++) + (str.charCodeAt(pos++) << 8);
  }
  function Umul32(n, m2) {
    n = n | 0;
    m2 = m2 | 0;
    var nlo = n & 65535;
    var nhi = n >>> 16;
    var res = nlo * m2 + ((nhi * m2 & 65535) << 16) | 0;
    return res;
  }
});

// node_modules/glamor/lib/index.js
var require_lib = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.compose = exports.merge = exports.$ = exports.style = exports.presets = exports.keyframes = exports.fontFace = exports.insertGlobal = exports.insertRule = exports.plugins = exports.styleSheet = void 0;
  exports.speedy = speedy;
  exports.simulations = simulations;
  exports.simulate = simulate;
  exports.cssLabels = cssLabels;
  exports.isLikeRule = isLikeRule;
  exports.idFor = idFor;
  exports.css = css6;
  exports.rehydrate = rehydrate;
  exports.flush = flush2;
  exports.select = select2;
  exports.parent = parent;
  exports.media = media;
  exports.pseudo = pseudo;
  exports.active = active;
  exports.any = any;
  exports.checked = checked;
  exports.disabled = disabled;
  exports.empty = empty3;
  exports.enabled = enabled;
  exports._default = _default;
  exports.first = first;
  exports.firstChild = firstChild;
  exports.firstOfType = firstOfType;
  exports.fullscreen = fullscreen;
  exports.focus = focus;
  exports.hover = hover2;
  exports.indeterminate = indeterminate;
  exports.inRange = inRange;
  exports.invalid = invalid;
  exports.lastChild = lastChild;
  exports.lastOfType = lastOfType;
  exports.left = left;
  exports.link = link2;
  exports.onlyChild = onlyChild;
  exports.onlyOfType = onlyOfType;
  exports.optional = optional2;
  exports.outOfRange = outOfRange;
  exports.readOnly = readOnly;
  exports.readWrite = readWrite;
  exports.required = required2;
  exports.right = right;
  exports.root = root2;
  exports.scope = scope;
  exports.target = target;
  exports.valid = valid;
  exports.visited = visited;
  exports.dir = dir;
  exports.lang = lang;
  exports.not = not;
  exports.nthChild = nthChild;
  exports.nthLastChild = nthLastChild;
  exports.nthLastOfType = nthLastOfType;
  exports.nthOfType = nthOfType;
  exports.after = after;
  exports.before = before;
  exports.firstLetter = firstLetter;
  exports.firstLine = firstLine;
  exports.selection = selection2;
  exports.backdrop = backdrop;
  exports.placeholder = placeholder;
  exports.cssFor = cssFor;
  exports.attribsFor = attribsFor;
  var _objectAssign = require_object_assign();
  var _objectAssign2 = _interopRequireDefault(_objectAssign);
  var _sheet = require_sheet();
  var _CSSPropertyOperations = require_CSSPropertyOperations();
  var _clean = require_clean2();
  var _clean2 = _interopRequireDefault(_clean);
  var _plugins = require_plugins();
  var _hash = require_hash();
  var _hash2 = _interopRequireDefault(_hash);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    } else {
      return Array.from(arr);
    }
  }
  function _defineProperty(obj, key2, value3) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, {value: value3, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key2] = value3;
    }
    return obj;
  }
  var styleSheet = exports.styleSheet = new _sheet.StyleSheet();
  styleSheet.inject();
  function speedy(bool) {
    return styleSheet.speedy(bool);
  }
  var plugins = exports.plugins = styleSheet.plugins = new _plugins.PluginSet([_plugins.prefixes, _plugins.contentWrap, _plugins.fallbacks]);
  plugins.media = new _plugins.PluginSet();
  plugins.fontFace = new _plugins.PluginSet();
  plugins.keyframes = new _plugins.PluginSet([_plugins.prefixes, _plugins.fallbacks]);
  var isDev = false;
  var isTest = false;
  var isBrowser = typeof window !== "undefined";
  var canSimulate = isDev;
  var warned1 = false;
  var warned2 = false;
  function simulations() {
    var bool = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    canSimulate = !!bool;
  }
  function simulate() {
    for (var _len = arguments.length, pseudos = Array(_len), _key = 0; _key < _len; _key++) {
      pseudos[_key] = arguments[_key];
    }
    pseudos = (0, _clean2.default)(pseudos);
    if (!pseudos)
      return {};
    if (!canSimulate) {
      if (!warned1) {
        console.warn("can't simulate without once calling simulations(true)");
        warned1 = true;
      }
      if (!isDev && !isTest && !warned2) {
        console.warn("don't use simulation outside dev");
        warned2 = true;
      }
      return {};
    }
    return pseudos.reduce(function(o, p) {
      return o["data-simulate-" + simple(p)] = "", o;
    }, {});
  }
  var hasLabels = isDev;
  function cssLabels(bool) {
    hasLabels = !!bool;
  }
  function simple(str) {
    var char = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return str.toLowerCase().replace(/[^a-z0-9]/g, char);
  }
  function hashify(obj) {
    var str = JSON.stringify(obj);
    var toRet = (0, _hash2.default)(str).toString(36);
    if (obj.label && obj.label.length > 0 && isDev) {
      return simple(obj.label.join("."), "-") + "-" + toRet;
    }
    return toRet;
  }
  function isLikeRule(rule4) {
    var keys4 = Object.keys(rule4).filter(function(x5) {
      return x5 !== "toString";
    });
    if (keys4.length !== 1) {
      return false;
    }
    return !!/data\-css\-([a-zA-Z0-9\-_]+)/.exec(keys4[0]);
  }
  function idFor(rule4) {
    var keys4 = Object.keys(rule4).filter(function(x5) {
      return x5 !== "toString";
    });
    if (keys4.length !== 1)
      throw new Error("not a rule");
    var regex = /data\-css\-([a-zA-Z0-9\-_]+)/;
    var match3 = regex.exec(keys4[0]);
    if (!match3)
      throw new Error("not a rule");
    return match3[1];
  }
  var selectorTokenizer = /[(),]|"(?:\\.|[^"\n])*"|'(?:\\.|[^'\n])*'|\/\*[\s\S]*?\*\//g;
  function splitSelector(selector2) {
    if (selector2.indexOf(",") === -1) {
      return [selector2];
    }
    var indices = [], res = [], inParen = 0, o;
    while (o = selectorTokenizer.exec(selector2)) {
      switch (o[0]) {
        case "(":
          inParen++;
          break;
        case ")":
          inParen--;
          break;
        case ",":
          if (inParen)
            break;
          indices.push(o.index);
      }
    }
    for (o = indices.length; o--; ) {
      res.unshift(selector2.slice(indices[o] + 1));
      selector2 = selector2.slice(0, indices[o]);
    }
    res.unshift(selector2);
    return res;
  }
  function selector(id4, path3) {
    if (!id4) {
      return path3.replace(/\&/g, "");
    }
    if (!path3)
      return ".css-" + id4 + ",[data-css-" + id4 + "]";
    var x5 = splitSelector(path3).map(function(x6) {
      return x6.indexOf("&") >= 0 ? [x6.replace(/\&/mg, ".css-" + id4), x6.replace(/\&/mg, "[data-css-" + id4 + "]")].join(",") : ".css-" + id4 + x6 + ",[data-css-" + id4 + "]" + x6;
    }).join(",");
    if (canSimulate && /^\&\:/.exec(path3) && !/\s/.exec(path3)) {
      x5 += ",.css-" + id4 + "[data-simulate-" + simple(path3) + "],[data-css-" + id4 + "][data-simulate-" + simple(path3) + "]";
    }
    return x5;
  }
  function toCSS(_ref) {
    var selector2 = _ref.selector, style3 = _ref.style;
    var result = plugins.transform({selector: selector2, style: style3});
    return result.selector + "{" + (0, _CSSPropertyOperations.createMarkupForStyles)(result.style) + "}";
  }
  function deconstruct(style3) {
    var plain = void 0, selects = void 0, medias = void 0, supports = void 0;
    Object.keys(style3).forEach(function(key2) {
      if (key2.indexOf("&") >= 0) {
        selects = selects || {};
        selects[key2] = style3[key2];
      } else if (key2.indexOf("@media") === 0) {
        medias = medias || {};
        medias[key2] = deconstruct(style3[key2]);
      } else if (key2.indexOf("@supports") === 0) {
        supports = supports || {};
        supports[key2] = deconstruct(style3[key2]);
      } else if (key2 === "label") {
        if (style3.label.length > 0) {
          plain = plain || {};
          plain.label = hasLabels ? style3.label.join(".") : "";
        }
      } else {
        plain = plain || {};
        plain[key2] = style3[key2];
      }
    });
    return {plain, selects, medias, supports};
  }
  function deconstructedStyleToCSS(id4, style3) {
    var css7 = [];
    var plain = style3.plain, selects = style3.selects, medias = style3.medias, supports = style3.supports;
    if (plain) {
      css7.push(toCSS({style: plain, selector: selector(id4)}));
    }
    if (selects) {
      Object.keys(selects).forEach(function(key2) {
        return css7.push(toCSS({style: selects[key2], selector: selector(id4, key2)}));
      });
    }
    if (medias) {
      Object.keys(medias).forEach(function(key2) {
        return css7.push(key2 + "{" + deconstructedStyleToCSS(id4, medias[key2]).join("") + "}");
      });
    }
    if (supports) {
      Object.keys(supports).forEach(function(key2) {
        return css7.push(key2 + "{" + deconstructedStyleToCSS(id4, supports[key2]).join("") + "}");
      });
    }
    return css7;
  }
  var inserted = styleSheet.inserted = {};
  function insert2(spec) {
    if (!inserted[spec.id]) {
      inserted[spec.id] = true;
      var deconstructed = deconstruct(spec.style);
      var rules = deconstructedStyleToCSS(spec.id, deconstructed);
      inserted[spec.id] = isBrowser ? true : rules;
      rules.forEach(function(cssRule) {
        return styleSheet.insert(cssRule);
      });
    }
  }
  var registered = styleSheet.registered = {};
  function register(spec) {
    if (!registered[spec.id]) {
      registered[spec.id] = spec;
    }
  }
  function _getRegistered(rule4) {
    if (isLikeRule(rule4)) {
      var ret = registered[idFor(rule4)];
      if (ret == null) {
        throw new Error("[glamor] an unexpected rule cache miss occurred. This is probably a sign of multiple glamor instances in your app. See https://github.com/threepointone/glamor/issues/79");
      }
      return ret;
    }
    return rule4;
  }
  var ruleCache = {};
  function toRule(spec) {
    register(spec);
    insert2(spec);
    if (ruleCache[spec.id]) {
      return ruleCache[spec.id];
    }
    var ret = _defineProperty({}, "data-css-" + spec.id, hasLabels ? spec.label || "" : "");
    Object.defineProperty(ret, "toString", {
      enumerable: false,
      value: function value3() {
        return "css-" + spec.id;
      }
    });
    ruleCache[spec.id] = ret;
    return ret;
  }
  function isSelector(key2) {
    var possibles = [":", ".", "[", ">", " "], found = false, ch2 = key2.charAt(0);
    for (var i = 0; i < possibles.length; i++) {
      if (ch2 === possibles[i]) {
        found = true;
        break;
      }
    }
    return found || key2.indexOf("&") >= 0;
  }
  function joinSelectors(a2, b2) {
    var as = splitSelector(a2).map(function(a3) {
      return !(a3.indexOf("&") >= 0) ? "&" + a3 : a3;
    });
    var bs = splitSelector(b2).map(function(b3) {
      return !(b3.indexOf("&") >= 0) ? "&" + b3 : b3;
    });
    return bs.reduce(function(arr, b3) {
      return arr.concat(as.map(function(a3) {
        return b3.replace(/\&/g, a3);
      }));
    }, []).join(",");
  }
  function joinMediaQueries(a2, b2) {
    return a2 ? "@media " + a2.substring(6) + " and " + b2.substring(6) : b2;
  }
  function isMediaQuery(key2) {
    return key2.indexOf("@media") === 0;
  }
  function isSupports(key2) {
    return key2.indexOf("@supports") === 0;
  }
  function joinSupports(a2, b2) {
    return a2 ? "@supports " + a2.substring(9) + " and " + b2.substring(9) : b2;
  }
  function flatten2(inArr) {
    var arr = [];
    for (var i = 0; i < inArr.length; i++) {
      if (Array.isArray(inArr[i]))
        arr = arr.concat(flatten2(inArr[i]));
      else
        arr = arr.concat(inArr[i]);
    }
    return arr;
  }
  var prefixedPseudoSelectors = {
    "::placeholder": ["::-webkit-input-placeholder", "::-moz-placeholder", "::-ms-input-placeholder"],
    ":fullscreen": [":-webkit-full-screen", ":-moz-full-screen", ":-ms-fullscreen"]
  };
  function build(dest, _ref2) {
    var _ref2$selector = _ref2.selector, selector2 = _ref2$selector === void 0 ? "" : _ref2$selector, _ref2$mq = _ref2.mq, mq = _ref2$mq === void 0 ? "" : _ref2$mq, _ref2$supp = _ref2.supp, supp = _ref2$supp === void 0 ? "" : _ref2$supp, _ref2$src = _ref2.src, src = _ref2$src === void 0 ? {} : _ref2$src;
    if (!Array.isArray(src)) {
      src = [src];
    }
    src = flatten2(src);
    src.forEach(function(_src) {
      if (isLikeRule(_src)) {
        var reg = _getRegistered(_src);
        if (reg.type !== "css") {
          throw new Error("cannot merge this rule");
        }
        _src = reg.style;
      }
      _src = (0, _clean2.default)(_src);
      if (_src && _src.composes) {
        build(dest, {selector: selector2, mq, supp, src: _src.composes});
      }
      Object.keys(_src || {}).forEach(function(key2) {
        if (isSelector(key2)) {
          if (prefixedPseudoSelectors[key2]) {
            prefixedPseudoSelectors[key2].forEach(function(p) {
              return build(dest, {selector: joinSelectors(selector2, p), mq, supp, src: _src[key2]});
            });
          }
          build(dest, {selector: joinSelectors(selector2, key2), mq, supp, src: _src[key2]});
        } else if (isMediaQuery(key2)) {
          build(dest, {selector: selector2, mq: joinMediaQueries(mq, key2), supp, src: _src[key2]});
        } else if (isSupports(key2)) {
          build(dest, {selector: selector2, mq, supp: joinSupports(supp, key2), src: _src[key2]});
        } else if (key2 === "composes") {
        } else {
          var _dest = dest;
          if (supp) {
            _dest[supp] = _dest[supp] || {};
            _dest = _dest[supp];
          }
          if (mq) {
            _dest[mq] = _dest[mq] || {};
            _dest = _dest[mq];
          }
          if (selector2) {
            _dest[selector2] = _dest[selector2] || {};
            _dest = _dest[selector2];
          }
          if (key2 === "label") {
            if (hasLabels) {
              dest.label = dest.label.concat(_src.label);
            }
          } else {
            _dest[key2] = _src[key2];
          }
        }
      });
    });
  }
  function _css(rules) {
    var style3 = {label: []};
    build(style3, {src: rules});
    var spec = {
      id: hashify(style3),
      style: style3,
      label: hasLabels ? style3.label.join(".") : "",
      type: "css"
    };
    return toRule(spec);
  }
  var nullrule = {};
  Object.defineProperty(nullrule, "toString", {
    enumerable: false,
    value: function value3() {
      return "css-nil";
    }
  });
  var inputCaches = typeof WeakMap !== "undefined" ? [nullrule, new WeakMap(), new WeakMap(), new WeakMap()] : [nullrule];
  var warnedWeakMapError = false;
  function multiIndexCache(fn) {
    return function(args) {
      if (inputCaches[args.length]) {
        var coi = inputCaches[args.length];
        var ctr = 0;
        while (ctr < args.length - 1) {
          if (!coi.has(args[ctr])) {
            coi.set(args[ctr], new WeakMap());
          }
          coi = coi.get(args[ctr]);
          ctr++;
        }
        if (coi.has(args[args.length - 1])) {
          var ret = coi.get(args[ctr]);
          if (registered[ret.toString().substring(4)]) {
            return ret;
          }
        }
      }
      var value3 = fn(args);
      if (inputCaches[args.length]) {
        var _ctr = 0, _coi = inputCaches[args.length];
        while (_ctr < args.length - 1) {
          _coi = _coi.get(args[_ctr]);
          _ctr++;
        }
        try {
          _coi.set(args[_ctr], value3);
        } catch (err) {
          if (isDev && !warnedWeakMapError) {
            var _console;
            warnedWeakMapError = true;
            (_console = console).warn.apply(_console, ["failed setting the WeakMap cache for args:"].concat(_toConsumableArray(args)));
            console.warn("this should NOT happen, please file a bug on the github repo.");
          }
        }
      }
      return value3;
    };
  }
  var cachedCss = typeof WeakMap !== "undefined" ? multiIndexCache(_css) : _css;
  function css6() {
    for (var _len2 = arguments.length, rules = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      rules[_key2] = arguments[_key2];
    }
    if (rules[0] && rules[0].length && rules[0].raw) {
      throw new Error("you forgot to include glamor/babel in your babel plugins.");
    }
    rules = (0, _clean2.default)(rules);
    if (!rules) {
      return nullrule;
    }
    return cachedCss(rules);
  }
  css6.insert = function(css7) {
    var spec = {
      id: hashify(css7),
      css: css7,
      type: "raw"
    };
    register(spec);
    if (!inserted[spec.id]) {
      styleSheet.insert(spec.css);
      inserted[spec.id] = isBrowser ? true : [spec.css];
    }
  };
  var insertRule = exports.insertRule = css6.insert;
  css6.global = function(selector2, style3) {
    style3 = (0, _clean2.default)(style3);
    if (style3) {
      return css6.insert(toCSS({selector: selector2, style: style3}));
    }
  };
  var insertGlobal = exports.insertGlobal = css6.global;
  function insertKeyframe(spec) {
    if (!inserted[spec.id]) {
      var inner = Object.keys(spec.keyframes).map(function(kf) {
        var result = plugins.keyframes.transform({id: spec.id, name: kf, style: spec.keyframes[kf]});
        return result.name + "{" + (0, _CSSPropertyOperations.createMarkupForStyles)(result.style) + "}";
      }).join("");
      var rules = ["-webkit-", "-moz-", "-o-", ""].map(function(prefix) {
        return "@" + prefix + "keyframes " + (spec.name + "_" + spec.id) + "{" + inner + "}";
      });
      rules.forEach(function(rule4) {
        return styleSheet.insert(rule4);
      });
      inserted[spec.id] = isBrowser ? true : rules;
    }
  }
  css6.keyframes = function(name4, kfs) {
    if (!kfs) {
      kfs = name4, name4 = "animation";
    }
    kfs = (0, _clean2.default)(kfs) || {};
    var spec = {
      id: hashify({name: name4, kfs}),
      type: "keyframes",
      name: name4,
      keyframes: kfs
    };
    register(spec);
    insertKeyframe(spec);
    return name4 + "_" + spec.id;
  };
  css6.fontFace = function(font3) {
    font3 = (0, _clean2.default)(font3);
    var spec = {
      id: hashify(font3),
      type: "font-face",
      font: font3
    };
    register(spec);
    insertFontFace(spec);
    return font3.fontFamily;
  };
  var fontFace = exports.fontFace = css6.fontFace;
  var keyframes = exports.keyframes = css6.keyframes;
  function insertFontFace(spec) {
    if (!inserted[spec.id]) {
      var rule4 = "@font-face{" + (0, _CSSPropertyOperations.createMarkupForStyles)(spec.font) + "}";
      styleSheet.insert(rule4);
      inserted[spec.id] = isBrowser ? true : [rule4];
    }
  }
  function rehydrate(ids) {
    (0, _objectAssign2.default)(inserted, ids.reduce(function(o, i) {
      return o[i] = true, o;
    }, {}));
  }
  function flush2() {
    inserted = styleSheet.inserted = {};
    registered = styleSheet.registered = {};
    ruleCache = {};
    styleSheet.flush();
    styleSheet.inject();
  }
  var presets = exports.presets = {
    mobile: "(min-width: 400px)",
    Mobile: "@media (min-width: 400px)",
    phablet: "(min-width: 550px)",
    Phablet: "@media (min-width: 550px)",
    tablet: "(min-width: 750px)",
    Tablet: "@media (min-width: 750px)",
    desktop: "(min-width: 1000px)",
    Desktop: "@media (min-width: 1000px)",
    hd: "(min-width: 1200px)",
    Hd: "@media (min-width: 1200px)"
  };
  var style2 = exports.style = css6;
  function select2(selector2) {
    for (var _len3 = arguments.length, styles2 = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      styles2[_key3 - 1] = arguments[_key3];
    }
    if (!selector2) {
      return style2(styles2);
    }
    return css6(_defineProperty({}, selector2, styles2));
  }
  var $3 = exports.$ = select2;
  function parent(selector2) {
    for (var _len4 = arguments.length, styles2 = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      styles2[_key4 - 1] = arguments[_key4];
    }
    return css6(_defineProperty({}, selector2 + " &", styles2));
  }
  var merge6 = exports.merge = css6;
  var compose = exports.compose = css6;
  function media(query) {
    for (var _len5 = arguments.length, rules = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
      rules[_key5 - 1] = arguments[_key5];
    }
    return css6(_defineProperty({}, "@media " + query, rules));
  }
  function pseudo(selector2) {
    for (var _len6 = arguments.length, styles2 = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
      styles2[_key6 - 1] = arguments[_key6];
    }
    return css6(_defineProperty({}, selector2, styles2));
  }
  function active(x5) {
    return pseudo(":active", x5);
  }
  function any(x5) {
    return pseudo(":any", x5);
  }
  function checked(x5) {
    return pseudo(":checked", x5);
  }
  function disabled(x5) {
    return pseudo(":disabled", x5);
  }
  function empty3(x5) {
    return pseudo(":empty", x5);
  }
  function enabled(x5) {
    return pseudo(":enabled", x5);
  }
  function _default(x5) {
    return pseudo(":default", x5);
  }
  function first(x5) {
    return pseudo(":first", x5);
  }
  function firstChild(x5) {
    return pseudo(":first-child", x5);
  }
  function firstOfType(x5) {
    return pseudo(":first-of-type", x5);
  }
  function fullscreen(x5) {
    return pseudo(":fullscreen", x5);
  }
  function focus(x5) {
    return pseudo(":focus", x5);
  }
  function hover2(x5) {
    return pseudo(":hover", x5);
  }
  function indeterminate(x5) {
    return pseudo(":indeterminate", x5);
  }
  function inRange(x5) {
    return pseudo(":in-range", x5);
  }
  function invalid(x5) {
    return pseudo(":invalid", x5);
  }
  function lastChild(x5) {
    return pseudo(":last-child", x5);
  }
  function lastOfType(x5) {
    return pseudo(":last-of-type", x5);
  }
  function left(x5) {
    return pseudo(":left", x5);
  }
  function link2(x5) {
    return pseudo(":link", x5);
  }
  function onlyChild(x5) {
    return pseudo(":only-child", x5);
  }
  function onlyOfType(x5) {
    return pseudo(":only-of-type", x5);
  }
  function optional2(x5) {
    return pseudo(":optional", x5);
  }
  function outOfRange(x5) {
    return pseudo(":out-of-range", x5);
  }
  function readOnly(x5) {
    return pseudo(":read-only", x5);
  }
  function readWrite(x5) {
    return pseudo(":read-write", x5);
  }
  function required2(x5) {
    return pseudo(":required", x5);
  }
  function right(x5) {
    return pseudo(":right", x5);
  }
  function root2(x5) {
    return pseudo(":root", x5);
  }
  function scope(x5) {
    return pseudo(":scope", x5);
  }
  function target(x5) {
    return pseudo(":target", x5);
  }
  function valid(x5) {
    return pseudo(":valid", x5);
  }
  function visited(x5) {
    return pseudo(":visited", x5);
  }
  function dir(p, x5) {
    return pseudo(":dir(" + p + ")", x5);
  }
  function lang(p, x5) {
    return pseudo(":lang(" + p + ")", x5);
  }
  function not(p, x5) {
    var selector2 = p.split(",").map(function(x6) {
      return x6.trim();
    }).map(function(x6) {
      return ":not(" + x6 + ")";
    });
    if (selector2.length === 1) {
      return pseudo(":not(" + p + ")", x5);
    }
    return select2(selector2.join(""), x5);
  }
  function nthChild(p, x5) {
    return pseudo(":nth-child(" + p + ")", x5);
  }
  function nthLastChild(p, x5) {
    return pseudo(":nth-last-child(" + p + ")", x5);
  }
  function nthLastOfType(p, x5) {
    return pseudo(":nth-last-of-type(" + p + ")", x5);
  }
  function nthOfType(p, x5) {
    return pseudo(":nth-of-type(" + p + ")", x5);
  }
  function after(x5) {
    return pseudo("::after", x5);
  }
  function before(x5) {
    return pseudo("::before", x5);
  }
  function firstLetter(x5) {
    return pseudo("::first-letter", x5);
  }
  function firstLine(x5) {
    return pseudo("::first-line", x5);
  }
  function selection2(x5) {
    return pseudo("::selection", x5);
  }
  function backdrop(x5) {
    return pseudo("::backdrop", x5);
  }
  function placeholder(x5) {
    return css6({"::placeholder": x5});
  }
  function cssFor() {
    for (var _len7 = arguments.length, rules = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      rules[_key7] = arguments[_key7];
    }
    rules = (0, _clean2.default)(rules);
    return rules ? rules.map(function(r2) {
      var style3 = {label: []};
      build(style3, {src: r2});
      return deconstructedStyleToCSS(hashify(style3), deconstruct(style3)).join("");
    }).join("") : "";
  }
  function attribsFor() {
    for (var _len8 = arguments.length, rules = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      rules[_key8] = arguments[_key8];
    }
    rules = (0, _clean2.default)(rules);
    var htmlAttributes = rules ? rules.map(function(rule4) {
      idFor(rule4);
      var key2 = Object.keys(rule4)[0], value3 = rule4[key2];
      return key2 + '="' + (value3 || "") + '"';
    }).join(" ") : "";
    return htmlAttributes;
  }
});

// src/index.ts
import "@tensorflow/tfjs-core";
import "@tensorflow/tfjs-core/dist/public/chained_ops/register_all_chained_ops";

// node_modules/tslib/tslib.es6.js
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value3) {
    return value3 instanceof P ? value3 : new P(function(resolve2) {
      resolve2(value3);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value3) {
      try {
        step(generator.next(value3));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value3) {
      try {
        step(generator["throw"](value3));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/fast-json-patch/module/core.mjs
var core_exports = {};
__export(core_exports, {
  JsonPatchError: () => JsonPatchError,
  _areEquals: () => _areEquals,
  applyOperation: () => applyOperation,
  applyPatch: () => applyPatch,
  applyReducer: () => applyReducer,
  deepClone: () => deepClone,
  getValueByPointer: () => getValueByPointer,
  validate: () => validate,
  validator: () => validator
});

// node_modules/fast-json-patch/module/helpers.mjs
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017 Joachim Wester
 * MIT license
 */
var __extends = function() {
  var extendStatics = function(d, b2) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p in b3)
        if (b3.hasOwnProperty(p))
          d2[p] = b3[p];
    };
    return extendStatics(d, b2);
  };
  return function(d, b2) {
    extendStatics(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key2) {
  return _hasOwnProperty.call(obj, key2);
}
function _objectKeys(obj) {
  if (Array.isArray(obj)) {
    var keys4 = new Array(obj.length);
    for (var k = 0; k < keys4.length; k++) {
      keys4[k] = "" + k;
    }
    return keys4;
  }
  if (Object.keys) {
    return Object.keys(obj);
  }
  var keys4 = [];
  for (var i in obj) {
    if (hasOwnProperty(obj, i)) {
      keys4.push(i);
    }
  }
  return keys4;
}
function _deepClone(obj) {
  switch (typeof obj) {
    case "object":
      return JSON.parse(JSON.stringify(obj));
    case "undefined":
      return null;
    default:
      return obj;
  }
}
function isInteger(str) {
  var i = 0;
  var len = str.length;
  var charCode;
  while (i < len) {
    charCode = str.charCodeAt(i);
    if (charCode >= 48 && charCode <= 57) {
      i++;
      continue;
    }
    return false;
  }
  return true;
}
function escapePathComponent(path3) {
  if (path3.indexOf("/") === -1 && path3.indexOf("~") === -1)
    return path3;
  return path3.replace(/~/g, "~0").replace(/\//g, "~1");
}
function unescapePathComponent(path3) {
  return path3.replace(/~1/g, "/").replace(/~0/g, "~");
}
function hasUndefined(obj) {
  if (obj === void 0) {
    return true;
  }
  if (obj) {
    if (Array.isArray(obj)) {
      for (var i = 0, len = obj.length; i < len; i++) {
        if (hasUndefined(obj[i])) {
          return true;
        }
      }
    } else if (typeof obj === "object") {
      var objKeys = _objectKeys(obj);
      var objKeysLength = objKeys.length;
      for (var i = 0; i < objKeysLength; i++) {
        if (hasUndefined(obj[objKeys[i]])) {
          return true;
        }
      }
    }
  }
  return false;
}
function patchErrorMessageFormatter(message, args) {
  var messageParts = [message];
  for (var key2 in args) {
    var value3 = typeof args[key2] === "object" ? JSON.stringify(args[key2], null, 2) : args[key2];
    if (typeof value3 !== "undefined") {
      messageParts.push(key2 + ": " + value3);
    }
  }
  return messageParts.join("\n");
}
var PatchError = function(_super) {
  __extends(PatchError2, _super);
  function PatchError2(message, name4, index4, operation, tree) {
    var _newTarget = this.constructor;
    var _this = _super.call(this, patchErrorMessageFormatter(message, {name: name4, index: index4, operation, tree})) || this;
    _this.name = name4;
    _this.index = index4;
    _this.operation = operation;
    _this.tree = tree;
    Object.setPrototypeOf(_this, _newTarget.prototype);
    _this.message = patchErrorMessageFormatter(message, {name: name4, index: index4, operation, tree});
    return _this;
  }
  return PatchError2;
}(Error);

// node_modules/fast-json-patch/module/core.mjs
var JsonPatchError = PatchError;
var deepClone = _deepClone;
var objOps = {
  add: function(obj, key2, document2) {
    obj[key2] = this.value;
    return {newDocument: document2};
  },
  remove: function(obj, key2, document2) {
    var removed = obj[key2];
    delete obj[key2];
    return {newDocument: document2, removed};
  },
  replace: function(obj, key2, document2) {
    var removed = obj[key2];
    obj[key2] = this.value;
    return {newDocument: document2, removed};
  },
  move: function(obj, key2, document2) {
    var removed = getValueByPointer(document2, this.path);
    if (removed) {
      removed = _deepClone(removed);
    }
    var originalValue = applyOperation(document2, {op: "remove", path: this.from}).removed;
    applyOperation(document2, {op: "add", path: this.path, value: originalValue});
    return {newDocument: document2, removed};
  },
  copy: function(obj, key2, document2) {
    var valueToCopy = getValueByPointer(document2, this.from);
    applyOperation(document2, {op: "add", path: this.path, value: _deepClone(valueToCopy)});
    return {newDocument: document2};
  },
  test: function(obj, key2, document2) {
    return {newDocument: document2, test: _areEquals(obj[key2], this.value)};
  },
  _get: function(obj, key2, document2) {
    this.value = obj[key2];
    return {newDocument: document2};
  }
};
var arrOps = {
  add: function(arr, i, document2) {
    if (isInteger(i)) {
      arr.splice(i, 0, this.value);
    } else {
      arr[i] = this.value;
    }
    return {newDocument: document2, index: i};
  },
  remove: function(arr, i, document2) {
    var removedList = arr.splice(i, 1);
    return {newDocument: document2, removed: removedList[0]};
  },
  replace: function(arr, i, document2) {
    var removed = arr[i];
    arr[i] = this.value;
    return {newDocument: document2, removed};
  },
  move: objOps.move,
  copy: objOps.copy,
  test: objOps.test,
  _get: objOps._get
};
function getValueByPointer(document2, pointer) {
  if (pointer == "") {
    return document2;
  }
  var getOriginalDestination = {op: "_get", path: pointer};
  applyOperation(document2, getOriginalDestination);
  return getOriginalDestination.value;
}
function applyOperation(document2, operation, validateOperation, mutateDocument, banPrototypeModifications, index4) {
  if (validateOperation === void 0) {
    validateOperation = false;
  }
  if (mutateDocument === void 0) {
    mutateDocument = true;
  }
  if (banPrototypeModifications === void 0) {
    banPrototypeModifications = true;
  }
  if (index4 === void 0) {
    index4 = 0;
  }
  if (validateOperation) {
    if (typeof validateOperation == "function") {
      validateOperation(operation, 0, document2, operation.path);
    } else {
      validator(operation, 0);
    }
  }
  if (operation.path === "") {
    var returnValue = {newDocument: document2};
    if (operation.op === "add") {
      returnValue.newDocument = operation.value;
      return returnValue;
    } else if (operation.op === "replace") {
      returnValue.newDocument = operation.value;
      returnValue.removed = document2;
      return returnValue;
    } else if (operation.op === "move" || operation.op === "copy") {
      returnValue.newDocument = getValueByPointer(document2, operation.from);
      if (operation.op === "move") {
        returnValue.removed = document2;
      }
      return returnValue;
    } else if (operation.op === "test") {
      returnValue.test = _areEquals(document2, operation.value);
      if (returnValue.test === false) {
        throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index4, operation, document2);
      }
      returnValue.newDocument = document2;
      return returnValue;
    } else if (operation.op === "remove") {
      returnValue.removed = document2;
      returnValue.newDocument = null;
      return returnValue;
    } else if (operation.op === "_get") {
      operation.value = document2;
      return returnValue;
    } else {
      if (validateOperation) {
        throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index4, operation, document2);
      } else {
        return returnValue;
      }
    }
  } else {
    if (!mutateDocument) {
      document2 = _deepClone(document2);
    }
    var path3 = operation.path || "";
    var keys4 = path3.split("/");
    var obj = document2;
    var t = 1;
    var len = keys4.length;
    var existingPathFragment = void 0;
    var key2 = void 0;
    var validateFunction = void 0;
    if (typeof validateOperation == "function") {
      validateFunction = validateOperation;
    } else {
      validateFunction = validator;
    }
    while (true) {
      key2 = keys4[t];
      if (banPrototypeModifications && key2 == "__proto__") {
        throw new TypeError("JSON-Patch: modifying `__proto__` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      }
      if (validateOperation) {
        if (existingPathFragment === void 0) {
          if (obj[key2] === void 0) {
            existingPathFragment = keys4.slice(0, t).join("/");
          } else if (t == len - 1) {
            existingPathFragment = operation.path;
          }
          if (existingPathFragment !== void 0) {
            validateFunction(operation, 0, document2, existingPathFragment);
          }
        }
      }
      t++;
      if (Array.isArray(obj)) {
        if (key2 === "-") {
          key2 = obj.length;
        } else {
          if (validateOperation && !isInteger(key2)) {
            throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index4, operation, document2);
          } else if (isInteger(key2)) {
            key2 = ~~key2;
          }
        }
        if (t >= len) {
          if (validateOperation && operation.op === "add" && key2 > obj.length) {
            throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index4, operation, document2);
          }
          var returnValue = arrOps[operation.op].call(operation, obj, key2, document2);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index4, operation, document2);
          }
          return returnValue;
        }
      } else {
        if (key2 && key2.indexOf("~") != -1) {
          key2 = unescapePathComponent(key2);
        }
        if (t >= len) {
          var returnValue = objOps[operation.op].call(operation, obj, key2, document2);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index4, operation, document2);
          }
          return returnValue;
        }
      }
      obj = obj[key2];
    }
  }
}
function applyPatch(document2, patch2, validateOperation, mutateDocument, banPrototypeModifications) {
  if (mutateDocument === void 0) {
    mutateDocument = true;
  }
  if (banPrototypeModifications === void 0) {
    banPrototypeModifications = true;
  }
  if (validateOperation) {
    if (!Array.isArray(patch2)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
  }
  if (!mutateDocument) {
    document2 = _deepClone(document2);
  }
  var results = new Array(patch2.length);
  for (var i = 0, length_1 = patch2.length; i < length_1; i++) {
    results[i] = applyOperation(document2, patch2[i], validateOperation, true, banPrototypeModifications, i);
    document2 = results[i].newDocument;
  }
  results.newDocument = document2;
  return results;
}
function applyReducer(document2, operation, index4) {
  var operationResult = applyOperation(document2, operation);
  if (operationResult.test === false) {
    throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index4, operation, document2);
  }
  return operationResult.newDocument;
}
function validator(operation, index4, document2, existingPathFragment) {
  if (typeof operation !== "object" || operation === null || Array.isArray(operation)) {
    throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index4, operation, document2);
  } else if (!objOps[operation.op]) {
    throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index4, operation, document2);
  } else if (typeof operation.path !== "string") {
    throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index4, operation, document2);
  } else if (operation.path.indexOf("/") !== 0 && operation.path.length > 0) {
    throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index4, operation, document2);
  } else if ((operation.op === "move" || operation.op === "copy") && typeof operation.from !== "string") {
    throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index4, operation, document2);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && operation.value === void 0) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index4, operation, document2);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && hasUndefined(operation.value)) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index4, operation, document2);
  } else if (document2) {
    if (operation.op == "add") {
      var pathLen = operation.path.split("/").length;
      var existingPathLen = existingPathFragment.split("/").length;
      if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
        throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index4, operation, document2);
      }
    } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
      if (operation.path !== existingPathFragment) {
        throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index4, operation, document2);
      }
    } else if (operation.op === "move" || operation.op === "copy") {
      var existingValue = {op: "_get", path: operation.from, value: void 0};
      var error3 = validate([existingValue], document2);
      if (error3 && error3.name === "OPERATION_PATH_UNRESOLVABLE") {
        throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index4, operation, document2);
      }
    }
  }
}
function validate(sequence4, document2, externalValidator) {
  try {
    if (!Array.isArray(sequence4)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
    if (document2) {
      applyPatch(_deepClone(document2), _deepClone(sequence4), externalValidator || true);
    } else {
      externalValidator = externalValidator || validator;
      for (var i = 0; i < sequence4.length; i++) {
        externalValidator(sequence4[i], i, document2, void 0);
      }
    }
  } catch (e) {
    if (e instanceof JsonPatchError) {
      return e;
    } else {
      throw e;
    }
  }
}
function _areEquals(a2, b2) {
  if (a2 === b2)
    return true;
  if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
    var arrA = Array.isArray(a2), arrB = Array.isArray(b2), i, length3, key2;
    if (arrA && arrB) {
      length3 = a2.length;
      if (length3 != b2.length)
        return false;
      for (i = length3; i-- !== 0; )
        if (!_areEquals(a2[i], b2[i]))
          return false;
      return true;
    }
    if (arrA != arrB)
      return false;
    var keys4 = Object.keys(a2);
    length3 = keys4.length;
    if (length3 !== Object.keys(b2).length)
      return false;
    for (i = length3; i-- !== 0; )
      if (!b2.hasOwnProperty(keys4[i]))
        return false;
    for (i = length3; i-- !== 0; ) {
      key2 = keys4[i];
      if (!_areEquals(a2[key2], b2[key2]))
        return false;
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}

// node_modules/fast-json-patch/module/duplex.mjs
var duplex_exports = {};
__export(duplex_exports, {
  compare: () => compare,
  generate: () => generate,
  observe: () => observe,
  unobserve: () => unobserve
});
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017 Joachim Wester
 * MIT license
 */
var beforeDict = new WeakMap();
var Mirror = function() {
  function Mirror2(obj) {
    this.observers = new Map();
    this.obj = obj;
  }
  return Mirror2;
}();
var ObserverInfo = function() {
  function ObserverInfo2(callback, observer) {
    this.callback = callback;
    this.observer = observer;
  }
  return ObserverInfo2;
}();
function getMirror(obj) {
  return beforeDict.get(obj);
}
function getObserverFromMirror(mirror, callback) {
  return mirror.observers.get(callback);
}
function removeObserverFromMirror(mirror, observer) {
  mirror.observers.delete(observer.callback);
}
function unobserve(root2, observer) {
  observer.unobserve();
}
function observe(obj, callback) {
  var patches = [];
  var observer;
  var mirror = getMirror(obj);
  if (!mirror) {
    mirror = new Mirror(obj);
    beforeDict.set(obj, mirror);
  } else {
    var observerInfo = getObserverFromMirror(mirror, callback);
    observer = observerInfo && observerInfo.observer;
  }
  if (observer) {
    return observer;
  }
  observer = {};
  mirror.value = _deepClone(obj);
  if (callback) {
    observer.callback = callback;
    observer.next = null;
    var dirtyCheck = function() {
      generate(observer);
    };
    var fastCheck = function() {
      clearTimeout(observer.next);
      observer.next = setTimeout(dirtyCheck);
    };
    if (typeof window !== "undefined") {
      window.addEventListener("mouseup", fastCheck);
      window.addEventListener("keyup", fastCheck);
      window.addEventListener("mousedown", fastCheck);
      window.addEventListener("keydown", fastCheck);
      window.addEventListener("change", fastCheck);
    }
  }
  observer.patches = patches;
  observer.object = obj;
  observer.unobserve = function() {
    generate(observer);
    clearTimeout(observer.next);
    removeObserverFromMirror(mirror, observer);
    if (typeof window !== "undefined") {
      window.removeEventListener("mouseup", fastCheck);
      window.removeEventListener("keyup", fastCheck);
      window.removeEventListener("mousedown", fastCheck);
      window.removeEventListener("keydown", fastCheck);
      window.removeEventListener("change", fastCheck);
    }
  };
  mirror.observers.set(callback, new ObserverInfo(callback, observer));
  return observer;
}
function generate(observer, invertible) {
  if (invertible === void 0) {
    invertible = false;
  }
  var mirror = beforeDict.get(observer.object);
  _generate(mirror.value, observer.object, observer.patches, "", invertible);
  if (observer.patches.length) {
    applyPatch(mirror.value, observer.patches);
  }
  var temp2 = observer.patches;
  if (temp2.length > 0) {
    observer.patches = [];
    if (observer.callback) {
      observer.callback(temp2);
    }
  }
  return temp2;
}
function _generate(mirror, obj, patches, path3, invertible) {
  if (obj === mirror) {
    return;
  }
  if (typeof obj.toJSON === "function") {
    obj = obj.toJSON();
  }
  var newKeys = _objectKeys(obj);
  var oldKeys = _objectKeys(mirror);
  var changed = false;
  var deleted = false;
  for (var t = oldKeys.length - 1; t >= 0; t--) {
    var key2 = oldKeys[t];
    var oldVal = mirror[key2];
    if (hasOwnProperty(obj, key2) && !(obj[key2] === void 0 && oldVal !== void 0 && Array.isArray(obj) === false)) {
      var newVal = obj[key2];
      if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null) {
        _generate(oldVal, newVal, patches, path3 + "/" + escapePathComponent(key2), invertible);
      } else {
        if (oldVal !== newVal) {
          changed = true;
          if (invertible) {
            patches.push({op: "test", path: path3 + "/" + escapePathComponent(key2), value: _deepClone(oldVal)});
          }
          patches.push({op: "replace", path: path3 + "/" + escapePathComponent(key2), value: _deepClone(newVal)});
        }
      }
    } else if (Array.isArray(mirror) === Array.isArray(obj)) {
      if (invertible) {
        patches.push({op: "test", path: path3 + "/" + escapePathComponent(key2), value: _deepClone(oldVal)});
      }
      patches.push({op: "remove", path: path3 + "/" + escapePathComponent(key2)});
      deleted = true;
    } else {
      if (invertible) {
        patches.push({op: "test", path: path3, value: mirror});
      }
      patches.push({op: "replace", path: path3, value: obj});
      changed = true;
    }
  }
  if (!deleted && newKeys.length == oldKeys.length) {
    return;
  }
  for (var t = 0; t < newKeys.length; t++) {
    var key2 = newKeys[t];
    if (!hasOwnProperty(mirror, key2) && obj[key2] !== void 0) {
      patches.push({op: "add", path: path3 + "/" + escapePathComponent(key2), value: _deepClone(obj[key2])});
    }
  }
}
function compare(tree1, tree2, invertible) {
  if (invertible === void 0) {
    invertible = false;
  }
  var patches = [];
  _generate(tree1, tree2, patches, "", invertible);
  return patches;
}

// node_modules/fast-json-patch/index.mjs
var fast_json_patch_default = Object.assign({}, core_exports, duplex_exports, {
  JsonPatchError: PatchError,
  deepClone: _deepClone,
  escapePathComponent,
  unescapePathComponent
});

// node_modules/vega-embed/build/src/embed.js
var import_json_stringify_pretty_compact = __toModule(require_json_stringify_pretty_compact());
var import_semver = __toModule(require_semver2());

// node_modules/vega/build/vega.module.js
var vega_module_exports = {};
__export(vega_module_exports, {
  Bounds: () => Bounds,
  CanvasHandler: () => CanvasHandler,
  CanvasRenderer: () => CanvasRenderer,
  DATE: () => DATE,
  DAY: () => DAY,
  DAYOFYEAR: () => DAYOFYEAR,
  Dataflow: () => Dataflow,
  Debug: () => Debug,
  Error: () => Error$1,
  EventStream: () => EventStream,
  Gradient: () => Gradient,
  GroupItem: () => GroupItem,
  HOURS: () => HOURS,
  Handler: () => Handler,
  Info: () => Info,
  Item: () => Item,
  MILLISECONDS: () => MILLISECONDS,
  MINUTES: () => MINUTES,
  MONTH: () => MONTH,
  Marks: () => Marks,
  MultiPulse: () => MultiPulse,
  None: () => None,
  Operator: () => Operator,
  Parameters: () => Parameters,
  Pulse: () => Pulse,
  QUARTER: () => QUARTER,
  RenderType: () => RenderType,
  Renderer: () => Renderer,
  ResourceLoader: () => ResourceLoader,
  SECONDS: () => SECONDS,
  SVGHandler: () => SVGHandler,
  SVGRenderer: () => SVGRenderer,
  SVGStringRenderer: () => SVGStringRenderer,
  Scenegraph: () => Scenegraph,
  TIME_UNITS: () => TIME_UNITS,
  Transform: () => Transform,
  View: () => View,
  WEEK: () => WEEK,
  Warn: () => Warn,
  YEAR: () => YEAR,
  accessor: () => accessor,
  accessorFields: () => accessorFields,
  accessorName: () => accessorName,
  array: () => array,
  ascending: () => ascending,
  bandwidthNRD: () => estimateBandwidth,
  bin: () => bin2,
  bootstrapCI: () => bootstrapCI,
  boundClip: () => boundClip,
  boundContext: () => boundContext,
  boundItem: () => boundItem,
  boundMark: () => boundMark,
  boundStroke: () => boundStroke,
  changeset: () => changeset,
  clampRange: () => clampRange,
  compare: () => compare2,
  constant: () => constant,
  cumulativeLogNormal: () => cumulativeLogNormal,
  cumulativeNormal: () => cumulativeNormal,
  cumulativeUniform: () => cumulativeUniform,
  dayofyear: () => dayofyear,
  debounce: () => debounce,
  defaultLocale: () => defaultLocale3,
  definition: () => definition,
  densityLogNormal: () => densityLogNormal,
  densityNormal: () => densityNormal,
  densityUniform: () => densityUniform,
  domChild: () => domChild,
  domClear: () => domClear,
  domCreate: () => domCreate,
  domFind: () => domFind,
  dotbin: () => dotbin,
  error: () => error,
  expressionFunction: () => expressionFunction2,
  extend: () => extend,
  extent: () => extent,
  extentIndex: () => extentIndex,
  falsy: () => falsy,
  fastmap: () => fastmap,
  field: () => field,
  flush: () => flush,
  font: () => font,
  fontFamily: () => fontFamily,
  fontSize: () => fontSize,
  format: () => format,
  formatLocale: () => numberFormatDefaultLocale,
  formats: () => formats,
  hasOwnProperty: () => has,
  id: () => id,
  identity: () => identity,
  inferType: () => inferType,
  inferTypes: () => inferTypes,
  ingest: () => ingest,
  inherits: () => inherits,
  inrange: () => inrange,
  interpolate: () => interpolate,
  interpolateColors: () => interpolateColors,
  interpolateRange: () => interpolateRange,
  intersect: () => intersect2,
  intersectBoxLine: () => intersectBoxLine,
  intersectPath: () => intersectPath,
  intersectPoint: () => intersectPoint,
  intersectRule: () => intersectRule,
  isArray: () => isArray,
  isBoolean: () => isBoolean,
  isDate: () => isDate,
  isFunction: () => isFunction,
  isIterable: () => isIterable,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isRegExp: () => isRegExp,
  isString: () => isString,
  isTuple: () => isTuple,
  key: () => key,
  lerp: () => lerp,
  lineHeight: () => lineHeight,
  loader: () => loader,
  locale: () => locale3,
  logger: () => logger,
  lruCache: () => lruCache,
  markup: () => markup,
  merge: () => merge,
  mergeConfig: () => mergeConfig,
  multiLineOffset: () => multiLineOffset,
  one: () => one,
  pad: () => pad,
  panLinear: () => panLinear,
  panLog: () => panLog,
  panPow: () => panPow,
  panSymlog: () => panSymlog,
  parse: () => parse$1,
  pathCurves: () => curves,
  pathEqual: () => pathEqual,
  pathParse: () => pathParse,
  pathRectangle: () => vg_rect,
  pathRender: () => pathRender,
  pathSymbols: () => symbols2,
  pathTrail: () => vg_trail,
  peek: () => peek,
  point: () => point6,
  projection: () => projection2,
  quantileLogNormal: () => quantileLogNormal,
  quantileNormal: () => quantileNormal,
  quantileUniform: () => quantileUniform,
  quantiles: () => quantiles,
  quantizeInterpolator: () => quantizeInterpolator,
  quarter: () => quarter,
  quartiles: () => quartiles,
  random: () => random,
  randomInteger: () => integer,
  randomKDE: () => kde,
  randomLCG: () => lcg,
  randomLogNormal: () => lognormal,
  randomMixture: () => mixture,
  randomNormal: () => gaussian,
  randomUniform: () => uniform,
  read: () => read_default,
  regressionExp: () => exp2,
  regressionLinear: () => linear,
  regressionLoess: () => loess,
  regressionLog: () => log2,
  regressionPoly: () => poly,
  regressionPow: () => pow2,
  regressionQuad: () => quad,
  renderModule: () => renderModule,
  repeat: () => repeat,
  resetDefaultLocale: () => resetDefaultLocale,
  resetSVGClipId: () => resetSVGClipId,
  resetSVGDefIds: () => resetSVGDefIds,
  responseType: () => responseType,
  runtimeContext: () => context2,
  sampleCurve: () => sampleCurve,
  sampleLogNormal: () => sampleLogNormal,
  sampleNormal: () => sampleNormal,
  sampleUniform: () => sampleUniform,
  scale: () => scale,
  sceneEqual: () => sceneEqual,
  sceneFromJSON: () => sceneFromJSON,
  scenePickVisit: () => pickVisit,
  sceneToJSON: () => sceneToJSON,
  sceneVisit: () => visit,
  sceneZOrder: () => zorder,
  scheme: () => scheme,
  serializeXML: () => serializeXML,
  setRandom: () => setRandom,
  span: () => span,
  splitAccessPath: () => splitAccessPath,
  stringValue: () => $,
  textMetrics: () => textMetrics,
  timeBin: () => bin,
  timeFloor: () => timeFloor,
  timeFormatLocale: () => timeFormatDefaultLocale,
  timeInterval: () => timeInterval,
  timeOffset: () => timeOffset,
  timeSequence: () => timeSequence,
  timeUnitSpecifier: () => timeUnitSpecifier,
  timeUnits: () => timeUnits,
  toBoolean: () => toBoolean,
  toDate: () => toDate,
  toNumber: () => toNumber,
  toSet: () => toSet,
  toString: () => toString,
  transform: () => transform,
  transforms: () => transforms,
  truncate: () => truncate,
  truthy: () => truthy,
  tupleid: () => tupleid,
  typeParsers: () => typeParsers,
  utcFloor: () => utcFloor,
  utcInterval: () => utcInterval,
  utcOffset: () => utcOffset,
  utcSequence: () => utcSequence,
  utcdayofyear: () => utcdayofyear,
  utcquarter: () => utcquarter,
  utcweek: () => utcweek,
  version: () => version,
  visitArray: () => visitArray,
  week: () => week,
  writeConfig: () => writeConfig,
  zero: () => zero,
  zoomLinear: () => zoomLinear,
  zoomLog: () => zoomLog,
  zoomPow: () => zoomPow,
  zoomSymlog: () => zoomSymlog
});

// node_modules/vega-util/build/vega-util.module.js
function accessor(fn, fields, name4) {
  fn.fields = fields || [];
  fn.fname = name4;
  return fn;
}
function accessorName(fn) {
  return fn == null ? null : fn.fname;
}
function accessorFields(fn) {
  return fn == null ? null : fn.fields;
}
function getter(path3) {
  return path3.length === 1 ? get1(path3[0]) : getN(path3);
}
var get1 = (field4) => function(obj) {
  return obj[field4];
};
var getN = (path3) => {
  const len = path3.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path3[i]];
    }
    return obj;
  };
};
function error(message) {
  throw Error(message);
}
function splitAccessPath(p) {
  const path3 = [], n = p.length;
  let q = null, b2 = 0, s = "", i, j, c2;
  p = p + "";
  function push() {
    path3.push(s + p.substring(i, j));
    s = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c2 = p[j];
    if (c2 === "\\") {
      s += p.substring(i, j);
      s += p.substring(++j, ++j);
      i = j;
    } else if (c2 === q) {
      push();
      q = null;
      b2 = -1;
    } else if (q) {
      continue;
    } else if (i === b2 && c2 === '"') {
      i = j + 1;
      q = c2;
    } else if (i === b2 && c2 === "'") {
      i = j + 1;
      q = c2;
    } else if (c2 === "." && !b2) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c2 === "[") {
      if (j > i)
        push();
      b2 = i = j + 1;
    } else if (c2 === "]") {
      if (!b2)
        error("Access path missing open bracket: " + p);
      if (b2 > 0)
        push();
      b2 = 0;
      i = j + 1;
    }
  }
  if (b2)
    error("Access path missing closing bracket: " + p);
  if (q)
    error("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path3;
}
function field(field4, name4, opt) {
  const path3 = splitAccessPath(field4);
  field4 = path3.length === 1 ? path3[0] : field4;
  return accessor((opt && opt.get || getter)(path3), [field4], name4 || field4);
}
var id = field("id");
var identity = accessor((_) => _, [], "identity");
var zero = accessor(() => 0, [], "zero");
var one = accessor(() => 1, [], "one");
var truthy = accessor(() => true, [], "true");
var falsy = accessor(() => false, [], "false");
function log(method2, level, input) {
  const args = [level].concat([].slice.call(input));
  console[method2].apply(console, args);
}
var None = 0;
var Error$1 = 1;
var Warn = 2;
var Info = 3;
var Debug = 4;
function logger(_, method2) {
  let level = _ || None;
  return {
    level(_2) {
      if (arguments.length) {
        level = +_2;
        return this;
      } else {
        return level;
      }
    },
    error() {
      if (level >= Error$1)
        log(method2 || "error", "ERROR", arguments);
      return this;
    },
    warn() {
      if (level >= Warn)
        log(method2 || "warn", "WARN", arguments);
      return this;
    },
    info() {
      if (level >= Info)
        log(method2 || "log", "INFO", arguments);
      return this;
    },
    debug() {
      if (level >= Debug)
        log(method2 || "log", "DEBUG", arguments);
      return this;
    }
  };
}
var isArray = Array.isArray;
function isObject(_) {
  return _ === Object(_);
}
var isLegalKey = (key2) => key2 !== "__proto__";
function mergeConfig(...configs) {
  return configs.reduce((out, source4) => {
    for (const key2 in source4) {
      if (key2 === "signals") {
        out.signals = mergeNamed(out.signals, source4.signals);
      } else {
        const r2 = key2 === "legend" ? {
          layout: 1
        } : key2 === "style" ? true : null;
        writeConfig(out, key2, source4[key2], r2);
      }
    }
    return out;
  }, {});
}
function writeConfig(output3, key2, value3, recurse2) {
  if (!isLegalKey(key2))
    return;
  let k, o;
  if (isObject(value3) && !isArray(value3)) {
    o = isObject(output3[key2]) ? output3[key2] : output3[key2] = {};
    for (k in value3) {
      if (recurse2 && (recurse2 === true || recurse2[k])) {
        writeConfig(o, k, value3[k]);
      } else if (isLegalKey(k)) {
        o[k] = value3[k];
      }
    }
  } else {
    output3[key2] = value3;
  }
}
function mergeNamed(a2, b2) {
  if (a2 == null)
    return b2;
  const map4 = {}, out = [];
  function add6(_) {
    if (!map4[_.name]) {
      map4[_.name] = 1;
      out.push(_);
    }
  }
  b2.forEach(add6);
  a2.forEach(add6);
  return out;
}
function peek(array5) {
  return array5[array5.length - 1];
}
function toNumber(_) {
  return _ == null || _ === "" ? null : +_;
}
var exp = (sign3) => (x5) => sign3 * Math.exp(x5);
var log$1 = (sign3) => (x5) => Math.log(sign3 * x5);
var symlog = (c2) => (x5) => Math.sign(x5) * Math.log1p(Math.abs(x5 / c2));
var symexp = (c2) => (x5) => Math.sign(x5) * Math.expm1(Math.abs(x5)) * c2;
var pow = (exponent) => (x5) => x5 < 0 ? -Math.pow(-x5, exponent) : Math.pow(x5, exponent);
function pan(domain4, delta, lift, ground) {
  const d0 = lift(domain4[0]), d1 = lift(peek(domain4)), dd = (d1 - d0) * delta;
  return [ground(d0 - dd), ground(d1 - dd)];
}
function panLinear(domain4, delta) {
  return pan(domain4, delta, toNumber, identity);
}
function panLog(domain4, delta) {
  var sign3 = Math.sign(domain4[0]);
  return pan(domain4, delta, log$1(sign3), exp(sign3));
}
function panPow(domain4, delta, exponent) {
  return pan(domain4, delta, pow(exponent), pow(1 / exponent));
}
function panSymlog(domain4, delta, constant2) {
  return pan(domain4, delta, symlog(constant2), symexp(constant2));
}
function zoom(domain4, anchor, scale7, lift, ground) {
  const d0 = lift(domain4[0]), d1 = lift(peek(domain4)), da = anchor != null ? lift(anchor) : (d0 + d1) / 2;
  return [ground(da + (d0 - da) * scale7), ground(da + (d1 - da) * scale7)];
}
function zoomLinear(domain4, anchor, scale7) {
  return zoom(domain4, anchor, scale7, toNumber, identity);
}
function zoomLog(domain4, anchor, scale7) {
  const sign3 = Math.sign(domain4[0]);
  return zoom(domain4, anchor, scale7, log$1(sign3), exp(sign3));
}
function zoomPow(domain4, anchor, scale7, exponent) {
  return zoom(domain4, anchor, scale7, pow(exponent), pow(1 / exponent));
}
function zoomSymlog(domain4, anchor, scale7, constant2) {
  return zoom(domain4, anchor, scale7, symlog(constant2), symexp(constant2));
}
function quarter(date2) {
  return 1 + ~~(new Date(date2).getMonth() / 3);
}
function utcquarter(date2) {
  return 1 + ~~(new Date(date2).getUTCMonth() / 3);
}
function array(_) {
  return _ != null ? isArray(_) ? _ : [_] : [];
}
function clampRange(range5, min4, max4) {
  let lo = range5[0], hi = range5[1], span2;
  if (hi < lo) {
    span2 = hi;
    hi = lo;
    lo = span2;
  }
  span2 = hi - lo;
  return span2 >= max4 - min4 ? [min4, max4] : [lo = Math.min(Math.max(lo, min4), max4 - span2), lo + span2];
}
function isFunction(_) {
  return typeof _ === "function";
}
var DESCENDING = "descending";
function compare2(fields, orders, opt) {
  opt = opt || {};
  orders = array(orders) || [];
  const ord = [], get6 = [], fmap = {}, gen = opt.comparator || comparator;
  array(fields).forEach((f, i) => {
    if (f == null)
      return;
    ord.push(orders[i] === DESCENDING ? -1 : 1);
    get6.push(f = isFunction(f) ? f : field(f, null, opt));
    (accessorFields(f) || []).forEach((_) => fmap[_] = 1);
  });
  return get6.length === 0 ? null : accessor(gen(get6, ord), Object.keys(fmap));
}
var ascending = (u, v) => (u < v || u == null) && v != null ? -1 : (u > v || v == null) && u != null ? 1 : (v = v instanceof Date ? +v : v, u = u instanceof Date ? +u : u) !== u && v === v ? -1 : v !== v && u === u ? 1 : 0;
var comparator = (fields, orders) => fields.length === 1 ? compare1(fields[0], orders[0]) : compareN(fields, orders, fields.length);
var compare1 = (field4, order) => function(a2, b2) {
  return ascending(field4(a2), field4(b2)) * order;
};
var compareN = (fields, orders, n) => {
  orders.push(0);
  return function(a2, b2) {
    let f, c2 = 0, i = -1;
    while (c2 === 0 && ++i < n) {
      f = fields[i];
      c2 = ascending(f(a2), f(b2));
    }
    return c2 * orders[i];
  };
};
function constant(_) {
  return isFunction(_) ? _ : () => _;
}
function debounce(delay, handler) {
  let tid;
  return (e) => {
    if (tid)
      clearTimeout(tid);
    tid = setTimeout(() => (handler(e), tid = null), delay);
  };
}
function extend(_) {
  for (let x5, k, i = 1, len = arguments.length; i < len; ++i) {
    x5 = arguments[i];
    for (k in x5) {
      _[k] = x5[k];
    }
  }
  return _;
}
function extent(array5, f) {
  let i = 0, n, v, min4, max4;
  if (array5 && (n = array5.length)) {
    if (f == null) {
      for (v = array5[i]; i < n && (v == null || v !== v); v = array5[++i])
        ;
      min4 = max4 = v;
      for (; i < n; ++i) {
        v = array5[i];
        if (v != null) {
          if (v < min4)
            min4 = v;
          if (v > max4)
            max4 = v;
        }
      }
    } else {
      for (v = f(array5[i]); i < n && (v == null || v !== v); v = f(array5[++i]))
        ;
      min4 = max4 = v;
      for (; i < n; ++i) {
        v = f(array5[i]);
        if (v != null) {
          if (v < min4)
            min4 = v;
          if (v > max4)
            max4 = v;
        }
      }
    }
  }
  return [min4, max4];
}
function extentIndex(array5, f) {
  const n = array5.length;
  let i = -1, a2, b2, c2, u, v;
  if (f == null) {
    while (++i < n) {
      b2 = array5[i];
      if (b2 != null && b2 >= b2) {
        a2 = c2 = b2;
        break;
      }
    }
    if (i === n)
      return [-1, -1];
    u = v = i;
    while (++i < n) {
      b2 = array5[i];
      if (b2 != null) {
        if (a2 > b2) {
          a2 = b2;
          u = i;
        }
        if (c2 < b2) {
          c2 = b2;
          v = i;
        }
      }
    }
  } else {
    while (++i < n) {
      b2 = f(array5[i], i, array5);
      if (b2 != null && b2 >= b2) {
        a2 = c2 = b2;
        break;
      }
    }
    if (i === n)
      return [-1, -1];
    u = v = i;
    while (++i < n) {
      b2 = f(array5[i], i, array5);
      if (b2 != null) {
        if (a2 > b2) {
          a2 = b2;
          u = i;
        }
        if (c2 < b2) {
          c2 = b2;
          v = i;
        }
      }
    }
  }
  return [u, v];
}
var hop = Object.prototype.hasOwnProperty;
function has(object2, property2) {
  return hop.call(object2, property2);
}
var NULL = {};
function fastmap(input) {
  let obj = {}, test2;
  function has$1(key2) {
    return has(obj, key2) && obj[key2] !== NULL;
  }
  const map4 = {
    size: 0,
    empty: 0,
    object: obj,
    has: has$1,
    get(key2) {
      return has$1(key2) ? obj[key2] : void 0;
    },
    set(key2, value3) {
      if (!has$1(key2)) {
        ++map4.size;
        if (obj[key2] === NULL)
          --map4.empty;
      }
      obj[key2] = value3;
      return this;
    },
    delete(key2) {
      if (has$1(key2)) {
        --map4.size;
        ++map4.empty;
        obj[key2] = NULL;
      }
      return this;
    },
    clear() {
      map4.size = map4.empty = 0;
      map4.object = obj = {};
    },
    test(_) {
      if (arguments.length) {
        test2 = _;
        return map4;
      } else {
        return test2;
      }
    },
    clean() {
      const next = {};
      let size = 0;
      for (const key2 in obj) {
        const value3 = obj[key2];
        if (value3 !== NULL && (!test2 || !test2(value3))) {
          next[key2] = value3;
          ++size;
        }
      }
      map4.size = size;
      map4.empty = 0;
      map4.object = obj = next;
    }
  };
  if (input)
    Object.keys(input).forEach((key2) => {
      map4.set(key2, input[key2]);
    });
  return map4;
}
function flush(range5, value3, threshold2, left, right, center) {
  if (!threshold2 && threshold2 !== 0)
    return center;
  const t = +threshold2;
  let a2 = range5[0], b2 = peek(range5), l;
  if (b2 < a2) {
    l = a2;
    a2 = b2;
    b2 = l;
  }
  l = Math.abs(value3 - a2);
  const r2 = Math.abs(b2 - value3);
  return l < r2 && l <= t ? left : r2 <= t ? right : center;
}
function inherits(child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  proto.constructor = child;
  return extend(proto, members);
}
function inrange(value3, range5, left, right) {
  let r0 = range5[0], r1 = range5[range5.length - 1], t;
  if (r0 > r1) {
    t = r0;
    r0 = r1;
    r1 = t;
  }
  left = left === void 0 || left;
  right = right === void 0 || right;
  return (left ? r0 <= value3 : r0 < value3) && (right ? value3 <= r1 : value3 < r1);
}
function isBoolean(_) {
  return typeof _ === "boolean";
}
function isDate(_) {
  return Object.prototype.toString.call(_) === "[object Date]";
}
function isIterable(_) {
  return _ && isFunction(_[Symbol.iterator]);
}
function isNumber(_) {
  return typeof _ === "number";
}
function isRegExp(_) {
  return Object.prototype.toString.call(_) === "[object RegExp]";
}
function isString(_) {
  return typeof _ === "string";
}
function key(fields, flat, opt) {
  if (fields) {
    fields = flat ? array(fields).map((f) => f.replace(/\\(.)/g, "$1")) : array(fields);
  }
  const len = fields && fields.length, gen = opt && opt.get || getter, map4 = (f) => gen(flat ? [f] : splitAccessPath(f));
  let fn;
  if (!len) {
    fn = function() {
      return "";
    };
  } else if (len === 1) {
    const get6 = map4(fields[0]);
    fn = function(_) {
      return "" + get6(_);
    };
  } else {
    const get6 = fields.map(map4);
    fn = function(_) {
      let s = "" + get6[0](_), i = 0;
      while (++i < len)
        s += "|" + get6[i](_);
      return s;
    };
  }
  return accessor(fn, fields, "key");
}
function lerp(array5, frac) {
  const lo = array5[0], hi = peek(array5), f = +frac;
  return !f ? lo : f === 1 ? hi : lo + f * (hi - lo);
}
var DEFAULT_MAX_SIZE = 1e4;
function lruCache(maxsize) {
  maxsize = +maxsize || DEFAULT_MAX_SIZE;
  let curr, prev, size;
  const clear2 = () => {
    curr = {};
    prev = {};
    size = 0;
  };
  const update3 = (key2, value3) => {
    if (++size > maxsize) {
      prev = curr;
      curr = {};
      size = 1;
    }
    return curr[key2] = value3;
  };
  clear2();
  return {
    clear: clear2,
    has: (key2) => has(curr, key2) || has(prev, key2),
    get: (key2) => has(curr, key2) ? curr[key2] : has(prev, key2) ? update3(key2, prev[key2]) : void 0,
    set: (key2, value3) => has(curr, key2) ? curr[key2] = value3 : update3(key2, value3)
  };
}
function merge(compare4, array0, array1, output3) {
  const n0 = array0.length, n1 = array1.length;
  if (!n1)
    return array0;
  if (!n0)
    return array1;
  const merged = output3 || new array0.constructor(n0 + n1);
  let i0 = 0, i1 = 0, i = 0;
  for (; i0 < n0 && i1 < n1; ++i) {
    merged[i] = compare4(array0[i0], array1[i1]) > 0 ? array1[i1++] : array0[i0++];
  }
  for (; i0 < n0; ++i0, ++i) {
    merged[i] = array0[i0];
  }
  for (; i1 < n1; ++i1, ++i) {
    merged[i] = array1[i1];
  }
  return merged;
}
function repeat(str, reps) {
  let s = "";
  while (--reps >= 0)
    s += str;
  return s;
}
function pad(str, length3, padchar, align2) {
  const c2 = padchar || " ", s = str + "", n = length3 - s.length;
  return n <= 0 ? s : align2 === "left" ? repeat(c2, n) + s : align2 === "center" ? repeat(c2, ~~(n / 2)) + s + repeat(c2, Math.ceil(n / 2)) : s + repeat(c2, n);
}
function span(array5) {
  return array5 && peek(array5) - array5[0] || 0;
}
function $(x5) {
  return isArray(x5) ? "[" + x5.map($) + "]" : isObject(x5) || isString(x5) ? JSON.stringify(x5).replace("\u2028", "\\u2028").replace("\u2029", "\\u2029") : x5;
}
function toBoolean(_) {
  return _ == null || _ === "" ? null : !_ || _ === "false" || _ === "0" ? false : !!_;
}
var defaultParser = (_) => isNumber(_) ? _ : isDate(_) ? _ : Date.parse(_);
function toDate(_, parser3) {
  parser3 = parser3 || defaultParser;
  return _ == null || _ === "" ? null : parser3(_);
}
function toString(_) {
  return _ == null || _ === "" ? null : _ + "";
}
function toSet(_) {
  const s = {}, n = _.length;
  for (let i = 0; i < n; ++i)
    s[_[i]] = true;
  return s;
}
function truncate(str, length3, align2, ellipsis) {
  const e = ellipsis != null ? ellipsis : "\u2026", s = str + "", n = s.length, l = Math.max(0, length3 - e.length);
  return n <= length3 ? s : align2 === "left" ? e + s.slice(n - l) : align2 === "center" ? s.slice(0, Math.ceil(l / 2)) + e + s.slice(n - ~~(l / 2)) : s.slice(0, l) + e;
}
function visitArray(array5, filter4, visitor) {
  if (array5) {
    if (filter4) {
      const n = array5.length;
      for (let i = 0; i < n; ++i) {
        const t = filter4(array5[i]);
        if (t)
          visitor(t, i, array5);
      }
    } else {
      array5.forEach(visitor);
    }
  }
}

// node_modules/vega-loader/src/loader.js
var protocol_re = /^([A-Za-z]+:)?\/\//;
var allowed_re = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;
var whitespace_re = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
var fileProtocol = "file://";
function loader_default(fetch2, fs) {
  return (options2) => ({
    options: options2 || {},
    sanitize,
    load,
    fileAccess: !!fs,
    file: fileLoader(fs),
    http: httpLoader(fetch2)
  });
}
async function load(uri, options2) {
  const opt = await this.sanitize(uri, options2), url = opt.href;
  return opt.localFile ? this.file(url) : this.http(url, options2);
}
async function sanitize(uri, options2) {
  options2 = extend({}, this.options, options2);
  const fileAccess = this.fileAccess, result = {href: null};
  let isFile, loadFile, base2;
  const isAllowed = allowed_re.test(uri.replace(whitespace_re, ""));
  if (uri == null || typeof uri !== "string" || !isAllowed) {
    error("Sanitize failure, invalid URI: " + $(uri));
  }
  const hasProtocol = protocol_re.test(uri);
  if ((base2 = options2.baseURL) && !hasProtocol) {
    if (!uri.startsWith("/") && base2[base2.length - 1] !== "/") {
      uri = "/" + uri;
    }
    uri = base2 + uri;
  }
  loadFile = (isFile = uri.startsWith(fileProtocol)) || options2.mode === "file" || options2.mode !== "http" && !hasProtocol && fileAccess;
  if (isFile) {
    uri = uri.slice(fileProtocol.length);
  } else if (uri.startsWith("//")) {
    if (options2.defaultProtocol === "file") {
      uri = uri.slice(2);
      loadFile = true;
    } else {
      uri = (options2.defaultProtocol || "http") + ":" + uri;
    }
  }
  Object.defineProperty(result, "localFile", {value: !!loadFile});
  result.href = uri;
  if (options2.target) {
    result.target = options2.target + "";
  }
  if (options2.rel) {
    result.rel = options2.rel + "";
  }
  if (options2.context === "image" && options2.crossOrigin) {
    result.crossOrigin = options2.crossOrigin + "";
  }
  return result;
}
function fileLoader(fs) {
  return fs ? (filename) => new Promise((accept, reject) => {
    fs.readFile(filename, (error3, data4) => {
      if (error3)
        reject(error3);
      else
        accept(data4);
    });
  }) : fileReject;
}
async function fileReject() {
  error("No file system access.");
}
function httpLoader(fetch2) {
  return fetch2 ? async function(url, options2) {
    const opt = extend({}, this.options.http, options2), type2 = options2 && options2.response, response = await fetch2(url, opt);
    return !response.ok ? error(response.status + "" + response.statusText) : isFunction(response[type2]) ? response[type2]() : response.text();
  } : httpReject;
}
async function httpReject() {
  error("No HTTP fetch method available.");
}

// node_modules/vega-loader/src/type.js
var isValid = (_) => _ != null && _ === _;
var isBoolean2 = (_) => _ === "true" || _ === "false" || _ === true || _ === false;
var isDate2 = (_) => !Number.isNaN(Date.parse(_));
var isNumber2 = (_) => !Number.isNaN(+_) && !(_ instanceof Date);
var isInteger2 = (_) => isNumber2(_) && Number.isInteger(+_);
var typeParsers = {
  boolean: toBoolean,
  integer: toNumber,
  number: toNumber,
  date: toDate,
  string: toString,
  unknown: identity
};
var typeTests = [
  isBoolean2,
  isInteger2,
  isNumber2,
  isDate2
];
var typeList = [
  "boolean",
  "integer",
  "number",
  "date"
];
function inferType(values4, field4) {
  if (!values4 || !values4.length)
    return "unknown";
  const n = values4.length, m2 = typeTests.length, a2 = typeTests.map((_, i) => i + 1);
  for (let i = 0, t = 0, j, value3; i < n; ++i) {
    value3 = field4 ? values4[i][field4] : values4[i];
    for (j = 0; j < m2; ++j) {
      if (a2[j] && isValid(value3) && !typeTests[j](value3)) {
        a2[j] = 0;
        ++t;
        if (t === typeTests.length)
          return "string";
      }
    }
  }
  return typeList[a2.reduce((u, v) => u === 0 ? v : u, 0) - 1];
}
function inferTypes(data4, fields) {
  return fields.reduce((types3, field4) => {
    types3[field4] = inferType(data4, field4);
    return types3;
  }, {});
}

// node_modules/d3-dsv/src/dsv.js
var EOL = {};
var EOF = {};
var QUOTE = 34;
var NEWLINE = 10;
var RETURN = 13;
function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name4, i) {
    return JSON.stringify(name4) + ": d[" + i + '] || ""';
  }).join(",") + "}");
}
function customConverter(columns, f) {
  var object2 = objectConverter(columns);
  return function(row, i) {
    return f(object2(row), i, columns);
  };
}
function inferColumns(rows) {
  var columnSet = Object.create(null), columns = [];
  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });
  return columns;
}
function pad2(value3, width2) {
  var s = value3 + "", length3 = s.length;
  return length3 < width2 ? new Array(width2 - length3 + 1).join(0) + s : s;
}
function formatYear(year2) {
  return year2 < 0 ? "-" + pad2(-year2, 6) : year2 > 9999 ? "+" + pad2(year2, 6) : pad2(year2, 4);
}
function formatDate(date2) {
  var hours2 = date2.getUTCHours(), minutes2 = date2.getUTCMinutes(), seconds2 = date2.getUTCSeconds(), milliseconds2 = date2.getUTCMilliseconds();
  return isNaN(date2) ? "Invalid Date" : formatYear(date2.getUTCFullYear(), 4) + "-" + pad2(date2.getUTCMonth() + 1, 2) + "-" + pad2(date2.getUTCDate(), 2) + (milliseconds2 ? "T" + pad2(hours2, 2) + ":" + pad2(minutes2, 2) + ":" + pad2(seconds2, 2) + "." + pad2(milliseconds2, 3) + "Z" : seconds2 ? "T" + pad2(hours2, 2) + ":" + pad2(minutes2, 2) + ":" + pad2(seconds2, 2) + "Z" : minutes2 || hours2 ? "T" + pad2(hours2, 2) + ":" + pad2(minutes2, 2) + "Z" : "");
}
function dsv_default(delimiter) {
  var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
  function parse6(text4, f) {
    var convert, columns, rows = parseRows(text4, function(row, i) {
      if (convert)
        return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }
  function parseRows(text4, f) {
    var rows = [], N = text4.length, I = 0, n = 0, t, eof = N <= 0, eol = false;
    if (text4.charCodeAt(N - 1) === NEWLINE)
      --N;
    if (text4.charCodeAt(N - 1) === RETURN)
      --N;
    function token() {
      if (eof)
        return EOF;
      if (eol)
        return eol = false, EOL;
      var i, j = I, c2;
      if (text4.charCodeAt(j) === QUOTE) {
        while (I++ < N && text4.charCodeAt(I) !== QUOTE || text4.charCodeAt(++I) === QUOTE)
          ;
        if ((i = I) >= N)
          eof = true;
        else if ((c2 = text4.charCodeAt(I++)) === NEWLINE)
          eol = true;
        else if (c2 === RETURN) {
          eol = true;
          if (text4.charCodeAt(I) === NEWLINE)
            ++I;
        }
        return text4.slice(j + 1, i - 1).replace(/""/g, '"');
      }
      while (I < N) {
        if ((c2 = text4.charCodeAt(i = I++)) === NEWLINE)
          eol = true;
        else if (c2 === RETURN) {
          eol = true;
          if (text4.charCodeAt(I) === NEWLINE)
            ++I;
        } else if (c2 !== DELIMITER)
          continue;
        return text4.slice(j, i);
      }
      return eof = true, text4.slice(j, N);
    }
    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF)
        row.push(t), t = token();
      if (f && (row = f(row, n++)) == null)
        continue;
      rows.push(row);
    }
    return rows;
  }
  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue4(row[column]);
      }).join(delimiter);
    });
  }
  function format8(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return [columns.map(formatValue4).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }
  function formatBody(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }
  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }
  function formatRow(row) {
    return row.map(formatValue4).join(delimiter);
  }
  function formatValue4(value3) {
    return value3 == null ? "" : value3 instanceof Date ? formatDate(value3) : reFormat.test(value3 += "") ? '"' + value3.replace(/"/g, '""') + '"' : value3;
  }
  return {
    parse: parse6,
    parseRows,
    format: format8,
    formatBody,
    formatRows,
    formatRow,
    formatValue: formatValue4
  };
}

// node_modules/vega-loader/src/formats/dsv.js
function delimitedFormat(delimiter) {
  const parse6 = function(data4, format8) {
    const delim = {delimiter};
    return dsv(data4, format8 ? extend(format8, delim) : delim);
  };
  parse6.responseType = "text";
  return parse6;
}
function dsv(data4, format8) {
  if (format8.header) {
    data4 = format8.header.map($).join(format8.delimiter) + "\n" + data4;
  }
  return dsv_default(format8.delimiter).parse(data4 + "");
}
dsv.responseType = "text";

// node_modules/vega-loader/src/formats/json.js
function isBuffer(_) {
  return typeof Buffer === "function" && isFunction(Buffer.isBuffer) ? Buffer.isBuffer(_) : false;
}
function json(data4, format8) {
  const prop = format8 && format8.property ? field(format8.property) : identity;
  return isObject(data4) && !isBuffer(data4) ? parseJSON(prop(data4), format8) : prop(JSON.parse(data4));
}
json.responseType = "json";
function parseJSON(data4, format8) {
  if (!isArray(data4) && isIterable(data4)) {
    data4 = [...data4];
  }
  return format8 && format8.copy ? JSON.parse(JSON.stringify(data4)) : data4;
}

// node_modules/topojson-client/src/identity.js
function identity_default(x5) {
  return x5;
}

// node_modules/topojson-client/src/transform.js
function transform_default(transform4) {
  if (transform4 == null)
    return identity_default;
  var x06, y06, kx = transform4.scale[0], ky = transform4.scale[1], dx = transform4.translate[0], dy = transform4.translate[1];
  return function(input, i) {
    if (!i)
      x06 = y06 = 0;
    var j = 2, n = input.length, output3 = new Array(n);
    output3[0] = (x06 += input[0]) * kx + dx;
    output3[1] = (y06 += input[1]) * ky + dy;
    while (j < n)
      output3[j] = input[j], ++j;
    return output3;
  };
}

// node_modules/topojson-client/src/reverse.js
function reverse_default(array5, n) {
  var t, j = array5.length, i = j - n;
  while (i < --j)
    t = array5[i], array5[i++] = array5[j], array5[j] = t;
}

// node_modules/topojson-client/src/feature.js
function feature_default(topology, o) {
  if (typeof o === "string")
    o = topology.objects[o];
  return o.type === "GeometryCollection" ? {type: "FeatureCollection", features: o.geometries.map(function(o2) {
    return feature(topology, o2);
  })} : feature(topology, o);
}
function feature(topology, o) {
  var id4 = o.id, bbox = o.bbox, properties = o.properties == null ? {} : o.properties, geometry = object(topology, o);
  return id4 == null && bbox == null ? {type: "Feature", properties, geometry} : bbox == null ? {type: "Feature", id: id4, properties, geometry} : {type: "Feature", id: id4, bbox, properties, geometry};
}
function object(topology, o) {
  var transformPoint = transform_default(topology.transform), arcs = topology.arcs;
  function arc4(i, points2) {
    if (points2.length)
      points2.pop();
    for (var a2 = arcs[i < 0 ? ~i : i], k = 0, n = a2.length; k < n; ++k) {
      points2.push(transformPoint(a2[k], k));
    }
    if (i < 0)
      reverse_default(points2, n);
  }
  function point8(p) {
    return transformPoint(p);
  }
  function line4(arcs2) {
    var points2 = [];
    for (var i = 0, n = arcs2.length; i < n; ++i)
      arc4(arcs2[i], points2);
    if (points2.length < 2)
      points2.push(points2[0]);
    return points2;
  }
  function ring(arcs2) {
    var points2 = line4(arcs2);
    while (points2.length < 4)
      points2.push(points2[0]);
    return points2;
  }
  function polygon(arcs2) {
    return arcs2.map(ring);
  }
  function geometry(o2) {
    var type2 = o2.type, coordinates;
    switch (type2) {
      case "GeometryCollection":
        return {type: type2, geometries: o2.geometries.map(geometry)};
      case "Point":
        coordinates = point8(o2.coordinates);
        break;
      case "MultiPoint":
        coordinates = o2.coordinates.map(point8);
        break;
      case "LineString":
        coordinates = line4(o2.arcs);
        break;
      case "MultiLineString":
        coordinates = o2.arcs.map(line4);
        break;
      case "Polygon":
        coordinates = polygon(o2.arcs);
        break;
      case "MultiPolygon":
        coordinates = o2.arcs.map(polygon);
        break;
      default:
        return null;
    }
    return {type: type2, coordinates};
  }
  return geometry(o);
}

// node_modules/topojson-client/src/stitch.js
function stitch_default(topology, arcs) {
  var stitchedArcs = {}, fragmentByStart = {}, fragmentByEnd = {}, fragments = [], emptyIndex = -1;
  arcs.forEach(function(i, j) {
    var arc4 = topology.arcs[i < 0 ? ~i : i], t;
    if (arc4.length < 3 && !arc4[1][0] && !arc4[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });
  arcs.forEach(function(i) {
    var e = ends(i), start = e[0], end = e[1], f, g;
    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;
      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;
      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });
  function ends(i) {
    var arc4 = topology.arcs[i < 0 ? ~i : i], p02 = arc4[0], p1;
    if (topology.transform)
      p1 = [0, 0], arc4.forEach(function(dp) {
        p1[0] += dp[0], p1[1] += dp[1];
      });
    else
      p1 = arc4[arc4.length - 1];
    return i < 0 ? [p1, p02] : [p02, p1];
  }
  function flush2(fragmentByEnd2, fragmentByStart2) {
    for (var k in fragmentByEnd2) {
      var f = fragmentByEnd2[k];
      delete fragmentByStart2[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) {
        stitchedArcs[i < 0 ? ~i : i] = 1;
      });
      fragments.push(f);
    }
  }
  flush2(fragmentByEnd, fragmentByStart);
  flush2(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) {
    if (!stitchedArcs[i < 0 ? ~i : i])
      fragments.push([i]);
  });
  return fragments;
}

// node_modules/topojson-client/src/mesh.js
function mesh_default(topology) {
  return object(topology, meshArcs.apply(this, arguments));
}
function meshArcs(topology, object2, filter4) {
  var arcs, i, n;
  if (arguments.length > 1)
    arcs = extractArcs(topology, object2, filter4);
  else
    for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i)
      arcs[i] = i;
  return {type: "MultiLineString", arcs: stitch_default(topology, arcs)};
}
function extractArcs(topology, object2, filter4) {
  var arcs = [], geomsByArc = [], geom;
  function extract0(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({i, g: geom});
  }
  function extract1(arcs2) {
    arcs2.forEach(extract0);
  }
  function extract2(arcs2) {
    arcs2.forEach(extract1);
  }
  function extract3(arcs2) {
    arcs2.forEach(extract2);
  }
  function geometry(o) {
    switch (geom = o, o.type) {
      case "GeometryCollection":
        o.geometries.forEach(geometry);
        break;
      case "LineString":
        extract1(o.arcs);
        break;
      case "MultiLineString":
      case "Polygon":
        extract2(o.arcs);
        break;
      case "MultiPolygon":
        extract3(o.arcs);
        break;
    }
  }
  geometry(object2);
  geomsByArc.forEach(filter4 == null ? function(geoms) {
    arcs.push(geoms[0].i);
  } : function(geoms) {
    if (filter4(geoms[0].g, geoms[geoms.length - 1].g))
      arcs.push(geoms[0].i);
  });
  return arcs;
}

// node_modules/vega-loader/src/formats/topojson.js
var filters = {
  interior: (a2, b2) => a2 !== b2,
  exterior: (a2, b2) => a2 === b2
};
function topojson(data4, format8) {
  let method2, object2, property2, filter4;
  data4 = json(data4, format8);
  if (format8 && format8.feature) {
    method2 = feature_default;
    property2 = format8.feature;
  } else if (format8 && format8.mesh) {
    method2 = mesh_default;
    property2 = format8.mesh;
    filter4 = filters[format8.filter];
  } else {
    error("Missing TopoJSON feature or mesh parameter.");
  }
  object2 = (object2 = data4.objects[property2]) ? method2(data4, object2, filter4) : error("Invalid TopoJSON object: " + property2);
  return object2 && object2.features || [object2];
}
topojson.responseType = "json";

// node_modules/vega-loader/src/formats/index.js
var format = {
  dsv,
  csv: delimitedFormat(","),
  tsv: delimitedFormat("	"),
  json,
  topojson
};
function formats(name4, reader) {
  if (arguments.length > 1) {
    format[name4] = reader;
    return this;
  } else {
    return has(format, name4) ? format[name4] : null;
  }
}
function responseType(type2) {
  const f = formats(type2);
  return f && f.responseType || "text";
}

// node_modules/d3-array/src/ascending.js
function ascending_default(a2, b2) {
  return a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector_default(f) {
  let delta = f;
  let compare4 = f;
  if (f.length === 1) {
    delta = (d, x5) => f(d) - x5;
    compare4 = ascendingComparator(f);
  }
  function left(a2, x5, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a2.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare4(a2[mid], x5) < 0)
        lo = mid + 1;
      else
        hi = mid;
    }
    return lo;
  }
  function right(a2, x5, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a2.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare4(a2[mid], x5) > 0)
        hi = mid;
      else
        lo = mid + 1;
    }
    return lo;
  }
  function center(a2, x5, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a2.length;
    const i = left(a2, x5, lo, hi - 1);
    return i > lo && delta(a2[i - 1], x5) > -delta(a2[i], x5) ? i - 1 : i;
  }
  return {left, center, right};
}
function ascendingComparator(f) {
  return (d, x5) => ascending_default(f(d), x5);
}

// node_modules/d3-array/src/number.js
function number_default(x5) {
  return x5 === null ? NaN : +x5;
}
function* numbers(values4, valueof) {
  if (valueof === void 0) {
    for (let value3 of values4) {
      if (value3 != null && (value3 = +value3) >= value3) {
        yield value3;
      }
    }
  } else {
    let index4 = -1;
    for (let value3 of values4) {
      if ((value3 = valueof(value3, ++index4, values4)) != null && (value3 = +value3) >= value3) {
        yield value3;
      }
    }
  }
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector_default(ascending_default);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector_default(number_default).center;
var bisect_default2 = bisectRight;

// node_modules/d3-array/src/variance.js
function variance(values4, valueof) {
  let count2 = 0;
  let delta;
  let mean2 = 0;
  let sum2 = 0;
  if (valueof === void 0) {
    for (let value3 of values4) {
      if (value3 != null && (value3 = +value3) >= value3) {
        delta = value3 - mean2;
        mean2 += delta / ++count2;
        sum2 += delta * (value3 - mean2);
      }
    }
  } else {
    let index4 = -1;
    for (let value3 of values4) {
      if ((value3 = valueof(value3, ++index4, values4)) != null && (value3 = +value3) >= value3) {
        delta = value3 - mean2;
        mean2 += delta / ++count2;
        sum2 += delta * (value3 - mean2);
      }
    }
  }
  if (count2 > 1)
    return sum2 / (count2 - 1);
}

// node_modules/d3-array/src/deviation.js
function deviation(values4, valueof) {
  const v = variance(values4, valueof);
  return v ? Math.sqrt(v) : v;
}

// node_modules/d3-array/src/fsum.js
var Adder = class {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x5) {
    const p = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y5 = p[j], hi = x5 + y5, lo = Math.abs(x5) < Math.abs(y5) ? x5 - (hi - y5) : y5 - (hi - x5);
      if (lo)
        p[i++] = lo;
      x5 = hi;
    }
    p[i] = x5;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p = this._partials;
    let n = this._n, x5, y5, lo, hi = 0;
    if (n > 0) {
      hi = p[--n];
      while (n > 0) {
        x5 = hi;
        y5 = p[--n];
        hi = x5 + y5;
        lo = y5 - (hi - x5);
        if (lo)
          break;
      }
      if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
        y5 = lo * 2;
        x5 = hi + y5;
        if (y5 == x5 - hi)
          hi = x5;
      }
    }
    return hi;
  }
};

// node_modules/d3-array/src/permute.js
function permute_default(source4, keys4) {
  return Array.from(keys4, (key2) => source4[key2]);
}

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function ticks_default(start, stop2, count2) {
  var reverse4, i = -1, n, ticks, step;
  stop2 = +stop2, start = +start, count2 = +count2;
  if (start === stop2 && count2 > 0)
    return [start];
  if (reverse4 = stop2 < start)
    n = start, start = stop2, stop2 = n;
  if ((step = tickIncrement(start, stop2, count2)) === 0 || !isFinite(step))
    return [];
  if (step > 0) {
    start = Math.ceil(start / step);
    stop2 = Math.floor(stop2 / step);
    ticks = new Array(n = Math.ceil(stop2 - start + 1));
    while (++i < n)
      ticks[i] = (start + i) * step;
  } else {
    step = -step;
    start = Math.ceil(start * step);
    stop2 = Math.floor(stop2 * step);
    ticks = new Array(n = Math.ceil(stop2 - start + 1));
    while (++i < n)
      ticks[i] = (start + i) / step;
  }
  if (reverse4)
    ticks.reverse();
  return ticks;
}
function tickIncrement(start, stop2, count2) {
  var step = (stop2 - start) / Math.max(0, count2), power = Math.floor(Math.log(step) / Math.LN10), error3 = step / Math.pow(10, power);
  return power >= 0 ? (error3 >= e10 ? 10 : error3 >= e5 ? 5 : error3 >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error3 >= e10 ? 10 : error3 >= e5 ? 5 : error3 >= e2 ? 2 : 1);
}
function tickStep(start, stop2, count2) {
  var step0 = Math.abs(stop2 - start) / Math.max(0, count2), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error3 = step0 / step1;
  if (error3 >= e10)
    step1 *= 10;
  else if (error3 >= e5)
    step1 *= 5;
  else if (error3 >= e2)
    step1 *= 2;
  return stop2 < start ? -step1 : step1;
}

// node_modules/d3-array/src/max.js
function max(values4, valueof) {
  let max4;
  if (valueof === void 0) {
    for (const value3 of values4) {
      if (value3 != null && (max4 < value3 || max4 === void 0 && value3 >= value3)) {
        max4 = value3;
      }
    }
  } else {
    let index4 = -1;
    for (let value3 of values4) {
      if ((value3 = valueof(value3, ++index4, values4)) != null && (max4 < value3 || max4 === void 0 && value3 >= value3)) {
        max4 = value3;
      }
    }
  }
  return max4;
}

// node_modules/d3-array/src/min.js
function min(values4, valueof) {
  let min4;
  if (valueof === void 0) {
    for (const value3 of values4) {
      if (value3 != null && (min4 > value3 || min4 === void 0 && value3 >= value3)) {
        min4 = value3;
      }
    }
  } else {
    let index4 = -1;
    for (let value3 of values4) {
      if ((value3 = valueof(value3, ++index4, values4)) != null && (min4 > value3 || min4 === void 0 && value3 >= value3)) {
        min4 = value3;
      }
    }
  }
  return min4;
}

// node_modules/d3-array/src/quickselect.js
function quickselect(array5, k, left = 0, right = array5.length - 1, compare4 = ascending_default) {
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m2 = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m2 - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m2 * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m2) * s / n + sd));
      quickselect(array5, k, newLeft, newRight, compare4);
    }
    const t = array5[k];
    let i = left;
    let j = right;
    swap(array5, left, k);
    if (compare4(array5[right], t) > 0)
      swap(array5, left, right);
    while (i < j) {
      swap(array5, i, j), ++i, --j;
      while (compare4(array5[i], t) < 0)
        ++i;
      while (compare4(array5[j], t) > 0)
        --j;
    }
    if (compare4(array5[left], t) === 0)
      swap(array5, left, j);
    else
      ++j, swap(array5, j, right);
    if (j <= k)
      left = j + 1;
    if (k <= j)
      right = j - 1;
  }
  return array5;
}
function swap(array5, i, j) {
  const t = array5[i];
  array5[i] = array5[j];
  array5[j] = t;
}

// node_modules/d3-array/src/quantile.js
function quantile(values4, p, valueof) {
  values4 = Float64Array.from(numbers(values4, valueof));
  if (!(n = values4.length))
    return;
  if ((p = +p) <= 0 || n < 2)
    return min(values4);
  if (p >= 1)
    return max(values4);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = max(quickselect(values4, i0).subarray(0, i0 + 1)), value1 = min(values4.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}
function quantileSorted(values4, p, valueof = number_default) {
  if (!(n = values4.length))
    return;
  if ((p = +p) <= 0 || n < 2)
    return +valueof(values4[0], 0, values4);
  if (p >= 1)
    return +valueof(values4[n - 1], n - 1, values4);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values4[i0], i0, values4), value1 = +valueof(values4[i0 + 1], i0 + 1, values4);
  return value0 + (value1 - value0) * (i - i0);
}

// node_modules/d3-array/src/mean.js
function mean(values4, valueof) {
  let count2 = 0;
  let sum2 = 0;
  if (valueof === void 0) {
    for (let value3 of values4) {
      if (value3 != null && (value3 = +value3) >= value3) {
        ++count2, sum2 += value3;
      }
    }
  } else {
    let index4 = -1;
    for (let value3 of values4) {
      if ((value3 = valueof(value3, ++index4, values4)) != null && (value3 = +value3) >= value3) {
        ++count2, sum2 += value3;
      }
    }
  }
  if (count2)
    return sum2 / count2;
}

// node_modules/d3-array/src/median.js
function median_default(values4, valueof) {
  return quantile(values4, 0.5, valueof);
}

// node_modules/d3-array/src/merge.js
function* flatten(arrays) {
  for (const array5 of arrays) {
    yield* array5;
  }
}
function merge2(arrays) {
  return Array.from(flatten(arrays));
}

// node_modules/d3-array/src/range.js
function range_default(start, stop2, step) {
  start = +start, stop2 = +stop2, step = (n = arguments.length) < 2 ? (stop2 = start, start = 0, 1) : n < 3 ? 1 : +step;
  var i = -1, n = Math.max(0, Math.ceil((stop2 - start) / step)) | 0, range5 = new Array(n);
  while (++i < n) {
    range5[i] = start + i * step;
  }
  return range5;
}

// node_modules/d3-array/src/sum.js
function sum(values4, valueof) {
  let sum2 = 0;
  if (valueof === void 0) {
    for (let value3 of values4) {
      if (value3 = +value3) {
        sum2 += value3;
      }
    }
  } else {
    let index4 = -1;
    for (let value3 of values4) {
      if (value3 = +valueof(value3, ++index4, values4)) {
        sum2 += value3;
      }
    }
  }
  return sum2;
}

// node_modules/vega-format/node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x5) {
  return Math.abs(x5 = Math.round(x5)) >= 1e21 ? x5.toLocaleString("en").replace(/,/g, "") : x5.toString(10);
}
function formatDecimalParts(x5, p) {
  if ((i = (x5 = p ? x5.toExponential(p - 1) : x5.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x5.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x5.slice(i + 1)
  ];
}

// node_modules/vega-format/node_modules/d3-format/src/exponent.js
function exponent_default(x5) {
  return x5 = formatDecimalParts(Math.abs(x5)), x5 ? x5[1] : NaN;
}

// node_modules/vega-format/node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value3, width2) {
    var i = value3.length, t = [], j = 0, g = grouping[0], length3 = 0;
    while (i > 0 && g > 0) {
      if (length3 + g + 1 > width2)
        g = Math.max(1, width2 - length3);
      t.push(value3.substring(i -= g, i + g));
      if ((length3 += g + 1) > width2)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// node_modules/vega-format/node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value3) {
    return value3.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// node_modules/vega-format/node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match3 = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match3;
  return new FormatSpecifier({
    fill: match3[1],
    align: match3[2],
    sign: match3[3],
    symbol: match3[4],
    zero: match3[5],
    width: match3[6],
    comma: match3[7],
    precision: match3[8] && match3[8].slice(1),
    trim: match3[9],
    type: match3[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/vega-format/node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s) {
  out:
    for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

// node_modules/vega-format/node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x5, p) {
  var d = formatDecimalParts(x5, p);
  if (!d)
    return x5 + "";
  var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x5, Math.max(0, p + i - 1))[0];
}

// node_modules/vega-format/node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x5, p) {
  var d = formatDecimalParts(x5, p);
  if (!d)
    return x5 + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/vega-format/node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x5, p) => (x5 * 100).toFixed(p),
  b: (x5) => Math.round(x5).toString(2),
  c: (x5) => x5 + "",
  d: formatDecimal_default,
  e: (x5, p) => x5.toExponential(p),
  f: (x5, p) => x5.toFixed(p),
  g: (x5, p) => x5.toPrecision(p),
  o: (x5) => Math.round(x5).toString(8),
  p: (x5, p) => formatRounded_default(x5 * 100, p),
  r: formatRounded_default,
  s: formatPrefixAuto_default,
  X: (x5) => Math.round(x5).toString(16).toUpperCase(),
  x: (x5) => Math.round(x5).toString(16)
};

// node_modules/vega-format/node_modules/d3-format/src/identity.js
function identity_default2(x5) {
  return x5;
}

// node_modules/vega-format/node_modules/d3-format/src/locale.js
var map = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale6) {
  var group2 = locale6.grouping === void 0 || locale6.thousands === void 0 ? identity_default2 : formatGroup_default(map.call(locale6.grouping, Number), locale6.thousands + ""), currencyPrefix = locale6.currency === void 0 ? "" : locale6.currency[0] + "", currencySuffix = locale6.currency === void 0 ? "" : locale6.currency[1] + "", decimal = locale6.decimal === void 0 ? "." : locale6.decimal + "", numerals = locale6.numerals === void 0 ? identity_default2 : formatNumerals_default(map.call(locale6.numerals, String)), percent = locale6.percent === void 0 ? "%" : locale6.percent + "", minus = locale6.minus === void 0 ? "\u2212" : locale6.minus + "", nan = locale6.nan === void 0 ? "NaN" : locale6.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill2 = specifier.fill, align2 = specifier.align, sign3 = specifier.sign, symbol2 = specifier.symbol, zero7 = specifier.zero, width2 = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;
    if (type2 === "n")
      comma = true, type2 = "g";
    else if (!formatTypes_default[type2])
      precision === void 0 && (precision = 12), trim = true, type2 = "g";
    if (zero7 || fill2 === "0" && align2 === "=")
      zero7 = true, fill2 = "0", align2 = "=";
    var prefix = symbol2 === "$" ? currencyPrefix : symbol2 === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol2 === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes_default[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format8(value3) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c2;
      if (type2 === "c") {
        valueSuffix = formatType(value3) + valueSuffix;
        value3 = "";
      } else {
        value3 = +value3;
        var valueNegative = value3 < 0 || 1 / value3 < 0;
        value3 = isNaN(value3) ? nan : formatType(Math.abs(value3), precision);
        if (trim)
          value3 = formatTrim_default(value3);
        if (valueNegative && +value3 === 0 && sign3 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign3 === "(" ? sign3 : minus : sign3 === "-" || sign3 === "(" ? "" : sign3) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign3 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value3.length;
          while (++i < n) {
            if (c2 = value3.charCodeAt(i), 48 > c2 || c2 > 57) {
              valueSuffix = (c2 === 46 ? decimal + value3.slice(i + 1) : value3.slice(i)) + valueSuffix;
              value3 = value3.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero7)
        value3 = group2(value3, Infinity);
      var length3 = valuePrefix.length + value3.length + valueSuffix.length, padding3 = length3 < width2 ? new Array(width2 - length3 + 1).join(fill2) : "";
      if (comma && zero7)
        value3 = group2(padding3 + value3, padding3.length ? width2 - valueSuffix.length : Infinity), padding3 = "";
      switch (align2) {
        case "<":
          value3 = valuePrefix + value3 + valueSuffix + padding3;
          break;
        case "=":
          value3 = valuePrefix + padding3 + value3 + valueSuffix;
          break;
        case "^":
          value3 = padding3.slice(0, length3 = padding3.length >> 1) + valuePrefix + value3 + valueSuffix + padding3.slice(length3);
          break;
        default:
          value3 = padding3 + valuePrefix + value3 + valueSuffix;
          break;
      }
      return numerals(value3);
    }
    format8.toString = function() {
      return specifier + "";
    };
    return format8;
  }
  function formatPrefix4(specifier, value3) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value3) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value4) {
      return f(k * value4) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix4
  };
}

// node_modules/vega-format/node_modules/d3-format/src/defaultLocale.js
var locale;
var format2;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition3) {
  locale = locale_default(definition3);
  format2 = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/vega-format/node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// node_modules/vega-format/node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value3) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value3) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// node_modules/vega-format/node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max4) {
  step = Math.abs(step), max4 = Math.abs(max4) - step;
  return Math.max(0, exponent_default(max4) - exponent_default(step)) + 1;
}

// node_modules/d3-time/src/interval.js
var t0 = new Date();
var t1 = new Date();
function newInterval(floori, offseti, count2, field4) {
  function interval3(date2) {
    return floori(date2 = arguments.length === 0 ? new Date() : new Date(+date2)), date2;
  }
  interval3.floor = function(date2) {
    return floori(date2 = new Date(+date2)), date2;
  };
  interval3.ceil = function(date2) {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval3.round = function(date2) {
    var d0 = interval3(date2), d1 = interval3.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval3.offset = function(date2, step) {
    return offseti(date2 = new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval3.range = function(start, stop2, step) {
    var range5 = [], previous;
    start = interval3.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop2) || !(step > 0))
      return range5;
    do
      range5.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop2);
    return range5;
  };
  interval3.filter = function(test2) {
    return newInterval(function(date2) {
      if (date2 >= date2)
        while (floori(date2), !test2(date2))
          date2.setTime(date2 - 1);
    }, function(date2, step) {
      if (date2 >= date2) {
        if (step < 0)
          while (++step <= 0) {
            while (offseti(date2, -1), !test2(date2)) {
            }
          }
        else
          while (--step >= 0) {
            while (offseti(date2, 1), !test2(date2)) {
            }
          }
      }
    });
  };
  if (count2) {
    interval3.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count2(t0, t1));
    };
    interval3.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval3 : interval3.filter(field4 ? function(d) {
        return field4(d) % step === 0;
      } : function(d) {
        return interval3.count(0, d) % step === 0;
      });
    };
  }
  return interval3;
}

// node_modules/d3-time/src/millisecond.js
var millisecond = newInterval(function() {
}, function(date2, step) {
  date2.setTime(+date2 + step);
}, function(start, end) {
  return end - start;
});
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0))
    return null;
  if (!(k > 1))
    return millisecond;
  return newInterval(function(date2) {
    date2.setTime(Math.floor(date2 / k) * k);
  }, function(date2, step) {
    date2.setTime(+date2 + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};
var millisecond_default = millisecond;
var milliseconds = millisecond.range;

// node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;

// node_modules/d3-time/src/second.js
var second = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds());
}, function(date2, step) {
  date2.setTime(+date2 + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date2) {
  return date2.getUTCSeconds();
});
var second_default = second;
var seconds = second.range;

// node_modules/d3-time/src/minute.js
var minute = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date2) {
  return date2.getMinutes();
});
var minute_default = minute;
var minutes = minute.range;

// node_modules/d3-time/src/hour.js
var hour = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date2) {
  return date2.getHours();
});
var hour_default = hour;
var hours = hour.range;

// node_modules/d3-time/src/day.js
var day = newInterval((date2) => date2.setHours(0, 0, 0, 0), (date2, step) => date2.setDate(date2.getDate() + step), (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay, (date2) => date2.getDate() - 1);
var day_default = day;
var days = day.range;

// node_modules/d3-time/src/week.js
function weekday(i) {
  return newInterval(function(date2) {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setDate(date2.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);
var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

// node_modules/d3-time/src/month.js
var month = newInterval(function(date2) {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setMonth(date2.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date2) {
  return date2.getMonth();
});
var month_default = month;
var months = month.range;

// node_modules/d3-time/src/year.js
var year = newInterval(function(date2) {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setFullYear(date2.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date2) {
  return date2.getFullYear();
});
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date2) {
    date2.setFullYear(Math.floor(date2.getFullYear() / k) * k);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setFullYear(date2.getFullYear() + step * k);
  });
};
var year_default = year;
var years = year.range;

// node_modules/d3-time/src/utcMinute.js
var utcMinute = newInterval(function(date2) {
  date2.setUTCSeconds(0, 0);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date2) {
  return date2.getUTCMinutes();
});
var utcMinute_default = utcMinute;
var utcMinutes = utcMinute.range;

// node_modules/d3-time/src/utcHour.js
var utcHour = newInterval(function(date2) {
  date2.setUTCMinutes(0, 0, 0);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date2) {
  return date2.getUTCHours();
});
var utcHour_default = utcHour;
var utcHours = utcHour.range;

// node_modules/d3-time/src/utcDay.js
var utcDay = newInterval(function(date2) {
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCDate(date2.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date2) {
  return date2.getUTCDate() - 1;
});
var utcDay_default = utcDay;
var utcDays = utcDay.range;

// node_modules/d3-time/src/utcWeek.js
function utcWeekday(i) {
  return newInterval(function(date2) {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// node_modules/d3-time/src/utcMonth.js
var utcMonth = newInterval(function(date2) {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date2) {
  return date2.getUTCMonth();
});
var utcMonth_default = utcMonth;
var utcMonths = utcMonth.range;

// node_modules/d3-time/src/utcYear.js
var utcYear = newInterval(function(date2) {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date2) {
  return date2.getUTCFullYear();
});
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date2) {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k) * k);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k);
  });
};
var utcYear_default = utcYear;
var utcYears = utcYear.range;

// node_modules/vega-time/build/vega-time.module.js
var YEAR = "year";
var QUARTER = "quarter";
var MONTH = "month";
var WEEK = "week";
var DATE = "date";
var DAY = "day";
var DAYOFYEAR = "dayofyear";
var HOURS = "hours";
var MINUTES = "minutes";
var SECONDS = "seconds";
var MILLISECONDS = "milliseconds";
var TIME_UNITS = [YEAR, QUARTER, MONTH, WEEK, DATE, DAY, DAYOFYEAR, HOURS, MINUTES, SECONDS, MILLISECONDS];
var UNITS = TIME_UNITS.reduce((o, u, i) => (o[u] = 1 + i, o), {});
function timeUnits(units) {
  const u = array(units).slice(), m2 = {};
  if (!u.length)
    error("Missing time unit.");
  u.forEach((unit2) => {
    if (has(UNITS, unit2)) {
      m2[unit2] = 1;
    } else {
      error("Invalid time unit: ".concat(unit2, "."));
    }
  });
  const numTypes = (m2[WEEK] || m2[DAY] ? 1 : 0) + (m2[QUARTER] || m2[MONTH] || m2[DATE] ? 1 : 0) + (m2[DAYOFYEAR] ? 1 : 0);
  if (numTypes > 1) {
    error("Incompatible time units: ".concat(units));
  }
  u.sort((a2, b2) => UNITS[a2] - UNITS[b2]);
  return u;
}
var defaultSpecifiers = {
  [YEAR]: "%Y ",
  [QUARTER]: "Q%q ",
  [MONTH]: "%b ",
  [DATE]: "%d ",
  [WEEK]: "W%U ",
  [DAY]: "%a ",
  [DAYOFYEAR]: "%j ",
  [HOURS]: "%H:00",
  [MINUTES]: "00:%M",
  [SECONDS]: ":%S",
  [MILLISECONDS]: ".%L",
  ["".concat(YEAR, "-").concat(MONTH)]: "%Y-%m ",
  ["".concat(YEAR, "-").concat(MONTH, "-").concat(DATE)]: "%Y-%m-%d ",
  ["".concat(HOURS, "-").concat(MINUTES)]: "%H:%M"
};
function timeUnitSpecifier(units, specifiers) {
  const s = extend({}, defaultSpecifiers, specifiers), u = timeUnits(units), n = u.length;
  let fmt = "", start = 0, end, key2;
  for (start = 0; start < n; ) {
    for (end = u.length; end > start; --end) {
      key2 = u.slice(start, end).join("-");
      if (s[key2] != null) {
        fmt += s[key2];
        start = end;
        break;
      }
    }
  }
  return fmt.trim();
}
var t02 = new Date();
function localYear(y5) {
  t02.setFullYear(y5);
  t02.setMonth(0);
  t02.setDate(1);
  t02.setHours(0, 0, 0, 0);
  return t02;
}
function dayofyear(d) {
  return localDayOfYear(new Date(d));
}
function week(d) {
  return localWeekNum(new Date(d));
}
function localDayOfYear(d) {
  return day_default.count(localYear(d.getFullYear()) - 1, d);
}
function localWeekNum(d) {
  return sunday.count(localYear(d.getFullYear()) - 1, d);
}
function localFirst(y5) {
  return localYear(y5).getDay();
}
function localDate(y5, m2, d, H, M2, S, L) {
  if (0 <= y5 && y5 < 100) {
    const date2 = new Date(-1, m2, d, H, M2, S, L);
    date2.setFullYear(y5);
    return date2;
  }
  return new Date(y5, m2, d, H, M2, S, L);
}
function utcdayofyear(d) {
  return utcDayOfYear(new Date(d));
}
function utcweek(d) {
  return utcWeekNum(new Date(d));
}
function utcDayOfYear(d) {
  const y5 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcDay_default.count(y5 - 1, d);
}
function utcWeekNum(d) {
  const y5 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcSunday.count(y5 - 1, d);
}
function utcFirst(y5) {
  t02.setTime(Date.UTC(y5, 0, 1));
  return t02.getUTCDay();
}
function utcDate(y5, m2, d, H, M2, S, L) {
  if (0 <= y5 && y5 < 100) {
    const date2 = new Date(Date.UTC(-1, m2, d, H, M2, S, L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(y5, m2, d, H, M2, S, L));
}
function floor(units, step, get6, inv, newDate2) {
  const s = step || 1, b2 = peek(units), _ = (unit2, p, key2) => {
    key2 = key2 || unit2;
    return getUnit(get6[key2], inv[key2], unit2 === b2 && s, p);
  };
  const t = new Date(), u = toSet(units), y5 = u[YEAR] ? _(YEAR) : constant(2012), m2 = u[MONTH] ? _(MONTH) : u[QUARTER] ? _(QUARTER) : zero, d = u[WEEK] && u[DAY] ? _(DAY, 1, WEEK + DAY) : u[WEEK] ? _(WEEK, 1) : u[DAY] ? _(DAY, 1) : u[DATE] ? _(DATE, 1) : u[DAYOFYEAR] ? _(DAYOFYEAR, 1) : one, H = u[HOURS] ? _(HOURS) : zero, M2 = u[MINUTES] ? _(MINUTES) : zero, S = u[SECONDS] ? _(SECONDS) : zero, L = u[MILLISECONDS] ? _(MILLISECONDS) : zero;
  return function(v) {
    t.setTime(+v);
    const year2 = y5(t);
    return newDate2(year2, m2(t), d(t, year2), H(t), M2(t), S(t), L(t));
  };
}
function getUnit(f, inv, step, phase) {
  const u = step <= 1 ? f : phase ? (d, y5) => phase + step * Math.floor((f(d, y5) - phase) / step) : (d, y5) => step * Math.floor(f(d, y5) / step);
  return inv ? (d, y5) => inv(u(d, y5), y5) : u;
}
function weekday2(week2, day2, firstDay) {
  return day2 + week2 * 7 - (firstDay + 6) % 7;
}
var localGet = {
  [YEAR]: (d) => d.getFullYear(),
  [QUARTER]: (d) => Math.floor(d.getMonth() / 3),
  [MONTH]: (d) => d.getMonth(),
  [DATE]: (d) => d.getDate(),
  [HOURS]: (d) => d.getHours(),
  [MINUTES]: (d) => d.getMinutes(),
  [SECONDS]: (d) => d.getSeconds(),
  [MILLISECONDS]: (d) => d.getMilliseconds(),
  [DAYOFYEAR]: (d) => localDayOfYear(d),
  [WEEK]: (d) => localWeekNum(d),
  [WEEK + DAY]: (d, y5) => weekday2(localWeekNum(d), d.getDay(), localFirst(y5)),
  [DAY]: (d, y5) => weekday2(1, d.getDay(), localFirst(y5))
};
var localInv = {
  [QUARTER]: (q) => 3 * q,
  [WEEK]: (w3, y5) => weekday2(w3, 0, localFirst(y5))
};
function timeFloor(units, step) {
  return floor(units, step || 1, localGet, localInv, localDate);
}
var utcGet = {
  [YEAR]: (d) => d.getUTCFullYear(),
  [QUARTER]: (d) => Math.floor(d.getUTCMonth() / 3),
  [MONTH]: (d) => d.getUTCMonth(),
  [DATE]: (d) => d.getUTCDate(),
  [HOURS]: (d) => d.getUTCHours(),
  [MINUTES]: (d) => d.getUTCMinutes(),
  [SECONDS]: (d) => d.getUTCSeconds(),
  [MILLISECONDS]: (d) => d.getUTCMilliseconds(),
  [DAYOFYEAR]: (d) => utcDayOfYear(d),
  [WEEK]: (d) => utcWeekNum(d),
  [DAY]: (d, y5) => weekday2(1, d.getUTCDay(), utcFirst(y5)),
  [WEEK + DAY]: (d, y5) => weekday2(utcWeekNum(d), d.getUTCDay(), utcFirst(y5))
};
var utcInv = {
  [QUARTER]: (q) => 3 * q,
  [WEEK]: (w3, y5) => weekday2(w3, 0, utcFirst(y5))
};
function utcFloor(units, step) {
  return floor(units, step || 1, utcGet, utcInv, utcDate);
}
var timeIntervals = {
  [YEAR]: year_default,
  [QUARTER]: month_default.every(3),
  [MONTH]: month_default,
  [WEEK]: sunday,
  [DATE]: day_default,
  [DAY]: day_default,
  [DAYOFYEAR]: day_default,
  [HOURS]: hour_default,
  [MINUTES]: minute_default,
  [SECONDS]: second_default,
  [MILLISECONDS]: millisecond_default
};
var utcIntervals = {
  [YEAR]: utcYear_default,
  [QUARTER]: utcMonth_default.every(3),
  [MONTH]: utcMonth_default,
  [WEEK]: utcSunday,
  [DATE]: utcDay_default,
  [DAY]: utcDay_default,
  [DAYOFYEAR]: utcDay_default,
  [HOURS]: utcHour_default,
  [MINUTES]: utcMinute_default,
  [SECONDS]: second_default,
  [MILLISECONDS]: millisecond_default
};
function timeInterval(unit2) {
  return timeIntervals[unit2];
}
function utcInterval(unit2) {
  return utcIntervals[unit2];
}
function offset(ival, date2, step) {
  return ival ? ival.offset(date2, step) : void 0;
}
function timeOffset(unit2, date2, step) {
  return offset(timeInterval(unit2), date2, step);
}
function utcOffset(unit2, date2, step) {
  return offset(utcInterval(unit2), date2, step);
}
function sequence(ival, start, stop2, step) {
  return ival ? ival.range(start, stop2, step) : void 0;
}
function timeSequence(unit2, start, stop2, step) {
  return sequence(timeInterval(unit2), start, stop2, step);
}
function utcSequence(unit2, start, stop2, step) {
  return sequence(utcInterval(unit2), start, stop2, step);
}
var durationSecond2 = 1e3;
var durationMinute2 = durationSecond2 * 60;
var durationHour2 = durationMinute2 * 60;
var durationDay2 = durationHour2 * 24;
var durationWeek2 = durationDay2 * 7;
var durationMonth = durationDay2 * 30;
var durationYear = durationDay2 * 365;
var Milli = [YEAR, MONTH, DATE, HOURS, MINUTES, SECONDS, MILLISECONDS];
var Seconds = Milli.slice(0, -1);
var Minutes = Seconds.slice(0, -1);
var Hours = Minutes.slice(0, -1);
var Day = Hours.slice(0, -1);
var Week = [YEAR, WEEK];
var Month = [YEAR, MONTH];
var Year = [YEAR];
var intervals = [[Seconds, 1, durationSecond2], [Seconds, 5, 5 * durationSecond2], [Seconds, 15, 15 * durationSecond2], [Seconds, 30, 30 * durationSecond2], [Minutes, 1, durationMinute2], [Minutes, 5, 5 * durationMinute2], [Minutes, 15, 15 * durationMinute2], [Minutes, 30, 30 * durationMinute2], [Hours, 1, durationHour2], [Hours, 3, 3 * durationHour2], [Hours, 6, 6 * durationHour2], [Hours, 12, 12 * durationHour2], [Day, 1, durationDay2], [Week, 1, durationWeek2], [Month, 1, durationMonth], [Month, 3, 3 * durationMonth], [Year, 1, durationYear]];
function bin(opt) {
  const ext = opt.extent, max4 = opt.maxbins || 40, target = Math.abs(span(ext)) / max4;
  let i = bisector_default((i2) => i2[2]).right(intervals, target), units, step;
  if (i === intervals.length) {
    units = Year, step = tickStep(ext[0] / durationYear, ext[1] / durationYear, max4);
  } else if (i) {
    i = intervals[target / intervals[i - 1][2] < intervals[i][2] / target ? i - 1 : i];
    units = i[0];
    step = i[1];
  } else {
    units = Milli;
    step = Math.max(tickStep(ext[0], ext[1], max4), 1);
  }
  return {
    units,
    step
  };
}

// node_modules/d3-time-format/src/locale.js
function localDate2(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate2(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y5, m2, d) {
  return {y: y5, m: m2, d, H: 0, M: 0, S: 0, L: 0};
}
function formatLocale(locale6) {
  var locale_dateTime = locale6.dateTime, locale_date = locale6.date, locale_time = locale6.time, locale_periods = locale6.periods, locale_weekdays = locale6.days, locale_shortWeekdays = locale6.shortDays, locale_months = locale6.months, locale_shortMonths = locale6.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats3 = {
    a: formatShortWeekday,
    A: formatWeekday,
    b: formatShortMonth,
    B: formatMonth,
    c: null,
    d: formatDayOfMonth,
    e: formatDayOfMonth,
    f: formatMicroseconds,
    g: formatYearISO,
    G: formatFullYearISO,
    H: formatHour24,
    I: formatHour12,
    j: formatDayOfYear,
    L: formatMilliseconds,
    m: formatMonthNumber,
    M: formatMinutes,
    p: formatPeriod,
    q: formatQuarter,
    Q: formatUnixTimestamp,
    s: formatUnixTimestampSeconds,
    S: formatSeconds,
    u: formatWeekdayNumberMonday,
    U: formatWeekNumberSunday,
    V: formatWeekNumberISO,
    w: formatWeekdayNumberSunday,
    W: formatWeekNumberMonday,
    x: null,
    X: null,
    y: formatYear2,
    Y: formatFullYear,
    Z: formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    a: formatUTCShortWeekday,
    A: formatUTCWeekday,
    b: formatUTCShortMonth,
    B: formatUTCMonth,
    c: null,
    d: formatUTCDayOfMonth,
    e: formatUTCDayOfMonth,
    f: formatUTCMicroseconds,
    g: formatUTCYearISO,
    G: formatUTCFullYearISO,
    H: formatUTCHour24,
    I: formatUTCHour12,
    j: formatUTCDayOfYear,
    L: formatUTCMilliseconds,
    m: formatUTCMonthNumber,
    M: formatUTCMinutes,
    p: formatUTCPeriod,
    q: formatUTCQuarter,
    Q: formatUnixTimestamp,
    s: formatUnixTimestampSeconds,
    S: formatUTCSeconds,
    u: formatUTCWeekdayNumberMonday,
    U: formatUTCWeekNumberSunday,
    V: formatUTCWeekNumberISO,
    w: formatUTCWeekdayNumberSunday,
    W: formatUTCWeekNumberMonday,
    x: null,
    X: null,
    y: formatUTCYear,
    Y: formatUTCFullYear,
    Z: formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    a: parseShortWeekday,
    A: parseWeekday,
    b: parseShortMonth,
    B: parseMonth,
    c: parseLocaleDateTime,
    d: parseDayOfMonth,
    e: parseDayOfMonth,
    f: parseMicroseconds,
    g: parseYear,
    G: parseFullYear,
    H: parseHour24,
    I: parseHour24,
    j: parseDayOfYear,
    L: parseMilliseconds,
    m: parseMonthNumber,
    M: parseMinutes,
    p: parsePeriod,
    q: parseQuarter,
    Q: parseUnixTimestamp,
    s: parseUnixTimestampSeconds,
    S: parseSeconds,
    u: parseWeekdayNumberMonday,
    U: parseWeekNumberSunday,
    V: parseWeekNumberISO,
    w: parseWeekdayNumberSunday,
    W: parseWeekNumberMonday,
    x: parseLocaleDate,
    X: parseLocaleTime,
    y: parseYear,
    Y: parseFullYear,
    Z: parseZone,
    "%": parseLiteralPercent
  };
  formats3.x = newFormat(locale_date, formats3);
  formats3.X = newFormat(locale_time, formats3);
  formats3.c = newFormat(locale_dateTime, formats3);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats4) {
    return function(date2) {
      var string = [], i = -1, j = 0, n = specifier.length, c2, pad4, format8;
      if (!(date2 instanceof Date))
        date2 = new Date(+date2);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad4 = pads[c2 = specifier.charAt(++i)]) != null)
            c2 = specifier.charAt(++i);
          else
            pad4 = c2 === "e" ? " " : "0";
          if (format8 = formats4[c2])
            c2 = format8(date2, pad4);
          string.push(c2);
          j = i + 1;
        }
      }
      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week2, day2;
      if (i != string.length)
        return null;
      if ("Q" in d)
        return new Date(d.Q);
      if ("s" in d)
        return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z && !("Z" in d))
        d.Z = 0;
      if ("p" in d)
        d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0)
        d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53)
          return null;
        if (!("w" in d))
          d.w = 1;
        if ("Z" in d) {
          week2 = utcDate2(newDate(d.y, 0, 1)), day2 = week2.getUTCDay();
          week2 = day2 > 4 || day2 === 0 ? utcMonday.ceil(week2) : utcMonday(week2);
          week2 = utcDay_default.offset(week2, (d.V - 1) * 7);
          d.y = week2.getUTCFullYear();
          d.m = week2.getUTCMonth();
          d.d = week2.getUTCDate() + (d.w + 6) % 7;
        } else {
          week2 = localDate2(newDate(d.y, 0, 1)), day2 = week2.getDay();
          week2 = day2 > 4 || day2 === 0 ? monday.ceil(week2) : monday(week2);
          week2 = day_default.offset(week2, (d.V - 1) * 7);
          d.y = week2.getFullYear();
          d.m = week2.getMonth();
          d.d = week2.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d))
          d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day2 = "Z" in d ? utcDate2(newDate(d.y, 0, 1)).getUTCDay() : localDate2(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day2 + 5) % 7 : d.w + d.U * 7 - (day2 + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate2(d);
      }
      return localDate2(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    var i = 0, n = specifier.length, m2 = string.length, c2, parse6;
    while (i < n) {
      if (j >= m2)
        return -1;
      c2 = specifier.charCodeAt(i++);
      if (c2 === 37) {
        c2 = specifier.charAt(i++);
        parse6 = parses[c2 in pads ? specifier.charAt(i++) : c2];
        if (!parse6 || (j = parse6(d, string, j)) < 0)
          return -1;
      } else if (c2 != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }
  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }
  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats3);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
var pads = {"-": "", _: " ", "0": "0"};
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad3(value3, fill2, width2) {
  var sign3 = value3 < 0 ? "-" : "", string = (sign3 ? -value3 : value3) + "", length3 = string.length;
  return sign3 + (length3 < width2 ? new Array(width2 - length3 + 1).join(fill2) + string : string);
}
function requote(s) {
  return s.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name4, i) => [name4.toLowerCase(), i]));
}
function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
  return pad3(d.getDate(), p, 2);
}
function formatHour24(d, p) {
  return pad3(d.getHours(), p, 2);
}
function formatHour12(d, p) {
  return pad3(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
  return pad3(1 + day_default.count(year_default(d), d), p, 3);
}
function formatMilliseconds(d, p) {
  return pad3(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
  return pad3(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
  return pad3(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
  return pad3(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
  var day2 = d.getDay();
  return day2 === 0 ? 7 : day2;
}
function formatWeekNumberSunday(d, p) {
  return pad3(sunday.count(year_default(d) - 1, d), p, 2);
}
function dISO(d) {
  var day2 = d.getDay();
  return day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad3(thursday.count(year_default(d), d) + (year_default(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p) {
  return pad3(monday.count(year_default(d) - 1, d), p, 2);
}
function formatYear2(d, p) {
  return pad3(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
  d = dISO(d);
  return pad3(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
  return pad3(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
  var day2 = d.getDay();
  d = day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
  return pad3(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad3(z / 60 | 0, "0", 2) + pad3(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
  return pad3(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
  return pad3(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
  return pad3(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
  return pad3(1 + utcDay_default.count(utcYear_default(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
  return pad3(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
  return pad3(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
  return pad3(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
  return pad3(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
  return pad3(utcSunday.count(utcYear_default(d) - 1, d), p, 2);
}
function UTCdISO(d) {
  var day2 = d.getUTCDay();
  return day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad3(utcThursday.count(utcYear_default(d), d) + (utcYear_default(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
  return pad3(utcMonday.count(utcYear_default(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
  return pad3(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad3(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
  return pad3(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
  var day2 = d.getUTCDay();
  d = day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad3(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}

// node_modules/d3-time-format/src/defaultLocale.js
var locale2;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale2({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale2(definition3) {
  locale2 = formatLocale(definition3);
  timeFormat = locale2.format;
  timeParse = locale2.parse;
  utcFormat = locale2.utcFormat;
  utcParse = locale2.utcParse;
  return locale2;
}

// node_modules/vega-format/build/vega-format.module.js
function memoize(method2) {
  const cache2 = {};
  return (spec) => cache2[spec] || (cache2[spec] = method2(spec));
}
function trimZeroes(numberFormat2, decimalChar) {
  return (x5) => {
    const str = numberFormat2(x5), dec = str.indexOf(decimalChar);
    if (dec < 0)
      return str;
    let idx = rightmostDigit(str, dec);
    const end = idx < str.length ? str.slice(idx) : "";
    while (--idx > dec)
      if (str[idx] !== "0") {
        ++idx;
        break;
      }
    return str.slice(0, idx) + end;
  };
}
function rightmostDigit(str, dec) {
  let i = str.lastIndexOf("e"), c2;
  if (i > 0)
    return i;
  for (i = str.length; --i > dec; ) {
    c2 = str.charCodeAt(i);
    if (c2 >= 48 && c2 <= 57)
      return i + 1;
  }
}
function numberLocale(locale6) {
  const format8 = memoize(locale6.format), formatPrefix4 = locale6.formatPrefix;
  return {
    format: format8,
    formatPrefix: formatPrefix4,
    formatFloat(spec) {
      const s = formatSpecifier(spec || ",");
      if (s.precision == null) {
        s.precision = 12;
        switch (s.type) {
          case "%":
            s.precision -= 2;
            break;
          case "e":
            s.precision -= 1;
            break;
        }
        return trimZeroes(format8(s), format8(".1f")(1)[1]);
      } else {
        return format8(s);
      }
    },
    formatSpan(start, stop2, count2, specifier) {
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      const step = tickStep(start, stop2, count2), value3 = Math.max(Math.abs(start), Math.abs(stop2));
      let precision;
      if (specifier.precision == null) {
        switch (specifier.type) {
          case "s": {
            if (!isNaN(precision = precisionPrefix_default(step, value3))) {
              specifier.precision = precision;
            }
            return formatPrefix4(specifier, value3);
          }
          case "":
          case "e":
          case "g":
          case "p":
          case "r": {
            if (!isNaN(precision = precisionRound_default(step, value3))) {
              specifier.precision = precision - (specifier.type === "e");
            }
            break;
          }
          case "f":
          case "%": {
            if (!isNaN(precision = precisionFixed_default(step))) {
              specifier.precision = precision - (specifier.type === "%") * 2;
            }
            break;
          }
        }
      }
      return format8(specifier);
    }
  };
}
var defaultNumberLocale;
resetNumberFormatDefaultLocale();
function resetNumberFormatDefaultLocale() {
  return defaultNumberLocale = numberLocale({
    format: format2,
    formatPrefix
  });
}
function numberFormatLocale(definition3) {
  return numberLocale(locale_default(definition3));
}
function numberFormatDefaultLocale(definition3) {
  return arguments.length ? defaultNumberLocale = numberFormatLocale(definition3) : defaultNumberLocale;
}
function timeMultiFormat(format8, interval3, spec) {
  spec = spec || {};
  if (!isObject(spec)) {
    error("Invalid time multi-format specifier: ".concat(spec));
  }
  const second2 = interval3(SECONDS), minute2 = interval3(MINUTES), hour2 = interval3(HOURS), day2 = interval3(DATE), week2 = interval3(WEEK), month2 = interval3(MONTH), quarter3 = interval3(QUARTER), year2 = interval3(YEAR), L = format8(spec[MILLISECONDS] || ".%L"), S = format8(spec[SECONDS] || ":%S"), M2 = format8(spec[MINUTES] || "%I:%M"), H = format8(spec[HOURS] || "%I %p"), d = format8(spec[DATE] || spec[DAY] || "%a %d"), w3 = format8(spec[WEEK] || "%b %d"), m2 = format8(spec[MONTH] || "%B"), q = format8(spec[QUARTER] || "%B"), y5 = format8(spec[YEAR] || "%Y");
  return (date2) => (second2(date2) < date2 ? L : minute2(date2) < date2 ? S : hour2(date2) < date2 ? M2 : day2(date2) < date2 ? H : month2(date2) < date2 ? week2(date2) < date2 ? d : w3 : year2(date2) < date2 ? quarter3(date2) < date2 ? m2 : q : y5)(date2);
}
function timeLocale(locale6) {
  const timeFormat5 = memoize(locale6.format), utcFormat4 = memoize(locale6.utcFormat);
  return {
    timeFormat: (spec) => isString(spec) ? timeFormat5(spec) : timeMultiFormat(timeFormat5, timeInterval, spec),
    utcFormat: (spec) => isString(spec) ? utcFormat4(spec) : timeMultiFormat(utcFormat4, utcInterval, spec),
    timeParse: memoize(locale6.parse),
    utcParse: memoize(locale6.utcParse)
  };
}
var defaultTimeLocale;
resetTimeFormatDefaultLocale();
function resetTimeFormatDefaultLocale() {
  return defaultTimeLocale = timeLocale({
    format: timeFormat,
    parse: timeParse,
    utcFormat,
    utcParse
  });
}
function timeFormatLocale(definition3) {
  return timeLocale(formatLocale(definition3));
}
function timeFormatDefaultLocale(definition3) {
  return arguments.length ? defaultTimeLocale = timeFormatLocale(definition3) : defaultTimeLocale;
}
var createLocale = (number7, time4) => extend({}, number7, time4);
function locale3(numberSpec, timeSpec) {
  const number7 = numberSpec ? numberFormatLocale(numberSpec) : numberFormatDefaultLocale();
  const time4 = timeSpec ? timeFormatLocale(timeSpec) : timeFormatDefaultLocale();
  return createLocale(number7, time4);
}
function defaultLocale3(numberSpec, timeSpec) {
  const args = arguments.length;
  if (args && args !== 2) {
    error("defaultLocale expects either zero or two arguments.");
  }
  return args ? createLocale(numberFormatDefaultLocale(numberSpec), timeFormatDefaultLocale(timeSpec)) : createLocale(numberFormatDefaultLocale(), timeFormatDefaultLocale());
}
function resetDefaultLocale() {
  resetNumberFormatDefaultLocale();
  resetTimeFormatDefaultLocale();
  return defaultLocale3();
}

// node_modules/vega-loader/src/read.js
function read_default(data4, schema, timeParser, utcParser) {
  schema = schema || {};
  const reader = formats(schema.type || "json");
  if (!reader)
    error("Unknown data format type: " + schema.type);
  data4 = reader(data4, schema);
  if (schema.parse)
    parse(data4, schema.parse, timeParser, utcParser);
  if (has(data4, "columns"))
    delete data4.columns;
  return data4;
}
function parse(data4, types3, timeParser, utcParser) {
  if (!data4.length)
    return;
  const locale6 = timeFormatDefaultLocale();
  timeParser = timeParser || locale6.timeParse;
  utcParser = utcParser || locale6.utcParse;
  let fields = data4.columns || Object.keys(data4[0]), datum3, field4, i, j, n, m2;
  if (types3 === "auto")
    types3 = inferTypes(data4, fields);
  fields = Object.keys(types3);
  const parsers = fields.map((field5) => {
    const type2 = types3[field5];
    let parts, pattern;
    if (type2 && (type2.startsWith("date:") || type2.startsWith("utc:"))) {
      parts = type2.split(/:(.+)?/, 2);
      pattern = parts[1];
      if (pattern[0] === "'" && pattern[pattern.length - 1] === "'" || pattern[0] === '"' && pattern[pattern.length - 1] === '"') {
        pattern = pattern.slice(1, -1);
      }
      const parse6 = parts[0] === "utc" ? utcParser : timeParser;
      return parse6(pattern);
    }
    if (!typeParsers[type2]) {
      throw Error("Illegal format pattern: " + field5 + ":" + type2);
    }
    return typeParsers[type2];
  });
  for (i = 0, n = data4.length, m2 = fields.length; i < n; ++i) {
    datum3 = data4[i];
    for (j = 0; j < m2; ++j) {
      field4 = fields[j];
      datum3[field4] = parsers[j](datum3[field4]);
    }
  }
}

// node_modules/vega-loader/index.browser.js
var loader = loader_default(typeof fetch !== "undefined" && fetch, null);

// node_modules/vega-dataflow/build/vega-dataflow.module.js
function UniqueList(idFunc) {
  const $3 = idFunc || identity, list = [], ids = {};
  list.add = (_) => {
    const id4 = $3(_);
    if (!ids[id4]) {
      ids[id4] = 1;
      list.push(_);
    }
    return list;
  };
  list.remove = (_) => {
    const id4 = $3(_);
    if (ids[id4]) {
      ids[id4] = 0;
      const idx = list.indexOf(_);
      if (idx >= 0)
        list.splice(idx, 1);
    }
    return list;
  };
  return list;
}
async function asyncCallback(df, callback) {
  try {
    await callback(df);
  } catch (err) {
    df.error(err);
  }
}
var TUPLE_ID_KEY = Symbol("vega_id");
var TUPLE_ID = 1;
function isTuple(t) {
  return !!(t && tupleid(t));
}
function tupleid(t) {
  return t[TUPLE_ID_KEY];
}
function setid(t, id4) {
  t[TUPLE_ID_KEY] = id4;
  return t;
}
function ingest(datum3) {
  const t = datum3 === Object(datum3) ? datum3 : {
    data: datum3
  };
  return tupleid(t) ? t : setid(t, TUPLE_ID++);
}
function derive(t) {
  return rederive(t, ingest({}));
}
function rederive(t, d) {
  for (const k in t)
    d[k] = t[k];
  return d;
}
function replace(t, d) {
  return setid(d, tupleid(t));
}
function stableCompare(cmp, f) {
  return !cmp ? null : f ? (a2, b2) => cmp(a2, b2) || tupleid(f(a2)) - tupleid(f(b2)) : (a2, b2) => cmp(a2, b2) || tupleid(a2) - tupleid(b2);
}
function isChangeSet(v) {
  return v && v.constructor === changeset;
}
function changeset() {
  const add6 = [], rem2 = [], mod = [], remp = [], modp = [];
  let clean = null, reflow2 = false;
  return {
    constructor: changeset,
    insert(t) {
      const d = array(t), n = d.length;
      for (let i = 0; i < n; ++i)
        add6.push(d[i]);
      return this;
    },
    remove(t) {
      const a2 = isFunction(t) ? remp : rem2, d = array(t), n = d.length;
      for (let i = 0; i < n; ++i)
        a2.push(d[i]);
      return this;
    },
    modify(t, field4, value3) {
      const m2 = {
        field: field4,
        value: constant(value3)
      };
      if (isFunction(t)) {
        m2.filter = t;
        modp.push(m2);
      } else {
        m2.tuple = t;
        mod.push(m2);
      }
      return this;
    },
    encode(t, set6) {
      if (isFunction(t))
        modp.push({
          filter: t,
          field: set6
        });
      else
        mod.push({
          tuple: t,
          field: set6
        });
      return this;
    },
    clean(value3) {
      clean = value3;
      return this;
    },
    reflow() {
      reflow2 = true;
      return this;
    },
    pulse(pulse2, tuples) {
      const cur = {}, out = {};
      let i, n, m2, f, t, id4;
      for (i = 0, n = tuples.length; i < n; ++i) {
        cur[tupleid(tuples[i])] = 1;
      }
      for (i = 0, n = rem2.length; i < n; ++i) {
        t = rem2[i];
        cur[tupleid(t)] = -1;
      }
      for (i = 0, n = remp.length; i < n; ++i) {
        f = remp[i];
        tuples.forEach((t4) => {
          if (f(t4))
            cur[tupleid(t4)] = -1;
        });
      }
      for (i = 0, n = add6.length; i < n; ++i) {
        t = add6[i];
        id4 = tupleid(t);
        if (cur[id4]) {
          cur[id4] = 1;
        } else {
          pulse2.add.push(ingest(add6[i]));
        }
      }
      for (i = 0, n = tuples.length; i < n; ++i) {
        t = tuples[i];
        if (cur[tupleid(t)] < 0)
          pulse2.rem.push(t);
      }
      function modify3(t4, f2, v) {
        if (v) {
          t4[f2] = v(t4);
        } else {
          pulse2.encode = f2;
        }
        if (!reflow2)
          out[tupleid(t4)] = t4;
      }
      for (i = 0, n = mod.length; i < n; ++i) {
        m2 = mod[i];
        t = m2.tuple;
        f = m2.field;
        id4 = cur[tupleid(t)];
        if (id4 > 0) {
          modify3(t, f, m2.value);
          pulse2.modifies(f);
        }
      }
      for (i = 0, n = modp.length; i < n; ++i) {
        m2 = modp[i];
        f = m2.filter;
        tuples.forEach((t4) => {
          if (f(t4) && cur[tupleid(t4)] > 0) {
            modify3(t4, m2.field, m2.value);
          }
        });
        pulse2.modifies(m2.field);
      }
      if (reflow2) {
        pulse2.mod = rem2.length || remp.length ? tuples.filter((t4) => cur[tupleid(t4)] > 0) : tuples.slice();
      } else {
        for (id4 in out)
          pulse2.mod.push(out[id4]);
      }
      if (clean || clean == null && (rem2.length || remp.length)) {
        pulse2.clean(true);
      }
      return pulse2;
    }
  };
}
var CACHE = "_:mod:_";
function Parameters() {
  Object.defineProperty(this, CACHE, {
    writable: true,
    value: {}
  });
}
Parameters.prototype = {
  set(name4, index4, value3, force) {
    const o = this, v = o[name4], mod = o[CACHE];
    if (index4 != null && index4 >= 0) {
      if (v[index4] !== value3 || force) {
        v[index4] = value3;
        mod[index4 + ":" + name4] = -1;
        mod[name4] = -1;
      }
    } else if (v !== value3 || force) {
      o[name4] = value3;
      mod[name4] = isArray(value3) ? 1 + value3.length : -1;
    }
    return o;
  },
  modified(name4, index4) {
    const mod = this[CACHE];
    if (!arguments.length) {
      for (const k in mod) {
        if (mod[k])
          return true;
      }
      return false;
    } else if (isArray(name4)) {
      for (let k = 0; k < name4.length; ++k) {
        if (mod[name4[k]])
          return true;
      }
      return false;
    }
    return index4 != null && index4 >= 0 ? index4 + 1 < mod[name4] || !!mod[index4 + ":" + name4] : !!mod[name4];
  },
  clear() {
    this[CACHE] = {};
    return this;
  }
};
var OP_ID = 0;
var PULSE = "pulse";
var NO_PARAMS = new Parameters();
var SKIP = 1;
var MODIFIED = 2;
function Operator(init2, update3, params2, react) {
  this.id = ++OP_ID;
  this.value = init2;
  this.stamp = -1;
  this.rank = -1;
  this.qrank = -1;
  this.flags = 0;
  if (update3) {
    this._update = update3;
  }
  if (params2)
    this.parameters(params2, react);
}
function flag(bit) {
  return function(state) {
    const f = this.flags;
    if (arguments.length === 0)
      return !!(f & bit);
    this.flags = state ? f | bit : f & ~bit;
    return this;
  };
}
Operator.prototype = {
  targets() {
    return this._targets || (this._targets = UniqueList(id));
  },
  set(value3) {
    if (this.value !== value3) {
      this.value = value3;
      return 1;
    } else {
      return 0;
    }
  },
  skip: flag(SKIP),
  modified: flag(MODIFIED),
  parameters(params2, react, initonly) {
    react = react !== false;
    const argval = this._argval = this._argval || new Parameters(), argops = this._argops = this._argops || [], deps = [];
    let name4, value3, n, i;
    const add6 = (name5, index4, value4) => {
      if (value4 instanceof Operator) {
        if (value4 !== this) {
          if (react)
            value4.targets().add(this);
          deps.push(value4);
        }
        argops.push({
          op: value4,
          name: name5,
          index: index4
        });
      } else {
        argval.set(name5, index4, value4);
      }
    };
    for (name4 in params2) {
      value3 = params2[name4];
      if (name4 === PULSE) {
        array(value3).forEach((op) => {
          if (!(op instanceof Operator)) {
            error("Pulse parameters must be operator instances.");
          } else if (op !== this) {
            op.targets().add(this);
            deps.push(op);
          }
        });
        this.source = value3;
      } else if (isArray(value3)) {
        argval.set(name4, -1, Array(n = value3.length));
        for (i = 0; i < n; ++i)
          add6(name4, i, value3[i]);
      } else {
        add6(name4, -1, value3);
      }
    }
    this.marshall().clear();
    if (initonly)
      argops.initonly = true;
    return deps;
  },
  marshall(stamp) {
    const argval = this._argval || NO_PARAMS, argops = this._argops;
    let item, i, op, mod;
    if (argops) {
      const n = argops.length;
      for (i = 0; i < n; ++i) {
        item = argops[i];
        op = item.op;
        mod = op.modified() && op.stamp === stamp;
        argval.set(item.name, item.index, op.value, mod);
      }
      if (argops.initonly) {
        for (i = 0; i < n; ++i) {
          item = argops[i];
          item.op.targets().remove(this);
        }
        this._argops = null;
        this._update = null;
      }
    }
    return argval;
  },
  detach() {
    const argops = this._argops;
    let i, n, item, op;
    if (argops) {
      for (i = 0, n = argops.length; i < n; ++i) {
        item = argops[i];
        op = item.op;
        if (op._targets) {
          op._targets.remove(this);
        }
      }
    }
  },
  evaluate(pulse2) {
    const update3 = this._update;
    if (update3) {
      const params2 = this.marshall(pulse2.stamp), v = update3.call(this, params2, pulse2);
      params2.clear();
      if (v !== this.value) {
        this.value = v;
      } else if (!this.modified()) {
        return pulse2.StopPropagation;
      }
    }
  },
  run(pulse2) {
    if (pulse2.stamp < this.stamp)
      return pulse2.StopPropagation;
    let rv;
    if (this.skip()) {
      this.skip(false);
      rv = 0;
    } else {
      rv = this.evaluate(pulse2);
    }
    return this.pulse = rv || pulse2;
  }
};
function add(init2, update3, params2, react) {
  let shift = 1, op;
  if (init2 instanceof Operator) {
    op = init2;
  } else if (init2 && init2.prototype instanceof Operator) {
    op = new init2();
  } else if (isFunction(init2)) {
    op = new Operator(null, init2);
  } else {
    shift = 0;
    op = new Operator(init2, update3);
  }
  this.rank(op);
  if (shift) {
    react = params2;
    params2 = update3;
  }
  if (params2)
    this.connect(op, op.parameters(params2, react));
  this.touch(op);
  return op;
}
function connect(target, sources) {
  const targetRank = target.rank, n = sources.length;
  for (let i = 0; i < n; ++i) {
    if (targetRank < sources[i].rank) {
      this.rerank(target);
      return;
    }
  }
}
var STREAM_ID = 0;
function EventStream(filter4, apply2, receive) {
  this.id = ++STREAM_ID;
  this.value = null;
  if (receive)
    this.receive = receive;
  if (filter4)
    this._filter = filter4;
  if (apply2)
    this._apply = apply2;
}
function stream(filter4, apply2, receive) {
  return new EventStream(filter4, apply2, receive);
}
EventStream.prototype = {
  _filter: truthy,
  _apply: identity,
  targets() {
    return this._targets || (this._targets = UniqueList(id));
  },
  consume(_) {
    if (!arguments.length)
      return !!this._consume;
    this._consume = !!_;
    return this;
  },
  receive(evt) {
    if (this._filter(evt)) {
      const val = this.value = this._apply(evt), trg = this._targets, n = trg ? trg.length : 0;
      for (let i = 0; i < n; ++i)
        trg[i].receive(val);
      if (this._consume) {
        evt.preventDefault();
        evt.stopPropagation();
      }
    }
  },
  filter(filter4) {
    const s = stream(filter4);
    this.targets().add(s);
    return s;
  },
  apply(apply2) {
    const s = stream(null, apply2);
    this.targets().add(s);
    return s;
  },
  merge() {
    const s = stream();
    this.targets().add(s);
    for (let i = 0, n = arguments.length; i < n; ++i) {
      arguments[i].targets().add(s);
    }
    return s;
  },
  throttle(pause) {
    let t = -1;
    return this.filter(() => {
      const now2 = Date.now();
      if (now2 - t > pause) {
        t = now2;
        return 1;
      } else {
        return 0;
      }
    });
  },
  debounce(delay) {
    const s = stream();
    this.targets().add(stream(null, null, debounce(delay, (e) => {
      const df = e.dataflow;
      s.receive(e);
      if (df && df.run)
        df.run();
    })));
    return s;
  },
  between(a2, b2) {
    let active = false;
    a2.targets().add(stream(null, null, () => active = true));
    b2.targets().add(stream(null, null, () => active = false));
    return this.filter(() => active);
  },
  detach() {
  }
};
function events(source4, type2, filter4, apply2) {
  const df = this, s = stream(filter4, apply2), send = function(e) {
    e.dataflow = df;
    try {
      s.receive(e);
    } catch (error3) {
      df.error(error3);
    } finally {
      df.run();
    }
  };
  let sources;
  if (typeof source4 === "string" && typeof document !== "undefined") {
    sources = document.querySelectorAll(source4);
  } else {
    sources = array(source4);
  }
  const n = sources.length;
  for (let i = 0; i < n; ++i) {
    sources[i].addEventListener(type2, send);
  }
  return s;
}
function parse2(data4, format8) {
  const locale6 = this.locale();
  return read_default(data4, format8, locale6.timeParse, locale6.utcParse);
}
function ingest$1(target, data4, format8) {
  data4 = this.parse(data4, format8);
  return this.pulse(target, this.changeset().insert(data4));
}
async function request(url, format8) {
  const df = this;
  let status = 0, data4;
  try {
    data4 = await df.loader().load(url, {
      context: "dataflow",
      response: responseType(format8 && format8.type)
    });
    try {
      data4 = df.parse(data4, format8);
    } catch (err) {
      status = -2;
      df.warn("Data ingestion failed", url, err);
    }
  } catch (err) {
    status = -1;
    df.warn("Loading failed", url, err);
  }
  return {
    data: data4,
    status
  };
}
async function preload(target, url, format8) {
  const df = this, pending = df._pending || loadPending(df);
  pending.requests += 1;
  const res = await df.request(url, format8);
  df.pulse(target, df.changeset().remove(truthy).insert(res.data || []));
  pending.done();
  return res;
}
function loadPending(df) {
  let accept;
  const pending = new Promise((a2) => accept = a2);
  pending.requests = 0;
  pending.done = () => {
    if (--pending.requests === 0) {
      df._pending = null;
      accept(df);
    }
  };
  return df._pending = pending;
}
var SKIP$1 = {
  skip: true
};
function on(source4, target, update3, params2, options2) {
  const fn = source4 instanceof Operator ? onOperator : onStream;
  fn(this, source4, target, update3, params2, options2);
  return this;
}
function onStream(df, stream2, target, update3, params2, options2) {
  const opt = extend({}, options2, SKIP$1);
  let func, op;
  if (!isFunction(target))
    target = constant(target);
  if (update3 === void 0) {
    func = (e) => df.touch(target(e));
  } else if (isFunction(update3)) {
    op = new Operator(null, update3, params2, false);
    func = (e) => {
      op.evaluate(e);
      const t = target(e), v = op.value;
      isChangeSet(v) ? df.pulse(t, v, options2) : df.update(t, v, opt);
    };
  } else {
    func = (e) => df.update(target(e), update3, opt);
  }
  stream2.apply(func);
}
function onOperator(df, source4, target, update3, params2, options2) {
  if (update3 === void 0) {
    source4.targets().add(target);
  } else {
    const opt = options2 || {}, op = new Operator(null, updater(target, update3), params2, false);
    op.modified(opt.force);
    op.rank = source4.rank;
    source4.targets().add(op);
    if (target) {
      op.skip(true);
      op.value = target.value;
      op.targets().add(target);
      df.connect(target, [op]);
    }
  }
}
function updater(target, update3) {
  update3 = isFunction(update3) ? update3 : constant(update3);
  return target ? function(_, pulse2) {
    const value3 = update3(_, pulse2);
    if (!target.skip()) {
      target.skip(value3 !== this.value).value = value3;
    }
    return value3;
  } : update3;
}
function rank(op) {
  op.rank = ++this._rank;
}
function rerank(op) {
  const queue = [op];
  let cur, list, i;
  while (queue.length) {
    this.rank(cur = queue.pop());
    if (list = cur._targets) {
      for (i = list.length; --i >= 0; ) {
        queue.push(cur = list[i]);
        if (cur === op)
          error("Cycle detected in dataflow graph.");
      }
    }
  }
}
var StopPropagation = {};
var ADD = 1 << 0;
var REM = 1 << 1;
var MOD = 1 << 2;
var ADD_REM = ADD | REM;
var ADD_MOD = ADD | MOD;
var ALL = ADD | REM | MOD;
var REFLOW = 1 << 3;
var SOURCE = 1 << 4;
var NO_SOURCE = 1 << 5;
var NO_FIELDS = 1 << 6;
function Pulse(dataflow, stamp, encode15) {
  this.dataflow = dataflow;
  this.stamp = stamp == null ? -1 : stamp;
  this.add = [];
  this.rem = [];
  this.mod = [];
  this.fields = null;
  this.encode = encode15 || null;
}
function materialize(data4, filter4) {
  const out = [];
  visitArray(data4, filter4, (_) => out.push(_));
  return out;
}
function filter(pulse2, flags) {
  const map4 = {};
  pulse2.visit(flags, (t) => {
    map4[tupleid(t)] = 1;
  });
  return (t) => map4[tupleid(t)] ? null : t;
}
function addFilter(a2, b2) {
  return a2 ? (t, i) => a2(t, i) && b2(t, i) : b2;
}
Pulse.prototype = {
  StopPropagation,
  ADD,
  REM,
  MOD,
  ADD_REM,
  ADD_MOD,
  ALL,
  REFLOW,
  SOURCE,
  NO_SOURCE,
  NO_FIELDS,
  fork(flags) {
    return new Pulse(this.dataflow).init(this, flags);
  },
  clone() {
    const p = this.fork(ALL);
    p.add = p.add.slice();
    p.rem = p.rem.slice();
    p.mod = p.mod.slice();
    if (p.source)
      p.source = p.source.slice();
    return p.materialize(ALL | SOURCE);
  },
  addAll() {
    let p = this;
    const reuse = !p.source || p.add === p.rem || !p.rem.length && p.source.length === p.add.length;
    if (reuse) {
      return p;
    } else {
      p = new Pulse(this.dataflow).init(this);
      p.add = p.source;
      p.rem = [];
      return p;
    }
  },
  init(src, flags) {
    const p = this;
    p.stamp = src.stamp;
    p.encode = src.encode;
    if (src.fields && !(flags & NO_FIELDS)) {
      p.fields = src.fields;
    }
    if (flags & ADD) {
      p.addF = src.addF;
      p.add = src.add;
    } else {
      p.addF = null;
      p.add = [];
    }
    if (flags & REM) {
      p.remF = src.remF;
      p.rem = src.rem;
    } else {
      p.remF = null;
      p.rem = [];
    }
    if (flags & MOD) {
      p.modF = src.modF;
      p.mod = src.mod;
    } else {
      p.modF = null;
      p.mod = [];
    }
    if (flags & NO_SOURCE) {
      p.srcF = null;
      p.source = null;
    } else {
      p.srcF = src.srcF;
      p.source = src.source;
      if (src.cleans)
        p.cleans = src.cleans;
    }
    return p;
  },
  runAfter(func) {
    this.dataflow.runAfter(func);
  },
  changed(flags) {
    const f = flags || ALL;
    return f & ADD && this.add.length || f & REM && this.rem.length || f & MOD && this.mod.length;
  },
  reflow(fork) {
    if (fork)
      return this.fork(ALL).reflow();
    const len = this.add.length, src = this.source && this.source.length;
    if (src && src !== len) {
      this.mod = this.source;
      if (len)
        this.filter(MOD, filter(this, ADD));
    }
    return this;
  },
  clean(value3) {
    if (arguments.length) {
      this.cleans = !!value3;
      return this;
    } else {
      return this.cleans;
    }
  },
  modifies(_) {
    const hash2 = this.fields || (this.fields = {});
    if (isArray(_)) {
      _.forEach((f) => hash2[f] = true);
    } else {
      hash2[_] = true;
    }
    return this;
  },
  modified(_, nomod) {
    const fields = this.fields;
    return !((nomod || this.mod.length) && fields) ? false : !arguments.length ? !!fields : isArray(_) ? _.some((f) => fields[f]) : fields[_];
  },
  filter(flags, filter4) {
    const p = this;
    if (flags & ADD)
      p.addF = addFilter(p.addF, filter4);
    if (flags & REM)
      p.remF = addFilter(p.remF, filter4);
    if (flags & MOD)
      p.modF = addFilter(p.modF, filter4);
    if (flags & SOURCE)
      p.srcF = addFilter(p.srcF, filter4);
    return p;
  },
  materialize(flags) {
    flags = flags || ALL;
    const p = this;
    if (flags & ADD && p.addF) {
      p.add = materialize(p.add, p.addF);
      p.addF = null;
    }
    if (flags & REM && p.remF) {
      p.rem = materialize(p.rem, p.remF);
      p.remF = null;
    }
    if (flags & MOD && p.modF) {
      p.mod = materialize(p.mod, p.modF);
      p.modF = null;
    }
    if (flags & SOURCE && p.srcF) {
      p.source = p.source.filter(p.srcF);
      p.srcF = null;
    }
    return p;
  },
  visit(flags, visitor) {
    const p = this, v = visitor;
    if (flags & SOURCE) {
      visitArray(p.source, p.srcF, v);
      return p;
    }
    if (flags & ADD)
      visitArray(p.add, p.addF, v);
    if (flags & REM)
      visitArray(p.rem, p.remF, v);
    if (flags & MOD)
      visitArray(p.mod, p.modF, v);
    const src = p.source;
    if (flags & REFLOW && src) {
      const sum2 = p.add.length + p.mod.length;
      if (sum2 === src.length)
        ;
      else if (sum2) {
        visitArray(src, filter(p, ADD_MOD), v);
      } else {
        visitArray(src, p.srcF, v);
      }
    }
    return p;
  }
};
function MultiPulse(dataflow, stamp, pulses, encode15) {
  const p = this, n = pulses.length;
  let c2 = 0;
  this.dataflow = dataflow;
  this.stamp = stamp;
  this.fields = null;
  this.encode = encode15 || null;
  this.pulses = pulses;
  for (let i = 0; i < n; ++i) {
    const pulse2 = pulses[i];
    if (pulse2.stamp !== stamp)
      continue;
    if (pulse2.fields) {
      const hash2 = p.fields || (p.fields = {});
      for (const f in pulse2.fields) {
        hash2[f] = 1;
      }
    }
    if (pulse2.changed(p.ADD))
      c2 |= p.ADD;
    if (pulse2.changed(p.REM))
      c2 |= p.REM;
    if (pulse2.changed(p.MOD))
      c2 |= p.MOD;
  }
  this.changes = c2;
}
inherits(MultiPulse, Pulse, {
  fork(flags) {
    const p = new Pulse(this.dataflow).init(this, flags & this.NO_FIELDS);
    if (flags !== void 0) {
      if (flags & p.ADD)
        this.visit(p.ADD, (t) => p.add.push(t));
      if (flags & p.REM)
        this.visit(p.REM, (t) => p.rem.push(t));
      if (flags & p.MOD)
        this.visit(p.MOD, (t) => p.mod.push(t));
    }
    return p;
  },
  changed(flags) {
    return this.changes & flags;
  },
  modified(_) {
    const p = this, fields = p.fields;
    return !(fields && p.changes & p.MOD) ? 0 : isArray(_) ? _.some((f) => fields[f]) : fields[_];
  },
  filter() {
    error("MultiPulse does not support filtering.");
  },
  materialize() {
    error("MultiPulse does not support materialization.");
  },
  visit(flags, visitor) {
    const p = this, pulses = p.pulses, n = pulses.length;
    let i = 0;
    if (flags & p.SOURCE) {
      for (; i < n; ++i) {
        pulses[i].visit(flags, visitor);
      }
    } else {
      for (; i < n; ++i) {
        if (pulses[i].stamp === p.stamp) {
          pulses[i].visit(flags, visitor);
        }
      }
    }
    return p;
  }
});
async function evaluate(encode15, prerun, postrun) {
  const df = this, async = [];
  if (df._pulse)
    return reentrant(df);
  if (df._pending)
    await df._pending;
  if (prerun)
    await asyncCallback(df, prerun);
  if (!df._touched.length) {
    df.debug("Dataflow invoked, but nothing to do.");
    return df;
  }
  const stamp = ++df._clock;
  df._pulse = new Pulse(df, stamp, encode15);
  df._touched.forEach((op2) => df._enqueue(op2, true));
  df._touched = UniqueList(id);
  let count2 = 0, op, next, error3;
  try {
    while (df._heap.size() > 0) {
      op = df._heap.pop();
      if (op.rank !== op.qrank) {
        df._enqueue(op, true);
        continue;
      }
      next = op.run(df._getPulse(op, encode15));
      if (next.then) {
        next = await next;
      } else if (next.async) {
        async.push(next.async);
        next = StopPropagation;
      }
      if (next !== StopPropagation) {
        if (op._targets)
          op._targets.forEach((op2) => df._enqueue(op2));
      }
      ++count2;
    }
  } catch (err) {
    df._heap.clear();
    error3 = err;
  }
  df._input = {};
  df._pulse = null;
  df.debug("Pulse ".concat(stamp, ": ").concat(count2, " operators"));
  if (error3) {
    df._postrun = [];
    df.error(error3);
  }
  if (df._postrun.length) {
    const pr = df._postrun.sort((a2, b2) => b2.priority - a2.priority);
    df._postrun = [];
    for (let i = 0; i < pr.length; ++i) {
      await asyncCallback(df, pr[i].callback);
    }
  }
  if (postrun)
    await asyncCallback(df, postrun);
  if (async.length) {
    Promise.all(async).then((cb) => df.runAsync(null, () => {
      cb.forEach((f) => {
        try {
          f(df);
        } catch (err) {
          df.error(err);
        }
      });
    }));
  }
  return df;
}
async function runAsync(encode15, prerun, postrun) {
  while (this._running)
    await this._running;
  const clear2 = () => this._running = null;
  (this._running = this.evaluate(encode15, prerun, postrun)).then(clear2, clear2);
  return this._running;
}
function run(encode15, prerun, postrun) {
  return this._pulse ? reentrant(this) : (this.evaluate(encode15, prerun, postrun), this);
}
function runAfter(callback, enqueue2, priority) {
  if (this._pulse || enqueue2) {
    this._postrun.push({
      priority: priority || 0,
      callback
    });
  } else {
    try {
      callback(this);
    } catch (err) {
      this.error(err);
    }
  }
}
function reentrant(df) {
  df.error("Dataflow already running. Use runAsync() to chain invocations.");
  return df;
}
function enqueue(op, force) {
  const q = op.stamp < this._clock;
  if (q)
    op.stamp = this._clock;
  if (q || force) {
    op.qrank = op.rank;
    this._heap.push(op);
  }
}
function getPulse(op, encode15) {
  const s = op.source, stamp = this._clock;
  return s && isArray(s) ? new MultiPulse(this, stamp, s.map((_) => _.pulse), encode15) : this._input[op.id] || singlePulse(this._pulse, s && s.pulse);
}
function singlePulse(p, s) {
  if (s && s.stamp === p.stamp) {
    return s;
  }
  p = p.fork();
  if (s && s !== StopPropagation) {
    p.source = s.source;
  }
  return p;
}
var NO_OPT = {
  skip: false,
  force: false
};
function touch(op, options2) {
  const opt = options2 || NO_OPT;
  if (this._pulse) {
    this._enqueue(op);
  } else {
    this._touched.add(op);
  }
  if (opt.skip)
    op.skip(true);
  return this;
}
function update(op, value3, options2) {
  const opt = options2 || NO_OPT;
  if (op.set(value3) || opt.force) {
    this.touch(op, opt);
  }
  return this;
}
function pulse(op, changeset2, options2) {
  this.touch(op, options2 || NO_OPT);
  const p = new Pulse(this, this._clock + (this._pulse ? 0 : 1)), t = op.pulse && op.pulse.source || [];
  p.target = op;
  this._input[op.id] = changeset2.pulse(p, t);
  return this;
}
function Heap(cmp) {
  let nodes = [];
  return {
    clear: () => nodes = [],
    size: () => nodes.length,
    peek: () => nodes[0],
    push: (x5) => {
      nodes.push(x5);
      return siftdown(nodes, 0, nodes.length - 1, cmp);
    },
    pop: () => {
      const last = nodes.pop();
      let item;
      if (nodes.length) {
        item = nodes[0];
        nodes[0] = last;
        siftup(nodes, 0, cmp);
      } else {
        item = last;
      }
      return item;
    }
  };
}
function siftdown(array5, start, idx, cmp) {
  let parent, pidx;
  const item = array5[idx];
  while (idx > start) {
    pidx = idx - 1 >> 1;
    parent = array5[pidx];
    if (cmp(item, parent) < 0) {
      array5[idx] = parent;
      idx = pidx;
      continue;
    }
    break;
  }
  return array5[idx] = item;
}
function siftup(array5, idx, cmp) {
  const start = idx, end = array5.length, item = array5[idx];
  let cidx = (idx << 1) + 1, ridx;
  while (cidx < end) {
    ridx = cidx + 1;
    if (ridx < end && cmp(array5[cidx], array5[ridx]) >= 0) {
      cidx = ridx;
    }
    array5[idx] = array5[cidx];
    idx = cidx;
    cidx = (idx << 1) + 1;
  }
  array5[idx] = item;
  return siftdown(array5, start, idx, cmp);
}
function Dataflow() {
  this.logger(logger());
  this.logLevel(Error$1);
  this._clock = 0;
  this._rank = 0;
  this._locale = defaultLocale3();
  try {
    this._loader = loader();
  } catch (e) {
  }
  this._touched = UniqueList(id);
  this._input = {};
  this._pulse = null;
  this._heap = Heap((a2, b2) => a2.qrank - b2.qrank);
  this._postrun = [];
}
function logMethod(method2) {
  return function() {
    return this._log[method2].apply(this, arguments);
  };
}
Dataflow.prototype = {
  stamp() {
    return this._clock;
  },
  loader(_) {
    if (arguments.length) {
      this._loader = _;
      return this;
    } else {
      return this._loader;
    }
  },
  locale(_) {
    if (arguments.length) {
      this._locale = _;
      return this;
    } else {
      return this._locale;
    }
  },
  logger(logger2) {
    if (arguments.length) {
      this._log = logger2;
      return this;
    } else {
      return this._log;
    }
  },
  error: logMethod("error"),
  warn: logMethod("warn"),
  info: logMethod("info"),
  debug: logMethod("debug"),
  logLevel: logMethod("level"),
  cleanThreshold: 1e4,
  add,
  connect,
  rank,
  rerank,
  pulse,
  touch,
  update,
  changeset,
  ingest: ingest$1,
  parse: parse2,
  preload,
  request,
  events,
  on,
  evaluate,
  run,
  runAsync,
  runAfter,
  _enqueue: enqueue,
  _getPulse: getPulse
};
function Transform(init2, params2) {
  Operator.call(this, init2, null, params2);
}
inherits(Transform, Operator, {
  run(pulse2) {
    if (pulse2.stamp < this.stamp)
      return pulse2.StopPropagation;
    let rv;
    if (this.skip()) {
      this.skip(false);
    } else {
      rv = this.evaluate(pulse2);
    }
    rv = rv || pulse2;
    if (rv.then) {
      rv = rv.then((_) => this.pulse = _);
    } else if (rv !== pulse2.StopPropagation) {
      this.pulse = rv;
    }
    return rv;
  },
  evaluate(pulse2) {
    const params2 = this.marshall(pulse2.stamp), out = this.transform(params2, pulse2);
    params2.clear();
    return out;
  },
  transform() {
  }
});
var transforms = {};
function definition(type2) {
  const t = transform(type2);
  return t && t.Definition || null;
}
function transform(type2) {
  type2 = type2 && type2.toLowerCase();
  return has(transforms, type2) ? transforms[type2] : null;
}

// node_modules/vega-transforms/build/vega-transforms.module.js
var vega_transforms_module_exports = {};
__export(vega_transforms_module_exports, {
  aggregate: () => Aggregate,
  bin: () => Bin,
  collect: () => Collect,
  compare: () => Compare,
  countpattern: () => CountPattern,
  cross: () => Cross,
  density: () => Density,
  dotbin: () => DotBin,
  expression: () => Expression,
  extent: () => Extent,
  facet: () => Facet,
  field: () => Field,
  filter: () => Filter,
  flatten: () => Flatten,
  fold: () => Fold,
  formula: () => Formula,
  generate: () => Generate,
  impute: () => Impute,
  joinaggregate: () => JoinAggregate,
  kde: () => KDE,
  key: () => Key,
  load: () => Load,
  lookup: () => Lookup,
  multiextent: () => MultiExtent,
  multivalues: () => MultiValues,
  params: () => Params,
  pivot: () => Pivot,
  prefacet: () => PreFacet,
  project: () => Project,
  proxy: () => Proxy,
  quantile: () => Quantile,
  relay: () => Relay,
  sample: () => Sample,
  sequence: () => Sequence,
  sieve: () => Sieve,
  subflow: () => Subflow,
  timeunit: () => TimeUnit,
  tupleindex: () => TupleIndex,
  values: () => Values,
  window: () => Window
});

// node_modules/vega-statistics/build/vega-statistics.module.js
function* numbers2(values4, valueof) {
  if (valueof == null) {
    for (let value3 of values4) {
      if (value3 != null && value3 !== "" && (value3 = +value3) >= value3) {
        yield value3;
      }
    }
  } else {
    let index4 = -1;
    for (let value3 of values4) {
      value3 = valueof(value3, ++index4, values4);
      if (value3 != null && value3 !== "" && (value3 = +value3) >= value3) {
        yield value3;
      }
    }
  }
}
function quantiles(array5, p, f) {
  const values4 = Float64Array.from(numbers2(array5, f));
  values4.sort(ascending_default);
  return p.map((_) => quantileSorted(values4, _));
}
function quartiles(array5, f) {
  return quantiles(array5, [0.25, 0.5, 0.75], f);
}
function estimateBandwidth(array5, f) {
  const n = array5.length, d = deviation(array5, f), q = quartiles(array5, f), h3 = (q[2] - q[0]) / 1.34, v = Math.min(d, h3) || d || Math.abs(q[0]) || 1;
  return 1.06 * v * Math.pow(n, -0.2);
}
function bin2(_) {
  const maxb = _.maxbins || 20, base2 = _.base || 10, logb = Math.log(base2), div = _.divide || [5, 2];
  let min4 = _.extent[0], max4 = _.extent[1], step, level, minstep, v, i, n;
  const span2 = _.span || max4 - min4 || Math.abs(min4) || 1;
  if (_.step) {
    step = _.step;
  } else if (_.steps) {
    v = span2 / maxb;
    for (i = 0, n = _.steps.length; i < n && _.steps[i] < v; ++i)
      ;
    step = _.steps[Math.max(0, i - 1)];
  } else {
    level = Math.ceil(Math.log(maxb) / logb);
    minstep = _.minstep || 0;
    step = Math.max(minstep, Math.pow(base2, Math.round(Math.log(span2) / logb) - level));
    while (Math.ceil(span2 / step) > maxb) {
      step *= base2;
    }
    for (i = 0, n = div.length; i < n; ++i) {
      v = step / div[i];
      if (v >= minstep && span2 / v <= maxb)
        step = v;
    }
  }
  v = Math.log(step);
  const precision = v >= 0 ? 0 : ~~(-v / logb) + 1, eps = Math.pow(base2, -precision - 1);
  if (_.nice || _.nice === void 0) {
    v = Math.floor(min4 / step + eps) * step;
    min4 = min4 < v ? v - step : v;
    max4 = Math.ceil(max4 / step) * step;
  }
  return {
    start: min4,
    stop: max4 === min4 ? min4 + step : max4,
    step
  };
}
var random = Math.random;
function setRandom(r2) {
  random = r2;
}
function bootstrapCI(array5, samples, alpha, f) {
  if (!array5.length)
    return [void 0, void 0];
  const values4 = Float64Array.from(numbers2(array5, f)), n = values4.length, m2 = samples;
  let a2, i, j, mu;
  for (j = 0, mu = Array(m2); j < m2; ++j) {
    for (a2 = 0, i = 0; i < n; ++i) {
      a2 += values4[~~(random() * n)];
    }
    mu[j] = a2 / n;
  }
  mu.sort(ascending_default);
  return [quantile(mu, alpha / 2), quantile(mu, 1 - alpha / 2)];
}
function dotbin(array5, step, smooth, f) {
  f = f || ((_) => _);
  const n = array5.length, v = new Float64Array(n);
  let i = 0, j = 1, a2 = f(array5[0]), b2 = a2, w3 = a2 + step, x5;
  for (; j < n; ++j) {
    x5 = f(array5[j]);
    if (x5 >= w3) {
      b2 = (a2 + b2) / 2;
      for (; i < j; ++i)
        v[i] = b2;
      w3 = x5 + step;
      a2 = x5;
    }
    b2 = x5;
  }
  b2 = (a2 + b2) / 2;
  for (; i < j; ++i)
    v[i] = b2;
  return smooth ? smoothing(v, step + step / 4) : v;
}
function smoothing(v, thresh) {
  const n = v.length;
  let a2 = 0, b2 = 1, c2, d;
  while (v[a2] === v[b2])
    ++b2;
  while (b2 < n) {
    c2 = b2 + 1;
    while (v[b2] === v[c2])
      ++c2;
    if (v[b2] - v[b2 - 1] < thresh) {
      d = b2 + (a2 + c2 - b2 - b2 >> 1);
      while (d < b2)
        v[d++] = v[b2];
      while (d > b2)
        v[d--] = v[a2];
    }
    a2 = b2;
    b2 = c2;
  }
  return v;
}
function lcg(seed) {
  return function() {
    seed = (1103515245 * seed + 12345) % 2147483647;
    return seed / 2147483647;
  };
}
function integer(min4, max4) {
  if (max4 == null) {
    max4 = min4;
    min4 = 0;
  }
  let a2, b2, d;
  const dist2 = {
    min(_) {
      if (arguments.length) {
        a2 = _ || 0;
        d = b2 - a2;
        return dist2;
      } else {
        return a2;
      }
    },
    max(_) {
      if (arguments.length) {
        b2 = _ || 0;
        d = b2 - a2;
        return dist2;
      } else {
        return b2;
      }
    },
    sample() {
      return a2 + Math.floor(d * random());
    },
    pdf(x5) {
      return x5 === Math.floor(x5) && x5 >= a2 && x5 < b2 ? 1 / d : 0;
    },
    cdf(x5) {
      const v = Math.floor(x5);
      return v < a2 ? 0 : v >= b2 ? 1 : (v - a2 + 1) / d;
    },
    icdf(p) {
      return p >= 0 && p <= 1 ? a2 - 1 + Math.floor(p * d) : NaN;
    }
  };
  return dist2.min(min4).max(max4);
}
var SQRT2PI = Math.sqrt(2 * Math.PI);
var SQRT2 = Math.SQRT2;
var nextSample = NaN;
function sampleNormal(mean2, stdev) {
  mean2 = mean2 || 0;
  stdev = stdev == null ? 1 : stdev;
  let x5 = 0, y5 = 0, rds, c2;
  if (nextSample === nextSample) {
    x5 = nextSample;
    nextSample = NaN;
  } else {
    do {
      x5 = random() * 2 - 1;
      y5 = random() * 2 - 1;
      rds = x5 * x5 + y5 * y5;
    } while (rds === 0 || rds > 1);
    c2 = Math.sqrt(-2 * Math.log(rds) / rds);
    x5 *= c2;
    nextSample = y5 * c2;
  }
  return mean2 + x5 * stdev;
}
function densityNormal(value3, mean2, stdev) {
  stdev = stdev == null ? 1 : stdev;
  const z = (value3 - (mean2 || 0)) / stdev;
  return Math.exp(-0.5 * z * z) / (stdev * SQRT2PI);
}
function cumulativeNormal(value3, mean2, stdev) {
  mean2 = mean2 || 0;
  stdev = stdev == null ? 1 : stdev;
  const z = (value3 - mean2) / stdev, Z = Math.abs(z);
  let cd;
  if (Z > 37) {
    cd = 0;
  } else {
    const exp4 = Math.exp(-Z * Z / 2);
    let sum2;
    if (Z < 7.07106781186547) {
      sum2 = 0.0352624965998911 * Z + 0.700383064443688;
      sum2 = sum2 * Z + 6.37396220353165;
      sum2 = sum2 * Z + 33.912866078383;
      sum2 = sum2 * Z + 112.079291497871;
      sum2 = sum2 * Z + 221.213596169931;
      sum2 = sum2 * Z + 220.206867912376;
      cd = exp4 * sum2;
      sum2 = 0.0883883476483184 * Z + 1.75566716318264;
      sum2 = sum2 * Z + 16.064177579207;
      sum2 = sum2 * Z + 86.7807322029461;
      sum2 = sum2 * Z + 296.564248779674;
      sum2 = sum2 * Z + 637.333633378831;
      sum2 = sum2 * Z + 793.826512519948;
      sum2 = sum2 * Z + 440.413735824752;
      cd = cd / sum2;
    } else {
      sum2 = Z + 0.65;
      sum2 = Z + 4 / sum2;
      sum2 = Z + 3 / sum2;
      sum2 = Z + 2 / sum2;
      sum2 = Z + 1 / sum2;
      cd = exp4 / sum2 / 2.506628274631;
    }
  }
  return z > 0 ? 1 - cd : cd;
}
function quantileNormal(p, mean2, stdev) {
  if (p < 0 || p > 1)
    return NaN;
  return (mean2 || 0) + (stdev == null ? 1 : stdev) * SQRT2 * erfinv(2 * p - 1);
}
function erfinv(x5) {
  let w3 = -Math.log((1 - x5) * (1 + x5)), p;
  if (w3 < 6.25) {
    w3 -= 3.125;
    p = -364441206401782e-35;
    p = -16850591381820166e-35 + p * w3;
    p = 128584807152564e-32 + p * w3;
    p = 11157877678025181e-33 + p * w3;
    p = -1333171662854621e-31 + p * w3;
    p = 20972767875968562e-33 + p * w3;
    p = 6637638134358324e-30 + p * w3;
    p = -4054566272975207e-29 + p * w3;
    p = -8151934197605472e-29 + p * w3;
    p = 26335093153082323e-28 + p * w3;
    p = -12975133253453532e-27 + p * w3;
    p = -5415412054294628e-26 + p * w3;
    p = 10512122733215323e-25 + p * w3;
    p = -4112633980346984e-24 + p * w3;
    p = -29070369957882005e-24 + p * w3;
    p = 42347877827932404e-23 + p * w3;
    p = -13654692000834679e-22 + p * w3;
    p = -13882523362786469e-21 + p * w3;
    p = 18673420803405714e-20 + p * w3;
    p = -740702534166267e-18 + p * w3;
    p = -0.006033670871430149 + p * w3;
    p = 0.24015818242558962 + p * w3;
    p = 1.6536545626831027 + p * w3;
  } else if (w3 < 16) {
    w3 = Math.sqrt(w3) - 3.25;
    p = 22137376921775787e-25;
    p = 9075656193888539e-23 + p * w3;
    p = -27517406297064545e-23 + p * w3;
    p = 18239629214389228e-24 + p * w3;
    p = 15027403968909828e-22 + p * w3;
    p = -4013867526981546e-21 + p * w3;
    p = 29234449089955446e-22 + p * w3;
    p = 12475304481671779e-21 + p * w3;
    p = -47318229009055734e-21 + p * w3;
    p = 6828485145957318e-20 + p * w3;
    p = 24031110387097894e-21 + p * w3;
    p = -3550375203628475e-19 + p * w3;
    p = 9532893797373805e-19 + p * w3;
    p = -0.0016882755560235047 + p * w3;
    p = 0.002491442096107851 + p * w3;
    p = -0.003751208507569241 + p * w3;
    p = 0.005370914553590064 + p * w3;
    p = 1.0052589676941592 + p * w3;
    p = 3.0838856104922208 + p * w3;
  } else if (Number.isFinite(w3)) {
    w3 = Math.sqrt(w3) - 5;
    p = -27109920616438573e-27;
    p = -2555641816996525e-25 + p * w3;
    p = 15076572693500548e-25 + p * w3;
    p = -3789465440126737e-24 + p * w3;
    p = 761570120807834e-23 + p * w3;
    p = -1496002662714924e-23 + p * w3;
    p = 2914795345090108e-23 + p * w3;
    p = -6771199775845234e-23 + p * w3;
    p = 22900482228026655e-23 + p * w3;
    p = -99298272942317e-20 + p * w3;
    p = 4526062597223154e-21 + p * w3;
    p = -1968177810553167e-20 + p * w3;
    p = 7599527703001776e-20 + p * w3;
    p = -21503011930044477e-20 + p * w3;
    p = -13871931833623122e-20 + p * w3;
    p = 1.0103004648645344 + p * w3;
    p = 4.849906401408584 + p * w3;
  } else {
    p = Infinity;
  }
  return p * x5;
}
function gaussian(mean2, stdev) {
  let mu, sigma;
  const dist2 = {
    mean(_) {
      if (arguments.length) {
        mu = _ || 0;
        return dist2;
      } else {
        return mu;
      }
    },
    stdev(_) {
      if (arguments.length) {
        sigma = _ == null ? 1 : _;
        return dist2;
      } else {
        return sigma;
      }
    },
    sample: () => sampleNormal(mu, sigma),
    pdf: (value3) => densityNormal(value3, mu, sigma),
    cdf: (value3) => cumulativeNormal(value3, mu, sigma),
    icdf: (p) => quantileNormal(p, mu, sigma)
  };
  return dist2.mean(mean2).stdev(stdev);
}
function kde(support, bandwidth3) {
  const kernel = gaussian();
  let n = 0;
  const dist2 = {
    data(_) {
      if (arguments.length) {
        support = _;
        n = _ ? _.length : 0;
        return dist2.bandwidth(bandwidth3);
      } else {
        return support;
      }
    },
    bandwidth(_) {
      if (!arguments.length)
        return bandwidth3;
      bandwidth3 = _;
      if (!bandwidth3 && support)
        bandwidth3 = estimateBandwidth(support);
      return dist2;
    },
    sample() {
      return support[~~(random() * n)] + bandwidth3 * kernel.sample();
    },
    pdf(x5) {
      let y5 = 0, i = 0;
      for (; i < n; ++i) {
        y5 += kernel.pdf((x5 - support[i]) / bandwidth3);
      }
      return y5 / bandwidth3 / n;
    },
    cdf(x5) {
      let y5 = 0, i = 0;
      for (; i < n; ++i) {
        y5 += kernel.cdf((x5 - support[i]) / bandwidth3);
      }
      return y5 / n;
    },
    icdf() {
      throw Error("KDE icdf not supported.");
    }
  };
  return dist2.data(support);
}
function sampleLogNormal(mean2, stdev) {
  mean2 = mean2 || 0;
  stdev = stdev == null ? 1 : stdev;
  return Math.exp(mean2 + sampleNormal() * stdev);
}
function densityLogNormal(value3, mean2, stdev) {
  if (value3 <= 0)
    return 0;
  mean2 = mean2 || 0;
  stdev = stdev == null ? 1 : stdev;
  const z = (Math.log(value3) - mean2) / stdev;
  return Math.exp(-0.5 * z * z) / (stdev * SQRT2PI * value3);
}
function cumulativeLogNormal(value3, mean2, stdev) {
  return cumulativeNormal(Math.log(value3), mean2, stdev);
}
function quantileLogNormal(p, mean2, stdev) {
  return Math.exp(quantileNormal(p, mean2, stdev));
}
function lognormal(mean2, stdev) {
  let mu, sigma;
  const dist2 = {
    mean(_) {
      if (arguments.length) {
        mu = _ || 0;
        return dist2;
      } else {
        return mu;
      }
    },
    stdev(_) {
      if (arguments.length) {
        sigma = _ == null ? 1 : _;
        return dist2;
      } else {
        return sigma;
      }
    },
    sample: () => sampleLogNormal(mu, sigma),
    pdf: (value3) => densityLogNormal(value3, mu, sigma),
    cdf: (value3) => cumulativeLogNormal(value3, mu, sigma),
    icdf: (p) => quantileLogNormal(p, mu, sigma)
  };
  return dist2.mean(mean2).stdev(stdev);
}
function mixture(dists, weights) {
  let m2 = 0, w3;
  function normalize3(x5) {
    const w4 = [];
    let sum2 = 0, i;
    for (i = 0; i < m2; ++i) {
      sum2 += w4[i] = x5[i] == null ? 1 : +x5[i];
    }
    for (i = 0; i < m2; ++i) {
      w4[i] /= sum2;
    }
    return w4;
  }
  const dist2 = {
    weights(_) {
      if (arguments.length) {
        w3 = normalize3(weights = _ || []);
        return dist2;
      }
      return weights;
    },
    distributions(_) {
      if (arguments.length) {
        if (_) {
          m2 = _.length;
          dists = _;
        } else {
          m2 = 0;
          dists = [];
        }
        return dist2.weights(weights);
      }
      return dists;
    },
    sample() {
      const r2 = random();
      let d = dists[m2 - 1], v = w3[0], i = 0;
      for (; i < m2 - 1; v += w3[++i]) {
        if (r2 < v) {
          d = dists[i];
          break;
        }
      }
      return d.sample();
    },
    pdf(x5) {
      let p = 0, i = 0;
      for (; i < m2; ++i) {
        p += w3[i] * dists[i].pdf(x5);
      }
      return p;
    },
    cdf(x5) {
      let p = 0, i = 0;
      for (; i < m2; ++i) {
        p += w3[i] * dists[i].cdf(x5);
      }
      return p;
    },
    icdf() {
      throw Error("Mixture icdf not supported.");
    }
  };
  return dist2.distributions(dists).weights(weights);
}
function sampleUniform(min4, max4) {
  if (max4 == null) {
    max4 = min4 == null ? 1 : min4;
    min4 = 0;
  }
  return min4 + (max4 - min4) * random();
}
function densityUniform(value3, min4, max4) {
  if (max4 == null) {
    max4 = min4 == null ? 1 : min4;
    min4 = 0;
  }
  return value3 >= min4 && value3 <= max4 ? 1 / (max4 - min4) : 0;
}
function cumulativeUniform(value3, min4, max4) {
  if (max4 == null) {
    max4 = min4 == null ? 1 : min4;
    min4 = 0;
  }
  return value3 < min4 ? 0 : value3 > max4 ? 1 : (value3 - min4) / (max4 - min4);
}
function quantileUniform(p, min4, max4) {
  if (max4 == null) {
    max4 = min4 == null ? 1 : min4;
    min4 = 0;
  }
  return p >= 0 && p <= 1 ? min4 + p * (max4 - min4) : NaN;
}
function uniform(min4, max4) {
  let a2, b2;
  const dist2 = {
    min(_) {
      if (arguments.length) {
        a2 = _ || 0;
        return dist2;
      } else {
        return a2;
      }
    },
    max(_) {
      if (arguments.length) {
        b2 = _ == null ? 1 : _;
        return dist2;
      } else {
        return b2;
      }
    },
    sample: () => sampleUniform(a2, b2),
    pdf: (value3) => densityUniform(value3, a2, b2),
    cdf: (value3) => cumulativeUniform(value3, a2, b2),
    icdf: (p) => quantileUniform(p, a2, b2)
  };
  if (max4 == null) {
    max4 = min4 == null ? 1 : min4;
    min4 = 0;
  }
  return dist2.min(min4).max(max4);
}
function ols(uX, uY, uXY, uX2) {
  const delta = uX2 - uX * uX, slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta, intercept = uY - slope * uX;
  return [intercept, slope];
}
function points(data4, x5, y5, sort2) {
  data4 = data4.filter((d2) => {
    let u = x5(d2), v = y5(d2);
    return u != null && (u = +u) >= u && v != null && (v = +v) >= v;
  });
  if (sort2) {
    data4.sort((a2, b2) => x5(a2) - x5(b2));
  }
  const n = data4.length, X4 = new Float64Array(n), Y4 = new Float64Array(n);
  let i = 0, ux = 0, uy = 0, xv, yv, d;
  for (d of data4) {
    X4[i] = xv = +x5(d);
    Y4[i] = yv = +y5(d);
    ++i;
    ux += (xv - ux) / i;
    uy += (yv - uy) / i;
  }
  for (i = 0; i < n; ++i) {
    X4[i] -= ux;
    Y4[i] -= uy;
  }
  return [X4, Y4, ux, uy];
}
function visitPoints(data4, x5, y5, callback) {
  let i = -1, u, v;
  for (const d of data4) {
    u = x5(d);
    v = y5(d);
    if (u != null && (u = +u) >= u && v != null && (v = +v) >= v) {
      callback(u, v, ++i);
    }
  }
}
function rSquared(data4, x5, y5, uY, predict) {
  let SSE = 0, SST = 0;
  visitPoints(data4, x5, y5, (dx, dy) => {
    const sse = dy - predict(dx), sst = dy - uY;
    SSE += sse * sse;
    SST += sst * sst;
  });
  return 1 - SSE / SST;
}
function linear(data4, x5, y5) {
  let X4 = 0, Y4 = 0, XY = 0, X24 = 0, n = 0;
  visitPoints(data4, x5, y5, (dx, dy) => {
    ++n;
    X4 += (dx - X4) / n;
    Y4 += (dy - Y4) / n;
    XY += (dx * dy - XY) / n;
    X24 += (dx * dx - X24) / n;
  });
  const coef = ols(X4, Y4, XY, X24), predict = (x6) => coef[0] + coef[1] * x6;
  return {
    coef,
    predict,
    rSquared: rSquared(data4, x5, y5, Y4, predict)
  };
}
function log2(data4, x5, y5) {
  let X4 = 0, Y4 = 0, XY = 0, X24 = 0, n = 0;
  visitPoints(data4, x5, y5, (dx, dy) => {
    ++n;
    dx = Math.log(dx);
    X4 += (dx - X4) / n;
    Y4 += (dy - Y4) / n;
    XY += (dx * dy - XY) / n;
    X24 += (dx * dx - X24) / n;
  });
  const coef = ols(X4, Y4, XY, X24), predict = (x6) => coef[0] + coef[1] * Math.log(x6);
  return {
    coef,
    predict,
    rSquared: rSquared(data4, x5, y5, Y4, predict)
  };
}
function exp2(data4, x5, y5) {
  const [xv, yv, ux, uy] = points(data4, x5, y5);
  let YL = 0, XY = 0, XYL = 0, X2Y = 0, n = 0, dx, ly2, xy;
  visitPoints(data4, x5, y5, (_, dy) => {
    dx = xv[n++];
    ly2 = Math.log(dy);
    xy = dx * dy;
    YL += (dy * ly2 - YL) / n;
    XY += (xy - XY) / n;
    XYL += (xy * ly2 - XYL) / n;
    X2Y += (dx * xy - X2Y) / n;
  });
  const [c0, c1] = ols(XY / uy, YL / uy, XYL / uy, X2Y / uy), predict = (x6) => Math.exp(c0 + c1 * (x6 - ux));
  return {
    coef: [Math.exp(c0 - c1 * ux), c1],
    predict,
    rSquared: rSquared(data4, x5, y5, uy, predict)
  };
}
function pow2(data4, x5, y5) {
  let X4 = 0, Y4 = 0, XY = 0, X24 = 0, YS = 0, n = 0;
  visitPoints(data4, x5, y5, (dx, dy) => {
    const lx2 = Math.log(dx), ly2 = Math.log(dy);
    ++n;
    X4 += (lx2 - X4) / n;
    Y4 += (ly2 - Y4) / n;
    XY += (lx2 * ly2 - XY) / n;
    X24 += (lx2 * lx2 - X24) / n;
    YS += (dy - YS) / n;
  });
  const coef = ols(X4, Y4, XY, X24), predict = (x6) => coef[0] * Math.pow(x6, coef[1]);
  coef[0] = Math.exp(coef[0]);
  return {
    coef,
    predict,
    rSquared: rSquared(data4, x5, y5, YS, predict)
  };
}
function quad(data4, x5, y5) {
  const [xv, yv, ux, uy] = points(data4, x5, y5), n = xv.length;
  let X24 = 0, X32 = 0, X4 = 0, XY = 0, X2Y = 0, i, dx, dy, x22;
  for (i = 0; i < n; ) {
    dx = xv[i];
    dy = yv[i++];
    x22 = dx * dx;
    X24 += (x22 - X24) / i;
    X32 += (x22 * dx - X32) / i;
    X4 += (x22 * x22 - X4) / i;
    XY += (dx * dy - XY) / i;
    X2Y += (x22 * dy - X2Y) / i;
  }
  const X2X2 = X4 - X24 * X24, d = X24 * X2X2 - X32 * X32, a2 = (X2Y * X24 - XY * X32) / d, b2 = (XY * X2X2 - X2Y * X32) / d, c2 = -a2 * X24, predict = (x6) => {
    x6 = x6 - ux;
    return a2 * x6 * x6 + b2 * x6 + c2 + uy;
  };
  return {
    coef: [c2 - b2 * ux + a2 * ux * ux + uy, b2 - 2 * a2 * ux, a2],
    predict,
    rSquared: rSquared(data4, x5, y5, uy, predict)
  };
}
function poly(data4, x5, y5, order) {
  if (order === 1)
    return linear(data4, x5, y5);
  if (order === 2)
    return quad(data4, x5, y5);
  const [xv, yv, ux, uy] = points(data4, x5, y5), n = xv.length, lhs = [], rhs = [], k = order + 1;
  let i, j, l, v, c2;
  for (i = 0; i < k; ++i) {
    for (l = 0, v = 0; l < n; ++l) {
      v += Math.pow(xv[l], i) * yv[l];
    }
    lhs.push(v);
    c2 = new Float64Array(k);
    for (j = 0; j < k; ++j) {
      for (l = 0, v = 0; l < n; ++l) {
        v += Math.pow(xv[l], i + j);
      }
      c2[j] = v;
    }
    rhs.push(c2);
  }
  rhs.push(lhs);
  const coef = gaussianElimination(rhs), predict = (x6) => {
    x6 -= ux;
    let y6 = uy + coef[0] + coef[1] * x6 + coef[2] * x6 * x6;
    for (i = 3; i < k; ++i)
      y6 += coef[i] * Math.pow(x6, i);
    return y6;
  };
  return {
    coef: uncenter(k, coef, -ux, uy),
    predict,
    rSquared: rSquared(data4, x5, y5, uy, predict)
  };
}
function uncenter(k, a2, x5, y5) {
  const z = Array(k);
  let i, j, v, c2;
  for (i = 0; i < k; ++i)
    z[i] = 0;
  for (i = k - 1; i >= 0; --i) {
    v = a2[i];
    c2 = 1;
    z[i] += v;
    for (j = 1; j <= i; ++j) {
      c2 *= (i + 1 - j) / j;
      z[i - j] += v * Math.pow(x5, j) * c2;
    }
  }
  z[0] += y5;
  return z;
}
function gaussianElimination(matrix) {
  const n = matrix.length - 1, coef = [];
  let i, j, k, r2, t;
  for (i = 0; i < n; ++i) {
    r2 = i;
    for (j = i + 1; j < n; ++j) {
      if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][r2])) {
        r2 = j;
      }
    }
    for (k = i; k < n + 1; ++k) {
      t = matrix[k][i];
      matrix[k][i] = matrix[k][r2];
      matrix[k][r2] = t;
    }
    for (j = i + 1; j < n; ++j) {
      for (k = n; k >= i; k--) {
        matrix[k][j] -= matrix[k][i] * matrix[i][j] / matrix[i][i];
      }
    }
  }
  for (j = n - 1; j >= 0; --j) {
    t = 0;
    for (k = j + 1; k < n; ++k) {
      t += matrix[k][j] * coef[k];
    }
    coef[j] = (matrix[n][j] - t) / matrix[j][j];
  }
  return coef;
}
var maxiters = 2;
var epsilon = 1e-12;
function loess(data4, x5, y5, bandwidth3) {
  const [xv, yv, ux, uy] = points(data4, x5, y5, true), n = xv.length, bw = Math.max(2, ~~(bandwidth3 * n)), yhat = new Float64Array(n), residuals = new Float64Array(n), robustWeights = new Float64Array(n).fill(1);
  for (let iter = -1; ++iter <= maxiters; ) {
    const interval3 = [0, bw - 1];
    for (let i = 0; i < n; ++i) {
      const dx = xv[i], i0 = interval3[0], i1 = interval3[1], edge = dx - xv[i0] > xv[i1] - dx ? i0 : i1;
      let W = 0, X4 = 0, Y4 = 0, XY = 0, X24 = 0;
      const denom = 1 / Math.abs(xv[edge] - dx || 1);
      for (let k = i0; k <= i1; ++k) {
        const xk = xv[k], yk = yv[k], w3 = tricube(Math.abs(dx - xk) * denom) * robustWeights[k], xkw = xk * w3;
        W += w3;
        X4 += xkw;
        Y4 += yk * w3;
        XY += yk * xkw;
        X24 += xk * xkw;
      }
      const [a2, b2] = ols(X4 / W, Y4 / W, XY / W, X24 / W);
      yhat[i] = a2 + b2 * dx;
      residuals[i] = Math.abs(yv[i] - yhat[i]);
      updateInterval(xv, i + 1, interval3);
    }
    if (iter === maxiters) {
      break;
    }
    const medianResidual = median_default(residuals);
    if (Math.abs(medianResidual) < epsilon)
      break;
    for (let i = 0, arg, w3; i < n; ++i) {
      arg = residuals[i] / (6 * medianResidual);
      robustWeights[i] = arg >= 1 ? epsilon : (w3 = 1 - arg * arg) * w3;
    }
  }
  return output(xv, yhat, ux, uy);
}
function tricube(x5) {
  return (x5 = 1 - x5 * x5 * x5) * x5 * x5;
}
function updateInterval(xv, i, interval3) {
  const val = xv[i];
  let left = interval3[0], right = interval3[1] + 1;
  if (right >= xv.length)
    return;
  while (i > left && xv[right] - val <= val - xv[left]) {
    interval3[0] = ++left;
    interval3[1] = right;
    ++right;
  }
}
function output(xv, yhat, ux, uy) {
  const n = xv.length, out = [];
  let i = 0, cnt = 0, prev = [], v;
  for (; i < n; ++i) {
    v = xv[i] + ux;
    if (prev[0] === v) {
      prev[1] += (yhat[i] - prev[1]) / ++cnt;
    } else {
      cnt = 0;
      prev[1] += uy;
      prev = [v, yhat[i]];
      out.push(prev);
    }
  }
  prev[1] += uy;
  return out;
}
var MIN_RADIANS = 0.1 * Math.PI / 180;
function sampleCurve(f, extent2, minSteps, maxSteps) {
  minSteps = minSteps || 25;
  maxSteps = Math.max(minSteps, maxSteps || 200);
  const point8 = (x5) => [x5, f(x5)], minX = extent2[0], maxX = extent2[1], span2 = maxX - minX, stop2 = span2 / maxSteps, prev = [point8(minX)], next = [];
  if (minSteps === maxSteps) {
    for (let i = 1; i < maxSteps; ++i) {
      prev.push(point8(minX + i / minSteps * span2));
    }
    prev.push(point8(maxX));
    return prev;
  } else {
    next.push(point8(maxX));
    for (let i = minSteps; --i > 0; ) {
      next.push(point8(minX + i / minSteps * span2));
    }
  }
  let p02 = prev[0], p1 = next[next.length - 1];
  while (p1) {
    const pm = point8((p02[0] + p1[0]) / 2);
    if (pm[0] - p02[0] >= stop2 && angleDelta(p02, pm, p1) > MIN_RADIANS) {
      next.push(pm);
    } else {
      p02 = p1;
      prev.push(p1);
      next.pop();
    }
    p1 = next[next.length - 1];
  }
  return prev;
}
function angleDelta(p, q, r2) {
  const a0 = Math.atan2(r2[1] - p[1], r2[0] - p[0]), a1 = Math.atan2(q[1] - p[1], q[0] - p[0]);
  return Math.abs(a0 - a1);
}

// node_modules/vega-transforms/build/vega-transforms.module.js
function multikey(f) {
  return (x5) => {
    const n = f.length;
    let i = 1, k = String(f[0](x5));
    for (; i < n; ++i) {
      k += "|" + f[i](x5);
    }
    return k;
  };
}
function groupkey(fields) {
  return !fields || !fields.length ? function() {
    return "";
  } : fields.length === 1 ? fields[0] : multikey(fields);
}
function measureName(op, field4, as) {
  return as || op + (!field4 ? "" : "_" + field4);
}
var noop = () => {
};
var base_op = {
  init: noop,
  add: noop,
  rem: noop,
  idx: 0
};
var AggregateOps = {
  values: {
    init: (m2) => m2.cell.store = true,
    value: (m2) => m2.cell.data.values(),
    idx: -1
  },
  count: {
    value: (m2) => m2.cell.num
  },
  __count__: {
    value: (m2) => m2.missing + m2.valid
  },
  missing: {
    value: (m2) => m2.missing
  },
  valid: {
    value: (m2) => m2.valid
  },
  sum: {
    init: (m2) => m2.sum = 0,
    value: (m2) => m2.sum,
    add: (m2, v) => m2.sum += +v,
    rem: (m2, v) => m2.sum -= v
  },
  product: {
    init: (m2) => m2.product = 1,
    value: (m2) => m2.valid ? m2.product : void 0,
    add: (m2, v) => m2.product *= v,
    rem: (m2, v) => m2.product /= v
  },
  mean: {
    init: (m2) => m2.mean = 0,
    value: (m2) => m2.valid ? m2.mean : void 0,
    add: (m2, v) => (m2.mean_d = v - m2.mean, m2.mean += m2.mean_d / m2.valid),
    rem: (m2, v) => (m2.mean_d = v - m2.mean, m2.mean -= m2.valid ? m2.mean_d / m2.valid : m2.mean)
  },
  average: {
    value: (m2) => m2.valid ? m2.mean : void 0,
    req: ["mean"],
    idx: 1
  },
  variance: {
    init: (m2) => m2.dev = 0,
    value: (m2) => m2.valid > 1 ? m2.dev / (m2.valid - 1) : void 0,
    add: (m2, v) => m2.dev += m2.mean_d * (v - m2.mean),
    rem: (m2, v) => m2.dev -= m2.mean_d * (v - m2.mean),
    req: ["mean"],
    idx: 1
  },
  variancep: {
    value: (m2) => m2.valid > 1 ? m2.dev / m2.valid : void 0,
    req: ["variance"],
    idx: 2
  },
  stdev: {
    value: (m2) => m2.valid > 1 ? Math.sqrt(m2.dev / (m2.valid - 1)) : void 0,
    req: ["variance"],
    idx: 2
  },
  stdevp: {
    value: (m2) => m2.valid > 1 ? Math.sqrt(m2.dev / m2.valid) : void 0,
    req: ["variance"],
    idx: 2
  },
  stderr: {
    value: (m2) => m2.valid > 1 ? Math.sqrt(m2.dev / (m2.valid * (m2.valid - 1))) : void 0,
    req: ["variance"],
    idx: 2
  },
  distinct: {
    value: (m2) => m2.cell.data.distinct(m2.get),
    req: ["values"],
    idx: 3
  },
  ci0: {
    value: (m2) => m2.cell.data.ci0(m2.get),
    req: ["values"],
    idx: 3
  },
  ci1: {
    value: (m2) => m2.cell.data.ci1(m2.get),
    req: ["values"],
    idx: 3
  },
  median: {
    value: (m2) => m2.cell.data.q2(m2.get),
    req: ["values"],
    idx: 3
  },
  q1: {
    value: (m2) => m2.cell.data.q1(m2.get),
    req: ["values"],
    idx: 3
  },
  q3: {
    value: (m2) => m2.cell.data.q3(m2.get),
    req: ["values"],
    idx: 3
  },
  min: {
    init: (m2) => m2.min = void 0,
    value: (m2) => m2.min = Number.isNaN(m2.min) ? m2.cell.data.min(m2.get) : m2.min,
    add: (m2, v) => {
      if (v < m2.min || m2.min === void 0)
        m2.min = v;
    },
    rem: (m2, v) => {
      if (v <= m2.min)
        m2.min = NaN;
    },
    req: ["values"],
    idx: 4
  },
  max: {
    init: (m2) => m2.max = void 0,
    value: (m2) => m2.max = Number.isNaN(m2.max) ? m2.cell.data.max(m2.get) : m2.max,
    add: (m2, v) => {
      if (v > m2.max || m2.max === void 0)
        m2.max = v;
    },
    rem: (m2, v) => {
      if (v >= m2.max)
        m2.max = NaN;
    },
    req: ["values"],
    idx: 4
  },
  argmin: {
    init: (m2) => m2.argmin = void 0,
    value: (m2) => m2.argmin || m2.cell.data.argmin(m2.get),
    add: (m2, v, t) => {
      if (v < m2.min)
        m2.argmin = t;
    },
    rem: (m2, v) => {
      if (v <= m2.min)
        m2.argmin = void 0;
    },
    req: ["min", "values"],
    idx: 3
  },
  argmax: {
    init: (m2) => m2.argmax = void 0,
    value: (m2) => m2.argmax || m2.cell.data.argmax(m2.get),
    add: (m2, v, t) => {
      if (v > m2.max)
        m2.argmax = t;
    },
    rem: (m2, v) => {
      if (v >= m2.max)
        m2.argmax = void 0;
    },
    req: ["max", "values"],
    idx: 3
  }
};
var ValidAggregateOps = Object.keys(AggregateOps);
function measure(key2, value3) {
  return (out) => extend({
    name: key2,
    out: out || key2
  }, base_op, value3);
}
ValidAggregateOps.forEach((key2) => {
  AggregateOps[key2] = measure(key2, AggregateOps[key2]);
});
function createMeasure(op, name4) {
  return AggregateOps[op](name4);
}
function compareIndex(a2, b2) {
  return a2.idx - b2.idx;
}
function resolve(agg) {
  const map4 = {};
  agg.forEach((a2) => map4[a2.name] = a2);
  const getreqs = (a2) => {
    if (!a2.req)
      return;
    a2.req.forEach((key2) => {
      if (!map4[key2])
        getreqs(map4[key2] = AggregateOps[key2]());
    });
  };
  agg.forEach(getreqs);
  return Object.values(map4).sort(compareIndex);
}
function init() {
  this.valid = 0;
  this.missing = 0;
  this._ops.forEach((op) => op.init(this));
}
function add2(v, t) {
  if (v == null || v === "") {
    ++this.missing;
    return;
  }
  if (v !== v)
    return;
  ++this.valid;
  this._ops.forEach((op) => op.add(this, v, t));
}
function rem(v, t) {
  if (v == null || v === "") {
    --this.missing;
    return;
  }
  if (v !== v)
    return;
  --this.valid;
  this._ops.forEach((op) => op.rem(this, v, t));
}
function set(t) {
  this._out.forEach((op) => t[op.out] = op.value(this));
  return t;
}
function compileMeasures(agg, field4) {
  const get6 = field4 || identity, ops2 = resolve(agg), out = agg.slice().sort(compareIndex);
  function ctr(cell2) {
    this._ops = ops2;
    this._out = out;
    this.cell = cell2;
    this.init();
  }
  ctr.prototype.init = init;
  ctr.prototype.add = add2;
  ctr.prototype.rem = rem;
  ctr.prototype.set = set;
  ctr.prototype.get = get6;
  ctr.fields = agg.map((op) => op.out);
  return ctr;
}
function TupleStore(key2) {
  this._key = key2 ? field(key2) : tupleid;
  this.reset();
}
var prototype = TupleStore.prototype;
prototype.reset = function() {
  this._add = [];
  this._rem = [];
  this._ext = null;
  this._get = null;
  this._q = null;
};
prototype.add = function(v) {
  this._add.push(v);
};
prototype.rem = function(v) {
  this._rem.push(v);
};
prototype.values = function() {
  this._get = null;
  if (this._rem.length === 0)
    return this._add;
  const a2 = this._add, r2 = this._rem, k = this._key, n = a2.length, m2 = r2.length, x5 = Array(n - m2), map4 = {};
  let i, j, v;
  for (i = 0; i < m2; ++i) {
    map4[k(r2[i])] = 1;
  }
  for (i = 0, j = 0; i < n; ++i) {
    if (map4[k(v = a2[i])]) {
      map4[k(v)] = 0;
    } else {
      x5[j++] = v;
    }
  }
  this._rem = [];
  return this._add = x5;
};
prototype.distinct = function(get6) {
  const v = this.values(), map4 = {};
  let n = v.length, count2 = 0, s;
  while (--n >= 0) {
    s = get6(v[n]) + "";
    if (!has(map4, s)) {
      map4[s] = 1;
      ++count2;
    }
  }
  return count2;
};
prototype.extent = function(get6) {
  if (this._get !== get6 || !this._ext) {
    const v = this.values(), i = extentIndex(v, get6);
    this._ext = [v[i[0]], v[i[1]]];
    this._get = get6;
  }
  return this._ext;
};
prototype.argmin = function(get6) {
  return this.extent(get6)[0] || {};
};
prototype.argmax = function(get6) {
  return this.extent(get6)[1] || {};
};
prototype.min = function(get6) {
  const m2 = this.extent(get6)[0];
  return m2 != null ? get6(m2) : void 0;
};
prototype.max = function(get6) {
  const m2 = this.extent(get6)[1];
  return m2 != null ? get6(m2) : void 0;
};
prototype.quartile = function(get6) {
  if (this._get !== get6 || !this._q) {
    this._q = quartiles(this.values(), get6);
    this._get = get6;
  }
  return this._q;
};
prototype.q1 = function(get6) {
  return this.quartile(get6)[0];
};
prototype.q2 = function(get6) {
  return this.quartile(get6)[1];
};
prototype.q3 = function(get6) {
  return this.quartile(get6)[2];
};
prototype.ci = function(get6) {
  if (this._get !== get6 || !this._ci) {
    this._ci = bootstrapCI(this.values(), 1e3, 0.05, get6);
    this._get = get6;
  }
  return this._ci;
};
prototype.ci0 = function(get6) {
  return this.ci(get6)[0];
};
prototype.ci1 = function(get6) {
  return this.ci(get6)[1];
};
function Aggregate(params2) {
  Transform.call(this, null, params2);
  this._adds = [];
  this._mods = [];
  this._alen = 0;
  this._mlen = 0;
  this._drop = true;
  this._cross = false;
  this._dims = [];
  this._dnames = [];
  this._measures = [];
  this._countOnly = false;
  this._counts = null;
  this._prev = null;
  this._inputs = null;
  this._outputs = null;
}
Aggregate.Definition = {
  type: "Aggregate",
  metadata: {
    generates: true,
    changes: true
  },
  params: [{
    name: "groupby",
    type: "field",
    array: true
  }, {
    name: "ops",
    type: "enum",
    array: true,
    values: ValidAggregateOps
  }, {
    name: "fields",
    type: "field",
    null: true,
    array: true
  }, {
    name: "as",
    type: "string",
    null: true,
    array: true
  }, {
    name: "drop",
    type: "boolean",
    default: true
  }, {
    name: "cross",
    type: "boolean",
    default: false
  }, {
    name: "key",
    type: "field"
  }]
};
inherits(Aggregate, Transform, {
  transform(_, pulse2) {
    const aggr = this, out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), mod = _.modified();
    aggr.stamp = out.stamp;
    if (aggr.value && (mod || pulse2.modified(aggr._inputs, true))) {
      aggr._prev = aggr.value;
      aggr.value = mod ? aggr.init(_) : {};
      pulse2.visit(pulse2.SOURCE, (t) => aggr.add(t));
    } else {
      aggr.value = aggr.value || aggr.init(_);
      pulse2.visit(pulse2.REM, (t) => aggr.rem(t));
      pulse2.visit(pulse2.ADD, (t) => aggr.add(t));
    }
    out.modifies(aggr._outputs);
    aggr._drop = _.drop !== false;
    if (_.cross && aggr._dims.length > 1) {
      aggr._drop = false;
      aggr.cross();
    }
    if (pulse2.clean() && aggr._drop) {
      out.clean(true).runAfter(() => this.clean());
    }
    return aggr.changes(out);
  },
  cross() {
    const aggr = this, curr = aggr.value, dims = aggr._dnames, vals2 = dims.map(() => ({})), n = dims.length;
    function collect2(cells) {
      let key2, i, t, v;
      for (key2 in cells) {
        t = cells[key2].tuple;
        for (i = 0; i < n; ++i) {
          vals2[i][v = t[dims[i]]] = v;
        }
      }
    }
    collect2(aggr._prev);
    collect2(curr);
    function generate3(base2, tuple, index4) {
      const name4 = dims[index4], v = vals2[index4++];
      for (const k in v) {
        const key2 = base2 ? base2 + "|" + k : k;
        tuple[name4] = v[k];
        if (index4 < n)
          generate3(key2, tuple, index4);
        else if (!curr[key2])
          aggr.cell(key2, tuple);
      }
    }
    generate3("", {}, 0);
  },
  init(_) {
    const inputs = this._inputs = [], outputs = this._outputs = [], inputMap = {};
    function inputVisit(get6) {
      const fields2 = array(accessorFields(get6)), n2 = fields2.length;
      let i2 = 0, f;
      for (; i2 < n2; ++i2) {
        if (!inputMap[f = fields2[i2]]) {
          inputMap[f] = 1;
          inputs.push(f);
        }
      }
    }
    this._dims = array(_.groupby);
    this._dnames = this._dims.map((d) => {
      const dname = accessorName(d);
      inputVisit(d);
      outputs.push(dname);
      return dname;
    });
    this.cellkey = _.key ? _.key : groupkey(this._dims);
    this._countOnly = true;
    this._counts = [];
    this._measures = [];
    const fields = _.fields || [null], ops2 = _.ops || ["count"], as = _.as || [], n = fields.length, map4 = {};
    let field4, op, m2, mname, outname, i;
    if (n !== ops2.length) {
      error("Unmatched number of fields and aggregate ops.");
    }
    for (i = 0; i < n; ++i) {
      field4 = fields[i];
      op = ops2[i];
      if (field4 == null && op !== "count") {
        error("Null aggregate field specified.");
      }
      mname = accessorName(field4);
      outname = measureName(op, mname, as[i]);
      outputs.push(outname);
      if (op === "count") {
        this._counts.push(outname);
        continue;
      }
      m2 = map4[mname];
      if (!m2) {
        inputVisit(field4);
        m2 = map4[mname] = [];
        m2.field = field4;
        this._measures.push(m2);
      }
      if (op !== "count")
        this._countOnly = false;
      m2.push(createMeasure(op, outname));
    }
    this._measures = this._measures.map((m3) => compileMeasures(m3, m3.field));
    return {};
  },
  cellkey: groupkey(),
  cell(key2, t) {
    let cell2 = this.value[key2];
    if (!cell2) {
      cell2 = this.value[key2] = this.newcell(key2, t);
      this._adds[this._alen++] = cell2;
    } else if (cell2.num === 0 && this._drop && cell2.stamp < this.stamp) {
      cell2.stamp = this.stamp;
      this._adds[this._alen++] = cell2;
    } else if (cell2.stamp < this.stamp) {
      cell2.stamp = this.stamp;
      this._mods[this._mlen++] = cell2;
    }
    return cell2;
  },
  newcell(key2, t) {
    const cell2 = {
      key: key2,
      num: 0,
      agg: null,
      tuple: this.newtuple(t, this._prev && this._prev[key2]),
      stamp: this.stamp,
      store: false
    };
    if (!this._countOnly) {
      const measures = this._measures, n = measures.length;
      cell2.agg = Array(n);
      for (let i = 0; i < n; ++i) {
        cell2.agg[i] = new measures[i](cell2);
      }
    }
    if (cell2.store) {
      cell2.data = new TupleStore();
    }
    return cell2;
  },
  newtuple(t, p) {
    const names = this._dnames, dims = this._dims, n = dims.length, x5 = {};
    for (let i = 0; i < n; ++i) {
      x5[names[i]] = dims[i](t);
    }
    return p ? replace(p.tuple, x5) : ingest(x5);
  },
  clean() {
    const cells = this.value;
    for (const key2 in cells) {
      if (cells[key2].num === 0) {
        delete cells[key2];
      }
    }
  },
  add(t) {
    const key2 = this.cellkey(t), cell2 = this.cell(key2, t);
    cell2.num += 1;
    if (this._countOnly)
      return;
    if (cell2.store)
      cell2.data.add(t);
    const agg = cell2.agg;
    for (let i = 0, n = agg.length; i < n; ++i) {
      agg[i].add(agg[i].get(t), t);
    }
  },
  rem(t) {
    const key2 = this.cellkey(t), cell2 = this.cell(key2, t);
    cell2.num -= 1;
    if (this._countOnly)
      return;
    if (cell2.store)
      cell2.data.rem(t);
    const agg = cell2.agg;
    for (let i = 0, n = agg.length; i < n; ++i) {
      agg[i].rem(agg[i].get(t), t);
    }
  },
  celltuple(cell2) {
    const tuple = cell2.tuple, counts = this._counts;
    if (cell2.store) {
      cell2.data.values();
    }
    for (let i = 0, n = counts.length; i < n; ++i) {
      tuple[counts[i]] = cell2.num;
    }
    if (!this._countOnly) {
      const agg = cell2.agg;
      for (let i = 0, n = agg.length; i < n; ++i) {
        agg[i].set(tuple);
      }
    }
    return tuple;
  },
  changes(out) {
    const adds = this._adds, mods = this._mods, prev = this._prev, drop = this._drop, add6 = out.add, rem2 = out.rem, mod = out.mod;
    let cell2, key2, i, n;
    if (prev)
      for (key2 in prev) {
        cell2 = prev[key2];
        if (!drop || cell2.num)
          rem2.push(cell2.tuple);
      }
    for (i = 0, n = this._alen; i < n; ++i) {
      add6.push(this.celltuple(adds[i]));
      adds[i] = null;
    }
    for (i = 0, n = this._mlen; i < n; ++i) {
      cell2 = mods[i];
      (cell2.num === 0 && drop ? rem2 : mod).push(this.celltuple(cell2));
      mods[i] = null;
    }
    this._alen = this._mlen = 0;
    this._prev = null;
    return out;
  }
});
var EPSILON = 1e-14;
function Bin(params2) {
  Transform.call(this, null, params2);
}
Bin.Definition = {
  type: "Bin",
  metadata: {
    modifies: true
  },
  params: [{
    name: "field",
    type: "field",
    required: true
  }, {
    name: "interval",
    type: "boolean",
    default: true
  }, {
    name: "anchor",
    type: "number"
  }, {
    name: "maxbins",
    type: "number",
    default: 20
  }, {
    name: "base",
    type: "number",
    default: 10
  }, {
    name: "divide",
    type: "number",
    array: true,
    default: [5, 2]
  }, {
    name: "extent",
    type: "number",
    array: true,
    length: 2,
    required: true
  }, {
    name: "span",
    type: "number"
  }, {
    name: "step",
    type: "number"
  }, {
    name: "steps",
    type: "number",
    array: true
  }, {
    name: "minstep",
    type: "number",
    default: 0
  }, {
    name: "nice",
    type: "boolean",
    default: true
  }, {
    name: "name",
    type: "string"
  }, {
    name: "as",
    type: "string",
    array: true,
    length: 2,
    default: ["bin0", "bin1"]
  }]
};
inherits(Bin, Transform, {
  transform(_, pulse2) {
    const band2 = _.interval !== false, bins2 = this._bins(_), start = bins2.start, step = bins2.step, as = _.as || ["bin0", "bin1"], b0 = as[0], b1 = as[1];
    let flag2;
    if (_.modified()) {
      pulse2 = pulse2.reflow(true);
      flag2 = pulse2.SOURCE;
    } else {
      flag2 = pulse2.modified(accessorFields(_.field)) ? pulse2.ADD_MOD : pulse2.ADD;
    }
    pulse2.visit(flag2, band2 ? (t) => {
      const v = bins2(t);
      t[b0] = v;
      t[b1] = v == null ? null : start + step * (1 + (v - start) / step);
    } : (t) => t[b0] = bins2(t));
    return pulse2.modifies(band2 ? as : b0);
  },
  _bins(_) {
    if (this.value && !_.modified()) {
      return this.value;
    }
    const field4 = _.field, bins2 = bin2(_), step = bins2.step;
    let start = bins2.start, stop2 = start + Math.ceil((bins2.stop - start) / step) * step, a2, d;
    if ((a2 = _.anchor) != null) {
      d = a2 - (start + step * Math.floor((a2 - start) / step));
      start += d;
      stop2 += d;
    }
    const f = function(t) {
      let v = toNumber(field4(t));
      return v == null ? null : v < start ? -Infinity : v > stop2 ? Infinity : (v = Math.max(start, Math.min(v, stop2 - step)), start + step * Math.floor(EPSILON + (v - start) / step));
    };
    f.start = start;
    f.stop = bins2.stop;
    f.step = step;
    return this.value = accessor(f, accessorFields(field4), _.name || "bin_" + accessorName(field4));
  }
});
function SortedList(idFunc, source4, input) {
  const $3 = idFunc;
  let data4 = source4 || [], add6 = input || [], rem2 = {}, cnt = 0;
  return {
    add: (t) => add6.push(t),
    remove: (t) => rem2[$3(t)] = ++cnt,
    size: () => data4.length,
    data: (compare4, resort) => {
      if (cnt) {
        data4 = data4.filter((t) => !rem2[$3(t)]);
        rem2 = {};
        cnt = 0;
      }
      if (resort && compare4) {
        data4.sort(compare4);
      }
      if (add6.length) {
        data4 = compare4 ? merge(compare4, data4, add6.sort(compare4)) : data4.concat(add6);
        add6 = [];
      }
      return data4;
    }
  };
}
function Collect(params2) {
  Transform.call(this, [], params2);
}
Collect.Definition = {
  type: "Collect",
  metadata: {
    source: true
  },
  params: [{
    name: "sort",
    type: "compare"
  }]
};
inherits(Collect, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.ALL), list = SortedList(tupleid, this.value, out.materialize(out.ADD).add), sort2 = _.sort, mod = pulse2.changed() || sort2 && (_.modified("sort") || pulse2.modified(sort2.fields));
    out.visit(out.REM, list.remove);
    this.modified(mod);
    this.value = out.source = list.data(stableCompare(sort2), mod);
    if (pulse2.source && pulse2.source.root) {
      this.value.root = pulse2.source.root;
    }
    return out;
  }
});
function Compare(params2) {
  Operator.call(this, null, update2, params2);
}
inherits(Compare, Operator);
function update2(_) {
  return this.value && !_.modified() ? this.value : compare2(_.fields, _.orders);
}
function CountPattern(params2) {
  Transform.call(this, null, params2);
}
CountPattern.Definition = {
  type: "CountPattern",
  metadata: {
    generates: true,
    changes: true
  },
  params: [{
    name: "field",
    type: "field",
    required: true
  }, {
    name: "case",
    type: "enum",
    values: ["upper", "lower", "mixed"],
    default: "mixed"
  }, {
    name: "pattern",
    type: "string",
    default: '[\\w"]+'
  }, {
    name: "stopwords",
    type: "string",
    default: ""
  }, {
    name: "as",
    type: "string",
    array: true,
    length: 2,
    default: ["text", "count"]
  }]
};
function tokenize(text4, tcase, match3) {
  switch (tcase) {
    case "upper":
      text4 = text4.toUpperCase();
      break;
    case "lower":
      text4 = text4.toLowerCase();
      break;
  }
  return text4.match(match3);
}
inherits(CountPattern, Transform, {
  transform(_, pulse2) {
    const process2 = (update3) => (tuple) => {
      var tokens = tokenize(get6(tuple), _.case, match3) || [], t;
      for (var i = 0, n = tokens.length; i < n; ++i) {
        if (!stop2.test(t = tokens[i]))
          update3(t);
      }
    };
    const init2 = this._parameterCheck(_, pulse2), counts = this._counts, match3 = this._match, stop2 = this._stop, get6 = _.field, as = _.as || ["text", "count"], add6 = process2((t) => counts[t] = 1 + (counts[t] || 0)), rem2 = process2((t) => counts[t] -= 1);
    if (init2) {
      pulse2.visit(pulse2.SOURCE, add6);
    } else {
      pulse2.visit(pulse2.ADD, add6);
      pulse2.visit(pulse2.REM, rem2);
    }
    return this._finish(pulse2, as);
  },
  _parameterCheck(_, pulse2) {
    let init2 = false;
    if (_.modified("stopwords") || !this._stop) {
      this._stop = new RegExp("^" + (_.stopwords || "") + "$", "i");
      init2 = true;
    }
    if (_.modified("pattern") || !this._match) {
      this._match = new RegExp(_.pattern || "[\\w']+", "g");
      init2 = true;
    }
    if (_.modified("field") || pulse2.modified(_.field.fields)) {
      init2 = true;
    }
    if (init2)
      this._counts = {};
    return init2;
  },
  _finish(pulse2, as) {
    const counts = this._counts, tuples = this._tuples || (this._tuples = {}), text4 = as[0], count2 = as[1], out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    let w3, t, c2;
    for (w3 in counts) {
      t = tuples[w3];
      c2 = counts[w3] || 0;
      if (!t && c2) {
        tuples[w3] = t = ingest({});
        t[text4] = w3;
        t[count2] = c2;
        out.add.push(t);
      } else if (c2 === 0) {
        if (t)
          out.rem.push(t);
        counts[w3] = null;
        tuples[w3] = null;
      } else if (t[count2] !== c2) {
        t[count2] = c2;
        out.mod.push(t);
      }
    }
    return out.modifies(as);
  }
});
function Cross(params2) {
  Transform.call(this, null, params2);
}
Cross.Definition = {
  type: "Cross",
  metadata: {
    generates: true
  },
  params: [{
    name: "filter",
    type: "expr"
  }, {
    name: "as",
    type: "string",
    array: true,
    length: 2,
    default: ["a", "b"]
  }]
};
inherits(Cross, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), as = _.as || ["a", "b"], a2 = as[0], b2 = as[1], reset3 = !this.value || pulse2.changed(pulse2.ADD_REM) || _.modified("as") || _.modified("filter");
    let data4 = this.value;
    if (reset3) {
      if (data4)
        out.rem = data4;
      data4 = pulse2.materialize(pulse2.SOURCE).source;
      out.add = this.value = cross(data4, a2, b2, _.filter || truthy);
    } else {
      out.mod = data4;
    }
    out.source = this.value;
    return out.modifies(as);
  }
});
function cross(input, a2, b2, filter4) {
  var data4 = [], t = {}, n = input.length, i = 0, j, left;
  for (; i < n; ++i) {
    t[a2] = left = input[i];
    for (j = 0; j < n; ++j) {
      t[b2] = input[j];
      if (filter4(t)) {
        data4.push(ingest(t));
        t = {};
        t[a2] = left;
      }
    }
  }
  return data4;
}
var Distributions = {
  kde,
  mixture,
  normal: gaussian,
  lognormal,
  uniform
};
var DISTRIBUTIONS = "distributions";
var FUNCTION = "function";
var FIELD = "field";
function parse3(def2, data4) {
  const func = def2[FUNCTION];
  if (!has(Distributions, func)) {
    error("Unknown distribution function: " + func);
  }
  const d = Distributions[func]();
  for (const name4 in def2) {
    if (name4 === FIELD) {
      d.data((def2.from || data4()).map(def2[name4]));
    } else if (name4 === DISTRIBUTIONS) {
      d[name4](def2[name4].map((_) => parse3(_, data4)));
    } else if (typeof d[name4] === FUNCTION) {
      d[name4](def2[name4]);
    }
  }
  return d;
}
function Density(params2) {
  Transform.call(this, null, params2);
}
var distributions = [{
  key: {
    function: "normal"
  },
  params: [{
    name: "mean",
    type: "number",
    default: 0
  }, {
    name: "stdev",
    type: "number",
    default: 1
  }]
}, {
  key: {
    function: "lognormal"
  },
  params: [{
    name: "mean",
    type: "number",
    default: 0
  }, {
    name: "stdev",
    type: "number",
    default: 1
  }]
}, {
  key: {
    function: "uniform"
  },
  params: [{
    name: "min",
    type: "number",
    default: 0
  }, {
    name: "max",
    type: "number",
    default: 1
  }]
}, {
  key: {
    function: "kde"
  },
  params: [{
    name: "field",
    type: "field",
    required: true
  }, {
    name: "from",
    type: "data"
  }, {
    name: "bandwidth",
    type: "number",
    default: 0
  }]
}];
var mixture2 = {
  key: {
    function: "mixture"
  },
  params: [{
    name: "distributions",
    type: "param",
    array: true,
    params: distributions
  }, {
    name: "weights",
    type: "number",
    array: true
  }]
};
Density.Definition = {
  type: "Density",
  metadata: {
    generates: true
  },
  params: [{
    name: "extent",
    type: "number",
    array: true,
    length: 2
  }, {
    name: "steps",
    type: "number"
  }, {
    name: "minsteps",
    type: "number",
    default: 25
  }, {
    name: "maxsteps",
    type: "number",
    default: 200
  }, {
    name: "method",
    type: "string",
    default: "pdf",
    values: ["pdf", "cdf"]
  }, {
    name: "distribution",
    type: "param",
    params: distributions.concat(mixture2)
  }, {
    name: "as",
    type: "string",
    array: true,
    default: ["value", "density"]
  }]
};
inherits(Density, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    if (!this.value || pulse2.changed() || _.modified()) {
      const dist2 = parse3(_.distribution, source(pulse2)), minsteps = _.steps || _.minsteps || 25, maxsteps = _.steps || _.maxsteps || 200;
      let method2 = _.method || "pdf";
      if (method2 !== "pdf" && method2 !== "cdf") {
        error("Invalid density method: " + method2);
      }
      if (!_.extent && !dist2.data) {
        error("Missing density extent parameter.");
      }
      method2 = dist2[method2];
      const as = _.as || ["value", "density"], domain4 = _.extent || extent(dist2.data()), values4 = sampleCurve(method2, domain4, minsteps, maxsteps).map((v) => {
        const tuple = {};
        tuple[as[0]] = v[0];
        tuple[as[1]] = v[1];
        return ingest(tuple);
      });
      if (this.value)
        out.rem = this.value;
      this.value = out.add = out.source = values4;
    }
    return out;
  }
});
function source(pulse2) {
  return () => pulse2.materialize(pulse2.SOURCE).source;
}
function fieldNames(fields, as) {
  if (!fields)
    return null;
  return fields.map((f, i) => as[i] || accessorName(f));
}
function partition(data4, groupby, field4) {
  const groups = [], get6 = (f) => f(t);
  let map4, i, n, t, k, g;
  if (groupby == null) {
    groups.push(data4.map(field4));
  } else {
    for (map4 = {}, i = 0, n = data4.length; i < n; ++i) {
      t = data4[i];
      k = groupby.map(get6);
      g = map4[k];
      if (!g) {
        map4[k] = g = [];
        g.dims = k;
        groups.push(g);
      }
      g.push(field4(t));
    }
  }
  return groups;
}
var Output = "bin";
function DotBin(params2) {
  Transform.call(this, null, params2);
}
DotBin.Definition = {
  type: "DotBin",
  metadata: {
    modifies: true
  },
  params: [{
    name: "field",
    type: "field",
    required: true
  }, {
    name: "groupby",
    type: "field",
    array: true
  }, {
    name: "step",
    type: "number"
  }, {
    name: "smooth",
    type: "boolean",
    default: false
  }, {
    name: "as",
    type: "string",
    default: Output
  }]
};
var autostep = (data4, field4) => span(extent(data4, field4)) / 30;
inherits(DotBin, Transform, {
  transform(_, pulse2) {
    if (this.value && !(_.modified() || pulse2.changed())) {
      return pulse2;
    }
    const source4 = pulse2.materialize(pulse2.SOURCE).source, groups = partition(pulse2.source, _.groupby, identity), smooth = _.smooth || false, field4 = _.field, step = _.step || autostep(source4, field4), sort2 = stableCompare((a2, b2) => field4(a2) - field4(b2)), as = _.as || Output, n = groups.length;
    let min4 = Infinity, max4 = -Infinity, i = 0, j;
    for (; i < n; ++i) {
      const g = groups[i].sort(sort2);
      j = -1;
      for (const v of dotbin(g, step, smooth, field4)) {
        if (v < min4)
          min4 = v;
        if (v > max4)
          max4 = v;
        g[++j][as] = v;
      }
    }
    this.value = {
      start: min4,
      stop: max4,
      step
    };
    return pulse2.reflow(true).modifies(as);
  }
});
function Expression(params2) {
  Operator.call(this, null, update$1, params2);
  this.modified(true);
}
inherits(Expression, Operator);
function update$1(_) {
  const expr2 = _.expr;
  return this.value && !_.modified("expr") ? this.value : accessor((datum3) => expr2(datum3, _), accessorFields(expr2), accessorName(expr2));
}
function Extent(params2) {
  Transform.call(this, [void 0, void 0], params2);
}
Extent.Definition = {
  type: "Extent",
  metadata: {},
  params: [{
    name: "field",
    type: "field",
    required: true
  }]
};
inherits(Extent, Transform, {
  transform(_, pulse2) {
    const extent2 = this.value, field4 = _.field, mod = pulse2.changed() || pulse2.modified(field4.fields) || _.modified("field");
    let min4 = extent2[0], max4 = extent2[1];
    if (mod || min4 == null) {
      min4 = Infinity;
      max4 = -Infinity;
    }
    pulse2.visit(mod ? pulse2.SOURCE : pulse2.ADD, (t) => {
      const v = toNumber(field4(t));
      if (v != null) {
        if (v < min4)
          min4 = v;
        if (v > max4)
          max4 = v;
      }
    });
    if (!Number.isFinite(min4) || !Number.isFinite(max4)) {
      let name4 = accessorName(field4);
      if (name4)
        name4 = ' for field "'.concat(name4, '"');
      pulse2.dataflow.warn("Infinite extent".concat(name4, ": [").concat(min4, ", ").concat(max4, "]"));
      min4 = max4 = void 0;
    }
    this.value = [min4, max4];
  }
});
function Subflow(pulse2, parent) {
  Operator.call(this, pulse2);
  this.parent = parent;
  this.count = 0;
}
inherits(Subflow, Operator, {
  connect(target) {
    this.detachSubflow = target.detachSubflow;
    this.targets().add(target);
    return target.source = this;
  },
  add(t) {
    this.count += 1;
    this.value.add.push(t);
  },
  rem(t) {
    this.count -= 1;
    this.value.rem.push(t);
  },
  mod(t) {
    this.value.mod.push(t);
  },
  init(pulse2) {
    this.value.init(pulse2, pulse2.NO_SOURCE);
  },
  evaluate() {
    return this.value;
  }
});
function Facet(params2) {
  Transform.call(this, {}, params2);
  this._keys = fastmap();
  const a2 = this._targets = [];
  a2.active = 0;
  a2.forEach = (f) => {
    for (let i = 0, n = a2.active; i < n; ++i) {
      f(a2[i], i, a2);
    }
  };
}
inherits(Facet, Transform, {
  activate(flow) {
    this._targets[this._targets.active++] = flow;
  },
  subflow(key2, flow, pulse2, parent) {
    const flows = this.value;
    let sf = has(flows, key2) && flows[key2], df, p;
    if (!sf) {
      p = parent || (p = this._group[key2]) && p.tuple;
      df = pulse2.dataflow;
      sf = new Subflow(pulse2.fork(pulse2.NO_SOURCE), this);
      df.add(sf).connect(flow(df, key2, p));
      flows[key2] = sf;
      this.activate(sf);
    } else if (sf.value.stamp < pulse2.stamp) {
      sf.init(pulse2);
      this.activate(sf);
    }
    return sf;
  },
  clean() {
    const flows = this.value;
    for (const key2 in flows) {
      if (flows[key2].count === 0) {
        const detach = flows[key2].detachSubflow;
        if (detach)
          detach();
        delete flows[key2];
      }
    }
  },
  initTargets() {
    const a2 = this._targets, n = a2.length;
    for (let i = 0; i < n && a2[i] != null; ++i) {
      a2[i] = null;
    }
    a2.active = 0;
  },
  transform(_, pulse2) {
    const df = pulse2.dataflow, key2 = _.key, flow = _.subflow, cache2 = this._keys, rekey = _.modified("key"), subflow = (key3) => this.subflow(key3, flow, pulse2);
    this._group = _.group || {};
    this.initTargets();
    pulse2.visit(pulse2.REM, (t) => {
      const id4 = tupleid(t), k = cache2.get(id4);
      if (k !== void 0) {
        cache2.delete(id4);
        subflow(k).rem(t);
      }
    });
    pulse2.visit(pulse2.ADD, (t) => {
      const k = key2(t);
      cache2.set(tupleid(t), k);
      subflow(k).add(t);
    });
    if (rekey || pulse2.modified(key2.fields)) {
      pulse2.visit(pulse2.MOD, (t) => {
        const id4 = tupleid(t), k0 = cache2.get(id4), k1 = key2(t);
        if (k0 === k1) {
          subflow(k1).mod(t);
        } else {
          cache2.set(id4, k1);
          subflow(k0).rem(t);
          subflow(k1).add(t);
        }
      });
    } else if (pulse2.changed(pulse2.MOD)) {
      pulse2.visit(pulse2.MOD, (t) => {
        subflow(cache2.get(tupleid(t))).mod(t);
      });
    }
    if (rekey) {
      pulse2.visit(pulse2.REFLOW, (t) => {
        const id4 = tupleid(t), k0 = cache2.get(id4), k1 = key2(t);
        if (k0 !== k1) {
          cache2.set(id4, k1);
          subflow(k0).rem(t);
          subflow(k1).add(t);
        }
      });
    }
    if (pulse2.clean()) {
      df.runAfter(() => {
        this.clean();
        cache2.clean();
      });
    } else if (cache2.empty > df.cleanThreshold) {
      df.runAfter(cache2.clean);
    }
    return pulse2;
  }
});
function Field(params2) {
  Operator.call(this, null, update$2, params2);
}
inherits(Field, Operator);
function update$2(_) {
  return this.value && !_.modified() ? this.value : isArray(_.name) ? array(_.name).map((f) => field(f)) : field(_.name, _.as);
}
function Filter(params2) {
  Transform.call(this, fastmap(), params2);
}
Filter.Definition = {
  type: "Filter",
  metadata: {
    changes: true
  },
  params: [{
    name: "expr",
    type: "expr",
    required: true
  }]
};
inherits(Filter, Transform, {
  transform(_, pulse2) {
    const df = pulse2.dataflow, cache2 = this.value, output3 = pulse2.fork(), add6 = output3.add, rem2 = output3.rem, mod = output3.mod, test2 = _.expr;
    let isMod = true;
    pulse2.visit(pulse2.REM, (t) => {
      const id4 = tupleid(t);
      if (!cache2.has(id4))
        rem2.push(t);
      else
        cache2.delete(id4);
    });
    pulse2.visit(pulse2.ADD, (t) => {
      if (test2(t, _))
        add6.push(t);
      else
        cache2.set(tupleid(t), 1);
    });
    function revisit(t) {
      const id4 = tupleid(t), b2 = test2(t, _), s = cache2.get(id4);
      if (b2 && s) {
        cache2.delete(id4);
        add6.push(t);
      } else if (!b2 && !s) {
        cache2.set(id4, 1);
        rem2.push(t);
      } else if (isMod && b2 && !s) {
        mod.push(t);
      }
    }
    pulse2.visit(pulse2.MOD, revisit);
    if (_.modified()) {
      isMod = false;
      pulse2.visit(pulse2.REFLOW, revisit);
    }
    if (cache2.empty > df.cleanThreshold)
      df.runAfter(cache2.clean);
    return output3;
  }
});
function Flatten(params2) {
  Transform.call(this, [], params2);
}
Flatten.Definition = {
  type: "Flatten",
  metadata: {
    generates: true
  },
  params: [{
    name: "fields",
    type: "field",
    array: true,
    required: true
  }, {
    name: "index",
    type: "string"
  }, {
    name: "as",
    type: "string",
    array: true
  }]
};
inherits(Flatten, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), fields = _.fields, as = fieldNames(fields, _.as || []), index4 = _.index || null, m2 = as.length;
    out.rem = this.value;
    pulse2.visit(pulse2.SOURCE, (t) => {
      const arrays = fields.map((f) => f(t)), maxlen = arrays.reduce((l, a2) => Math.max(l, a2.length), 0);
      let i = 0, j, d, v;
      for (; i < maxlen; ++i) {
        d = derive(t);
        for (j = 0; j < m2; ++j) {
          d[as[j]] = (v = arrays[j][i]) == null ? null : v;
        }
        if (index4) {
          d[index4] = i;
        }
        out.add.push(d);
      }
    });
    this.value = out.source = out.add;
    if (index4)
      out.modifies(index4);
    return out.modifies(as);
  }
});
function Fold(params2) {
  Transform.call(this, [], params2);
}
Fold.Definition = {
  type: "Fold",
  metadata: {
    generates: true
  },
  params: [{
    name: "fields",
    type: "field",
    array: true,
    required: true
  }, {
    name: "as",
    type: "string",
    array: true,
    length: 2,
    default: ["key", "value"]
  }]
};
inherits(Fold, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), fields = _.fields, fnames = fields.map(accessorName), as = _.as || ["key", "value"], k = as[0], v = as[1], n = fields.length;
    out.rem = this.value;
    pulse2.visit(pulse2.SOURCE, (t) => {
      for (let i = 0, d; i < n; ++i) {
        d = derive(t);
        d[k] = fnames[i];
        d[v] = fields[i](t);
        out.add.push(d);
      }
    });
    this.value = out.source = out.add;
    return out.modifies(as);
  }
});
function Formula(params2) {
  Transform.call(this, null, params2);
}
Formula.Definition = {
  type: "Formula",
  metadata: {
    modifies: true
  },
  params: [{
    name: "expr",
    type: "expr",
    required: true
  }, {
    name: "as",
    type: "string",
    required: true
  }, {
    name: "initonly",
    type: "boolean"
  }]
};
inherits(Formula, Transform, {
  transform(_, pulse2) {
    const func = _.expr, as = _.as, mod = _.modified(), flag2 = _.initonly ? pulse2.ADD : mod ? pulse2.SOURCE : pulse2.modified(func.fields) || pulse2.modified(as) ? pulse2.ADD_MOD : pulse2.ADD;
    if (mod) {
      pulse2 = pulse2.materialize().reflow(true);
    }
    if (!_.initonly) {
      pulse2.modifies(as);
    }
    return pulse2.visit(flag2, (t) => t[as] = func(t, _));
  }
});
function Generate(params2) {
  Transform.call(this, [], params2);
}
inherits(Generate, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.ALL), gen = _.generator;
    let data4 = this.value, num = _.size - data4.length, add6, rem2, t;
    if (num > 0) {
      for (add6 = []; --num >= 0; ) {
        add6.push(t = ingest(gen(_)));
        data4.push(t);
      }
      out.add = out.add.length ? out.materialize(out.ADD).add.concat(add6) : add6;
    } else {
      rem2 = data4.slice(0, -num);
      out.rem = out.rem.length ? out.materialize(out.REM).rem.concat(rem2) : rem2;
      data4 = data4.slice(-num);
    }
    out.source = this.value = data4;
    return out;
  }
});
var Methods = {
  value: "value",
  median: median_default,
  mean,
  min,
  max
};
var Empty = [];
function Impute(params2) {
  Transform.call(this, [], params2);
}
Impute.Definition = {
  type: "Impute",
  metadata: {
    changes: true
  },
  params: [{
    name: "field",
    type: "field",
    required: true
  }, {
    name: "key",
    type: "field",
    required: true
  }, {
    name: "keyvals",
    array: true
  }, {
    name: "groupby",
    type: "field",
    array: true
  }, {
    name: "method",
    type: "enum",
    default: "value",
    values: ["value", "mean", "median", "max", "min"]
  }, {
    name: "value",
    default: 0
  }]
};
function getValue(_) {
  var m2 = _.method || Methods.value, v;
  if (Methods[m2] == null) {
    error("Unrecognized imputation method: " + m2);
  } else if (m2 === Methods.value) {
    v = _.value !== void 0 ? _.value : 0;
    return () => v;
  } else {
    return Methods[m2];
  }
}
function getField(_) {
  const f = _.field;
  return (t) => t ? f(t) : NaN;
}
inherits(Impute, Transform, {
  transform(_, pulse2) {
    var out = pulse2.fork(pulse2.ALL), impute = getValue(_), field4 = getField(_), fName = accessorName(_.field), kName = accessorName(_.key), gNames = (_.groupby || []).map(accessorName), groups = partition$1(pulse2.source, _.groupby, _.key, _.keyvals), curr = [], prev = this.value, m2 = groups.domain.length, group2, value3, gVals, kVal, g, i, j, l, n, t;
    for (g = 0, l = groups.length; g < l; ++g) {
      group2 = groups[g];
      gVals = group2.values;
      value3 = NaN;
      for (j = 0; j < m2; ++j) {
        if (group2[j] != null)
          continue;
        kVal = groups.domain[j];
        t = {
          _impute: true
        };
        for (i = 0, n = gVals.length; i < n; ++i)
          t[gNames[i]] = gVals[i];
        t[kName] = kVal;
        t[fName] = Number.isNaN(value3) ? value3 = impute(group2, field4) : value3;
        curr.push(ingest(t));
      }
    }
    if (curr.length)
      out.add = out.materialize(out.ADD).add.concat(curr);
    if (prev.length)
      out.rem = out.materialize(out.REM).rem.concat(prev);
    this.value = curr;
    return out;
  }
});
function partition$1(data4, groupby, key2, keyvals) {
  var get6 = (f) => f(t), groups = [], domain4 = keyvals ? keyvals.slice() : [], kMap = {}, gMap = {}, gVals, gKey, group2, i, j, k, n, t;
  domain4.forEach((k2, i2) => kMap[k2] = i2 + 1);
  for (i = 0, n = data4.length; i < n; ++i) {
    t = data4[i];
    k = key2(t);
    j = kMap[k] || (kMap[k] = domain4.push(k));
    gKey = (gVals = groupby ? groupby.map(get6) : Empty) + "";
    if (!(group2 = gMap[gKey])) {
      group2 = gMap[gKey] = [];
      groups.push(group2);
      group2.values = gVals;
    }
    group2[j - 1] = t;
  }
  groups.domain = domain4;
  return groups;
}
function JoinAggregate(params2) {
  Aggregate.call(this, params2);
}
JoinAggregate.Definition = {
  type: "JoinAggregate",
  metadata: {
    modifies: true
  },
  params: [{
    name: "groupby",
    type: "field",
    array: true
  }, {
    name: "fields",
    type: "field",
    null: true,
    array: true
  }, {
    name: "ops",
    type: "enum",
    array: true,
    values: ValidAggregateOps
  }, {
    name: "as",
    type: "string",
    null: true,
    array: true
  }, {
    name: "key",
    type: "field"
  }]
};
inherits(JoinAggregate, Aggregate, {
  transform(_, pulse2) {
    const aggr = this, mod = _.modified();
    let cells;
    if (aggr.value && (mod || pulse2.modified(aggr._inputs, true))) {
      cells = aggr.value = mod ? aggr.init(_) : {};
      pulse2.visit(pulse2.SOURCE, (t) => aggr.add(t));
    } else {
      cells = aggr.value = aggr.value || this.init(_);
      pulse2.visit(pulse2.REM, (t) => aggr.rem(t));
      pulse2.visit(pulse2.ADD, (t) => aggr.add(t));
    }
    aggr.changes();
    pulse2.visit(pulse2.SOURCE, (t) => {
      extend(t, cells[aggr.cellkey(t)].tuple);
    });
    return pulse2.reflow(mod).modifies(this._outputs);
  },
  changes() {
    const adds = this._adds, mods = this._mods;
    let i, n;
    for (i = 0, n = this._alen; i < n; ++i) {
      this.celltuple(adds[i]);
      adds[i] = null;
    }
    for (i = 0, n = this._mlen; i < n; ++i) {
      this.celltuple(mods[i]);
      mods[i] = null;
    }
    this._alen = this._mlen = 0;
  }
});
function KDE(params2) {
  Transform.call(this, null, params2);
}
KDE.Definition = {
  type: "KDE",
  metadata: {
    generates: true
  },
  params: [{
    name: "groupby",
    type: "field",
    array: true
  }, {
    name: "field",
    type: "field",
    required: true
  }, {
    name: "cumulative",
    type: "boolean",
    default: false
  }, {
    name: "counts",
    type: "boolean",
    default: false
  }, {
    name: "bandwidth",
    type: "number",
    default: 0
  }, {
    name: "extent",
    type: "number",
    array: true,
    length: 2
  }, {
    name: "resolve",
    type: "enum",
    values: ["shared", "independent"],
    default: "independent"
  }, {
    name: "steps",
    type: "number"
  }, {
    name: "minsteps",
    type: "number",
    default: 25
  }, {
    name: "maxsteps",
    type: "number",
    default: 200
  }, {
    name: "as",
    type: "string",
    array: true,
    default: ["value", "density"]
  }]
};
inherits(KDE, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    if (!this.value || pulse2.changed() || _.modified()) {
      const source4 = pulse2.materialize(pulse2.SOURCE).source, groups = partition(source4, _.groupby, _.field), names = (_.groupby || []).map(accessorName), bandwidth3 = _.bandwidth, method2 = _.cumulative ? "cdf" : "pdf", as = _.as || ["value", "density"], values4 = [];
      let domain4 = _.extent, minsteps = _.steps || _.minsteps || 25, maxsteps = _.steps || _.maxsteps || 200;
      if (method2 !== "pdf" && method2 !== "cdf") {
        error("Invalid density method: " + method2);
      }
      if (_.resolve === "shared") {
        if (!domain4)
          domain4 = extent(source4, _.field);
        minsteps = maxsteps = _.steps || maxsteps;
      }
      groups.forEach((g) => {
        const density = kde(g, bandwidth3)[method2], scale7 = _.counts ? g.length : 1, local2 = domain4 || extent(g);
        sampleCurve(density, local2, minsteps, maxsteps).forEach((v) => {
          const t = {};
          for (let i = 0; i < names.length; ++i) {
            t[names[i]] = g.dims[i];
          }
          t[as[0]] = v[0];
          t[as[1]] = v[1] * scale7;
          values4.push(ingest(t));
        });
      });
      if (this.value)
        out.rem = this.value;
      this.value = out.add = out.source = values4;
    }
    return out;
  }
});
function Key(params2) {
  Operator.call(this, null, update$3, params2);
}
inherits(Key, Operator);
function update$3(_) {
  return this.value && !_.modified() ? this.value : key(_.fields, _.flat);
}
function Load(params2) {
  Transform.call(this, [], params2);
  this._pending = null;
}
inherits(Load, Transform, {
  transform(_, pulse2) {
    const df = pulse2.dataflow;
    if (this._pending) {
      return output2(this, pulse2, this._pending);
    }
    if (stop(_))
      return pulse2.StopPropagation;
    if (_.values) {
      return output2(this, pulse2, df.parse(_.values, _.format));
    } else if (_.async) {
      const p = df.request(_.url, _.format).then((res) => {
        this._pending = array(res.data);
        return (df2) => df2.touch(this);
      });
      return {
        async: p
      };
    } else {
      return df.request(_.url, _.format).then((res) => output2(this, pulse2, array(res.data)));
    }
  }
});
function stop(_) {
  return _.modified("async") && !(_.modified("values") || _.modified("url") || _.modified("format"));
}
function output2(op, pulse2, data4) {
  data4.forEach(ingest);
  const out = pulse2.fork(pulse2.NO_FIELDS & pulse2.NO_SOURCE);
  out.rem = op.value;
  op.value = out.source = out.add = data4;
  op._pending = null;
  if (out.rem.length)
    out.clean(true);
  return out;
}
function Lookup(params2) {
  Transform.call(this, {}, params2);
}
Lookup.Definition = {
  type: "Lookup",
  metadata: {
    modifies: true
  },
  params: [{
    name: "index",
    type: "index",
    params: [{
      name: "from",
      type: "data",
      required: true
    }, {
      name: "key",
      type: "field",
      required: true
    }]
  }, {
    name: "values",
    type: "field",
    array: true
  }, {
    name: "fields",
    type: "field",
    array: true,
    required: true
  }, {
    name: "as",
    type: "string",
    array: true
  }, {
    name: "default",
    default: null
  }]
};
inherits(Lookup, Transform, {
  transform(_, pulse2) {
    const keys4 = _.fields, index4 = _.index, values4 = _.values, defaultValue = _.default == null ? null : _.default, reset3 = _.modified(), n = keys4.length;
    let flag2 = reset3 ? pulse2.SOURCE : pulse2.ADD, out = pulse2, as = _.as, set6, m2, mods;
    if (values4) {
      m2 = values4.length;
      if (n > 1 && !as) {
        error('Multi-field lookup requires explicit "as" parameter.');
      }
      if (as && as.length !== n * m2) {
        error('The "as" parameter has too few output field names.');
      }
      as = as || values4.map(accessorName);
      set6 = function(t) {
        for (var i = 0, k = 0, j, v; i < n; ++i) {
          v = index4.get(keys4[i](t));
          if (v == null)
            for (j = 0; j < m2; ++j, ++k)
              t[as[k]] = defaultValue;
          else
            for (j = 0; j < m2; ++j, ++k)
              t[as[k]] = values4[j](v);
        }
      };
    } else {
      if (!as) {
        error("Missing output field names.");
      }
      set6 = function(t) {
        for (var i = 0, v; i < n; ++i) {
          v = index4.get(keys4[i](t));
          t[as[i]] = v == null ? defaultValue : v;
        }
      };
    }
    if (reset3) {
      out = pulse2.reflow(true);
    } else {
      mods = keys4.some((k) => pulse2.modified(k.fields));
      flag2 |= mods ? pulse2.MOD : 0;
    }
    pulse2.visit(flag2, set6);
    return out.modifies(as);
  }
});
function MultiExtent(params2) {
  Operator.call(this, null, update$4, params2);
}
inherits(MultiExtent, Operator);
function update$4(_) {
  if (this.value && !_.modified()) {
    return this.value;
  }
  const ext = _.extents, n = ext.length;
  let min4 = Infinity, max4 = -Infinity, i, e;
  for (i = 0; i < n; ++i) {
    e = ext[i];
    if (e[0] < min4)
      min4 = e[0];
    if (e[1] > max4)
      max4 = e[1];
  }
  return [min4, max4];
}
function MultiValues(params2) {
  Operator.call(this, null, update$5, params2);
}
inherits(MultiValues, Operator);
function update$5(_) {
  return this.value && !_.modified() ? this.value : _.values.reduce((data4, _2) => data4.concat(_2), []);
}
function Params(params2) {
  Transform.call(this, null, params2);
}
inherits(Params, Transform, {
  transform(_, pulse2) {
    this.modified(_.modified());
    this.value = _;
    return pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
  }
});
function Pivot(params2) {
  Aggregate.call(this, params2);
}
Pivot.Definition = {
  type: "Pivot",
  metadata: {
    generates: true,
    changes: true
  },
  params: [{
    name: "groupby",
    type: "field",
    array: true
  }, {
    name: "field",
    type: "field",
    required: true
  }, {
    name: "value",
    type: "field",
    required: true
  }, {
    name: "op",
    type: "enum",
    values: ValidAggregateOps,
    default: "sum"
  }, {
    name: "limit",
    type: "number",
    default: 0
  }, {
    name: "key",
    type: "field"
  }]
};
inherits(Pivot, Aggregate, {
  _transform: Aggregate.prototype.transform,
  transform(_, pulse2) {
    return this._transform(aggregateParams(_, pulse2), pulse2);
  }
});
function aggregateParams(_, pulse2) {
  const key2 = _.field, value3 = _.value, op = (_.op === "count" ? "__count__" : _.op) || "sum", fields = accessorFields(key2).concat(accessorFields(value3)), keys4 = pivotKeys(key2, _.limit || 0, pulse2);
  if (pulse2.changed())
    _.set("__pivot__", null, null, true);
  return {
    key: _.key,
    groupby: _.groupby,
    ops: keys4.map(() => op),
    fields: keys4.map((k) => get(k, key2, value3, fields)),
    as: keys4.map((k) => k + ""),
    modified: _.modified.bind(_)
  };
}
function get(k, key2, value3, fields) {
  return accessor((d) => key2(d) === k ? value3(d) : NaN, fields, k + "");
}
function pivotKeys(key2, limit, pulse2) {
  const map4 = {}, list = [];
  pulse2.visit(pulse2.SOURCE, (t) => {
    const k = key2(t);
    if (!map4[k]) {
      map4[k] = 1;
      list.push(k);
    }
  });
  list.sort(ascending);
  return limit ? list.slice(0, limit) : list;
}
function PreFacet(params2) {
  Facet.call(this, params2);
}
inherits(PreFacet, Facet, {
  transform(_, pulse2) {
    const flow = _.subflow, field4 = _.field, subflow = (t) => this.subflow(tupleid(t), flow, pulse2, t);
    if (_.modified("field") || field4 && pulse2.modified(accessorFields(field4))) {
      error("PreFacet does not support field modification.");
    }
    this.initTargets();
    if (field4) {
      pulse2.visit(pulse2.MOD, (t) => {
        const sf = subflow(t);
        field4(t).forEach((_2) => sf.mod(_2));
      });
      pulse2.visit(pulse2.ADD, (t) => {
        const sf = subflow(t);
        field4(t).forEach((_2) => sf.add(ingest(_2)));
      });
      pulse2.visit(pulse2.REM, (t) => {
        const sf = subflow(t);
        field4(t).forEach((_2) => sf.rem(_2));
      });
    } else {
      pulse2.visit(pulse2.MOD, (t) => subflow(t).mod(t));
      pulse2.visit(pulse2.ADD, (t) => subflow(t).add(t));
      pulse2.visit(pulse2.REM, (t) => subflow(t).rem(t));
    }
    if (pulse2.clean()) {
      pulse2.runAfter(() => this.clean());
    }
    return pulse2;
  }
});
function Project(params2) {
  Transform.call(this, null, params2);
}
Project.Definition = {
  type: "Project",
  metadata: {
    generates: true,
    changes: true
  },
  params: [{
    name: "fields",
    type: "field",
    array: true
  }, {
    name: "as",
    type: "string",
    null: true,
    array: true
  }]
};
inherits(Project, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), fields = _.fields, as = fieldNames(_.fields, _.as || []), derive2 = fields ? (s, t) => project(s, t, fields, as) : rederive;
    let lut;
    if (this.value) {
      lut = this.value;
    } else {
      pulse2 = pulse2.addAll();
      lut = this.value = {};
    }
    pulse2.visit(pulse2.REM, (t) => {
      const id4 = tupleid(t);
      out.rem.push(lut[id4]);
      lut[id4] = null;
    });
    pulse2.visit(pulse2.ADD, (t) => {
      const dt = derive2(t, ingest({}));
      lut[tupleid(t)] = dt;
      out.add.push(dt);
    });
    pulse2.visit(pulse2.MOD, (t) => {
      out.mod.push(derive2(t, lut[tupleid(t)]));
    });
    return out;
  }
});
function project(s, t, fields, as) {
  for (let i = 0, n = fields.length; i < n; ++i) {
    t[as[i]] = fields[i](s);
  }
  return t;
}
function Proxy(params2) {
  Transform.call(this, null, params2);
}
inherits(Proxy, Transform, {
  transform(_, pulse2) {
    this.value = _.value;
    return _.modified("value") ? pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS) : pulse2.StopPropagation;
  }
});
function Quantile(params2) {
  Transform.call(this, null, params2);
}
Quantile.Definition = {
  type: "Quantile",
  metadata: {
    generates: true,
    changes: true
  },
  params: [{
    name: "groupby",
    type: "field",
    array: true
  }, {
    name: "field",
    type: "field",
    required: true
  }, {
    name: "probs",
    type: "number",
    array: true
  }, {
    name: "step",
    type: "number",
    default: 0.01
  }, {
    name: "as",
    type: "string",
    array: true,
    default: ["prob", "value"]
  }]
};
var EPSILON$1 = 1e-14;
inherits(Quantile, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), as = _.as || ["prob", "value"];
    if (this.value && !_.modified() && !pulse2.changed()) {
      out.source = this.value;
      return out;
    }
    const source4 = pulse2.materialize(pulse2.SOURCE).source, groups = partition(source4, _.groupby, _.field), names = (_.groupby || []).map(accessorName), values4 = [], step = _.step || 0.01, p = _.probs || range_default(step / 2, 1 - EPSILON$1, step), n = p.length;
    groups.forEach((g) => {
      const q = quantiles(g, p);
      for (let i = 0; i < n; ++i) {
        const t = {};
        for (let i2 = 0; i2 < names.length; ++i2) {
          t[names[i2]] = g.dims[i2];
        }
        t[as[0]] = p[i];
        t[as[1]] = q[i];
        values4.push(ingest(t));
      }
    });
    if (this.value)
      out.rem = this.value;
    this.value = out.add = out.source = values4;
    return out;
  }
});
function Relay(params2) {
  Transform.call(this, null, params2);
}
inherits(Relay, Transform, {
  transform(_, pulse2) {
    let out, lut;
    if (this.value) {
      lut = this.value;
    } else {
      out = pulse2 = pulse2.addAll();
      lut = this.value = {};
    }
    if (_.derive) {
      out = pulse2.fork(pulse2.NO_SOURCE);
      pulse2.visit(pulse2.REM, (t) => {
        const id4 = tupleid(t);
        out.rem.push(lut[id4]);
        lut[id4] = null;
      });
      pulse2.visit(pulse2.ADD, (t) => {
        const dt = derive(t);
        lut[tupleid(t)] = dt;
        out.add.push(dt);
      });
      pulse2.visit(pulse2.MOD, (t) => {
        const dt = lut[tupleid(t)];
        for (const k in t) {
          dt[k] = t[k];
          out.modifies(k);
        }
        out.mod.push(dt);
      });
    }
    return out;
  }
});
function Sample(params2) {
  Transform.call(this, [], params2);
  this.count = 0;
}
Sample.Definition = {
  type: "Sample",
  metadata: {},
  params: [{
    name: "size",
    type: "number",
    default: 1e3
  }]
};
inherits(Sample, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), mod = _.modified("size"), num = _.size, map4 = this.value.reduce((m2, t) => (m2[tupleid(t)] = 1, m2), {});
    let res = this.value, cnt = this.count, cap = 0;
    function update3(t) {
      let p, idx;
      if (res.length < num) {
        res.push(t);
      } else {
        idx = ~~((cnt + 1) * random());
        if (idx < res.length && idx >= cap) {
          p = res[idx];
          if (map4[tupleid(p)])
            out.rem.push(p);
          res[idx] = t;
        }
      }
      ++cnt;
    }
    if (pulse2.rem.length) {
      pulse2.visit(pulse2.REM, (t) => {
        const id4 = tupleid(t);
        if (map4[id4]) {
          map4[id4] = -1;
          out.rem.push(t);
        }
        --cnt;
      });
      res = res.filter((t) => map4[tupleid(t)] !== -1);
    }
    if ((pulse2.rem.length || mod) && res.length < num && pulse2.source) {
      cap = cnt = res.length;
      pulse2.visit(pulse2.SOURCE, (t) => {
        if (!map4[tupleid(t)])
          update3(t);
      });
      cap = -1;
    }
    if (mod && res.length > num) {
      const n = res.length - num;
      for (let i = 0; i < n; ++i) {
        map4[tupleid(res[i])] = -1;
        out.rem.push(res[i]);
      }
      res = res.slice(n);
    }
    if (pulse2.mod.length) {
      pulse2.visit(pulse2.MOD, (t) => {
        if (map4[tupleid(t)])
          out.mod.push(t);
      });
    }
    if (pulse2.add.length) {
      pulse2.visit(pulse2.ADD, update3);
    }
    if (pulse2.add.length || cap < 0) {
      out.add = res.filter((t) => !map4[tupleid(t)]);
    }
    this.count = cnt;
    this.value = out.source = res;
    return out;
  }
});
function Sequence(params2) {
  Transform.call(this, null, params2);
}
Sequence.Definition = {
  type: "Sequence",
  metadata: {
    generates: true,
    changes: true
  },
  params: [{
    name: "start",
    type: "number",
    required: true
  }, {
    name: "stop",
    type: "number",
    required: true
  }, {
    name: "step",
    type: "number",
    default: 1
  }, {
    name: "as",
    type: "string",
    default: "data"
  }]
};
inherits(Sequence, Transform, {
  transform(_, pulse2) {
    if (this.value && !_.modified())
      return;
    const out = pulse2.materialize().fork(pulse2.MOD), as = _.as || "data";
    out.rem = this.value ? pulse2.rem.concat(this.value) : pulse2.rem;
    this.value = range_default(_.start, _.stop, _.step || 1).map((v) => {
      const t = {};
      t[as] = v;
      return ingest(t);
    });
    out.add = pulse2.add.concat(this.value);
    return out;
  }
});
function Sieve(params2) {
  Transform.call(this, null, params2);
  this.modified(true);
}
inherits(Sieve, Transform, {
  transform(_, pulse2) {
    this.value = pulse2.source;
    return pulse2.changed() ? pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS) : pulse2.StopPropagation;
  }
});
function TimeUnit(params2) {
  Transform.call(this, null, params2);
}
var OUTPUT = ["unit0", "unit1"];
TimeUnit.Definition = {
  type: "TimeUnit",
  metadata: {
    modifies: true
  },
  params: [{
    name: "field",
    type: "field",
    required: true
  }, {
    name: "interval",
    type: "boolean",
    default: true
  }, {
    name: "units",
    type: "enum",
    values: TIME_UNITS,
    array: true
  }, {
    name: "step",
    type: "number",
    default: 1
  }, {
    name: "maxbins",
    type: "number",
    default: 40
  }, {
    name: "extent",
    type: "date",
    array: true
  }, {
    name: "timezone",
    type: "enum",
    default: "local",
    values: ["local", "utc"]
  }, {
    name: "as",
    type: "string",
    array: true,
    length: 2,
    default: OUTPUT
  }]
};
inherits(TimeUnit, Transform, {
  transform(_, pulse2) {
    const field4 = _.field, band2 = _.interval !== false, utc = _.timezone === "utc", floor2 = this._floor(_, pulse2), offset4 = (utc ? utcInterval : timeInterval)(floor2.unit).offset, as = _.as || OUTPUT, u0 = as[0], u1 = as[1], step = floor2.step;
    let min4 = floor2.start || Infinity, max4 = floor2.stop || -Infinity, flag2 = pulse2.ADD;
    if (_.modified() || pulse2.modified(accessorFields(field4))) {
      pulse2 = pulse2.reflow(true);
      flag2 = pulse2.SOURCE;
      min4 = Infinity;
      max4 = -Infinity;
    }
    pulse2.visit(flag2, (t) => {
      const v = field4(t);
      let a2, b2;
      if (v == null) {
        t[u0] = null;
        if (band2)
          t[u1] = null;
      } else {
        t[u0] = a2 = b2 = floor2(v);
        if (band2)
          t[u1] = b2 = offset4(a2, step);
        if (a2 < min4)
          min4 = a2;
        if (b2 > max4)
          max4 = b2;
      }
    });
    floor2.start = min4;
    floor2.stop = max4;
    return pulse2.modifies(band2 ? as : u0);
  },
  _floor(_, pulse2) {
    const utc = _.timezone === "utc";
    const {
      units,
      step
    } = _.units ? {
      units: _.units,
      step: _.step || 1
    } : bin({
      extent: _.extent || extent(pulse2.materialize(pulse2.SOURCE).source, _.field),
      maxbins: _.maxbins
    });
    const tunits = timeUnits(units), prev = this.value || {}, floor2 = (utc ? utcFloor : timeFloor)(tunits, step);
    floor2.unit = peek(tunits);
    floor2.units = tunits;
    floor2.step = step;
    floor2.start = prev.start;
    floor2.stop = prev.stop;
    return this.value = floor2;
  }
});
function TupleIndex(params2) {
  Transform.call(this, fastmap(), params2);
}
inherits(TupleIndex, Transform, {
  transform(_, pulse2) {
    const df = pulse2.dataflow, field4 = _.field, index4 = this.value, set6 = (t) => index4.set(field4(t), t);
    let mod = true;
    if (_.modified("field") || pulse2.modified(field4.fields)) {
      index4.clear();
      pulse2.visit(pulse2.SOURCE, set6);
    } else if (pulse2.changed()) {
      pulse2.visit(pulse2.REM, (t) => index4.delete(field4(t)));
      pulse2.visit(pulse2.ADD, set6);
    } else {
      mod = false;
    }
    this.modified(mod);
    if (index4.empty > df.cleanThreshold)
      df.runAfter(index4.clean);
    return pulse2.fork();
  }
});
function Values(params2) {
  Transform.call(this, null, params2);
}
inherits(Values, Transform, {
  transform(_, pulse2) {
    const run2 = !this.value || _.modified("field") || _.modified("sort") || pulse2.changed() || _.sort && pulse2.modified(_.sort.fields);
    if (run2) {
      this.value = (_.sort ? pulse2.source.slice().sort(stableCompare(_.sort)) : pulse2.source).map(_.field);
    }
  }
});
function WindowOp(op, field4, param2, as) {
  const fn = WindowOps[op](field4, param2);
  return {
    init: fn.init || zero,
    update: function(w3, t) {
      t[as] = fn.next(w3);
    }
  };
}
var WindowOps = {
  row_number: function() {
    return {
      next: (w3) => w3.index + 1
    };
  },
  rank: function() {
    let rank2;
    return {
      init: () => rank2 = 1,
      next: (w3) => {
        const i = w3.index, data4 = w3.data;
        return i && w3.compare(data4[i - 1], data4[i]) ? rank2 = i + 1 : rank2;
      }
    };
  },
  dense_rank: function() {
    let drank;
    return {
      init: () => drank = 1,
      next: (w3) => {
        const i = w3.index, d = w3.data;
        return i && w3.compare(d[i - 1], d[i]) ? ++drank : drank;
      }
    };
  },
  percent_rank: function() {
    const rank2 = WindowOps.rank(), next = rank2.next;
    return {
      init: rank2.init,
      next: (w3) => (next(w3) - 1) / (w3.data.length - 1)
    };
  },
  cume_dist: function() {
    let cume;
    return {
      init: () => cume = 0,
      next: (w3) => {
        const d = w3.data, c2 = w3.compare;
        let i = w3.index;
        if (cume < i) {
          while (i + 1 < d.length && !c2(d[i], d[i + 1]))
            ++i;
          cume = i;
        }
        return (1 + cume) / d.length;
      }
    };
  },
  ntile: function(field4, num) {
    num = +num;
    if (!(num > 0))
      error("ntile num must be greater than zero.");
    const cume = WindowOps.cume_dist(), next = cume.next;
    return {
      init: cume.init,
      next: (w3) => Math.ceil(num * next(w3))
    };
  },
  lag: function(field4, offset4) {
    offset4 = +offset4 || 1;
    return {
      next: (w3) => {
        const i = w3.index - offset4;
        return i >= 0 ? field4(w3.data[i]) : null;
      }
    };
  },
  lead: function(field4, offset4) {
    offset4 = +offset4 || 1;
    return {
      next: (w3) => {
        const i = w3.index + offset4, d = w3.data;
        return i < d.length ? field4(d[i]) : null;
      }
    };
  },
  first_value: function(field4) {
    return {
      next: (w3) => field4(w3.data[w3.i0])
    };
  },
  last_value: function(field4) {
    return {
      next: (w3) => field4(w3.data[w3.i1 - 1])
    };
  },
  nth_value: function(field4, nth) {
    nth = +nth;
    if (!(nth > 0))
      error("nth_value nth must be greater than zero.");
    return {
      next: (w3) => {
        const i = w3.i0 + (nth - 1);
        return i < w3.i1 ? field4(w3.data[i]) : null;
      }
    };
  },
  prev_value: function(field4) {
    let prev;
    return {
      init: () => prev = null,
      next: (w3) => {
        const v = field4(w3.data[w3.index]);
        return v != null ? prev = v : prev;
      }
    };
  },
  next_value: function(field4) {
    let v, i;
    return {
      init: () => (v = null, i = -1),
      next: (w3) => {
        const d = w3.data;
        return w3.index <= i ? v : (i = find(field4, d, w3.index)) < 0 ? (i = d.length, v = null) : v = field4(d[i]);
      }
    };
  }
};
function find(field4, data4, index4) {
  for (let n = data4.length; index4 < n; ++index4) {
    const v = field4(data4[index4]);
    if (v != null)
      return index4;
  }
  return -1;
}
var ValidWindowOps = Object.keys(WindowOps);
function WindowState(_) {
  const ops2 = array(_.ops), fields = array(_.fields), params2 = array(_.params), as = array(_.as), outputs = this.outputs = [], windows = this.windows = [], inputs = {}, map4 = {}, counts = [], measures = [];
  let countOnly = true;
  function visitInputs(f) {
    array(accessorFields(f)).forEach((_2) => inputs[_2] = 1);
  }
  visitInputs(_.sort);
  ops2.forEach((op, i) => {
    const field4 = fields[i], mname = accessorName(field4), name4 = measureName(op, mname, as[i]);
    visitInputs(field4);
    outputs.push(name4);
    if (has(WindowOps, op)) {
      windows.push(WindowOp(op, fields[i], params2[i], name4));
    } else {
      if (field4 == null && op !== "count") {
        error("Null aggregate field specified.");
      }
      if (op === "count") {
        counts.push(name4);
        return;
      }
      countOnly = false;
      let m2 = map4[mname];
      if (!m2) {
        m2 = map4[mname] = [];
        m2.field = field4;
        measures.push(m2);
      }
      m2.push(createMeasure(op, name4));
    }
  });
  if (counts.length || measures.length) {
    this.cell = cell(measures, counts, countOnly);
  }
  this.inputs = Object.keys(inputs);
}
var prototype$1 = WindowState.prototype;
prototype$1.init = function() {
  this.windows.forEach((_) => _.init());
  if (this.cell)
    this.cell.init();
};
prototype$1.update = function(w3, t) {
  const cell2 = this.cell, wind = this.windows, data4 = w3.data, m2 = wind && wind.length;
  let j;
  if (cell2) {
    for (j = w3.p0; j < w3.i0; ++j)
      cell2.rem(data4[j]);
    for (j = w3.p1; j < w3.i1; ++j)
      cell2.add(data4[j]);
    cell2.set(t);
  }
  for (j = 0; j < m2; ++j)
    wind[j].update(w3, t);
};
function cell(measures, counts, countOnly) {
  measures = measures.map((m2) => compileMeasures(m2, m2.field));
  const cell2 = {
    num: 0,
    agg: null,
    store: false,
    count: counts
  };
  if (!countOnly) {
    var n = measures.length, a2 = cell2.agg = Array(n), i = 0;
    for (; i < n; ++i)
      a2[i] = new measures[i](cell2);
  }
  if (cell2.store) {
    var store = cell2.data = new TupleStore();
  }
  cell2.add = function(t) {
    cell2.num += 1;
    if (countOnly)
      return;
    if (store)
      store.add(t);
    for (let i2 = 0; i2 < n; ++i2) {
      a2[i2].add(a2[i2].get(t), t);
    }
  };
  cell2.rem = function(t) {
    cell2.num -= 1;
    if (countOnly)
      return;
    if (store)
      store.rem(t);
    for (let i2 = 0; i2 < n; ++i2) {
      a2[i2].rem(a2[i2].get(t), t);
    }
  };
  cell2.set = function(t) {
    let i2, n2;
    if (store)
      store.values();
    for (i2 = 0, n2 = counts.length; i2 < n2; ++i2)
      t[counts[i2]] = cell2.num;
    if (!countOnly)
      for (i2 = 0, n2 = a2.length; i2 < n2; ++i2)
        a2[i2].set(t);
  };
  cell2.init = function() {
    cell2.num = 0;
    if (store)
      store.reset();
    for (let i2 = 0; i2 < n; ++i2)
      a2[i2].init();
  };
  return cell2;
}
function Window(params2) {
  Transform.call(this, {}, params2);
  this._mlen = 0;
  this._mods = [];
}
Window.Definition = {
  type: "Window",
  metadata: {
    modifies: true
  },
  params: [{
    name: "sort",
    type: "compare"
  }, {
    name: "groupby",
    type: "field",
    array: true
  }, {
    name: "ops",
    type: "enum",
    array: true,
    values: ValidWindowOps.concat(ValidAggregateOps)
  }, {
    name: "params",
    type: "number",
    null: true,
    array: true
  }, {
    name: "fields",
    type: "field",
    null: true,
    array: true
  }, {
    name: "as",
    type: "string",
    null: true,
    array: true
  }, {
    name: "frame",
    type: "number",
    null: true,
    array: true,
    length: 2,
    default: [null, 0]
  }, {
    name: "ignorePeers",
    type: "boolean",
    default: false
  }]
};
inherits(Window, Transform, {
  transform(_, pulse2) {
    this.stamp = pulse2.stamp;
    const mod = _.modified(), cmp = stableCompare(_.sort), key2 = groupkey(_.groupby), group2 = (t) => this.group(key2(t));
    let state = this.state;
    if (!state || mod) {
      state = this.state = new WindowState(_);
    }
    if (mod || pulse2.modified(state.inputs)) {
      this.value = {};
      pulse2.visit(pulse2.SOURCE, (t) => group2(t).add(t));
    } else {
      pulse2.visit(pulse2.REM, (t) => group2(t).remove(t));
      pulse2.visit(pulse2.ADD, (t) => group2(t).add(t));
    }
    for (let i = 0, n = this._mlen; i < n; ++i) {
      processPartition(this._mods[i], state, cmp, _);
    }
    this._mlen = 0;
    this._mods = [];
    return pulse2.reflow(mod).modifies(state.outputs);
  },
  group(key2) {
    let group2 = this.value[key2];
    if (!group2) {
      group2 = this.value[key2] = SortedList(tupleid);
      group2.stamp = -1;
    }
    if (group2.stamp < this.stamp) {
      group2.stamp = this.stamp;
      this._mods[this._mlen++] = group2;
    }
    return group2;
  }
});
function processPartition(list, state, cmp, _) {
  const sort2 = _.sort, range5 = sort2 && !_.ignorePeers, frame2 = _.frame || [null, 0], data4 = list.data(cmp), n = data4.length, b2 = range5 ? bisector_default(sort2) : null, w3 = {
    i0: 0,
    i1: 0,
    p0: 0,
    p1: 0,
    index: 0,
    data: data4,
    compare: sort2 || constant(-1)
  };
  state.init();
  for (let i = 0; i < n; ++i) {
    setWindow(w3, frame2, i, n);
    if (range5)
      adjustRange(w3, b2);
    state.update(w3, data4[i]);
  }
}
function setWindow(w3, f, i, n) {
  w3.p0 = w3.i0;
  w3.p1 = w3.i1;
  w3.i0 = f[0] == null ? 0 : Math.max(0, i - Math.abs(f[0]));
  w3.i1 = f[1] == null ? n : Math.min(n, i + Math.abs(f[1]) + 1);
  w3.index = i;
}
function adjustRange(w3, bisect2) {
  const r0 = w3.i0, r1 = w3.i1 - 1, c2 = w3.compare, d = w3.data, n = d.length - 1;
  if (r0 > 0 && !c2(d[r0], d[r0 - 1]))
    w3.i0 = bisect2.left(d, d[r0]);
  if (r1 < n && !c2(d[r1], d[r1 + 1]))
    w3.i1 = bisect2.right(d, d[r1]);
}

// node_modules/vega-view-transforms/build/vega-view-transforms.module.js
var vega_view_transforms_module_exports = {};
__export(vega_view_transforms_module_exports, {
  bound: () => Bound,
  identifier: () => Identifier,
  mark: () => Mark,
  overlap: () => Overlap,
  render: () => Render,
  viewlayout: () => ViewLayout
});

// node_modules/d3-path/src/path.js
var pi = Math.PI;
var tau = 2 * pi;
var epsilon2 = 1e-6;
var tauEpsilon = tau - epsilon2;
function Path() {
  this._x0 = this._y0 = this._x1 = this._y1 = null;
  this._ = "";
}
function path() {
  return new Path();
}
Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x5, y5) {
    this._ += "M" + (this._x0 = this._x1 = +x5) + "," + (this._y0 = this._y1 = +y5);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x5, y5) {
    this._ += "L" + (this._x1 = +x5) + "," + (this._y1 = +y5);
  },
  quadraticCurveTo: function(x12, y12, x5, y5) {
    this._ += "Q" + +x12 + "," + +y12 + "," + (this._x1 = +x5) + "," + (this._y1 = +y5);
  },
  bezierCurveTo: function(x12, y12, x22, y22, x5, y5) {
    this._ += "C" + +x12 + "," + +y12 + "," + +x22 + "," + +y22 + "," + (this._x1 = +x5) + "," + (this._y1 = +y5);
  },
  arcTo: function(x12, y12, x22, y22, r2) {
    x12 = +x12, y12 = +y12, x22 = +x22, y22 = +y22, r2 = +r2;
    var x06 = this._x1, y06 = this._y1, x21 = x22 - x12, y21 = y22 - y12, x01 = x06 - x12, y01 = y06 - y12, l01_2 = x01 * x01 + y01 * y01;
    if (r2 < 0)
      throw new Error("negative radius: " + r2);
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x12) + "," + (this._y1 = y12);
    } else if (!(l01_2 > epsilon2))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon2) || !r2) {
      this._ += "L" + (this._x1 = x12) + "," + (this._y1 = y12);
    } else {
      var x20 = x22 - x06, y20 = y22 - y06, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r2 * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon2) {
        this._ += "L" + (x12 + t01 * x01) + "," + (y12 + t01 * y01);
      }
      this._ += "A" + r2 + "," + r2 + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x12 + t21 * x21) + "," + (this._y1 = y12 + t21 * y21);
    }
  },
  arc: function(x5, y5, r2, a0, a1, ccw) {
    x5 = +x5, y5 = +y5, r2 = +r2, ccw = !!ccw;
    var dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x06 = x5 + dx, y06 = y5 + dy, cw2 = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (r2 < 0)
      throw new Error("negative radius: " + r2);
    if (this._x1 === null) {
      this._ += "M" + x06 + "," + y06;
    } else if (Math.abs(this._x1 - x06) > epsilon2 || Math.abs(this._y1 - y06) > epsilon2) {
      this._ += "L" + x06 + "," + y06;
    }
    if (!r2)
      return;
    if (da < 0)
      da = da % tau + tau;
    if (da > tauEpsilon) {
      this._ += "A" + r2 + "," + r2 + ",0,1," + cw2 + "," + (x5 - dx) + "," + (y5 - dy) + "A" + r2 + "," + r2 + ",0,1," + cw2 + "," + (this._x1 = x06) + "," + (this._y1 = y06);
    } else if (da > epsilon2) {
      this._ += "A" + r2 + "," + r2 + ",0," + +(da >= pi) + "," + cw2 + "," + (this._x1 = x5 + r2 * Math.cos(a1)) + "," + (this._y1 = y5 + r2 * Math.sin(a1));
    }
  },
  rect: function(x5, y5, w3, h3) {
    this._ += "M" + (this._x0 = this._x1 = +x5) + "," + (this._y0 = this._y1 = +y5) + "h" + +w3 + "v" + +h3 + "h" + -w3 + "Z";
  },
  toString: function() {
    return this._;
  }
};
var path_default = path;

// node_modules/d3-shape/src/constant.js
function constant_default(x5) {
  return function constant2() {
    return x5;
  };
}

// node_modules/d3-shape/src/math.js
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max2 = Math.max;
var min2 = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;
var epsilon3 = 1e-12;
var pi2 = Math.PI;
var halfPi = pi2 / 2;
var tau2 = 2 * pi2;
function acos(x5) {
  return x5 > 1 ? 0 : x5 < -1 ? pi2 : Math.acos(x5);
}
function asin(x5) {
  return x5 >= 1 ? halfPi : x5 <= -1 ? -halfPi : Math.asin(x5);
}

// node_modules/d3-shape/src/arc.js
function arcInnerRadius(d) {
  return d.innerRadius;
}
function arcOuterRadius(d) {
  return d.outerRadius;
}
function arcStartAngle(d) {
  return d.startAngle;
}
function arcEndAngle(d) {
  return d.endAngle;
}
function arcPadAngle(d) {
  return d && d.padAngle;
}
function intersect(x06, y06, x12, y12, x22, y22, x32, y32) {
  var x10 = x12 - x06, y10 = y12 - y06, x322 = x32 - x22, y322 = y32 - y22, t = y322 * x10 - x322 * y10;
  if (t * t < epsilon3)
    return;
  t = (x322 * (y06 - y22) - y322 * (x06 - x22)) / t;
  return [x06 + t * x10, y06 + t * y10];
}
function cornerTangents(x06, y06, x12, y12, r1, rc, cw2) {
  var x01 = x06 - x12, y01 = y06 - y12, lo = (cw2 ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x06 + ox, y11 = y06 + oy, x10 = x12 + ox, y10 = y12 + oy, x004 = (x11 + x10) / 2, y004 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r2 = r1 - rc, D2 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt(max2(0, r2 * r2 * d2 - D2 * D2)), cx0 = (D2 * dy - dx * d) / d2, cy0 = (-D2 * dx - dy * d) / d2, cx1 = (D2 * dy + dx * d) / d2, cy1 = (-D2 * dx + dy * d) / d2, dx0 = cx0 - x004, dy0 = cy0 - y004, dx1 = cx1 - x004, dy1 = cy1 - y004;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
    cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r2 - 1),
    y11: cy0 * (r1 / r2 - 1)
  };
}
function arc_default() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context3 = null;
  function arc4() {
    var buffer, r2, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs(a1 - a0), cw2 = a1 > a0;
    if (!context3)
      context3 = buffer = path_default();
    if (r1 < r0)
      r2 = r1, r1 = r0, r0 = r2;
    if (!(r1 > epsilon3))
      context3.moveTo(0, 0);
    else if (da > tau2 - epsilon3) {
      context3.moveTo(r1 * cos(a0), r1 * sin(a0));
      context3.arc(0, 0, r1, a0, a1, !cw2);
      if (r0 > epsilon3) {
        context3.moveTo(r0 * cos(a1), r0 * sin(a1));
        context3.arc(0, 0, r0, a1, a0, cw2);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon3 && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min2(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t04, t13;
      if (rp > epsilon3) {
        var p02 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p02 * 2) > epsilon3)
          p02 *= cw2 ? 1 : -1, a00 += p02, a10 -= p02;
        else
          da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon3)
          p1 *= cw2 ? 1 : -1, a01 += p1, a11 -= p1;
        else
          da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
      if (rc > epsilon3) {
        var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x004 = r0 * cos(a00), y004 = r0 * sin(a00), oc;
        if (da < pi2 && (oc = intersect(x01, y01, x004, y004, x11, y11, x10, y10))) {
          var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min2(rc, (r0 - lc) / (kc - 1));
          rc1 = min2(rc, (r1 - lc) / (kc + 1));
        }
      }
      if (!(da1 > epsilon3))
        context3.moveTo(x01, y01);
      else if (rc1 > epsilon3) {
        t04 = cornerTangents(x004, y004, x01, y01, r1, rc1, cw2);
        t13 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw2);
        context3.moveTo(t04.cx + t04.x01, t04.cy + t04.y01);
        if (rc1 < rc)
          context3.arc(t04.cx, t04.cy, rc1, atan2(t04.y01, t04.x01), atan2(t13.y01, t13.x01), !cw2);
        else {
          context3.arc(t04.cx, t04.cy, rc1, atan2(t04.y01, t04.x01), atan2(t04.y11, t04.x11), !cw2);
          context3.arc(0, 0, r1, atan2(t04.cy + t04.y11, t04.cx + t04.x11), atan2(t13.cy + t13.y11, t13.cx + t13.x11), !cw2);
          context3.arc(t13.cx, t13.cy, rc1, atan2(t13.y11, t13.x11), atan2(t13.y01, t13.x01), !cw2);
        }
      } else
        context3.moveTo(x01, y01), context3.arc(0, 0, r1, a01, a11, !cw2);
      if (!(r0 > epsilon3) || !(da0 > epsilon3))
        context3.lineTo(x10, y10);
      else if (rc0 > epsilon3) {
        t04 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw2);
        t13 = cornerTangents(x01, y01, x004, y004, r0, -rc0, cw2);
        context3.lineTo(t04.cx + t04.x01, t04.cy + t04.y01);
        if (rc0 < rc)
          context3.arc(t04.cx, t04.cy, rc0, atan2(t04.y01, t04.x01), atan2(t13.y01, t13.x01), !cw2);
        else {
          context3.arc(t04.cx, t04.cy, rc0, atan2(t04.y01, t04.x01), atan2(t04.y11, t04.x11), !cw2);
          context3.arc(0, 0, r0, atan2(t04.cy + t04.y11, t04.cx + t04.x11), atan2(t13.cy + t13.y11, t13.cx + t13.x11), cw2);
          context3.arc(t13.cx, t13.cy, rc0, atan2(t13.y11, t13.x11), atan2(t13.y01, t13.x01), !cw2);
        }
      } else
        context3.arc(0, 0, r0, a10, a00, cw2);
    }
    context3.closePath();
    if (buffer)
      return context3 = null, buffer + "" || null;
  }
  arc4.centroid = function() {
    var r2 = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a2 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi2 / 2;
    return [cos(a2) * r2, sin(a2) * r2];
  };
  arc4.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant_default(+_), arc4) : innerRadius;
  };
  arc4.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant_default(+_), arc4) : outerRadius;
  };
  arc4.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant_default(+_), arc4) : cornerRadius;
  };
  arc4.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), arc4) : padRadius;
  };
  arc4.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default(+_), arc4) : startAngle;
  };
  arc4.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default(+_), arc4) : endAngle;
  };
  arc4.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default(+_), arc4) : padAngle;
  };
  arc4.context = function(_) {
    return arguments.length ? (context3 = _ == null ? null : _, arc4) : context3;
  };
  return arc4;
}

// node_modules/d3-shape/src/array.js
var slice = Array.prototype.slice;
function array_default(x5) {
  return typeof x5 === "object" && "length" in x5 ? x5 : Array.from(x5);
}

// node_modules/d3-shape/src/curve/linear.js
function Linear(context3) {
  this._context = context3;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x5, y5) {
    x5 = +x5, y5 = +y5;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x5, y5) : this._context.moveTo(x5, y5);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x5, y5);
        break;
    }
  }
};
function linear_default(context3) {
  return new Linear(context3);
}

// node_modules/d3-shape/src/point.js
function x(p) {
  return p[0];
}
function y(p) {
  return p[1];
}

// node_modules/d3-shape/src/line.js
function line_default(x5, y5) {
  var defined2 = constant_default(true), context3 = null, curve2 = linear_default, output3 = null;
  x5 = typeof x5 === "function" ? x5 : x5 === void 0 ? x : constant_default(x5);
  y5 = typeof y5 === "function" ? y5 : y5 === void 0 ? y : constant_default(y5);
  function line4(data4) {
    var i, n = (data4 = array_default(data4)).length, d, defined0 = false, buffer;
    if (context3 == null)
      output3 = curve2(buffer = path_default());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined2(d = data4[i], i, data4)) === defined0) {
        if (defined0 = !defined0)
          output3.lineStart();
        else
          output3.lineEnd();
      }
      if (defined0)
        output3.point(+x5(d, i, data4), +y5(d, i, data4));
    }
    if (buffer)
      return output3 = null, buffer + "" || null;
  }
  line4.x = function(_) {
    return arguments.length ? (x5 = typeof _ === "function" ? _ : constant_default(+_), line4) : x5;
  };
  line4.y = function(_) {
    return arguments.length ? (y5 = typeof _ === "function" ? _ : constant_default(+_), line4) : y5;
  };
  line4.defined = function(_) {
    return arguments.length ? (defined2 = typeof _ === "function" ? _ : constant_default(!!_), line4) : defined2;
  };
  line4.curve = function(_) {
    return arguments.length ? (curve2 = _, context3 != null && (output3 = curve2(context3)), line4) : curve2;
  };
  line4.context = function(_) {
    return arguments.length ? (_ == null ? context3 = output3 = null : output3 = curve2(context3 = _), line4) : context3;
  };
  return line4;
}

// node_modules/d3-shape/src/area.js
function area_default(x06, y06, y12) {
  var x12 = null, defined2 = constant_default(true), context3 = null, curve2 = linear_default, output3 = null;
  x06 = typeof x06 === "function" ? x06 : x06 === void 0 ? x : constant_default(+x06);
  y06 = typeof y06 === "function" ? y06 : y06 === void 0 ? constant_default(0) : constant_default(+y06);
  y12 = typeof y12 === "function" ? y12 : y12 === void 0 ? y : constant_default(+y12);
  function area4(data4) {
    var i, j, k, n = (data4 = array_default(data4)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context3 == null)
      output3 = curve2(buffer = path_default());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined2(d = data4[i], i, data4)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output3.areaStart();
          output3.lineStart();
        } else {
          output3.lineEnd();
          output3.lineStart();
          for (k = i - 1; k >= j; --k) {
            output3.point(x0z[k], y0z[k]);
          }
          output3.lineEnd();
          output3.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x06(d, i, data4), y0z[i] = +y06(d, i, data4);
        output3.point(x12 ? +x12(d, i, data4) : x0z[i], y12 ? +y12(d, i, data4) : y0z[i]);
      }
    }
    if (buffer)
      return output3 = null, buffer + "" || null;
  }
  function arealine() {
    return line_default().defined(defined2).curve(curve2).context(context3);
  }
  area4.x = function(_) {
    return arguments.length ? (x06 = typeof _ === "function" ? _ : constant_default(+_), x12 = null, area4) : x06;
  };
  area4.x0 = function(_) {
    return arguments.length ? (x06 = typeof _ === "function" ? _ : constant_default(+_), area4) : x06;
  };
  area4.x1 = function(_) {
    return arguments.length ? (x12 = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), area4) : x12;
  };
  area4.y = function(_) {
    return arguments.length ? (y06 = typeof _ === "function" ? _ : constant_default(+_), y12 = null, area4) : y06;
  };
  area4.y0 = function(_) {
    return arguments.length ? (y06 = typeof _ === "function" ? _ : constant_default(+_), area4) : y06;
  };
  area4.y1 = function(_) {
    return arguments.length ? (y12 = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), area4) : y12;
  };
  area4.lineX0 = area4.lineY0 = function() {
    return arealine().x(x06).y(y06);
  };
  area4.lineY1 = function() {
    return arealine().x(x06).y(y12);
  };
  area4.lineX1 = function() {
    return arealine().x(x12).y(y06);
  };
  area4.defined = function(_) {
    return arguments.length ? (defined2 = typeof _ === "function" ? _ : constant_default(!!_), area4) : defined2;
  };
  area4.curve = function(_) {
    return arguments.length ? (curve2 = _, context3 != null && (output3 = curve2(context3)), area4) : curve2;
  };
  area4.context = function(_) {
    return arguments.length ? (_ == null ? context3 = output3 = null : output3 = curve2(context3 = _), area4) : context3;
  };
  return area4;
}

// node_modules/d3-shape/src/symbol/circle.js
var circle_default = {
  draw: function(context3, size) {
    var r2 = Math.sqrt(size / pi2);
    context3.moveTo(r2, 0);
    context3.arc(0, 0, r2, 0, tau2);
  }
};

// node_modules/d3-shape/src/symbol.js
function symbol_default(type2, size) {
  var context3 = null;
  type2 = typeof type2 === "function" ? type2 : constant_default(type2 || circle_default);
  size = typeof size === "function" ? size : constant_default(size === void 0 ? 64 : +size);
  function symbol2() {
    var buffer;
    if (!context3)
      context3 = buffer = path_default();
    type2.apply(this, arguments).draw(context3, +size.apply(this, arguments));
    if (buffer)
      return context3 = null, buffer + "" || null;
  }
  symbol2.type = function(_) {
    return arguments.length ? (type2 = typeof _ === "function" ? _ : constant_default(_), symbol2) : type2;
  };
  symbol2.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant_default(+_), symbol2) : size;
  };
  symbol2.context = function(_) {
    return arguments.length ? (context3 = _ == null ? null : _, symbol2) : context3;
  };
  return symbol2;
}

// node_modules/d3-shape/src/noop.js
function noop_default() {
}

// node_modules/d3-shape/src/curve/basis.js
function point(that, x5, y5) {
  that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x5) / 6, (that._y0 + 4 * that._y1 + y5) / 6);
}
function Basis(context3) {
  this._context = context3;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x5, y5) {
    x5 = +x5, y5 = +y5;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x5, y5) : this._context.moveTo(x5, y5);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point(this, x5, y5);
        break;
    }
    this._x0 = this._x1, this._x1 = x5;
    this._y0 = this._y1, this._y1 = y5;
  }
};
function basis_default(context3) {
  return new Basis(context3);
}

// node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context3) {
  this._context = context3;
}
BasisClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x5, y5) {
    x5 = +x5, y5 = +y5;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x5, this._y2 = y5;
        break;
      case 1:
        this._point = 2;
        this._x3 = x5, this._y3 = y5;
        break;
      case 2:
        this._point = 3;
        this._x4 = x5, this._y4 = y5;
        this._context.moveTo((this._x0 + 4 * this._x1 + x5) / 6, (this._y0 + 4 * this._y1 + y5) / 6);
        break;
      default:
        point(this, x5, y5);
        break;
    }
    this._x0 = this._x1, this._x1 = x5;
    this._y0 = this._y1, this._y1 = y5;
  }
};
function basisClosed_default(context3) {
  return new BasisClosed(context3);
}

// node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context3) {
  this._context = context3;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x5, y5) {
    x5 = +x5, y5 = +y5;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x06 = (this._x0 + 4 * this._x1 + x5) / 6, y06 = (this._y0 + 4 * this._y1 + y5) / 6;
        this._line ? this._context.lineTo(x06, y06) : this._context.moveTo(x06, y06);
        break;
      case 3:
        this._point = 4;
      default:
        point(this, x5, y5);
        break;
    }
    this._x0 = this._x1, this._x1 = x5;
    this._y0 = this._y1, this._y1 = y5;
  }
};
function basisOpen_default(context3) {
  return new BasisOpen(context3);
}

// node_modules/d3-shape/src/curve/bundle.js
function Bundle(context3, beta) {
  this._basis = new Basis(context3);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x5 = this._x, y5 = this._y, j = x5.length - 1;
    if (j > 0) {
      var x06 = x5[0], y06 = y5[0], dx = x5[j] - x06, dy = y5[j] - y06, i = -1, t;
      while (++i <= j) {
        t = i / j;
        this._basis.point(this._beta * x5[i] + (1 - this._beta) * (x06 + t * dx), this._beta * y5[i] + (1 - this._beta) * (y06 + t * dy));
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x5, y5) {
    this._x.push(+x5);
    this._y.push(+y5);
  }
};
var bundle_default = function custom(beta) {
  function bundle2(context3) {
    return beta === 1 ? new Basis(context3) : new Bundle(context3, beta);
  }
  bundle2.beta = function(beta2) {
    return custom(+beta2);
  };
  return bundle2;
}(0.85);

// node_modules/d3-shape/src/curve/cardinal.js
function point2(that, x5, y5) {
  that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x5), that._y2 + that._k * (that._y1 - y5), that._x2, that._y2);
}
function Cardinal(context3, tension) {
  this._context = context3;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point2(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x5, y5) {
    x5 = +x5, y5 = +y5;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x5, y5) : this._context.moveTo(x5, y5);
        break;
      case 1:
        this._point = 2;
        this._x1 = x5, this._y1 = y5;
        break;
      case 2:
        this._point = 3;
      default:
        point2(this, x5, y5);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y5;
  }
};
var cardinal_default = function custom2(tension) {
  function cardinal(context3) {
    return new Cardinal(context3, tension);
  }
  cardinal.tension = function(tension2) {
    return custom2(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context3, tension) {
  this._context = context3;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x5, y5) {
    x5 = +x5, y5 = +y5;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x5, this._y3 = y5;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x5, this._y4 = y5);
        break;
      case 2:
        this._point = 3;
        this._x5 = x5, this._y5 = y5;
        break;
      default:
        point2(this, x5, y5);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y5;
  }
};
var cardinalClosed_default = function custom3(tension) {
  function cardinal(context3) {
    return new CardinalClosed(context3, tension);
  }
  cardinal.tension = function(tension2) {
    return custom3(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context3, tension) {
  this._context = context3;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x5, y5) {
    x5 = +x5, y5 = +y5;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point2(this, x5, y5);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y5;
  }
};
var cardinalOpen_default = function custom4(tension) {
  function cardinal(context3) {
    return new CardinalOpen(context3, tension);
  }
  cardinal.tension = function(tension2) {
    return custom4(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/catmullRom.js
function point3(that, x5, y5) {
  var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon3) {
    var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x12 = (x12 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y12 = (y12 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon3) {
    var b2 = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m2 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b2 + that._x1 * that._l23_2a - x5 * that._l12_2a) / m2;
    y22 = (y22 * b2 + that._y1 * that._l23_2a - y5 * that._l12_2a) / m2;
  }
  that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
}
function CatmullRom(context3, alpha) {
  this._context = context3;
  this._alpha = alpha;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x5, y5) {
    x5 = +x5, y5 = +y5;
    if (this._point) {
      var x23 = this._x2 - x5, y23 = this._y2 - y5;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x5, y5) : this._context.moveTo(x5, y5);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point3(this, x5, y5);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y5;
  }
};
var catmullRom_default = function custom5(alpha) {
  function catmullRom(context3) {
    return alpha ? new CatmullRom(context3, alpha) : new Cardinal(context3, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom5(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context3, alpha) {
  this._context = context3;
  this._alpha = alpha;
}
CatmullRomClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x5, y5) {
    x5 = +x5, y5 = +y5;
    if (this._point) {
      var x23 = this._x2 - x5, y23 = this._y2 - y5;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x5, this._y3 = y5;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x5, this._y4 = y5);
        break;
      case 2:
        this._point = 3;
        this._x5 = x5, this._y5 = y5;
        break;
      default:
        point3(this, x5, y5);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y5;
  }
};
var catmullRomClosed_default = function custom6(alpha) {
  function catmullRom(context3) {
    return alpha ? new CatmullRomClosed(context3, alpha) : new CardinalClosed(context3, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom6(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context3, alpha) {
  this._context = context3;
  this._alpha = alpha;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x5, y5) {
    x5 = +x5, y5 = +y5;
    if (this._point) {
      var x23 = this._x2 - x5, y23 = this._y2 - y5;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point3(this, x5, y5);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y5;
  }
};
var catmullRomOpen_default = function custom7(alpha) {
  function catmullRom(context3) {
    return alpha ? new CatmullRomOpen(context3, alpha) : new CardinalOpen(context3, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom7(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context3) {
  this._context = context3;
}
LinearClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point)
      this._context.closePath();
  },
  point: function(x5, y5) {
    x5 = +x5, y5 = +y5;
    if (this._point)
      this._context.lineTo(x5, y5);
    else
      this._point = 1, this._context.moveTo(x5, y5);
  }
};
function linearClosed_default(context3) {
  return new LinearClosed(context3);
}

// node_modules/d3-shape/src/curve/monotone.js
function sign(x5) {
  return x5 < 0 ? -1 : 1;
}
function slope3(that, x22, y22) {
  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(that, t) {
  var h3 = that._x1 - that._x0;
  return h3 ? (3 * (that._y1 - that._y0) / h3 - t) / 2 : t;
}
function point4(that, t04, t13) {
  var x06 = that._x0, y06 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x06) / 3;
  that._context.bezierCurveTo(x06 + dx, y06 + dx * t04, x12 - dx, y12 - dx * t13, x12, y12);
}
function MonotoneX(context3) {
  this._context = context3;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point4(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x5, y5) {
    var t13 = NaN;
    x5 = +x5, y5 = +y5;
    if (x5 === this._x1 && y5 === this._y1)
      return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x5, y5) : this._context.moveTo(x5, y5);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point4(this, slope2(this, t13 = slope3(this, x5, y5)), t13);
        break;
      default:
        point4(this, this._t0, t13 = slope3(this, x5, y5));
        break;
    }
    this._x0 = this._x1, this._x1 = x5;
    this._y0 = this._y1, this._y1 = y5;
    this._t0 = t13;
  }
};
function MonotoneY(context3) {
  this._context = new ReflectContext(context3);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x5, y5) {
  MonotoneX.prototype.point.call(this, y5, x5);
};
function ReflectContext(context3) {
  this._context = context3;
}
ReflectContext.prototype = {
  moveTo: function(x5, y5) {
    this._context.moveTo(y5, x5);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x5, y5) {
    this._context.lineTo(y5, x5);
  },
  bezierCurveTo: function(x12, y12, x22, y22, x5, y5) {
    this._context.bezierCurveTo(y12, x12, y22, x22, y5, x5);
  }
};
function monotoneX(context3) {
  return new MonotoneX(context3);
}
function monotoneY(context3) {
  return new MonotoneY(context3);
}

// node_modules/d3-shape/src/curve/natural.js
function Natural(context3) {
  this._context = context3;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x5 = this._x, y5 = this._y, n = x5.length;
    if (n) {
      this._line ? this._context.lineTo(x5[0], y5[0]) : this._context.moveTo(x5[0], y5[0]);
      if (n === 2) {
        this._context.lineTo(x5[1], y5[1]);
      } else {
        var px2 = controlPoints(x5), py2 = controlPoints(y5);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px2[0][i0], py2[0][i0], px2[1][i0], py2[1][i0], x5[i1], y5[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1)
      this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x5, y5) {
    this._x.push(+x5);
    this._y.push(+y5);
  }
};
function controlPoints(x5) {
  var i, n = x5.length - 1, m2, a2 = new Array(n), b2 = new Array(n), r2 = new Array(n);
  a2[0] = 0, b2[0] = 2, r2[0] = x5[0] + 2 * x5[1];
  for (i = 1; i < n - 1; ++i)
    a2[i] = 1, b2[i] = 4, r2[i] = 4 * x5[i] + 2 * x5[i + 1];
  a2[n - 1] = 2, b2[n - 1] = 7, r2[n - 1] = 8 * x5[n - 1] + x5[n];
  for (i = 1; i < n; ++i)
    m2 = a2[i] / b2[i - 1], b2[i] -= m2, r2[i] -= m2 * r2[i - 1];
  a2[n - 1] = r2[n - 1] / b2[n - 1];
  for (i = n - 2; i >= 0; --i)
    a2[i] = (r2[i] - a2[i + 1]) / b2[i];
  b2[n - 1] = (x5[n] + a2[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i)
    b2[i] = 2 * x5[i + 1] - a2[i + 1];
  return [a2, b2];
}
function natural_default(context3) {
  return new Natural(context3);
}

// node_modules/d3-shape/src/curve/step.js
function Step(context3, t) {
  this._context = context3;
  this._t = t;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2)
      this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    if (this._line >= 0)
      this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x5, y5) {
    x5 = +x5, y5 = +y5;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x5, y5) : this._context.moveTo(x5, y5);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y5);
          this._context.lineTo(x5, y5);
        } else {
          var x12 = this._x * (1 - this._t) + x5 * this._t;
          this._context.lineTo(x12, this._y);
          this._context.lineTo(x12, y5);
        }
        break;
      }
    }
    this._x = x5, this._y = y5;
  }
};
function step_default(context3) {
  return new Step(context3, 0.5);
}
function stepBefore(context3) {
  return new Step(context3, 0);
}
function stepAfter(context3) {
  return new Step(context3, 1);
}

// node_modules/vega-canvas/src/domCanvas.js
function domCanvas(w3, h3) {
  if (typeof document !== "undefined" && document.createElement) {
    const c2 = document.createElement("canvas");
    if (c2 && c2.getContext) {
      c2.width = w3;
      c2.height = h3;
      return c2;
    }
  }
  return null;
}
var domImage = () => typeof Image !== "undefined" ? Image : null;

// node_modules/d3-scale/src/init.js
function initRange(domain4, range5) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain4);
      break;
    default:
      this.range(range5).domain(domain4);
      break;
  }
  return this;
}
function initInterpolator(domain4, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain4 === "function")
        this.interpolator(domain4);
      else
        this.range(domain4);
      break;
    }
    default: {
      this.domain(domain4);
      if (typeof interpolator === "function")
        this.interpolator(interpolator);
      else
        this.range(interpolator);
      break;
    }
  }
  return this;
}

// node_modules/d3-scale/src/ordinal.js
var implicit = Symbol("implicit");
function ordinal() {
  var index4 = new Map(), domain4 = [], range5 = [], unknown = implicit;
  function scale7(d) {
    var key2 = d + "", i = index4.get(key2);
    if (!i) {
      if (unknown !== implicit)
        return unknown;
      index4.set(key2, i = domain4.push(d));
    }
    return range5[(i - 1) % range5.length];
  }
  scale7.domain = function(_) {
    if (!arguments.length)
      return domain4.slice();
    domain4 = [], index4 = new Map();
    for (const value3 of _) {
      const key2 = value3 + "";
      if (index4.has(key2))
        continue;
      index4.set(key2, domain4.push(value3));
    }
    return scale7;
  };
  scale7.range = function(_) {
    return arguments.length ? (range5 = Array.from(_), scale7) : range5.slice();
  };
  scale7.unknown = function(_) {
    return arguments.length ? (unknown = _, scale7) : unknown;
  };
  scale7.copy = function() {
    return ordinal(domain4, range5).unknown(unknown);
  };
  initRange.apply(scale7, arguments);
  return scale7;
}

// node_modules/d3-interpolate/src/index.js
var src_exports = {};
__export(src_exports, {
  interpolate: () => value_default,
  interpolateArray: () => array_default2,
  interpolateBasis: () => basis_default2,
  interpolateBasisClosed: () => basisClosed_default2,
  interpolateCubehelix: () => cubehelix_default,
  interpolateCubehelixLong: () => cubehelixLong,
  interpolateDate: () => date_default,
  interpolateDiscrete: () => discrete_default,
  interpolateHcl: () => hcl_default,
  interpolateHclLong: () => hclLong,
  interpolateHsl: () => hsl_default,
  interpolateHslLong: () => hslLong,
  interpolateHue: () => hue_default,
  interpolateLab: () => lab2,
  interpolateNumber: () => number_default2,
  interpolateNumberArray: () => numberArray_default,
  interpolateObject: () => object_default,
  interpolateRgb: () => rgb_default,
  interpolateRgbBasis: () => rgbBasis,
  interpolateRgbBasisClosed: () => rgbBasisClosed,
  interpolateRound: () => round_default,
  interpolateString: () => string_default,
  interpolateTransformCss: () => interpolateTransformCss,
  interpolateTransformSvg: () => interpolateTransformSvg,
  interpolateZoom: () => zoom_default,
  piecewise: () => piecewise,
  quantize: () => quantize_default2
});

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype2) {
  constructor.prototype = factory.prototype = prototype2;
  prototype2.constructor = constructor;
}
function extend2(parent, definition3) {
  var prototype2 = Object.create(parent.prototype);
  for (var key2 in definition3)
    prototype2[key2] = definition3[key2];
  return prototype2;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format8) {
  var m2, l;
  format8 = (format8 + "").trim().toLowerCase();
  return (m2 = reHex.exec(format8)) ? (l = m2[1].length, m2 = parseInt(m2[1], 16), l === 6 ? rgbn(m2) : l === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format8)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format8)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format8)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format8)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format8)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format8)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format8) ? rgbn(named[format8]) : format8 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r2, g, b2, a2) {
  if (a2 <= 0)
    r2 = g = b2 = NaN;
  return new Rgb(r2, g, b2, a2);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r2, g, b2, opacity2) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g, b2, opacity2 == null ? 1 : opacity2);
}
function Rgb(r2, g, b2, opacity2) {
  this.r = +r2;
  this.g = +g;
  this.b = +b2;
  this.opacity = +opacity2;
}
define_default(Rgb, rgb, extend2(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
  var a2 = this.opacity;
  a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
  return (a2 === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a2 === 1 ? ")" : ", " + a2 + ")");
}
function hex(value3) {
  value3 = Math.max(0, Math.min(255, Math.round(value3) || 0));
  return (value3 < 16 ? "0" : "") + value3.toString(16);
}
function hsla(h3, s, l, a2) {
  if (a2 <= 0)
    h3 = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h3 = s = NaN;
  else if (s <= 0)
    h3 = NaN;
  return new Hsl(h3, s, l, a2);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r2 = o.r / 255, g = o.g / 255, b2 = o.b / 255, min4 = Math.min(r2, g, b2), max4 = Math.max(r2, g, b2), h3 = NaN, s = max4 - min4, l = (max4 + min4) / 2;
  if (s) {
    if (r2 === max4)
      h3 = (g - b2) / s + (g < b2) * 6;
    else if (g === max4)
      h3 = (b2 - r2) / s + 2;
    else
      h3 = (r2 - g) / s + 4;
    s /= l < 0.5 ? max4 + min4 : 2 - max4 - min4;
    h3 *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h3;
  }
  return new Hsl(h3, s, l, o.opacity);
}
function hsl(h3, s, l, opacity2) {
  return arguments.length === 1 ? hslConvert(h3) : new Hsl(h3, s, l, opacity2 == null ? 1 : opacity2);
}
function Hsl(h3, s, l, opacity2) {
  this.h = +h3;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity2;
}
define_default(Hsl, hsl, extend2(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h3 = this.h % 360 + (this.h < 0) * 360, s = isNaN(h3) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(hsl2rgb(h3 >= 240 ? h3 - 240 : h3 + 120, m1, m2), hsl2rgb(h3, m1, m2), hsl2rgb(h3 < 120 ? h3 + 240 : h3 - 120, m1, m2), this.opacity);
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a2 = this.opacity;
    a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
    return (a2 === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a2 === 1 ? ")" : ", " + a2 + ")");
  }
}));
function hsl2rgb(h3, m1, m2) {
  return (h3 < 60 ? m1 + (m2 - m1) * h3 / 60 : h3 < 180 ? m2 : h3 < 240 ? m1 + (m2 - m1) * (240 - h3) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t03 = 4 / 29;
var t12 = 6 / 29;
var t2 = 3 * t12 * t12;
var t3 = t12 * t12 * t12;
function labConvert(o) {
  if (o instanceof Lab)
    return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl)
    return hcl2lab(o);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r2 = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b2 = rgb2lrgb(o.b), y5 = xyz2lab((0.2225045 * r2 + 0.7168786 * g + 0.0606169 * b2) / Yn), x5, z;
  if (r2 === g && g === b2)
    x5 = z = y5;
  else {
    x5 = xyz2lab((0.4360747 * r2 + 0.3850649 * g + 0.1430804 * b2) / Xn);
    z = xyz2lab((0.0139322 * r2 + 0.0971045 * g + 0.7141733 * b2) / Zn);
  }
  return new Lab(116 * y5 - 16, 500 * (x5 - y5), 200 * (y5 - z), o.opacity);
}
function lab(l, a2, b2, opacity2) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a2, b2, opacity2 == null ? 1 : opacity2);
}
function Lab(l, a2, b2, opacity2) {
  this.l = +l;
  this.a = +a2;
  this.b = +b2;
  this.opacity = +opacity2;
}
define_default(Lab, lab, extend2(Color, {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y5 = (this.l + 16) / 116, x5 = isNaN(this.a) ? y5 : y5 + this.a / 500, z = isNaN(this.b) ? y5 : y5 - this.b / 200;
    x5 = Xn * lab2xyz(x5);
    y5 = Yn * lab2xyz(y5);
    z = Zn * lab2xyz(z);
    return new Rgb(lrgb2rgb(3.1338561 * x5 - 1.6168667 * y5 - 0.4906146 * z), lrgb2rgb(-0.9787684 * x5 + 1.9161415 * y5 + 0.033454 * z), lrgb2rgb(0.0719453 * x5 - 0.2289914 * y5 + 1.4052427 * z), this.opacity);
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t03;
}
function lab2xyz(t) {
  return t > t12 ? t * t * t : t2 * (t - t03);
}
function lrgb2rgb(x5) {
  return 255 * (x5 <= 31308e-7 ? 12.92 * x5 : 1.055 * Math.pow(x5, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x5) {
  return (x5 /= 255) <= 0.04045 ? x5 / 12.92 : Math.pow((x5 + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl)
    return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab))
    o = labConvert(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h3 = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h3 < 0 ? h3 + 360 : h3, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h3, c2, l, opacity2) {
  return arguments.length === 1 ? hclConvert(h3) : new Hcl(h3, c2, l, opacity2 == null ? 1 : opacity2);
}
function Hcl(h3, c2, l, opacity2) {
  this.h = +h3;
  this.c = +c2;
  this.l = +l;
  this.opacity = +opacity2;
}
function hcl2lab(o) {
  if (isNaN(o.h))
    return new Lab(o.l, 0, 0, o.opacity);
  var h3 = o.h * radians;
  return new Lab(o.l, Math.cos(h3) * o.c, Math.sin(h3) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend2(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix)
    return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r2 = o.r / 255, g = o.g / 255, b2 = o.b / 255, l = (BC_DA * b2 + ED * r2 - EB * g) / (BC_DA + ED - EB), bl2 = b2 - l, k = (E * (g - l) - C * bl2) / D, s = Math.sqrt(k * k + bl2 * bl2) / (E * l * (1 - l)), h3 = s ? Math.atan2(k, bl2) * degrees - 120 : NaN;
  return new Cubehelix(h3 < 0 ? h3 + 360 : h3, s, l, o.opacity);
}
function cubehelix(h3, s, l, opacity2) {
  return arguments.length === 1 ? cubehelixConvert(h3) : new Cubehelix(h3, s, l, opacity2 == null ? 1 : opacity2);
}
function Cubehelix(h3, s, l, opacity2) {
  this.h = +h3;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity2;
}
define_default(Cubehelix, cubehelix, extend2(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h3 = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a2 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h3), sinh2 = Math.sin(h3);
    return new Rgb(255 * (l + a2 * (A * cosh2 + B * sinh2)), 255 * (l + a2 * (C * cosh2 + D * sinh2)), 255 * (l + a2 * (E * cosh2)), this.opacity);
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t13, v0, v1, v2, v3) {
  var t22 = t13 * t13, t32 = t22 * t13;
  return ((1 - 3 * t13 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t13 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default2(values4) {
  var n = values4.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values4[i], v2 = values4[i + 1], v0 = i > 0 ? values4[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values4[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default2(values4) {
  var n = values4.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values4[(i + n - 1) % n], v1 = values4[i % n], v2 = values4[(i + 1) % n], v3 = values4[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default2 = (x5) => () => x5;

// node_modules/d3-interpolate/src/color.js
function linear2(a2, d) {
  return function(t) {
    return a2 + t * d;
  };
}
function exponential(a2, b2, y5) {
  return a2 = Math.pow(a2, y5), b2 = Math.pow(b2, y5) - a2, y5 = 1 / y5, function(t) {
    return Math.pow(a2 + t * b2, y5);
  };
}
function hue(a2, b2) {
  var d = b2 - a2;
  return d ? linear2(a2, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default2(isNaN(a2) ? b2 : a2);
}
function gamma(y5) {
  return (y5 = +y5) === 1 ? nogamma : function(a2, b2) {
    return b2 - a2 ? exponential(a2, b2, y5) : constant_default2(isNaN(a2) ? b2 : a2);
  };
}
function nogamma(a2, b2) {
  var d = b2 - a2;
  return d ? linear2(a2, d) : constant_default2(isNaN(a2) ? b2 : a2);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y5) {
  var color5 = gamma(y5);
  function rgb2(start, end) {
    var r2 = color5((start = rgb(start)).r, (end = rgb(end)).r), g = color5(start.g, end.g), b2 = color5(start.b, end.b), opacity2 = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r2(t);
      start.g = g(t);
      start.b = b2(t);
      start.opacity = opacity2(t);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors2) {
    var n = colors2.length, r2 = new Array(n), g = new Array(n), b2 = new Array(n), i, color5;
    for (i = 0; i < n; ++i) {
      color5 = rgb(colors2[i]);
      r2[i] = color5.r || 0;
      g[i] = color5.g || 0;
      b2[i] = color5.b || 0;
    }
    r2 = spline(r2);
    g = spline(g);
    b2 = spline(b2);
    color5.opacity = 1;
    return function(t) {
      color5.r = r2(t);
      color5.g = g(t);
      color5.b = b2(t);
      return color5 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default2);
var rgbBasisClosed = rgbSpline(basisClosed_default2);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a2, b2) {
  if (!b2)
    b2 = [];
  var n = a2 ? Math.min(b2.length, a2.length) : 0, c2 = b2.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c2[i] = a2[i] * (1 - t) + b2[i] * t;
    return c2;
  };
}
function isNumberArray(x5) {
  return ArrayBuffer.isView(x5) && !(x5 instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function array_default2(a2, b2) {
  return (isNumberArray(b2) ? numberArray_default : genericArray)(a2, b2);
}
function genericArray(a2, b2) {
  var nb = b2 ? b2.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x5 = new Array(na), c2 = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x5[i] = value_default(a2[i], b2[i]);
  for (; i < nb; ++i)
    c2[i] = b2[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c2[i] = x5[i](t);
    return c2;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a2, b2) {
  var d = new Date();
  return a2 = +a2, b2 = +b2, function(t) {
    return d.setTime(a2 * (1 - t) + b2 * t), d;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default2(a2, b2) {
  return a2 = +a2, b2 = +b2, function(t) {
    return a2 * (1 - t) + b2 * t;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a2, b2) {
  var i = {}, c2 = {}, k;
  if (a2 === null || typeof a2 !== "object")
    a2 = {};
  if (b2 === null || typeof b2 !== "object")
    b2 = {};
  for (k in b2) {
    if (k in a2) {
      i[k] = value_default(a2[k], b2[k]);
    } else {
      c2[k] = b2[k];
    }
  }
  return function(t) {
    for (k in i)
      c2[k] = i[k](t);
    return c2;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero2(b2) {
  return function() {
    return b2;
  };
}
function one2(b2) {
  return function(t) {
    return b2(t) + "";
  };
}
function string_default(a2, b2) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a2 = a2 + "", b2 = b2 + "";
  while ((am = reA.exec(a2)) && (bm = reB.exec(b2))) {
    if ((bs = bm.index) > bi) {
      bs = b2.slice(bi, bs);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i])
        s[i] += bm;
      else
        s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({i, x: number_default2(am, bm)});
    }
    bi = reB.lastIndex;
  }
  if (bi < b2.length) {
    bs = b2.slice(bi);
    if (s[i])
      s[i] += bs;
    else
      s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one2(q[0].x) : zero2(b2) : (b2 = q.length, function(t) {
    for (var i2 = 0, o; i2 < b2; ++i2)
      s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a2, b2) {
  var t = typeof b2, c2;
  return b2 == null || t === "boolean" ? constant_default2(b2) : (t === "number" ? number_default2 : t === "string" ? (c2 = color(b2)) ? (b2 = c2, rgb_default) : string_default : b2 instanceof color ? rgb_default : b2 instanceof Date ? date_default : isNumberArray(b2) ? numberArray_default : Array.isArray(b2) ? genericArray : typeof b2.valueOf !== "function" && typeof b2.toString !== "function" || isNaN(b2) ? object_default : number_default2)(a2, b2);
}

// node_modules/d3-interpolate/src/discrete.js
function discrete_default(range5) {
  var n = range5.length;
  return function(t) {
    return range5[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

// node_modules/d3-interpolate/src/hue.js
function hue_default(a2, b2) {
  var i = hue(+a2, +b2);
  return function(t) {
    var x5 = i(t);
    return x5 - 360 * Math.floor(x5 / 360);
  };
}

// node_modules/d3-interpolate/src/round.js
function round_default(a2, b2) {
  return a2 = +a2, b2 = +b2, function(t) {
    return Math.round(a2 * (1 - t) + b2 * t);
  };
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity2 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a2, b2, c2, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a2 * a2 + b2 * b2))
    a2 /= scaleX, b2 /= scaleX;
  if (skewX = a2 * c2 + b2 * d)
    c2 -= a2 * skewX, d -= b2 * skewX;
  if (scaleY = Math.sqrt(c2 * c2 + d * d))
    c2 /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a2 * d < b2 * c2)
    a2 = -a2, b2 = -b2, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b2, a2) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value3) {
  const m2 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value3 + "");
  return m2.isIdentity ? identity2 : decompose_default(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
}
function parseSvg(value3) {
  if (value3 == null)
    return identity2;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value3);
  if (!(value3 = svgNode.transform.baseVal.consolidate()))
    return identity2;
  value3 = value3.matrix;
  return decompose_default(value3.a, value3.b, value3.c, value3.d, value3.e, value3.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse6, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate4(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: number_default2(xa, xb)}, {i: i - 2, x: number_default2(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate2(a2, b2, s, q) {
    if (a2 !== b2) {
      if (a2 - b2 > 180)
        b2 += 360;
      else if (b2 - a2 > 180)
        a2 += 360;
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number_default2(a2, b2)});
    } else if (b2) {
      s.push(pop(s) + "rotate(" + b2 + degParen);
    }
  }
  function skewX(a2, b2, s, q) {
    if (a2 !== b2) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number_default2(a2, b2)});
    } else if (b2) {
      s.push(pop(s) + "skewX(" + b2 + degParen);
    }
  }
  function scale7(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: number_default2(xa, xb)}, {i: i - 2, x: number_default2(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a2, b2) {
    var s = [], q = [];
    a2 = parse6(a2), b2 = parse6(b2);
    translate4(a2.translateX, a2.translateY, b2.translateX, b2.translateY, s, q);
    rotate2(a2.rotate, b2.rotate, s, q);
    skewX(a2.skewX, b2.skewX, s, q);
    scale7(a2.scaleX, a2.scaleY, b2.scaleX, b2.scaleY, s, q);
    a2 = b2 = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon22 = 1e-12;
function cosh(x5) {
  return ((x5 = Math.exp(x5)) + 1 / x5) / 2;
}
function sinh(x5) {
  return ((x5 = Math.exp(x5)) - 1 / x5) / 2;
}
function tanh(x5) {
  return ((x5 = Math.exp(2 * x5)) - 1) / (x5 + 1);
}
var zoom_default = function zoomRho(rho, rho2, rho4) {
  function zoom3(p02, p1) {
    var ux0 = p02[0], uy0 = p02[1], w0 = p02[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon22) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom3.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom3;
}(Math.SQRT2, 2, 4);

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start, end) {
    var h3 = hue2((start = hsl(start)).h, (end = hsl(end)).h), s = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity2 = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h3(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity2(t);
      return start + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/lab.js
function lab2(start, end) {
  var l = nogamma((start = lab(start)).l, (end = lab(end)).l), a2 = nogamma(start.a, end.a), b2 = nogamma(start.b, end.b), opacity2 = nogamma(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a2(t);
    start.b = b2(t);
    start.opacity = opacity2(t);
    return start + "";
  };
}

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start, end) {
    var h3 = hue2((start = hcl(start)).h, (end = hcl(end)).h), c2 = nogamma(start.c, end.c), l = nogamma(start.l, end.l), opacity2 = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h3(t);
      start.c = c2(t);
      start.l = l(t);
      start.opacity = opacity2(t);
      return start + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y5) {
    y5 = +y5;
    function cubehelix3(start, end) {
      var h3 = hue2((start = cubehelix(start)).h, (end = cubehelix(end)).h), s = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity2 = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h3(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y5));
        start.opacity = opacity2(t);
        return start + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-interpolate/src/piecewise.js
function piecewise(interpolate3, values4) {
  if (values4 === void 0)
    values4 = interpolate3, interpolate3 = value_default;
  var i = 0, n = values4.length - 1, v = values4[0], I = new Array(n < 0 ? 0 : n);
  while (i < n)
    I[i] = interpolate3(v, v = values4[++i]);
  return function(t) {
    var i2 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i2](t - i2);
  };
}

// node_modules/d3-interpolate/src/quantize.js
function quantize_default2(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i)
    samples[i] = interpolator(i / (n - 1));
  return samples;
}

// node_modules/d3-scale/src/constant.js
function constants(x5) {
  return function() {
    return x5;
  };
}

// node_modules/d3-scale/src/number.js
function number(x5) {
  return +x5;
}

// node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity3(x5) {
  return x5;
}
function normalize(a2, b2) {
  return (b2 -= a2 = +a2) ? function(x5) {
    return (x5 - a2) / b2;
  } : constants(isNaN(b2) ? NaN : 0.5);
}
function clamper(a2, b2) {
  var t;
  if (a2 > b2)
    t = a2, a2 = b2, b2 = t;
  return function(x5) {
    return Math.max(a2, Math.min(b2, x5));
  };
}
function bimap(domain4, range5, interpolate3) {
  var d0 = domain4[0], d1 = domain4[1], r0 = range5[0], r1 = range5[1];
  if (d1 < d0)
    d0 = normalize(d1, d0), r0 = interpolate3(r1, r0);
  else
    d0 = normalize(d0, d1), r0 = interpolate3(r0, r1);
  return function(x5) {
    return r0(d0(x5));
  };
}
function polymap(domain4, range5, interpolate3) {
  var j = Math.min(domain4.length, range5.length) - 1, d = new Array(j), r2 = new Array(j), i = -1;
  if (domain4[j] < domain4[0]) {
    domain4 = domain4.slice().reverse();
    range5 = range5.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize(domain4[i], domain4[i + 1]);
    r2[i] = interpolate3(range5[i], range5[i + 1]);
  }
  return function(x5) {
    var i2 = bisect_default2(domain4, x5, 1, j) - 1;
    return r2[i2](d[i2](x5));
  };
}
function copy(source4, target) {
  return target.domain(source4.domain()).range(source4.range()).interpolate(source4.interpolate()).clamp(source4.clamp()).unknown(source4.unknown());
}
function transformer() {
  var domain4 = unit, range5 = unit, interpolate3 = value_default, transform4, untransform, unknown, clamp2 = identity3, piecewise2, output3, input;
  function rescale() {
    var n = Math.min(domain4.length, range5.length);
    if (clamp2 !== identity3)
      clamp2 = clamper(domain4[0], domain4[n - 1]);
    piecewise2 = n > 2 ? polymap : bimap;
    output3 = input = null;
    return scale7;
  }
  function scale7(x5) {
    return isNaN(x5 = +x5) ? unknown : (output3 || (output3 = piecewise2(domain4.map(transform4), range5, interpolate3)))(transform4(clamp2(x5)));
  }
  scale7.invert = function(y5) {
    return clamp2(untransform((input || (input = piecewise2(range5, domain4.map(transform4), number_default2)))(y5)));
  };
  scale7.domain = function(_) {
    return arguments.length ? (domain4 = Array.from(_, number), rescale()) : domain4.slice();
  };
  scale7.range = function(_) {
    return arguments.length ? (range5 = Array.from(_), rescale()) : range5.slice();
  };
  scale7.rangeRound = function(_) {
    return range5 = Array.from(_), interpolate3 = round_default, rescale();
  };
  scale7.clamp = function(_) {
    return arguments.length ? (clamp2 = _ ? true : identity3, rescale()) : clamp2 !== identity3;
  };
  scale7.interpolate = function(_) {
    return arguments.length ? (interpolate3 = _, rescale()) : interpolate3;
  };
  scale7.unknown = function(_) {
    return arguments.length ? (unknown = _, scale7) : unknown;
  };
  return function(t, u) {
    transform4 = t, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity3, identity3);
}

// node_modules/d3-scale/node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default2(x5) {
  return Math.abs(x5 = Math.round(x5)) >= 1e21 ? x5.toLocaleString("en").replace(/,/g, "") : x5.toString(10);
}
function formatDecimalParts2(x5, p) {
  if ((i = (x5 = p ? x5.toExponential(p - 1) : x5.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x5.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x5.slice(i + 1)
  ];
}

// node_modules/d3-scale/node_modules/d3-format/src/exponent.js
function exponent_default2(x5) {
  return x5 = formatDecimalParts2(Math.abs(x5)), x5 ? x5[1] : NaN;
}

// node_modules/d3-scale/node_modules/d3-format/src/formatGroup.js
function formatGroup_default2(grouping, thousands) {
  return function(value3, width2) {
    var i = value3.length, t = [], j = 0, g = grouping[0], length3 = 0;
    while (i > 0 && g > 0) {
      if (length3 + g + 1 > width2)
        g = Math.max(1, width2 - length3);
      t.push(value3.substring(i -= g, i + g));
      if ((length3 += g + 1) > width2)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// node_modules/d3-scale/node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default2(numerals) {
  return function(value3) {
    return value3.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// node_modules/d3-scale/node_modules/d3-format/src/formatSpecifier.js
var re2 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier2(specifier) {
  if (!(match3 = re2.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match3;
  return new FormatSpecifier2({
    fill: match3[1],
    align: match3[2],
    sign: match3[3],
    symbol: match3[4],
    zero: match3[5],
    width: match3[6],
    comma: match3[7],
    precision: match3[8] && match3[8].slice(1),
    trim: match3[9],
    type: match3[10]
  });
}
formatSpecifier2.prototype = FormatSpecifier2.prototype;
function FormatSpecifier2(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier2.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-scale/node_modules/d3-format/src/formatTrim.js
function formatTrim_default2(s) {
  out:
    for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

// node_modules/d3-scale/node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent2;
function formatPrefixAuto_default2(x5, p) {
  var d = formatDecimalParts2(x5, p);
  if (!d)
    return x5 + "";
  var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent2 = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts2(x5, Math.max(0, p + i - 1))[0];
}

// node_modules/d3-scale/node_modules/d3-format/src/formatRounded.js
function formatRounded_default2(x5, p) {
  var d = formatDecimalParts2(x5, p);
  if (!d)
    return x5 + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-scale/node_modules/d3-format/src/formatTypes.js
var formatTypes_default2 = {
  "%": (x5, p) => (x5 * 100).toFixed(p),
  b: (x5) => Math.round(x5).toString(2),
  c: (x5) => x5 + "",
  d: formatDecimal_default2,
  e: (x5, p) => x5.toExponential(p),
  f: (x5, p) => x5.toFixed(p),
  g: (x5, p) => x5.toPrecision(p),
  o: (x5) => Math.round(x5).toString(8),
  p: (x5, p) => formatRounded_default2(x5 * 100, p),
  r: formatRounded_default2,
  s: formatPrefixAuto_default2,
  X: (x5) => Math.round(x5).toString(16).toUpperCase(),
  x: (x5) => Math.round(x5).toString(16)
};

// node_modules/d3-scale/node_modules/d3-format/src/identity.js
function identity_default3(x5) {
  return x5;
}

// node_modules/d3-scale/node_modules/d3-format/src/locale.js
var map2 = Array.prototype.map;
var prefixes2 = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default2(locale6) {
  var group2 = locale6.grouping === void 0 || locale6.thousands === void 0 ? identity_default3 : formatGroup_default2(map2.call(locale6.grouping, Number), locale6.thousands + ""), currencyPrefix = locale6.currency === void 0 ? "" : locale6.currency[0] + "", currencySuffix = locale6.currency === void 0 ? "" : locale6.currency[1] + "", decimal = locale6.decimal === void 0 ? "." : locale6.decimal + "", numerals = locale6.numerals === void 0 ? identity_default3 : formatNumerals_default2(map2.call(locale6.numerals, String)), percent = locale6.percent === void 0 ? "%" : locale6.percent + "", minus = locale6.minus === void 0 ? "\u2212" : locale6.minus + "", nan = locale6.nan === void 0 ? "NaN" : locale6.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier2(specifier);
    var fill2 = specifier.fill, align2 = specifier.align, sign3 = specifier.sign, symbol2 = specifier.symbol, zero7 = specifier.zero, width2 = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;
    if (type2 === "n")
      comma = true, type2 = "g";
    else if (!formatTypes_default2[type2])
      precision === void 0 && (precision = 12), trim = true, type2 = "g";
    if (zero7 || fill2 === "0" && align2 === "=")
      zero7 = true, fill2 = "0", align2 = "=";
    var prefix = symbol2 === "$" ? currencyPrefix : symbol2 === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol2 === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes_default2[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format8(value3) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c2;
      if (type2 === "c") {
        valueSuffix = formatType(value3) + valueSuffix;
        value3 = "";
      } else {
        value3 = +value3;
        var valueNegative = value3 < 0 || 1 / value3 < 0;
        value3 = isNaN(value3) ? nan : formatType(Math.abs(value3), precision);
        if (trim)
          value3 = formatTrim_default2(value3);
        if (valueNegative && +value3 === 0 && sign3 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign3 === "(" ? sign3 : minus : sign3 === "-" || sign3 === "(" ? "" : sign3) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes2[8 + prefixExponent2 / 3] : "") + valueSuffix + (valueNegative && sign3 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value3.length;
          while (++i < n) {
            if (c2 = value3.charCodeAt(i), 48 > c2 || c2 > 57) {
              valueSuffix = (c2 === 46 ? decimal + value3.slice(i + 1) : value3.slice(i)) + valueSuffix;
              value3 = value3.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero7)
        value3 = group2(value3, Infinity);
      var length3 = valuePrefix.length + value3.length + valueSuffix.length, padding3 = length3 < width2 ? new Array(width2 - length3 + 1).join(fill2) : "";
      if (comma && zero7)
        value3 = group2(padding3 + value3, padding3.length ? width2 - valueSuffix.length : Infinity), padding3 = "";
      switch (align2) {
        case "<":
          value3 = valuePrefix + value3 + valueSuffix + padding3;
          break;
        case "=":
          value3 = valuePrefix + padding3 + value3 + valueSuffix;
          break;
        case "^":
          value3 = padding3.slice(0, length3 = padding3.length >> 1) + valuePrefix + value3 + valueSuffix + padding3.slice(length3);
          break;
        default:
          value3 = padding3 + valuePrefix + value3 + valueSuffix;
          break;
      }
      return numerals(value3);
    }
    format8.toString = function() {
      return specifier + "";
    };
    return format8;
  }
  function formatPrefix4(specifier, value3) {
    var f = newFormat((specifier = formatSpecifier2(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default2(value3) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes2[8 + e / 3];
    return function(value4) {
      return f(k * value4) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix4
  };
}

// node_modules/d3-scale/node_modules/d3-format/src/defaultLocale.js
var locale4;
var format3;
var formatPrefix2;
defaultLocale4({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale4(definition3) {
  locale4 = locale_default2(definition3);
  format3 = locale4.format;
  formatPrefix2 = locale4.formatPrefix;
  return locale4;
}

// node_modules/d3-scale/node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default2(step) {
  return Math.max(0, -exponent_default2(Math.abs(step)));
}

// node_modules/d3-scale/node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default2(step, value3) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default2(value3) / 3))) * 3 - exponent_default2(Math.abs(step)));
}

// node_modules/d3-scale/node_modules/d3-format/src/precisionRound.js
function precisionRound_default2(step, max4) {
  step = Math.abs(step), max4 = Math.abs(max4) - step;
  return Math.max(0, exponent_default2(max4) - exponent_default2(step)) + 1;
}

// node_modules/d3-scale/src/tickFormat.js
function tickFormat(start, stop2, count2, specifier) {
  var step = tickStep(start, stop2, count2), precision;
  specifier = formatSpecifier2(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value3 = Math.max(Math.abs(start), Math.abs(stop2));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default2(step, value3)))
        specifier.precision = precision;
      return formatPrefix2(specifier, value3);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default2(step, Math.max(Math.abs(start), Math.abs(stop2)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default2(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format3(specifier);
}

// node_modules/d3-scale/src/linear.js
function linearish(scale7) {
  var domain4 = scale7.domain;
  scale7.ticks = function(count2) {
    var d = domain4();
    return ticks_default(d[0], d[d.length - 1], count2 == null ? 10 : count2);
  };
  scale7.tickFormat = function(count2, specifier) {
    var d = domain4();
    return tickFormat(d[0], d[d.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale7.nice = function(count2) {
    if (count2 == null)
      count2 = 10;
    var d = domain4();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop2 = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop2 < start) {
      step = start, start = stop2, stop2 = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop2, count2);
      if (step === prestep) {
        d[i0] = start;
        d[i1] = stop2;
        return domain4(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop2 = Math.ceil(stop2 / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop2 = Math.floor(stop2 * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale7;
  };
  return scale7;
}
function linear3() {
  var scale7 = continuous();
  scale7.copy = function() {
    return copy(scale7, linear3());
  };
  initRange.apply(scale7, arguments);
  return linearish(scale7);
}

// node_modules/d3-scale/src/identity.js
function identity4(domain4) {
  var unknown;
  function scale7(x5) {
    return isNaN(x5 = +x5) ? unknown : x5;
  }
  scale7.invert = scale7;
  scale7.domain = scale7.range = function(_) {
    return arguments.length ? (domain4 = Array.from(_, number), scale7) : domain4.slice();
  };
  scale7.unknown = function(_) {
    return arguments.length ? (unknown = _, scale7) : unknown;
  };
  scale7.copy = function() {
    return identity4(domain4).unknown(unknown);
  };
  domain4 = arguments.length ? Array.from(domain4, number) : [0, 1];
  return linearish(scale7);
}

// node_modules/d3-scale/src/nice.js
function nice(domain4, interval3) {
  domain4 = domain4.slice();
  var i0 = 0, i1 = domain4.length - 1, x06 = domain4[i0], x12 = domain4[i1], t;
  if (x12 < x06) {
    t = i0, i0 = i1, i1 = t;
    t = x06, x06 = x12, x12 = t;
  }
  domain4[i0] = interval3.floor(x06);
  domain4[i1] = interval3.ceil(x12);
  return domain4;
}

// node_modules/d3-scale/src/log.js
function transformLog(x5) {
  return Math.log(x5);
}
function transformExp(x5) {
  return Math.exp(x5);
}
function transformLogn(x5) {
  return -Math.log(-x5);
}
function transformExpn(x5) {
  return -Math.exp(-x5);
}
function pow10(x5) {
  return isFinite(x5) ? +("1e" + x5) : x5 < 0 ? 0 : x5;
}
function powp(base2) {
  return base2 === 10 ? pow10 : base2 === Math.E ? Math.exp : function(x5) {
    return Math.pow(base2, x5);
  };
}
function logp(base2) {
  return base2 === Math.E ? Math.log : base2 === 10 && Math.log10 || base2 === 2 && Math.log2 || (base2 = Math.log(base2), function(x5) {
    return Math.log(x5) / base2;
  });
}
function reflect(f) {
  return function(x5) {
    return -f(-x5);
  };
}
function loggish(transform4) {
  var scale7 = transform4(transformLog, transformExp), domain4 = scale7.domain, base2 = 10, logs, pows;
  function rescale() {
    logs = logp(base2), pows = powp(base2);
    if (domain4()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform4(transformLogn, transformExpn);
    } else {
      transform4(transformLog, transformExp);
    }
    return scale7;
  }
  scale7.base = function(_) {
    return arguments.length ? (base2 = +_, rescale()) : base2;
  };
  scale7.domain = function(_) {
    return arguments.length ? (domain4(_), rescale()) : domain4();
  };
  scale7.ticks = function(count2) {
    var d = domain4(), u = d[0], v = d[d.length - 1], r2;
    if (r2 = v < u)
      i = u, u = v, v = i;
    var i = logs(u), j = logs(v), p, k, t, n = count2 == null ? 10 : +count2, z = [];
    if (!(base2 % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u > 0)
        for (; i <= j; ++i) {
          for (k = 1, p = pows(i); k < base2; ++k) {
            t = p * k;
            if (t < u)
              continue;
            if (t > v)
              break;
            z.push(t);
          }
        }
      else
        for (; i <= j; ++i) {
          for (k = base2 - 1, p = pows(i); k >= 1; --k) {
            t = p * k;
            if (t < u)
              continue;
            if (t > v)
              break;
            z.push(t);
          }
        }
      if (z.length * 2 < n)
        z = ticks_default(u, v, n);
    } else {
      z = ticks_default(i, j, Math.min(j - i, n)).map(pows);
    }
    return r2 ? z.reverse() : z;
  };
  scale7.tickFormat = function(count2, specifier) {
    if (specifier == null)
      specifier = base2 === 10 ? ".0e" : ",";
    if (typeof specifier !== "function")
      specifier = format3(specifier);
    if (count2 === Infinity)
      return specifier;
    if (count2 == null)
      count2 = 10;
    var k = Math.max(1, base2 * count2 / scale7.ticks().length);
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base2 < base2 - 0.5)
        i *= base2;
      return i <= k ? specifier(d) : "";
    };
  };
  scale7.nice = function() {
    return domain4(nice(domain4(), {
      floor: function(x5) {
        return pows(Math.floor(logs(x5)));
      },
      ceil: function(x5) {
        return pows(Math.ceil(logs(x5)));
      }
    }));
  };
  return scale7;
}
function log3() {
  var scale7 = loggish(transformer()).domain([1, 10]);
  scale7.copy = function() {
    return copy(scale7, log3()).base(scale7.base());
  };
  initRange.apply(scale7, arguments);
  return scale7;
}

// node_modules/d3-scale/src/symlog.js
function transformSymlog(c2) {
  return function(x5) {
    return Math.sign(x5) * Math.log1p(Math.abs(x5 / c2));
  };
}
function transformSymexp(c2) {
  return function(x5) {
    return Math.sign(x5) * Math.expm1(Math.abs(x5)) * c2;
  };
}
function symlogish(transform4) {
  var c2 = 1, scale7 = transform4(transformSymlog(c2), transformSymexp(c2));
  scale7.constant = function(_) {
    return arguments.length ? transform4(transformSymlog(c2 = +_), transformSymexp(c2)) : c2;
  };
  return linearish(scale7);
}
function symlog2() {
  var scale7 = symlogish(transformer());
  scale7.copy = function() {
    return copy(scale7, symlog2()).constant(scale7.constant());
  };
  return initRange.apply(scale7, arguments);
}

// node_modules/d3-scale/src/pow.js
function transformPow(exponent) {
  return function(x5) {
    return x5 < 0 ? -Math.pow(-x5, exponent) : Math.pow(x5, exponent);
  };
}
function transformSqrt(x5) {
  return x5 < 0 ? -Math.sqrt(-x5) : Math.sqrt(x5);
}
function transformSquare(x5) {
  return x5 < 0 ? -x5 * x5 : x5 * x5;
}
function powish(transform4) {
  var scale7 = transform4(identity3, identity3), exponent = 1;
  function rescale() {
    return exponent === 1 ? transform4(identity3, identity3) : exponent === 0.5 ? transform4(transformSqrt, transformSquare) : transform4(transformPow(exponent), transformPow(1 / exponent));
  }
  scale7.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };
  return linearish(scale7);
}
function pow3() {
  var scale7 = powish(transformer());
  scale7.copy = function() {
    return copy(scale7, pow3()).exponent(scale7.exponent());
  };
  initRange.apply(scale7, arguments);
  return scale7;
}
function sqrt2() {
  return pow3.apply(null, arguments).exponent(0.5);
}

// node_modules/d3-scale/src/quantile.js
function quantile2() {
  var domain4 = [], range5 = [], thresholds = [], unknown;
  function rescale() {
    var i = 0, n = Math.max(1, range5.length);
    thresholds = new Array(n - 1);
    while (++i < n)
      thresholds[i - 1] = quantileSorted(domain4, i / n);
    return scale7;
  }
  function scale7(x5) {
    return isNaN(x5 = +x5) ? unknown : range5[bisect_default2(thresholds, x5)];
  }
  scale7.invertExtent = function(y5) {
    var i = range5.indexOf(y5);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain4[0],
      i < thresholds.length ? thresholds[i] : domain4[domain4.length - 1]
    ];
  };
  scale7.domain = function(_) {
    if (!arguments.length)
      return domain4.slice();
    domain4 = [];
    for (let d of _)
      if (d != null && !isNaN(d = +d))
        domain4.push(d);
    domain4.sort(ascending_default);
    return rescale();
  };
  scale7.range = function(_) {
    return arguments.length ? (range5 = Array.from(_), rescale()) : range5.slice();
  };
  scale7.unknown = function(_) {
    return arguments.length ? (unknown = _, scale7) : unknown;
  };
  scale7.quantiles = function() {
    return thresholds.slice();
  };
  scale7.copy = function() {
    return quantile2().domain(domain4).range(range5).unknown(unknown);
  };
  return initRange.apply(scale7, arguments);
}

// node_modules/d3-scale/src/quantize.js
function quantize() {
  var x06 = 0, x12 = 1, n = 1, domain4 = [0.5], range5 = [0, 1], unknown;
  function scale7(x5) {
    return x5 <= x5 ? range5[bisect_default2(domain4, x5, 0, n)] : unknown;
  }
  function rescale() {
    var i = -1;
    domain4 = new Array(n);
    while (++i < n)
      domain4[i] = ((i + 1) * x12 - (i - n) * x06) / (n + 1);
    return scale7;
  }
  scale7.domain = function(_) {
    return arguments.length ? ([x06, x12] = _, x06 = +x06, x12 = +x12, rescale()) : [x06, x12];
  };
  scale7.range = function(_) {
    return arguments.length ? (n = (range5 = Array.from(_)).length - 1, rescale()) : range5.slice();
  };
  scale7.invertExtent = function(y5) {
    var i = range5.indexOf(y5);
    return i < 0 ? [NaN, NaN] : i < 1 ? [x06, domain4[0]] : i >= n ? [domain4[n - 1], x12] : [domain4[i - 1], domain4[i]];
  };
  scale7.unknown = function(_) {
    return arguments.length ? (unknown = _, scale7) : scale7;
  };
  scale7.thresholds = function() {
    return domain4.slice();
  };
  scale7.copy = function() {
    return quantize().domain([x06, x12]).range(range5).unknown(unknown);
  };
  return initRange.apply(linearish(scale7), arguments);
}

// node_modules/d3-scale/src/threshold.js
function threshold() {
  var domain4 = [0.5], range5 = [0, 1], unknown, n = 1;
  function scale7(x5) {
    return x5 <= x5 ? range5[bisect_default2(domain4, x5, 0, n)] : unknown;
  }
  scale7.domain = function(_) {
    return arguments.length ? (domain4 = Array.from(_), n = Math.min(domain4.length, range5.length - 1), scale7) : domain4.slice();
  };
  scale7.range = function(_) {
    return arguments.length ? (range5 = Array.from(_), n = Math.min(domain4.length, range5.length - 1), scale7) : range5.slice();
  };
  scale7.invertExtent = function(y5) {
    var i = range5.indexOf(y5);
    return [domain4[i - 1], domain4[i]];
  };
  scale7.unknown = function(_) {
    return arguments.length ? (unknown = _, scale7) : unknown;
  };
  scale7.copy = function() {
    return threshold().domain(domain4).range(range5).unknown(unknown);
  };
  return initRange.apply(scale7, arguments);
}

// node_modules/d3-scale/src/time.js
var durationSecond3 = 1e3;
var durationMinute3 = durationSecond3 * 60;
var durationHour3 = durationMinute3 * 60;
var durationDay3 = durationHour3 * 24;
var durationWeek3 = durationDay3 * 7;
var durationMonth2 = durationDay3 * 30;
var durationYear2 = durationDay3 * 365;
function date(t) {
  return new Date(t);
}
function number2(t) {
  return t instanceof Date ? +t : +new Date(+t);
}
function calendar(year2, month2, week2, day2, hour2, minute2, second2, millisecond2, format8) {
  var scale7 = continuous(), invert3 = scale7.invert, domain4 = scale7.domain;
  var formatMillisecond = format8(".%L"), formatSecond = format8(":%S"), formatMinute = format8("%I:%M"), formatHour = format8("%I %p"), formatDay = format8("%a %d"), formatWeek = format8("%b %d"), formatMonth = format8("%B"), formatYear3 = format8("%Y");
  var tickIntervals = [
    [second2, 1, durationSecond3],
    [second2, 5, 5 * durationSecond3],
    [second2, 15, 15 * durationSecond3],
    [second2, 30, 30 * durationSecond3],
    [minute2, 1, durationMinute3],
    [minute2, 5, 5 * durationMinute3],
    [minute2, 15, 15 * durationMinute3],
    [minute2, 30, 30 * durationMinute3],
    [hour2, 1, durationHour3],
    [hour2, 3, 3 * durationHour3],
    [hour2, 6, 6 * durationHour3],
    [hour2, 12, 12 * durationHour3],
    [day2, 1, durationDay3],
    [day2, 2, 2 * durationDay3],
    [week2, 1, durationWeek3],
    [month2, 1, durationMonth2],
    [month2, 3, 3 * durationMonth2],
    [year2, 1, durationYear2]
  ];
  function tickFormat3(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute2(date2) < date2 ? formatSecond : hour2(date2) < date2 ? formatMinute : day2(date2) < date2 ? formatHour : month2(date2) < date2 ? week2(date2) < date2 ? formatDay : formatWeek : year2(date2) < date2 ? formatMonth : formatYear3)(date2);
  }
  function tickInterval(interval3, start, stop2) {
    if (interval3 == null)
      interval3 = 10;
    if (typeof interval3 === "number") {
      var target = Math.abs(stop2 - start) / interval3, i = bisector_default(function(i2) {
        return i2[2];
      }).right(tickIntervals, target), step;
      if (i === tickIntervals.length) {
        step = tickStep(start / durationYear2, stop2 / durationYear2, interval3);
        interval3 = year2;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval3 = i[0];
      } else {
        step = Math.max(tickStep(start, stop2, interval3), 1);
        interval3 = millisecond2;
      }
      return interval3.every(step);
    }
    return interval3;
  }
  scale7.invert = function(y5) {
    return new Date(invert3(y5));
  };
  scale7.domain = function(_) {
    return arguments.length ? domain4(Array.from(_, number2)) : domain4().map(date);
  };
  scale7.ticks = function(interval3) {
    var d = domain4(), t04 = d[0], t13 = d[d.length - 1], r2 = t13 < t04, t;
    if (r2)
      t = t04, t04 = t13, t13 = t;
    t = tickInterval(interval3, t04, t13);
    t = t ? t.range(t04, t13 + 1) : [];
    return r2 ? t.reverse() : t;
  };
  scale7.tickFormat = function(count2, specifier) {
    return specifier == null ? tickFormat3 : format8(specifier);
  };
  scale7.nice = function(interval3) {
    var d = domain4();
    return (interval3 = tickInterval(interval3, d[0], d[d.length - 1])) ? domain4(nice(d, interval3)) : scale7;
  };
  scale7.copy = function() {
    return copy(scale7, calendar(year2, month2, week2, day2, hour2, minute2, second2, millisecond2, format8));
  };
  return scale7;
}
function time() {
  return initRange.apply(calendar(year_default, month_default, sunday, day_default, hour_default, minute_default, second_default, millisecond_default, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}

// node_modules/d3-scale/src/utcTime.js
function utcTime() {
  return initRange.apply(calendar(utcYear_default, utcMonth_default, utcSunday, utcDay_default, utcHour_default, utcMinute_default, second_default, millisecond_default, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}

// node_modules/d3-scale/src/sequential.js
function transformer2() {
  var x06 = 0, x12 = 1, t04, t13, k10, transform4, interpolator = identity3, clamp2 = false, unknown;
  function scale7(x5) {
    return isNaN(x5 = +x5) ? unknown : interpolator(k10 === 0 ? 0.5 : (x5 = (transform4(x5) - t04) * k10, clamp2 ? Math.max(0, Math.min(1, x5)) : x5));
  }
  scale7.domain = function(_) {
    return arguments.length ? ([x06, x12] = _, t04 = transform4(x06 = +x06), t13 = transform4(x12 = +x12), k10 = t04 === t13 ? 0 : 1 / (t13 - t04), scale7) : [x06, x12];
  };
  scale7.clamp = function(_) {
    return arguments.length ? (clamp2 = !!_, scale7) : clamp2;
  };
  scale7.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale7) : interpolator;
  };
  function range5(interpolate3) {
    return function(_) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _, interpolator = interpolate3(r0, r1), scale7) : [interpolator(0), interpolator(1)];
    };
  }
  scale7.range = range5(value_default);
  scale7.rangeRound = range5(round_default);
  scale7.unknown = function(_) {
    return arguments.length ? (unknown = _, scale7) : unknown;
  };
  return function(t) {
    transform4 = t, t04 = t(x06), t13 = t(x12), k10 = t04 === t13 ? 0 : 1 / (t13 - t04);
    return scale7;
  };
}
function copy2(source4, target) {
  return target.domain(source4.domain()).interpolator(source4.interpolator()).clamp(source4.clamp()).unknown(source4.unknown());
}
function sequential() {
  var scale7 = linearish(transformer2()(identity3));
  scale7.copy = function() {
    return copy2(scale7, sequential());
  };
  return initInterpolator.apply(scale7, arguments);
}
function sequentialLog() {
  var scale7 = loggish(transformer2()).domain([1, 10]);
  scale7.copy = function() {
    return copy2(scale7, sequentialLog()).base(scale7.base());
  };
  return initInterpolator.apply(scale7, arguments);
}
function sequentialSymlog() {
  var scale7 = symlogish(transformer2());
  scale7.copy = function() {
    return copy2(scale7, sequentialSymlog()).constant(scale7.constant());
  };
  return initInterpolator.apply(scale7, arguments);
}
function sequentialPow() {
  var scale7 = powish(transformer2());
  scale7.copy = function() {
    return copy2(scale7, sequentialPow()).exponent(scale7.exponent());
  };
  return initInterpolator.apply(scale7, arguments);
}
function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}

// node_modules/d3-scale/src/diverging.js
function transformer3() {
  var x06 = 0, x12 = 0.5, x22 = 1, s = 1, t04, t13, t22, k10, k21, interpolator = identity3, transform4, clamp2 = false, unknown;
  function scale7(x5) {
    return isNaN(x5 = +x5) ? unknown : (x5 = 0.5 + ((x5 = +transform4(x5)) - t13) * (s * x5 < s * t13 ? k10 : k21), interpolator(clamp2 ? Math.max(0, Math.min(1, x5)) : x5));
  }
  scale7.domain = function(_) {
    return arguments.length ? ([x06, x12, x22] = _, t04 = transform4(x06 = +x06), t13 = transform4(x12 = +x12), t22 = transform4(x22 = +x22), k10 = t04 === t13 ? 0 : 0.5 / (t13 - t04), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s = t13 < t04 ? -1 : 1, scale7) : [x06, x12, x22];
  };
  scale7.clamp = function(_) {
    return arguments.length ? (clamp2 = !!_, scale7) : clamp2;
  };
  scale7.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale7) : interpolator;
  };
  function range5(interpolate3) {
    return function(_) {
      var r0, r1, r2;
      return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate3, [r0, r1, r2]), scale7) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }
  scale7.range = range5(value_default);
  scale7.rangeRound = range5(round_default);
  scale7.unknown = function(_) {
    return arguments.length ? (unknown = _, scale7) : unknown;
  };
  return function(t) {
    transform4 = t, t04 = t(x06), t13 = t(x12), t22 = t(x22), k10 = t04 === t13 ? 0 : 0.5 / (t13 - t04), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s = t13 < t04 ? -1 : 1;
    return scale7;
  };
}
function diverging() {
  var scale7 = linearish(transformer3()(identity3));
  scale7.copy = function() {
    return copy2(scale7, diverging());
  };
  return initInterpolator.apply(scale7, arguments);
}
function divergingLog() {
  var scale7 = loggish(transformer3()).domain([0.1, 1, 10]);
  scale7.copy = function() {
    return copy2(scale7, divergingLog()).base(scale7.base());
  };
  return initInterpolator.apply(scale7, arguments);
}
function divergingSymlog() {
  var scale7 = symlogish(transformer3());
  scale7.copy = function() {
    return copy2(scale7, divergingSymlog()).constant(scale7.constant());
  };
  return initInterpolator.apply(scale7, arguments);
}
function divergingPow() {
  var scale7 = powish(transformer3());
  scale7.copy = function() {
    return copy2(scale7, divergingPow()).exponent(scale7.exponent());
  };
  return initInterpolator.apply(scale7, arguments);
}
function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}

// node_modules/vega-scale/build/vega-scale.module.js
function bandSpace(count2, paddingInner2, paddingOuter2) {
  const space = count2 - paddingInner2 + paddingOuter2 * 2;
  return count2 ? space > 0 ? space : 1 : 0;
}
var Identity = "identity";
var Linear2 = "linear";
var Log = "log";
var Pow = "pow";
var Sqrt = "sqrt";
var Symlog = "symlog";
var Time = "time";
var UTC = "utc";
var Sequential = "sequential";
var Diverging = "diverging";
var Quantile2 = "quantile";
var Quantize = "quantize";
var Threshold = "threshold";
var Ordinal = "ordinal";
var Point = "point";
var Band = "band";
var BinOrdinal = "bin-ordinal";
var Continuous = "continuous";
var Discrete = "discrete";
var Discretizing = "discretizing";
var Interpolating = "interpolating";
var Temporal = "temporal";
function invertRange(scale7) {
  return function(_) {
    let lo = _[0], hi = _[1], t;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    return [scale7.invert(lo), scale7.invert(hi)];
  };
}
function invertRangeExtent(scale7) {
  return function(_) {
    const range5 = scale7.range();
    let lo = _[0], hi = _[1], min4 = -1, max4, t, i, n;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    for (i = 0, n = range5.length; i < n; ++i) {
      if (range5[i] >= lo && range5[i] <= hi) {
        if (min4 < 0)
          min4 = i;
        max4 = i;
      }
    }
    if (min4 < 0)
      return void 0;
    lo = scale7.invertExtent(range5[min4]);
    hi = scale7.invertExtent(range5[max4]);
    return [lo[0] === void 0 ? lo[1] : lo[0], hi[1] === void 0 ? hi[0] : hi[1]];
  };
}
function band() {
  const scale7 = ordinal().unknown(void 0), domain4 = scale7.domain, ordinalRange = scale7.range;
  let range$1 = [0, 1], step, bandwidth3, round = false, paddingInner2 = 0, paddingOuter2 = 0, align2 = 0.5;
  delete scale7.unknown;
  function rescale() {
    const n = domain4().length, reverse4 = range$1[1] < range$1[0], stop2 = range$1[1 - reverse4], space = bandSpace(n, paddingInner2, paddingOuter2);
    let start = range$1[reverse4 - 0];
    step = (stop2 - start) / (space || 1);
    if (round) {
      step = Math.floor(step);
    }
    start += (stop2 - start - step * (n - paddingInner2)) * align2;
    bandwidth3 = step * (1 - paddingInner2);
    if (round) {
      start = Math.round(start);
      bandwidth3 = Math.round(bandwidth3);
    }
    const values4 = range_default(n).map((i) => start + step * i);
    return ordinalRange(reverse4 ? values4.reverse() : values4);
  }
  scale7.domain = function(_) {
    if (arguments.length) {
      domain4(_);
      return rescale();
    } else {
      return domain4();
    }
  };
  scale7.range = function(_) {
    if (arguments.length) {
      range$1 = [+_[0], +_[1]];
      return rescale();
    } else {
      return range$1.slice();
    }
  };
  scale7.rangeRound = function(_) {
    range$1 = [+_[0], +_[1]];
    round = true;
    return rescale();
  };
  scale7.bandwidth = function() {
    return bandwidth3;
  };
  scale7.step = function() {
    return step;
  };
  scale7.round = function(_) {
    if (arguments.length) {
      round = !!_;
      return rescale();
    } else {
      return round;
    }
  };
  scale7.padding = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      paddingInner2 = paddingOuter2;
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale7.paddingInner = function(_) {
    if (arguments.length) {
      paddingInner2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale7.paddingOuter = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingOuter2;
    }
  };
  scale7.align = function(_) {
    if (arguments.length) {
      align2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return align2;
    }
  };
  scale7.invertRange = function(_) {
    if (_[0] == null || _[1] == null)
      return;
    const reverse4 = range$1[1] < range$1[0], values4 = reverse4 ? ordinalRange().reverse() : ordinalRange(), n = values4.length - 1;
    let lo = +_[0], hi = +_[1], a2, b2, t;
    if (lo !== lo || hi !== hi)
      return;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    if (hi < values4[0] || lo > range$1[1 - reverse4])
      return;
    a2 = Math.max(0, bisectRight(values4, lo) - 1);
    b2 = lo === hi ? a2 : bisectRight(values4, hi) - 1;
    if (lo - values4[a2] > bandwidth3 + 1e-10)
      ++a2;
    if (reverse4) {
      t = a2;
      a2 = n - b2;
      b2 = n - t;
    }
    return a2 > b2 ? void 0 : domain4().slice(a2, b2 + 1);
  };
  scale7.invert = function(_) {
    const value3 = scale7.invertRange([_, _]);
    return value3 ? value3[0] : value3;
  };
  scale7.copy = function() {
    return band().domain(domain4()).range(range$1).round(round).paddingInner(paddingInner2).paddingOuter(paddingOuter2).align(align2);
  };
  return rescale();
}
function pointish(scale7) {
  const copy5 = scale7.copy;
  scale7.padding = scale7.paddingOuter;
  delete scale7.paddingInner;
  scale7.copy = function() {
    return pointish(copy5());
  };
  return scale7;
}
function point5() {
  return pointish(band().paddingInner(1));
}
var map3 = Array.prototype.map;
function numbers3(_) {
  return map3.call(_, toNumber);
}
var slice2 = Array.prototype.slice;
function scaleBinOrdinal() {
  let domain4 = [], range5 = [];
  function scale7(x5) {
    return x5 == null || x5 !== x5 ? void 0 : range5[(bisect_default2(domain4, x5) - 1) % range5.length];
  }
  scale7.domain = function(_) {
    if (arguments.length) {
      domain4 = numbers3(_);
      return scale7;
    } else {
      return domain4.slice();
    }
  };
  scale7.range = function(_) {
    if (arguments.length) {
      range5 = slice2.call(_);
      return scale7;
    } else {
      return range5.slice();
    }
  };
  scale7.tickFormat = function(count2, specifier) {
    return tickFormat(domain4[0], peek(domain4), count2 == null ? 10 : count2, specifier);
  };
  scale7.copy = function() {
    return scaleBinOrdinal().domain(scale7.domain()).range(scale7.range());
  };
  return scale7;
}
var scales = {};
function create(type2, constructor, metadata2) {
  const ctr = function scale7() {
    const s = constructor();
    if (!s.invertRange) {
      s.invertRange = s.invert ? invertRange(s) : s.invertExtent ? invertRangeExtent(s) : void 0;
    }
    s.type = type2;
    return s;
  };
  ctr.metadata = toSet(array(metadata2));
  return ctr;
}
function scale(type2, scale7, metadata2) {
  if (arguments.length > 1) {
    scales[type2] = create(type2, scale7, metadata2);
    return this;
  } else {
    return isValidScaleType(type2) ? scales[type2] : void 0;
  }
}
scale(Identity, identity4);
scale(Linear2, linear3, Continuous);
scale(Log, log3, [Continuous, Log]);
scale(Pow, pow3, Continuous);
scale(Sqrt, sqrt2, Continuous);
scale(Symlog, symlog2, Continuous);
scale(Time, time, [Continuous, Temporal]);
scale(UTC, utcTime, [Continuous, Temporal]);
scale(Sequential, sequential, [Continuous, Interpolating]);
scale("".concat(Sequential, "-").concat(Linear2), sequential, [Continuous, Interpolating]);
scale("".concat(Sequential, "-").concat(Log), sequentialLog, [Continuous, Interpolating, Log]);
scale("".concat(Sequential, "-").concat(Pow), sequentialPow, [Continuous, Interpolating]);
scale("".concat(Sequential, "-").concat(Sqrt), sequentialSqrt, [Continuous, Interpolating]);
scale("".concat(Sequential, "-").concat(Symlog), sequentialSymlog, [Continuous, Interpolating]);
scale("".concat(Diverging, "-").concat(Linear2), diverging, [Continuous, Interpolating]);
scale("".concat(Diverging, "-").concat(Log), divergingLog, [Continuous, Interpolating, Log]);
scale("".concat(Diverging, "-").concat(Pow), divergingPow, [Continuous, Interpolating]);
scale("".concat(Diverging, "-").concat(Sqrt), divergingSqrt, [Continuous, Interpolating]);
scale("".concat(Diverging, "-").concat(Symlog), divergingSymlog, [Continuous, Interpolating]);
scale(Quantile2, quantile2, [Discretizing, Quantile2]);
scale(Quantize, quantize, Discretizing);
scale(Threshold, threshold, Discretizing);
scale(BinOrdinal, scaleBinOrdinal, [Discrete, Discretizing]);
scale(Ordinal, ordinal, Discrete);
scale(Band, band, Discrete);
scale(Point, point5, Discrete);
function isValidScaleType(type2) {
  return has(scales, type2);
}
function hasType(key2, type2) {
  const s = scales[key2];
  return s && s.metadata[type2];
}
function isContinuous(key2) {
  return hasType(key2, Continuous);
}
function isDiscrete(key2) {
  return hasType(key2, Discrete);
}
function isDiscretizing(key2) {
  return hasType(key2, Discretizing);
}
function isLogarithmic(key2) {
  return hasType(key2, Log);
}
function isTemporal(key2) {
  return hasType(key2, Temporal);
}
function isInterpolating(key2) {
  return hasType(key2, Interpolating);
}
function isQuantile(key2) {
  return hasType(key2, Quantile2);
}
var scaleProps = ["clamp", "base", "constant", "exponent"];
function interpolateRange(interpolator, range5) {
  const start = range5[0], span2 = peek(range5) - start;
  return function(i) {
    return interpolator(start + i * span2);
  };
}
function interpolateColors(colors2, type2, gamma2) {
  return piecewise(interpolate(type2 || "rgb", gamma2), colors2);
}
function quantizeInterpolator(interpolator, count2) {
  const samples = new Array(count2), n = count2 + 1;
  for (let i = 0; i < count2; )
    samples[i] = interpolator(++i / n);
  return samples;
}
function scaleFraction(scale$12, min4, max4) {
  const delta = max4 - min4;
  let i, t, s;
  if (!delta || !Number.isFinite(delta)) {
    return constant(0.5);
  } else {
    i = (t = scale$12.type).indexOf("-");
    t = i < 0 ? t : t.slice(i + 1);
    s = scale(t)().domain([min4, max4]).range([0, 1]);
    scaleProps.forEach((m2) => scale$12[m2] ? s[m2](scale$12[m2]()) : 0);
    return s;
  }
}
function interpolate(type2, gamma2) {
  const interp = src_exports[method(type2)];
  return gamma2 != null && interp && interp.gamma ? interp.gamma(gamma2) : interp;
}
function method(type2) {
  return "interpolate" + type2.toLowerCase().split("-").map((s) => s[0].toUpperCase() + s.slice(1)).join("");
}
var continuous2 = {
  blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
  greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
  greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
  oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
  purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
  reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
  blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
  bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
  greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
  orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
  purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
  purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
  purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
  redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
  yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
  yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
  yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
  blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
  brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
  purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
  purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
  redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
  redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
  yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
  redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
  redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
  pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
  spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
  viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
  magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
  inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
  plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
  cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
  rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
  sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
  turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
  browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
  tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
  teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
  warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
  goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
  goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
  goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
  lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
  lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
  lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
  lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
  lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
  darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
  darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
  darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
  darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
  darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
};
var discrete = {
  category10: "1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf",
  category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
  category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
  category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
  tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
  tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5",
  accent: "7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666",
  dark2: "1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666",
  paired: "a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928",
  pastel1: "fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2",
  pastel2: "b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc",
  set1: "e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999",
  set2: "66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3",
  set3: "8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"
};
function colors(palette) {
  const n = palette.length / 6 | 0, c2 = new Array(n);
  for (let i = 0; i < n; ) {
    c2[i] = "#" + palette.slice(i * 6, ++i * 6);
  }
  return c2;
}
function apply(_, f) {
  for (const k in _)
    scheme(k, f(_[k]));
}
var schemes = {};
apply(discrete, colors);
apply(continuous2, (_) => interpolateColors(colors(_)));
function scheme(name4, scheme2) {
  name4 = name4 && name4.toLowerCase();
  if (arguments.length > 1) {
    schemes[name4] = scheme2;
    return this;
  } else {
    return schemes[name4];
  }
}
var SymbolLegend = "symbol";
var DiscreteLegend = "discrete";
var GradientLegend = "gradient";
var defaultFormatter = (value3) => isArray(value3) ? value3.map((v) => String(v)) : String(value3);
var ascending2 = (a2, b2) => a2[1] - b2[1];
var descending = (a2, b2) => b2[1] - a2[1];
function tickCount(scale7, count2, minStep) {
  let step;
  if (isNumber(count2)) {
    if (scale7.bins) {
      count2 = Math.max(count2, scale7.bins.length);
    }
    if (minStep != null) {
      count2 = Math.min(count2, Math.floor(span(scale7.domain()) / minStep || 1));
    }
  }
  if (isObject(count2)) {
    step = count2.step;
    count2 = count2.interval;
  }
  if (isString(count2)) {
    count2 = scale7.type === Time ? timeInterval(count2) : scale7.type == UTC ? utcInterval(count2) : error("Only time and utc scales accept interval strings.");
    if (step)
      count2 = count2.every(step);
  }
  return count2;
}
function validTicks(scale7, ticks, count2) {
  let range5 = scale7.range(), lo = range5[0], hi = peek(range5), cmp = ascending2;
  if (lo > hi) {
    range5 = hi;
    hi = lo;
    lo = range5;
    cmp = descending;
  }
  lo = Math.floor(lo);
  hi = Math.ceil(hi);
  ticks = ticks.map((v) => [v, scale7(v)]).filter((_) => lo <= _[1] && _[1] <= hi).sort(cmp).map((_) => _[0]);
  if (count2 > 0 && ticks.length > 1) {
    const endpoints = [ticks[0], peek(ticks)];
    while (ticks.length > count2 && ticks.length >= 3) {
      ticks = ticks.filter((_, i) => !(i % 2));
    }
    if (ticks.length < 3) {
      ticks = endpoints;
    }
  }
  return ticks;
}
function tickValues(scale7, count2) {
  return scale7.bins ? validTicks(scale7, scale7.bins) : scale7.ticks ? scale7.ticks(count2) : scale7.domain();
}
function tickFormat2(locale6, scale7, count2, specifier, formatType, noSkip) {
  const type2 = scale7.type;
  let format8 = defaultFormatter;
  if (type2 === Time || formatType === Time) {
    format8 = locale6.timeFormat(specifier);
  } else if (type2 === UTC || formatType === UTC) {
    format8 = locale6.utcFormat(specifier);
  } else if (isLogarithmic(type2)) {
    const varfmt = locale6.formatFloat(specifier);
    if (noSkip || scale7.bins) {
      format8 = varfmt;
    } else {
      const test2 = tickLog(scale7, count2, false);
      format8 = (_) => test2(_) ? varfmt(_) : "";
    }
  } else if (scale7.tickFormat) {
    const d = scale7.domain();
    format8 = locale6.formatSpan(d[0], d[d.length - 1], count2, specifier);
  } else if (specifier) {
    format8 = locale6.format(specifier);
  }
  return format8;
}
function tickLog(scale7, count2, values4) {
  const ticks = tickValues(scale7, count2), base2 = scale7.base(), logb = Math.log(base2), k = Math.max(1, base2 * count2 / ticks.length);
  const test2 = (d) => {
    let i = d / Math.pow(base2, Math.round(Math.log(d) / logb));
    if (i * base2 < base2 - 0.5)
      i *= base2;
    return i <= k;
  };
  return values4 ? ticks.filter(test2) : test2;
}
var symbols = {
  [Quantile2]: "quantiles",
  [Quantize]: "thresholds",
  [Threshold]: "domain"
};
var formats2 = {
  [Quantile2]: "quantiles",
  [Quantize]: "domain"
};
function labelValues(scale7, count2) {
  return scale7.bins ? binValues(scale7.bins) : scale7.type === Log ? tickLog(scale7, count2, true) : symbols[scale7.type] ? thresholdValues(scale7[symbols[scale7.type]]()) : tickValues(scale7, count2);
}
function thresholdFormat(locale6, scale7, specifier) {
  const _ = scale7[formats2[scale7.type]](), n = _.length;
  let d = n > 1 ? _[1] - _[0] : _[0], i;
  for (i = 1; i < n; ++i) {
    d = Math.min(d, _[i] - _[i - 1]);
  }
  return locale6.formatSpan(0, d, 3 * 10, specifier);
}
function thresholdValues(thresholds) {
  const values4 = [-Infinity].concat(thresholds);
  values4.max = Infinity;
  return values4;
}
function binValues(bins2) {
  const values4 = bins2.slice(0, -1);
  values4.max = peek(bins2);
  return values4;
}
var isDiscreteRange = (scale7) => symbols[scale7.type] || scale7.bins;
function labelFormat(locale6, scale7, count2, type2, specifier, formatType, noSkip) {
  const format8 = formats2[scale7.type] && formatType !== Time && formatType !== UTC ? thresholdFormat(locale6, scale7, specifier) : tickFormat2(locale6, scale7, count2, specifier, formatType, noSkip);
  return type2 === SymbolLegend && isDiscreteRange(scale7) ? formatRange(format8) : type2 === DiscreteLegend ? formatDiscrete(format8) : formatPoint(format8);
}
var formatRange = (format8) => (value3, index4, array5) => {
  const limit = get2(array5[index4 + 1], get2(array5.max, Infinity)), lo = formatValue(value3, format8), hi = formatValue(limit, format8);
  return lo && hi ? lo + " \u2013 " + hi : hi ? "< " + hi : "\u2265 " + lo;
};
var get2 = (value3, dflt) => value3 != null ? value3 : dflt;
var formatDiscrete = (format8) => (value3, index4) => index4 ? format8(value3) : null;
var formatPoint = (format8) => (value3) => format8(value3);
var formatValue = (value3, format8) => Number.isFinite(value3) ? format8(value3) : null;
function labelFraction(scale7) {
  const domain4 = scale7.domain(), count2 = domain4.length - 1;
  let lo = +domain4[0], hi = +peek(domain4), span2 = hi - lo;
  if (scale7.type === Threshold) {
    const adjust = count2 ? span2 / count2 : 0.1;
    lo -= adjust;
    hi += adjust;
    span2 = hi - lo;
  }
  return (value3) => (value3 - lo) / span2;
}
function format4(locale6, scale7, specifier, formatType) {
  const type2 = formatType || scale7.type;
  if (isString(specifier) && isTemporal(type2)) {
    specifier = specifier.replace(/%a/g, "%A").replace(/%b/g, "%B");
  }
  return !specifier && type2 === Time ? locale6.timeFormat("%A, %d %B %Y, %X") : !specifier && type2 === UTC ? locale6.utcFormat("%A, %d %B %Y, %X UTC") : labelFormat(locale6, scale7, 5, null, specifier, formatType, true);
}
function domainCaption(locale6, scale7, opt) {
  opt = opt || {};
  const max4 = Math.max(3, opt.maxlen || 7), fmt = format4(locale6, scale7, opt.format, opt.formatType);
  if (isDiscretizing(scale7.type)) {
    const v = labelValues(scale7).slice(1).map(fmt), n = v.length;
    return "".concat(n, " boundar").concat(n === 1 ? "y" : "ies", ": ").concat(v.join(", "));
  } else if (isDiscrete(scale7.type)) {
    const d = scale7.domain(), n = d.length, v = n > max4 ? d.slice(0, max4 - 2).map(fmt).join(", ") + ", ending with " + d.slice(-1).map(fmt) : d.map(fmt).join(", ");
    return "".concat(n, " value").concat(n === 1 ? "" : "s", ": ").concat(v);
  } else {
    const d = scale7.domain();
    return "values from ".concat(fmt(d[0]), " to ").concat(fmt(peek(d)));
  }
}

// node_modules/vega-scenegraph/build/vega-scenegraph.module.js
var gradient_id = 0;
function resetSVGGradientId() {
  gradient_id = 0;
}
var patternPrefix = "p_";
function isGradient(value3) {
  return value3 && value3.gradient;
}
function gradientRef(g, defs, base2) {
  const type2 = g.gradient;
  let id4 = g.id, prefix = type2 === "radial" ? patternPrefix : "";
  if (!id4) {
    id4 = g.id = "gradient_" + gradient_id++;
    if (type2 === "radial") {
      g.x1 = get3(g.x1, 0.5);
      g.y1 = get3(g.y1, 0.5);
      g.r1 = get3(g.r1, 0);
      g.x2 = get3(g.x2, 0.5);
      g.y2 = get3(g.y2, 0.5);
      g.r2 = get3(g.r2, 0.5);
      prefix = patternPrefix;
    } else {
      g.x1 = get3(g.x1, 0);
      g.y1 = get3(g.y1, 0);
      g.x2 = get3(g.x2, 1);
      g.y2 = get3(g.y2, 0);
    }
  }
  defs[id4] = g;
  return "url(" + (base2 || "") + "#" + prefix + id4 + ")";
}
function get3(val, def2) {
  return val != null ? val : def2;
}
function Gradient(p02, p1) {
  var stops = [], gradient4;
  return gradient4 = {
    gradient: "linear",
    x1: p02 ? p02[0] : 0,
    y1: p02 ? p02[1] : 0,
    x2: p1 ? p1[0] : 1,
    y2: p1 ? p1[1] : 0,
    stops,
    stop: function(offset4, color5) {
      stops.push({
        offset: offset4,
        color: color5
      });
      return gradient4;
    }
  };
}
var lookup = {
  basis: {
    curve: basis_default
  },
  "basis-closed": {
    curve: basisClosed_default
  },
  "basis-open": {
    curve: basisOpen_default
  },
  bundle: {
    curve: bundle_default,
    tension: "beta",
    value: 0.85
  },
  cardinal: {
    curve: cardinal_default,
    tension: "tension",
    value: 0
  },
  "cardinal-open": {
    curve: cardinalOpen_default,
    tension: "tension",
    value: 0
  },
  "cardinal-closed": {
    curve: cardinalClosed_default,
    tension: "tension",
    value: 0
  },
  "catmull-rom": {
    curve: catmullRom_default,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-closed": {
    curve: catmullRomClosed_default,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-open": {
    curve: catmullRomOpen_default,
    tension: "alpha",
    value: 0.5
  },
  linear: {
    curve: linear_default
  },
  "linear-closed": {
    curve: linearClosed_default
  },
  monotone: {
    horizontal: monotoneY,
    vertical: monotoneX
  },
  natural: {
    curve: natural_default
  },
  step: {
    curve: step_default
  },
  "step-after": {
    curve: stepAfter
  },
  "step-before": {
    curve: stepBefore
  }
};
function curves(type2, orientation, tension) {
  var entry2 = has(lookup, type2) && lookup[type2], curve2 = null;
  if (entry2) {
    curve2 = entry2.curve || entry2[orientation || "vertical"];
    if (entry2.tension && tension != null) {
      curve2 = curve2[entry2.tension](tension);
    }
  }
  return curve2;
}
var cmdlen = {
  m: 2,
  l: 2,
  h: 1,
  v: 1,
  c: 6,
  s: 4,
  q: 4,
  t: 2,
  a: 7
};
var regexp = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\.\d+)(\.\d)/g, /(\d)([-+])/g, /\s|,|###/];
function pathParse(pathstr) {
  const result = [];
  let curr, chunks, parsed, param2, cmd, len, i, j, n, m2;
  const path3 = pathstr.slice().replace(regexp[0], "###$1").split(regexp[1]).slice(1);
  for (i = 0, n = path3.length; i < n; ++i) {
    curr = path3[i];
    chunks = curr.slice(1).trim().replace(regexp[2], "$1###$2").replace(regexp[3], "$1###$2").split(regexp[4]);
    cmd = curr.charAt(0);
    parsed = [cmd];
    for (j = 0, m2 = chunks.length; j < m2; ++j) {
      if ((param2 = +chunks[j]) === param2) {
        parsed.push(param2);
      }
    }
    len = cmdlen[cmd.toLowerCase()];
    if (parsed.length - 1 > len) {
      const m3 = parsed.length;
      j = 1;
      result.push([cmd].concat(parsed.slice(j, j += len)));
      cmd = cmd === "M" ? "L" : cmd === "m" ? "l" : cmd;
      for (; j < m3; j += len) {
        result.push([cmd].concat(parsed.slice(j, j + len)));
      }
    } else {
      result.push(parsed);
    }
  }
  return result;
}
var DegToRad = Math.PI / 180;
var Epsilon = 1e-14;
var HalfPi = Math.PI / 2;
var Tau = Math.PI * 2;
var HalfSqrt3 = Math.sqrt(3) / 2;
var segmentCache = {};
var bezierCache = {};
var join = [].join;
function segments(x5, y5, rx, ry, large, sweep, rotateX, ox, oy) {
  const key2 = join.call(arguments);
  if (segmentCache[key2]) {
    return segmentCache[key2];
  }
  const th = rotateX * DegToRad;
  const sin_th = Math.sin(th);
  const cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const px2 = cos_th * (ox - x5) * 0.5 + sin_th * (oy - y5) * 0.5;
  const py2 = cos_th * (oy - y5) * 0.5 - sin_th * (ox - x5) * 0.5;
  let pl = px2 * px2 / (rx * rx) + py2 * py2 / (ry * ry);
  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }
  const a00 = cos_th / rx;
  const a01 = sin_th / rx;
  const a10 = -sin_th / ry;
  const a11 = cos_th / ry;
  const x06 = a00 * ox + a01 * oy;
  const y06 = a10 * ox + a11 * oy;
  const x12 = a00 * x5 + a01 * y5;
  const y12 = a10 * x5 + a11 * y5;
  const d = (x12 - x06) * (x12 - x06) + (y12 - y06) * (y12 - y06);
  let sfactor_sq = 1 / d - 0.25;
  if (sfactor_sq < 0)
    sfactor_sq = 0;
  let sfactor = Math.sqrt(sfactor_sq);
  if (sweep == large)
    sfactor = -sfactor;
  const xc = 0.5 * (x06 + x12) - sfactor * (y12 - y06);
  const yc = 0.5 * (y06 + y12) + sfactor * (x12 - x06);
  const th0 = Math.atan2(y06 - yc, x06 - xc);
  const th1 = Math.atan2(y12 - yc, x12 - xc);
  let th_arc = th1 - th0;
  if (th_arc < 0 && sweep === 1) {
    th_arc += Tau;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= Tau;
  }
  const segs = Math.ceil(Math.abs(th_arc / (HalfPi + 1e-3)));
  const result = [];
  for (let i = 0; i < segs; ++i) {
    const th2 = th0 + i * th_arc / segs;
    const th3 = th0 + (i + 1) * th_arc / segs;
    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return segmentCache[key2] = result;
}
function bezier(params2) {
  const key2 = join.call(params2);
  if (bezierCache[key2]) {
    return bezierCache[key2];
  }
  var cx = params2[0], cy = params2[1], th0 = params2[2], th1 = params2[3], rx = params2[4], ry = params2[5], sin_th = params2[6], cos_th = params2[7];
  const a00 = cos_th * rx;
  const a01 = -sin_th * ry;
  const a10 = sin_th * rx;
  const a11 = cos_th * ry;
  const cos_th0 = Math.cos(th0);
  const sin_th0 = Math.sin(th0);
  const cos_th1 = Math.cos(th1);
  const sin_th1 = Math.sin(th1);
  const th_half = 0.5 * (th1 - th0);
  const sin_th_h2 = Math.sin(th_half * 0.5);
  const t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);
  const x12 = cx + cos_th0 - t * sin_th0;
  const y12 = cy + sin_th0 + t * cos_th0;
  const x32 = cx + cos_th1;
  const y32 = cy + sin_th1;
  const x22 = x32 + t * sin_th1;
  const y22 = y32 - t * cos_th1;
  return bezierCache[key2] = [a00 * x12 + a01 * y12, a10 * x12 + a11 * y12, a00 * x22 + a01 * y22, a10 * x22 + a11 * y22, a00 * x32 + a01 * y32, a10 * x32 + a11 * y32];
}
var temp = ["l", 0, 0, 0, 0, 0, 0, 0];
function scale2(current2, sX, sY) {
  const c2 = temp[0] = current2[0];
  if (c2 === "a" || c2 === "A") {
    temp[1] = sX * current2[1];
    temp[2] = sY * current2[2];
    temp[3] = current2[3];
    temp[4] = current2[4];
    temp[5] = current2[5];
    temp[6] = sX * current2[6];
    temp[7] = sY * current2[7];
  } else if (c2 === "h" || c2 === "H") {
    temp[1] = sX * current2[1];
  } else if (c2 === "v" || c2 === "V") {
    temp[1] = sY * current2[1];
  } else {
    for (var i = 1, n = current2.length; i < n; ++i) {
      temp[i] = (i % 2 == 1 ? sX : sY) * current2[i];
    }
  }
  return temp;
}
function pathRender(context3, path3, l, t, sX, sY) {
  var current2, previous = null, x5 = 0, y5 = 0, controlX = 0, controlY = 0, tempX, tempY, tempControlX, tempControlY;
  if (l == null)
    l = 0;
  if (t == null)
    t = 0;
  if (sX == null)
    sX = 1;
  if (sY == null)
    sY = sX;
  if (context3.beginPath)
    context3.beginPath();
  for (var i = 0, len = path3.length; i < len; ++i) {
    current2 = path3[i];
    if (sX !== 1 || sY !== 1) {
      current2 = scale2(current2, sX, sY);
    }
    switch (current2[0]) {
      case "l":
        x5 += current2[1];
        y5 += current2[2];
        context3.lineTo(x5 + l, y5 + t);
        break;
      case "L":
        x5 = current2[1];
        y5 = current2[2];
        context3.lineTo(x5 + l, y5 + t);
        break;
      case "h":
        x5 += current2[1];
        context3.lineTo(x5 + l, y5 + t);
        break;
      case "H":
        x5 = current2[1];
        context3.lineTo(x5 + l, y5 + t);
        break;
      case "v":
        y5 += current2[1];
        context3.lineTo(x5 + l, y5 + t);
        break;
      case "V":
        y5 = current2[1];
        context3.lineTo(x5 + l, y5 + t);
        break;
      case "m":
        x5 += current2[1];
        y5 += current2[2];
        context3.moveTo(x5 + l, y5 + t);
        break;
      case "M":
        x5 = current2[1];
        y5 = current2[2];
        context3.moveTo(x5 + l, y5 + t);
        break;
      case "c":
        tempX = x5 + current2[5];
        tempY = y5 + current2[6];
        controlX = x5 + current2[3];
        controlY = y5 + current2[4];
        context3.bezierCurveTo(x5 + current2[1] + l, y5 + current2[2] + t, controlX + l, controlY + t, tempX + l, tempY + t);
        x5 = tempX;
        y5 = tempY;
        break;
      case "C":
        x5 = current2[5];
        y5 = current2[6];
        controlX = current2[3];
        controlY = current2[4];
        context3.bezierCurveTo(current2[1] + l, current2[2] + t, controlX + l, controlY + t, x5 + l, y5 + t);
        break;
      case "s":
        tempX = x5 + current2[3];
        tempY = y5 + current2[4];
        controlX = 2 * x5 - controlX;
        controlY = 2 * y5 - controlY;
        context3.bezierCurveTo(controlX + l, controlY + t, x5 + current2[1] + l, y5 + current2[2] + t, tempX + l, tempY + t);
        controlX = x5 + current2[1];
        controlY = y5 + current2[2];
        x5 = tempX;
        y5 = tempY;
        break;
      case "S":
        tempX = current2[3];
        tempY = current2[4];
        controlX = 2 * x5 - controlX;
        controlY = 2 * y5 - controlY;
        context3.bezierCurveTo(controlX + l, controlY + t, current2[1] + l, current2[2] + t, tempX + l, tempY + t);
        x5 = tempX;
        y5 = tempY;
        controlX = current2[1];
        controlY = current2[2];
        break;
      case "q":
        tempX = x5 + current2[3];
        tempY = y5 + current2[4];
        controlX = x5 + current2[1];
        controlY = y5 + current2[2];
        context3.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x5 = tempX;
        y5 = tempY;
        break;
      case "Q":
        tempX = current2[3];
        tempY = current2[4];
        context3.quadraticCurveTo(current2[1] + l, current2[2] + t, tempX + l, tempY + t);
        x5 = tempX;
        y5 = tempY;
        controlX = current2[1];
        controlY = current2[2];
        break;
      case "t":
        tempX = x5 + current2[1];
        tempY = y5 + current2[2];
        if (previous[0].match(/[QqTt]/) === null) {
          controlX = x5;
          controlY = y5;
        } else if (previous[0] === "t") {
          controlX = 2 * x5 - tempControlX;
          controlY = 2 * y5 - tempControlY;
        } else if (previous[0] === "q") {
          controlX = 2 * x5 - controlX;
          controlY = 2 * y5 - controlY;
        }
        tempControlX = controlX;
        tempControlY = controlY;
        context3.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x5 = tempX;
        y5 = tempY;
        controlX = x5 + current2[1];
        controlY = y5 + current2[2];
        break;
      case "T":
        tempX = current2[1];
        tempY = current2[2];
        controlX = 2 * x5 - controlX;
        controlY = 2 * y5 - controlY;
        context3.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x5 = tempX;
        y5 = tempY;
        break;
      case "a":
        drawArc(context3, x5 + l, y5 + t, [current2[1], current2[2], current2[3], current2[4], current2[5], current2[6] + x5 + l, current2[7] + y5 + t]);
        x5 += current2[6];
        y5 += current2[7];
        break;
      case "A":
        drawArc(context3, x5 + l, y5 + t, [current2[1], current2[2], current2[3], current2[4], current2[5], current2[6] + l, current2[7] + t]);
        x5 = current2[6];
        y5 = current2[7];
        break;
      case "z":
      case "Z":
        context3.closePath();
        break;
    }
    previous = current2;
  }
}
function drawArc(context3, x5, y5, coords) {
  const seg = segments(coords[5], coords[6], coords[0], coords[1], coords[3], coords[4], coords[2], x5, y5);
  for (let i = 0; i < seg.length; ++i) {
    const bez = bezier(seg[i]);
    context3.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
  }
}
var Tan30 = 0.5773502691896257;
var builtins = {
  circle: {
    draw: function(context3, size) {
      const r2 = Math.sqrt(size) / 2;
      context3.moveTo(r2, 0);
      context3.arc(0, 0, r2, 0, Tau);
    }
  },
  cross: {
    draw: function(context3, size) {
      var r2 = Math.sqrt(size) / 2, s = r2 / 2.5;
      context3.moveTo(-r2, -s);
      context3.lineTo(-r2, s);
      context3.lineTo(-s, s);
      context3.lineTo(-s, r2);
      context3.lineTo(s, r2);
      context3.lineTo(s, s);
      context3.lineTo(r2, s);
      context3.lineTo(r2, -s);
      context3.lineTo(s, -s);
      context3.lineTo(s, -r2);
      context3.lineTo(-s, -r2);
      context3.lineTo(-s, -s);
      context3.closePath();
    }
  },
  diamond: {
    draw: function(context3, size) {
      const r2 = Math.sqrt(size) / 2;
      context3.moveTo(-r2, 0);
      context3.lineTo(0, -r2);
      context3.lineTo(r2, 0);
      context3.lineTo(0, r2);
      context3.closePath();
    }
  },
  square: {
    draw: function(context3, size) {
      var w3 = Math.sqrt(size), x5 = -w3 / 2;
      context3.rect(x5, x5, w3, w3);
    }
  },
  arrow: {
    draw: function(context3, size) {
      var r2 = Math.sqrt(size) / 2, s = r2 / 7, t = r2 / 2.5, v = r2 / 8;
      context3.moveTo(-s, r2);
      context3.lineTo(s, r2);
      context3.lineTo(s, -v);
      context3.lineTo(t, -v);
      context3.lineTo(0, -r2);
      context3.lineTo(-t, -v);
      context3.lineTo(-s, -v);
      context3.closePath();
    }
  },
  wedge: {
    draw: function(context3, size) {
      var r2 = Math.sqrt(size) / 2, h3 = HalfSqrt3 * r2, o = h3 - r2 * Tan30, b2 = r2 / 4;
      context3.moveTo(0, -h3 - o);
      context3.lineTo(-b2, h3 - o);
      context3.lineTo(b2, h3 - o);
      context3.closePath();
    }
  },
  triangle: {
    draw: function(context3, size) {
      var r2 = Math.sqrt(size) / 2, h3 = HalfSqrt3 * r2, o = h3 - r2 * Tan30;
      context3.moveTo(0, -h3 - o);
      context3.lineTo(-r2, h3 - o);
      context3.lineTo(r2, h3 - o);
      context3.closePath();
    }
  },
  "triangle-up": {
    draw: function(context3, size) {
      var r2 = Math.sqrt(size) / 2, h3 = HalfSqrt3 * r2;
      context3.moveTo(0, -h3);
      context3.lineTo(-r2, h3);
      context3.lineTo(r2, h3);
      context3.closePath();
    }
  },
  "triangle-down": {
    draw: function(context3, size) {
      var r2 = Math.sqrt(size) / 2, h3 = HalfSqrt3 * r2;
      context3.moveTo(0, h3);
      context3.lineTo(-r2, -h3);
      context3.lineTo(r2, -h3);
      context3.closePath();
    }
  },
  "triangle-right": {
    draw: function(context3, size) {
      var r2 = Math.sqrt(size) / 2, h3 = HalfSqrt3 * r2;
      context3.moveTo(h3, 0);
      context3.lineTo(-h3, -r2);
      context3.lineTo(-h3, r2);
      context3.closePath();
    }
  },
  "triangle-left": {
    draw: function(context3, size) {
      var r2 = Math.sqrt(size) / 2, h3 = HalfSqrt3 * r2;
      context3.moveTo(-h3, 0);
      context3.lineTo(h3, -r2);
      context3.lineTo(h3, r2);
      context3.closePath();
    }
  },
  stroke: {
    draw: function(context3, size) {
      const r2 = Math.sqrt(size) / 2;
      context3.moveTo(-r2, 0);
      context3.lineTo(r2, 0);
    }
  }
};
function symbols2(_) {
  return has(builtins, _) ? builtins[_] : customSymbol(_);
}
var custom8 = {};
function customSymbol(path3) {
  if (!has(custom8, path3)) {
    const parsed = pathParse(path3);
    custom8[path3] = {
      draw: function(context3, size) {
        pathRender(context3, parsed, 0, 0, Math.sqrt(size) / 2);
      }
    };
  }
  return custom8[path3];
}
var C2 = 0.448084975506;
function rectangleX(d) {
  return d.x;
}
function rectangleY(d) {
  return d.y;
}
function rectangleWidth(d) {
  return d.width;
}
function rectangleHeight(d) {
  return d.height;
}
function number3(_) {
  return typeof _ === "function" ? _ : () => +_;
}
function clamp(value3, min4, max4) {
  return Math.max(min4, Math.min(value3, max4));
}
function vg_rect() {
  var x5 = rectangleX, y5 = rectangleY, width2 = rectangleWidth, height2 = rectangleHeight, crTL = number3(0), crTR = crTL, crBL = crTL, crBR = crTL, context3 = null;
  function rectangle2(_, x06, y06) {
    var buffer, x12 = x06 != null ? x06 : +x5.call(this, _), y12 = y06 != null ? y06 : +y5.call(this, _), w3 = +width2.call(this, _), h3 = +height2.call(this, _), s = Math.min(w3, h3) / 2, tl2 = clamp(+crTL.call(this, _), 0, s), tr2 = clamp(+crTR.call(this, _), 0, s), bl2 = clamp(+crBL.call(this, _), 0, s), br2 = clamp(+crBR.call(this, _), 0, s);
    if (!context3)
      context3 = buffer = path_default();
    if (tl2 <= 0 && tr2 <= 0 && bl2 <= 0 && br2 <= 0) {
      context3.rect(x12, y12, w3, h3);
    } else {
      var x22 = x12 + w3, y22 = y12 + h3;
      context3.moveTo(x12 + tl2, y12);
      context3.lineTo(x22 - tr2, y12);
      context3.bezierCurveTo(x22 - C2 * tr2, y12, x22, y12 + C2 * tr2, x22, y12 + tr2);
      context3.lineTo(x22, y22 - br2);
      context3.bezierCurveTo(x22, y22 - C2 * br2, x22 - C2 * br2, y22, x22 - br2, y22);
      context3.lineTo(x12 + bl2, y22);
      context3.bezierCurveTo(x12 + C2 * bl2, y22, x12, y22 - C2 * bl2, x12, y22 - bl2);
      context3.lineTo(x12, y12 + tl2);
      context3.bezierCurveTo(x12, y12 + C2 * tl2, x12 + C2 * tl2, y12, x12 + tl2, y12);
      context3.closePath();
    }
    if (buffer) {
      context3 = null;
      return buffer + "" || null;
    }
  }
  rectangle2.x = function(_) {
    if (arguments.length) {
      x5 = number3(_);
      return rectangle2;
    } else {
      return x5;
    }
  };
  rectangle2.y = function(_) {
    if (arguments.length) {
      y5 = number3(_);
      return rectangle2;
    } else {
      return y5;
    }
  };
  rectangle2.width = function(_) {
    if (arguments.length) {
      width2 = number3(_);
      return rectangle2;
    } else {
      return width2;
    }
  };
  rectangle2.height = function(_) {
    if (arguments.length) {
      height2 = number3(_);
      return rectangle2;
    } else {
      return height2;
    }
  };
  rectangle2.cornerRadius = function(tl2, tr2, br2, bl2) {
    if (arguments.length) {
      crTL = number3(tl2);
      crTR = tr2 != null ? number3(tr2) : crTL;
      crBR = br2 != null ? number3(br2) : crTL;
      crBL = bl2 != null ? number3(bl2) : crTR;
      return rectangle2;
    } else {
      return crTL;
    }
  };
  rectangle2.context = function(_) {
    if (arguments.length) {
      context3 = _ == null ? null : _;
      return rectangle2;
    } else {
      return context3;
    }
  };
  return rectangle2;
}
function vg_trail() {
  var x5, y5, size, defined2, context3 = null, ready, x12, y12, r1;
  function point8(x22, y22, w22) {
    const r2 = w22 / 2;
    if (ready) {
      var ux = y12 - y22, uy = x22 - x12;
      if (ux || uy) {
        var ud = Math.sqrt(ux * ux + uy * uy), rx = (ux /= ud) * r1, ry = (uy /= ud) * r1, t = Math.atan2(uy, ux);
        context3.moveTo(x12 - rx, y12 - ry);
        context3.lineTo(x22 - ux * r2, y22 - uy * r2);
        context3.arc(x22, y22, r2, t - Math.PI, t);
        context3.lineTo(x12 + rx, y12 + ry);
        context3.arc(x12, y12, r1, t, t + Math.PI);
      } else {
        context3.arc(x22, y22, r2, 0, Tau);
      }
      context3.closePath();
    } else {
      ready = 1;
    }
    x12 = x22;
    y12 = y22;
    r1 = r2;
  }
  function trail3(data4) {
    var i, n = data4.length, d, defined0 = false, buffer;
    if (context3 == null)
      context3 = buffer = path_default();
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined2(d = data4[i], i, data4)) === defined0) {
        if (defined0 = !defined0)
          ready = 0;
      }
      if (defined0)
        point8(+x5(d, i, data4), +y5(d, i, data4), +size(d, i, data4));
    }
    if (buffer) {
      context3 = null;
      return buffer + "" || null;
    }
  }
  trail3.x = function(_) {
    if (arguments.length) {
      x5 = _;
      return trail3;
    } else {
      return x5;
    }
  };
  trail3.y = function(_) {
    if (arguments.length) {
      y5 = _;
      return trail3;
    } else {
      return y5;
    }
  };
  trail3.size = function(_) {
    if (arguments.length) {
      size = _;
      return trail3;
    } else {
      return size;
    }
  };
  trail3.defined = function(_) {
    if (arguments.length) {
      defined2 = _;
      return trail3;
    } else {
      return defined2;
    }
  };
  trail3.context = function(_) {
    if (arguments.length) {
      if (_ == null) {
        context3 = null;
      } else {
        context3 = _;
      }
      return trail3;
    } else {
      return context3;
    }
  };
  return trail3;
}
function value(a2, b2) {
  return a2 != null ? a2 : b2;
}
var x2 = (item) => item.x || 0;
var y2 = (item) => item.y || 0;
var w = (item) => item.width || 0;
var h = (item) => item.height || 0;
var xw = (item) => (item.x || 0) + (item.width || 0);
var yh = (item) => (item.y || 0) + (item.height || 0);
var sa = (item) => item.startAngle || 0;
var ea = (item) => item.endAngle || 0;
var pa = (item) => item.padAngle || 0;
var ir = (item) => item.innerRadius || 0;
var or = (item) => item.outerRadius || 0;
var cr = (item) => item.cornerRadius || 0;
var tl = (item) => value(item.cornerRadiusTopLeft, item.cornerRadius) || 0;
var tr = (item) => value(item.cornerRadiusTopRight, item.cornerRadius) || 0;
var br = (item) => value(item.cornerRadiusBottomRight, item.cornerRadius) || 0;
var bl = (item) => value(item.cornerRadiusBottomLeft, item.cornerRadius) || 0;
var sz = (item) => value(item.size, 64);
var ts = (item) => item.size || 1;
var def = (item) => !(item.defined === false);
var type = (item) => symbols2(item.shape || "circle");
var arcShape = arc_default().startAngle(sa).endAngle(ea).padAngle(pa).innerRadius(ir).outerRadius(or).cornerRadius(cr);
var areavShape = area_default().x(x2).y1(y2).y0(yh).defined(def);
var areahShape = area_default().y(y2).x1(x2).x0(xw).defined(def);
var lineShape = line_default().x(x2).y(y2).defined(def);
var rectShape = vg_rect().x(x2).y(y2).width(w).height(h).cornerRadius(tl, tr, br, bl);
var symbolShape = symbol_default().type(type).size(sz);
var trailShape = vg_trail().x(x2).y(y2).defined(def).size(ts);
function hasCornerRadius(item) {
  return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;
}
function arc(context3, item) {
  return arcShape.context(context3)(item);
}
function area(context3, items2) {
  const item = items2[0], interp = item.interpolate || "linear";
  return (item.orient === "horizontal" ? areahShape : areavShape).curve(curves(interp, item.orient, item.tension)).context(context3)(items2);
}
function line(context3, items2) {
  const item = items2[0], interp = item.interpolate || "linear";
  return lineShape.curve(curves(interp, item.orient, item.tension)).context(context3)(items2);
}
function rectangle(context3, item, x5, y5) {
  return rectShape.context(context3)(item, x5, y5);
}
function shape(context3, item) {
  return (item.mark.shape || item.shape).context(context3)(item);
}
function symbol(context3, item) {
  return symbolShape.context(context3)(item);
}
function trail(context3, items2) {
  return trailShape.context(context3)(items2);
}
var clip_id = 1;
function resetSVGClipId() {
  clip_id = 1;
}
function clip(renderer, item, size) {
  var clip3 = item.clip, defs = renderer._defs, id4 = item.clip_id || (item.clip_id = "clip" + clip_id++), c2 = defs.clipping[id4] || (defs.clipping[id4] = {
    id: id4
  });
  if (isFunction(clip3)) {
    c2.path = clip3(null);
  } else if (hasCornerRadius(size)) {
    c2.path = rectangle(null, size, 0, 0);
  } else {
    c2.width = size.width || 0;
    c2.height = size.height || 0;
  }
  return "url(#" + id4 + ")";
}
function Bounds(b2) {
  this.clear();
  if (b2)
    this.union(b2);
}
Bounds.prototype = {
  clone() {
    return new Bounds(this);
  },
  clear() {
    this.x1 = +Number.MAX_VALUE;
    this.y1 = +Number.MAX_VALUE;
    this.x2 = -Number.MAX_VALUE;
    this.y2 = -Number.MAX_VALUE;
    return this;
  },
  empty() {
    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
  },
  equals(b2) {
    return this.x1 === b2.x1 && this.y1 === b2.y1 && this.x2 === b2.x2 && this.y2 === b2.y2;
  },
  set(x12, y12, x22, y22) {
    if (x22 < x12) {
      this.x2 = x12;
      this.x1 = x22;
    } else {
      this.x1 = x12;
      this.x2 = x22;
    }
    if (y22 < y12) {
      this.y2 = y12;
      this.y1 = y22;
    } else {
      this.y1 = y12;
      this.y2 = y22;
    }
    return this;
  },
  add(x5, y5) {
    if (x5 < this.x1)
      this.x1 = x5;
    if (y5 < this.y1)
      this.y1 = y5;
    if (x5 > this.x2)
      this.x2 = x5;
    if (y5 > this.y2)
      this.y2 = y5;
    return this;
  },
  expand(d) {
    this.x1 -= d;
    this.y1 -= d;
    this.x2 += d;
    this.y2 += d;
    return this;
  },
  round() {
    this.x1 = Math.floor(this.x1);
    this.y1 = Math.floor(this.y1);
    this.x2 = Math.ceil(this.x2);
    this.y2 = Math.ceil(this.y2);
    return this;
  },
  scale(s) {
    this.x1 *= s;
    this.y1 *= s;
    this.x2 *= s;
    this.y2 *= s;
    return this;
  },
  translate(dx, dy) {
    this.x1 += dx;
    this.x2 += dx;
    this.y1 += dy;
    this.y2 += dy;
    return this;
  },
  rotate(angle2, x5, y5) {
    const p = this.rotatedPoints(angle2, x5, y5);
    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
  },
  rotatedPoints(angle2, x5, y5) {
    var {
      x1: x12,
      y1: y12,
      x2: x22,
      y2: y22
    } = this, cos4 = Math.cos(angle2), sin4 = Math.sin(angle2), cx = x5 - x5 * cos4 + y5 * sin4, cy = y5 - x5 * sin4 - y5 * cos4;
    return [cos4 * x12 - sin4 * y12 + cx, sin4 * x12 + cos4 * y12 + cy, cos4 * x12 - sin4 * y22 + cx, sin4 * x12 + cos4 * y22 + cy, cos4 * x22 - sin4 * y12 + cx, sin4 * x22 + cos4 * y12 + cy, cos4 * x22 - sin4 * y22 + cx, sin4 * x22 + cos4 * y22 + cy];
  },
  union(b2) {
    if (b2.x1 < this.x1)
      this.x1 = b2.x1;
    if (b2.y1 < this.y1)
      this.y1 = b2.y1;
    if (b2.x2 > this.x2)
      this.x2 = b2.x2;
    if (b2.y2 > this.y2)
      this.y2 = b2.y2;
    return this;
  },
  intersect(b2) {
    if (b2.x1 > this.x1)
      this.x1 = b2.x1;
    if (b2.y1 > this.y1)
      this.y1 = b2.y1;
    if (b2.x2 < this.x2)
      this.x2 = b2.x2;
    if (b2.y2 < this.y2)
      this.y2 = b2.y2;
    return this;
  },
  encloses(b2) {
    return b2 && this.x1 <= b2.x1 && this.x2 >= b2.x2 && this.y1 <= b2.y1 && this.y2 >= b2.y2;
  },
  alignsWith(b2) {
    return b2 && (this.x1 == b2.x1 || this.x2 == b2.x2 || this.y1 == b2.y1 || this.y2 == b2.y2);
  },
  intersects(b2) {
    return b2 && !(this.x2 < b2.x1 || this.x1 > b2.x2 || this.y2 < b2.y1 || this.y1 > b2.y2);
  },
  contains(x5, y5) {
    return !(x5 < this.x1 || x5 > this.x2 || y5 < this.y1 || y5 > this.y2);
  },
  width() {
    return this.x2 - this.x1;
  },
  height() {
    return this.y2 - this.y1;
  }
};
function Item(mark2) {
  this.mark = mark2;
  this.bounds = this.bounds || new Bounds();
}
function GroupItem(mark2) {
  Item.call(this, mark2);
  this.items = this.items || [];
}
inherits(GroupItem, Item);
function ResourceLoader(customLoader) {
  this._pending = 0;
  this._loader = customLoader || loader();
}
function increment(loader2) {
  loader2._pending += 1;
}
function decrement(loader2) {
  loader2._pending -= 1;
}
ResourceLoader.prototype = {
  pending() {
    return this._pending;
  },
  sanitizeURL(uri) {
    const loader2 = this;
    increment(loader2);
    return loader2._loader.sanitize(uri, {
      context: "href"
    }).then((opt) => {
      decrement(loader2);
      return opt;
    }).catch(() => {
      decrement(loader2);
      return null;
    });
  },
  loadImage(uri) {
    const loader2 = this, Image2 = domImage();
    increment(loader2);
    return loader2._loader.sanitize(uri, {
      context: "image"
    }).then((opt) => {
      const url = opt.href;
      if (!url || !Image2)
        throw {
          url
        };
      const img = new Image2();
      const cors = has(opt, "crossOrigin") ? opt.crossOrigin : "anonymous";
      if (cors != null)
        img.crossOrigin = cors;
      img.onload = () => decrement(loader2);
      img.onerror = () => decrement(loader2);
      img.src = url;
      return img;
    }).catch((e) => {
      decrement(loader2);
      return {
        complete: false,
        width: 0,
        height: 0,
        src: e && e.url || ""
      };
    });
  },
  ready() {
    const loader2 = this;
    return new Promise((accept) => {
      function poll(value3) {
        if (!loader2.pending())
          accept(value3);
        else
          setTimeout(() => {
            poll(true);
          }, 10);
      }
      poll(false);
    });
  }
};
function boundStroke(bounds2, item, miter) {
  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {
    const sw = item.strokeWidth != null ? +item.strokeWidth : 1;
    bounds2.expand(sw + (miter ? miterAdjustment(item, sw) : 0));
  }
  return bounds2;
}
function miterAdjustment(item, strokeWidth) {
  return item.strokeJoin && item.strokeJoin !== "miter" ? 0 : strokeWidth;
}
var circleThreshold = Tau - 1e-8;
var bounds;
var lx;
var ly;
var rot;
var ma;
var mb;
var mc;
var md;
var add3 = (x5, y5) => bounds.add(x5, y5);
var addL = (x5, y5) => add3(lx = x5, ly = y5);
var addX = (x5) => add3(x5, bounds.y1);
var addY = (y5) => add3(bounds.x1, y5);
var px = (x5, y5) => ma * x5 + mc * y5;
var py = (x5, y5) => mb * x5 + md * y5;
var addp = (x5, y5) => add3(px(x5, y5), py(x5, y5));
var addpL = (x5, y5) => addL(px(x5, y5), py(x5, y5));
function boundContext(_, deg) {
  bounds = _;
  if (deg) {
    rot = deg * DegToRad;
    ma = md = Math.cos(rot);
    mb = Math.sin(rot);
    mc = -mb;
  } else {
    ma = md = 1;
    rot = mb = mc = 0;
  }
  return context;
}
var context = {
  beginPath() {
  },
  closePath() {
  },
  moveTo: addpL,
  lineTo: addpL,
  rect(x5, y5, w3, h3) {
    if (rot) {
      addp(x5 + w3, y5);
      addp(x5 + w3, y5 + h3);
      addp(x5, y5 + h3);
      addpL(x5, y5);
    } else {
      add3(x5 + w3, y5 + h3);
      addL(x5, y5);
    }
  },
  quadraticCurveTo(x12, y12, x22, y22) {
    const px1 = px(x12, y12), py1 = py(x12, y12), px2 = px(x22, y22), py2 = py(x22, y22);
    quadExtrema(lx, px1, px2, addX);
    quadExtrema(ly, py1, py2, addY);
    addL(px2, py2);
  },
  bezierCurveTo(x12, y12, x22, y22, x32, y32) {
    const px1 = px(x12, y12), py1 = py(x12, y12), px2 = px(x22, y22), py2 = py(x22, y22), px3 = px(x32, y32), py3 = py(x32, y32);
    cubicExtrema(lx, px1, px2, px3, addX);
    cubicExtrema(ly, py1, py2, py3, addY);
    addL(px3, py3);
  },
  arc(cx, cy, r2, sa2, ea2, ccw) {
    sa2 += rot;
    ea2 += rot;
    lx = r2 * Math.cos(ea2) + cx;
    ly = r2 * Math.sin(ea2) + cy;
    if (Math.abs(ea2 - sa2) > circleThreshold) {
      add3(cx - r2, cy - r2);
      add3(cx + r2, cy + r2);
    } else {
      const update3 = (a2) => add3(r2 * Math.cos(a2) + cx, r2 * Math.sin(a2) + cy);
      let s, i;
      update3(sa2);
      update3(ea2);
      if (ea2 !== sa2) {
        sa2 = sa2 % Tau;
        if (sa2 < 0)
          sa2 += Tau;
        ea2 = ea2 % Tau;
        if (ea2 < 0)
          ea2 += Tau;
        if (ea2 < sa2) {
          ccw = !ccw;
          s = sa2;
          sa2 = ea2;
          ea2 = s;
        }
        if (ccw) {
          ea2 -= Tau;
          s = sa2 - sa2 % HalfPi;
          for (i = 0; i < 4 && s > ea2; ++i, s -= HalfPi)
            update3(s);
        } else {
          s = sa2 - sa2 % HalfPi + HalfPi;
          for (i = 0; i < 4 && s < ea2; ++i, s = s + HalfPi)
            update3(s);
        }
      }
    }
  }
};
function quadExtrema(x06, x12, x22, cb) {
  const t = (x06 - x12) / (x06 + x22 - 2 * x12);
  if (0 < t && t < 1)
    cb(x06 + (x12 - x06) * t);
}
function cubicExtrema(x06, x12, x22, x32, cb) {
  const a2 = x32 - x06 + 3 * x12 - 3 * x22, b2 = x06 + x22 - 2 * x12, c2 = x06 - x12;
  let t04 = 0, t13 = 0, r2;
  if (Math.abs(a2) > Epsilon) {
    r2 = b2 * b2 + c2 * a2;
    if (r2 >= 0) {
      r2 = Math.sqrt(r2);
      t04 = (-b2 + r2) / a2;
      t13 = (-b2 - r2) / a2;
    }
  } else {
    t04 = 0.5 * c2 / b2;
  }
  if (0 < t04 && t04 < 1)
    cb(cubic(t04, x06, x12, x22, x32));
  if (0 < t13 && t13 < 1)
    cb(cubic(t13, x06, x12, x22, x32));
}
function cubic(t, x06, x12, x22, x32) {
  const s = 1 - t, s2 = s * s, t22 = t * t;
  return s2 * s * x06 + 3 * s2 * t * x12 + 3 * s * t22 * x22 + t22 * t * x32;
}
var context$1 = (context$1 = domCanvas(1, 1)) ? context$1.getContext("2d") : null;
var b = new Bounds();
function intersectPath(draw3) {
  return function(item, brush) {
    if (!context$1)
      return true;
    draw3(context$1, item);
    b.clear().union(item.bounds).intersect(brush).round();
    const {
      x1: x12,
      y1: y12,
      x2: x22,
      y2: y22
    } = b;
    for (let y5 = y12; y5 <= y22; ++y5) {
      for (let x5 = x12; x5 <= x22; ++x5) {
        if (context$1.isPointInPath(x5, y5)) {
          return true;
        }
      }
    }
    return false;
  };
}
function intersectPoint(item, box) {
  return box.contains(item.x || 0, item.y || 0);
}
function intersectRect(item, box) {
  const x5 = item.x || 0, y5 = item.y || 0, w3 = item.width || 0, h3 = item.height || 0;
  return box.intersects(b.set(x5, y5, x5 + w3, y5 + h3));
}
function intersectRule(item, box) {
  const x5 = item.x || 0, y5 = item.y || 0, x22 = item.x2 != null ? item.x2 : x5, y22 = item.y2 != null ? item.y2 : y5;
  return intersectBoxLine(box, x5, y5, x22, y22);
}
function intersectBoxLine(box, x5, y5, u, v) {
  const {
    x1: x12,
    y1: y12,
    x2: x22,
    y2: y22
  } = box, dx = u - x5, dy = v - y5;
  let t04 = 0, t13 = 1, p, q, r2, e;
  for (e = 0; e < 4; ++e) {
    if (e === 0) {
      p = -dx;
      q = -(x12 - x5);
    }
    if (e === 1) {
      p = dx;
      q = x22 - x5;
    }
    if (e === 2) {
      p = -dy;
      q = -(y12 - y5);
    }
    if (e === 3) {
      p = dy;
      q = y22 - y5;
    }
    if (Math.abs(p) < 1e-10 && q < 0)
      return false;
    r2 = q / p;
    if (p < 0) {
      if (r2 > t13)
        return false;
      else if (r2 > t04)
        t04 = r2;
    } else if (p > 0) {
      if (r2 < t04)
        return false;
      else if (r2 < t13)
        t13 = r2;
    }
  }
  return true;
}
function blend(context3, item) {
  context3.globalCompositeOperation = item.blend || "source-over";
}
function value$1(value3, dflt) {
  return value3 == null ? dflt : value3;
}
function addStops(gradient4, stops) {
  const n = stops.length;
  for (let i = 0; i < n; ++i) {
    gradient4.addColorStop(stops[i].offset, stops[i].color);
  }
  return gradient4;
}
function gradient(context3, spec, bounds2) {
  const w3 = bounds2.width(), h3 = bounds2.height();
  let gradient4;
  if (spec.gradient === "radial") {
    gradient4 = context3.createRadialGradient(bounds2.x1 + value$1(spec.x1, 0.5) * w3, bounds2.y1 + value$1(spec.y1, 0.5) * h3, Math.max(w3, h3) * value$1(spec.r1, 0), bounds2.x1 + value$1(spec.x2, 0.5) * w3, bounds2.y1 + value$1(spec.y2, 0.5) * h3, Math.max(w3, h3) * value$1(spec.r2, 0.5));
  } else {
    const x12 = value$1(spec.x1, 0), y12 = value$1(spec.y1, 0), x22 = value$1(spec.x2, 1), y22 = value$1(spec.y2, 0);
    if (x12 === x22 || y12 === y22 || w3 === h3) {
      gradient4 = context3.createLinearGradient(bounds2.x1 + x12 * w3, bounds2.y1 + y12 * h3, bounds2.x1 + x22 * w3, bounds2.y1 + y22 * h3);
    } else {
      const image3 = domCanvas(Math.ceil(w3), Math.ceil(h3)), ictx = image3.getContext("2d");
      ictx.scale(w3, h3);
      ictx.fillStyle = addStops(ictx.createLinearGradient(x12, y12, x22, y22), spec.stops);
      ictx.fillRect(0, 0, w3, h3);
      return context3.createPattern(image3, "no-repeat");
    }
  }
  return addStops(gradient4, spec.stops);
}
function color2(context3, item, value3) {
  return isGradient(value3) ? gradient(context3, value3, item.bounds) : value3;
}
function fill(context3, item, opacity2) {
  opacity2 *= item.fillOpacity == null ? 1 : item.fillOpacity;
  if (opacity2 > 0) {
    context3.globalAlpha = opacity2;
    context3.fillStyle = color2(context3, item, item.fill);
    return true;
  } else {
    return false;
  }
}
var Empty2 = [];
function stroke(context3, item, opacity2) {
  var lw = (lw = item.strokeWidth) != null ? lw : 1;
  if (lw <= 0)
    return false;
  opacity2 *= item.strokeOpacity == null ? 1 : item.strokeOpacity;
  if (opacity2 > 0) {
    context3.globalAlpha = opacity2;
    context3.strokeStyle = color2(context3, item, item.stroke);
    context3.lineWidth = lw;
    context3.lineCap = item.strokeCap || "butt";
    context3.lineJoin = item.strokeJoin || "miter";
    context3.miterLimit = item.strokeMiterLimit || 10;
    if (context3.setLineDash) {
      context3.setLineDash(item.strokeDash || Empty2);
      context3.lineDashOffset = item.strokeDashOffset || 0;
    }
    return true;
  } else {
    return false;
  }
}
function compare3(a2, b2) {
  return a2.zindex - b2.zindex || a2.index - b2.index;
}
function zorder(scene) {
  if (!scene.zdirty)
    return scene.zitems;
  var items2 = scene.items, output3 = [], item, i, n;
  for (i = 0, n = items2.length; i < n; ++i) {
    item = items2[i];
    item.index = i;
    if (item.zindex)
      output3.push(item);
  }
  scene.zdirty = false;
  return scene.zitems = output3.sort(compare3);
}
function visit(scene, visitor) {
  var items2 = scene.items, i, n;
  if (!items2 || !items2.length)
    return;
  const zitems = zorder(scene);
  if (zitems && zitems.length) {
    for (i = 0, n = items2.length; i < n; ++i) {
      if (!items2[i].zindex)
        visitor(items2[i]);
    }
    items2 = zitems;
  }
  for (i = 0, n = items2.length; i < n; ++i) {
    visitor(items2[i]);
  }
}
function pickVisit(scene, visitor) {
  var items2 = scene.items, hit2, i;
  if (!items2 || !items2.length)
    return null;
  const zitems = zorder(scene);
  if (zitems && zitems.length)
    items2 = zitems;
  for (i = items2.length; --i >= 0; ) {
    if (hit2 = visitor(items2[i]))
      return hit2;
  }
  if (items2 === zitems) {
    for (items2 = scene.items, i = items2.length; --i >= 0; ) {
      if (!items2[i].zindex) {
        if (hit2 = visitor(items2[i]))
          return hit2;
      }
    }
  }
  return null;
}
function drawAll(path3) {
  return function(context3, scene, bounds2) {
    visit(scene, (item) => {
      if (!bounds2 || bounds2.intersects(item.bounds)) {
        drawPath(path3, context3, item, item);
      }
    });
  };
}
function drawOne(path3) {
  return function(context3, scene, bounds2) {
    if (scene.items.length && (!bounds2 || bounds2.intersects(scene.bounds))) {
      drawPath(path3, context3, scene.items[0], scene.items);
    }
  };
}
function drawPath(path3, context3, item, items2) {
  var opacity2 = item.opacity == null ? 1 : item.opacity;
  if (opacity2 === 0)
    return;
  if (path3(context3, items2))
    return;
  blend(context3, item);
  if (item.fill && fill(context3, item, opacity2)) {
    context3.fill();
  }
  if (item.stroke && stroke(context3, item, opacity2)) {
    context3.stroke();
  }
}
function pick(test2) {
  test2 = test2 || truthy;
  return function(context3, scene, x5, y5, gx, gy) {
    x5 *= context3.pixelRatio;
    y5 *= context3.pixelRatio;
    return pickVisit(scene, (item) => {
      const b2 = item.bounds;
      if (b2 && !b2.contains(gx, gy) || !b2)
        return;
      if (test2(context3, item, x5, y5, gx, gy))
        return item;
    });
  };
}
function hitPath(path3, filled2) {
  return function(context3, o, x5, y5) {
    var item = Array.isArray(o) ? o[0] : o, fill2 = filled2 == null ? item.fill : filled2, stroke2 = item.stroke && context3.isPointInStroke, lw, lc;
    if (stroke2) {
      lw = item.strokeWidth;
      lc = item.strokeCap;
      context3.lineWidth = lw != null ? lw : 1;
      context3.lineCap = lc != null ? lc : "butt";
    }
    return path3(context3, o) ? false : fill2 && context3.isPointInPath(x5, y5) || stroke2 && context3.isPointInStroke(x5, y5);
  };
}
function pickPath(path3) {
  return pick(hitPath(path3));
}
function translate(x5, y5) {
  return "translate(" + x5 + "," + y5 + ")";
}
function rotate(a2) {
  return "rotate(" + a2 + ")";
}
function scale$1(scaleX, scaleY) {
  return "scale(" + scaleX + "," + scaleY + ")";
}
function translateItem(item) {
  return translate(item.x || 0, item.y || 0);
}
function rotateItem(item) {
  return translate(item.x || 0, item.y || 0) + (item.angle ? " " + rotate(item.angle) : "");
}
function transformItem(item) {
  return translate(item.x || 0, item.y || 0) + (item.angle ? " " + rotate(item.angle) : "") + (item.scaleX || item.scaleY ? " " + scale$1(item.scaleX || 1, item.scaleY || 1) : "");
}
function markItemPath(type2, shape2, isect) {
  function attr2(emit2, item) {
    emit2("transform", rotateItem(item));
    emit2("d", shape2(null, item));
  }
  function bound2(bounds2, item) {
    shape2(boundContext(bounds2, item.angle), item);
    return boundStroke(bounds2, item).translate(item.x || 0, item.y || 0);
  }
  function draw3(context3, item) {
    var x5 = item.x || 0, y5 = item.y || 0, a2 = item.angle || 0;
    context3.translate(x5, y5);
    if (a2)
      context3.rotate(a2 *= DegToRad);
    context3.beginPath();
    shape2(context3, item);
    if (a2)
      context3.rotate(-a2);
    context3.translate(-x5, -y5);
  }
  return {
    type: type2,
    tag: "path",
    nested: false,
    attr: attr2,
    bound: bound2,
    draw: drawAll(draw3),
    pick: pickPath(draw3),
    isect: isect || intersectPath(draw3)
  };
}
var arc$1 = markItemPath("arc", arc);
function pickArea(a2, p) {
  var v = a2[0].orient === "horizontal" ? p[1] : p[0], z = a2[0].orient === "horizontal" ? "y" : "x", i = a2.length, min4 = Infinity, hit2, d;
  while (--i >= 0) {
    if (a2[i].defined === false)
      continue;
    d = Math.abs(a2[i][z] - v);
    if (d < min4) {
      min4 = d;
      hit2 = a2[i];
    }
  }
  return hit2;
}
function pickLine(a2, p) {
  var t = Math.pow(a2[0].strokeWidth || 1, 2), i = a2.length, dx, dy, dd;
  while (--i >= 0) {
    if (a2[i].defined === false)
      continue;
    dx = a2[i].x - p[0];
    dy = a2[i].y - p[1];
    dd = dx * dx + dy * dy;
    if (dd < t)
      return a2[i];
  }
  return null;
}
function pickTrail(a2, p) {
  var i = a2.length, dx, dy, dd;
  while (--i >= 0) {
    if (a2[i].defined === false)
      continue;
    dx = a2[i].x - p[0];
    dy = a2[i].y - p[1];
    dd = dx * dx + dy * dy;
    dx = a2[i].size || 1;
    if (dd < dx * dx)
      return a2[i];
  }
  return null;
}
function markMultiItemPath(type2, shape2, tip) {
  function attr2(emit2, item) {
    var items2 = item.mark.items;
    if (items2.length)
      emit2("d", shape2(null, items2));
  }
  function bound2(bounds2, mark2) {
    var items2 = mark2.items;
    if (items2.length === 0) {
      return bounds2;
    } else {
      shape2(boundContext(bounds2), items2);
      return boundStroke(bounds2, items2[0]);
    }
  }
  function draw3(context3, items2) {
    context3.beginPath();
    shape2(context3, items2);
  }
  const hit2 = hitPath(draw3);
  function pick3(context3, scene, x5, y5, gx, gy) {
    var items2 = scene.items, b2 = scene.bounds;
    if (!items2 || !items2.length || b2 && !b2.contains(gx, gy)) {
      return null;
    }
    x5 *= context3.pixelRatio;
    y5 *= context3.pixelRatio;
    return hit2(context3, items2, x5, y5) ? items2[0] : null;
  }
  return {
    type: type2,
    tag: "path",
    nested: true,
    attr: attr2,
    bound: bound2,
    draw: drawOne(draw3),
    pick: pick3,
    isect: intersectPoint,
    tip
  };
}
var area$1 = markMultiItemPath("area", area, pickArea);
function clip$1(context3, scene) {
  var clip3 = scene.clip;
  context3.save();
  if (isFunction(clip3)) {
    context3.beginPath();
    clip3(context3);
    context3.clip();
  } else {
    clipGroup(context3, scene.group);
  }
}
function clipGroup(context3, group2) {
  context3.beginPath();
  hasCornerRadius(group2) ? rectangle(context3, group2, 0, 0) : context3.rect(0, 0, group2.width || 0, group2.height || 0);
  context3.clip();
}
function offset2(item) {
  const sw = value$1(item.strokeWidth, 1);
  return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;
}
function attr(emit2, item) {
  emit2("transform", translateItem(item));
}
function emitRectangle(emit2, item) {
  const off = offset2(item);
  emit2("d", rectangle(null, item, off, off));
}
function background(emit2, item) {
  emit2("class", "background");
  emit2("aria-hidden", true);
  emitRectangle(emit2, item);
}
function foreground(emit2, item) {
  emit2("class", "foreground");
  emit2("aria-hidden", true);
  if (item.strokeForeground) {
    emitRectangle(emit2, item);
  } else {
    emit2("d", "");
  }
}
function content(emit2, item, renderer) {
  const url = item.clip ? clip(renderer, item, item) : null;
  emit2("clip-path", url);
}
function bound(bounds2, group2) {
  if (!group2.clip && group2.items) {
    const items2 = group2.items, m2 = items2.length;
    for (let j = 0; j < m2; ++j) {
      bounds2.union(items2[j].bounds);
    }
  }
  if ((group2.clip || group2.width || group2.height) && !group2.noBound) {
    bounds2.add(0, 0).add(group2.width || 0, group2.height || 0);
  }
  boundStroke(bounds2, group2);
  return bounds2.translate(group2.x || 0, group2.y || 0);
}
function rectanglePath(context3, group2, x5, y5) {
  const off = offset2(group2);
  context3.beginPath();
  rectangle(context3, group2, (x5 || 0) + off, (y5 || 0) + off);
}
var hitBackground = hitPath(rectanglePath);
var hitForeground = hitPath(rectanglePath, false);
var hitCorner = hitPath(rectanglePath, true);
function draw(context3, scene, bounds2) {
  visit(scene, (group2) => {
    const gx = group2.x || 0, gy = group2.y || 0, fore = group2.strokeForeground, opacity2 = group2.opacity == null ? 1 : group2.opacity;
    if ((group2.stroke || group2.fill) && opacity2) {
      rectanglePath(context3, group2, gx, gy);
      blend(context3, group2);
      if (group2.fill && fill(context3, group2, opacity2)) {
        context3.fill();
      }
      if (group2.stroke && !fore && stroke(context3, group2, opacity2)) {
        context3.stroke();
      }
    }
    context3.save();
    context3.translate(gx, gy);
    if (group2.clip)
      clipGroup(context3, group2);
    if (bounds2)
      bounds2.translate(-gx, -gy);
    visit(group2, (item) => {
      this.draw(context3, item, bounds2);
    });
    if (bounds2)
      bounds2.translate(gx, gy);
    context3.restore();
    if (fore && group2.stroke && opacity2) {
      rectanglePath(context3, group2, gx, gy);
      blend(context3, group2);
      if (stroke(context3, group2, opacity2)) {
        context3.stroke();
      }
    }
  });
}
function pick$1(context3, scene, x5, y5, gx, gy) {
  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {
    return null;
  }
  const cx = x5 * context3.pixelRatio, cy = y5 * context3.pixelRatio;
  return pickVisit(scene, (group2) => {
    let hit2, dx, dy;
    const b2 = group2.bounds;
    if (b2 && !b2.contains(gx, gy))
      return;
    dx = group2.x || 0;
    dy = group2.y || 0;
    const dw = dx + (group2.width || 0), dh = dy + (group2.height || 0), c2 = group2.clip;
    if (c2 && (gx < dx || gx > dw || gy < dy || gy > dh))
      return;
    context3.save();
    context3.translate(dx, dy);
    dx = gx - dx;
    dy = gy - dy;
    if (c2 && hasCornerRadius(group2) && !hitCorner(context3, group2, cx, cy)) {
      context3.restore();
      return null;
    }
    const fore = group2.strokeForeground, ix = scene.interactive !== false;
    if (ix && fore && group2.stroke && hitForeground(context3, group2, cx, cy)) {
      context3.restore();
      return group2;
    }
    hit2 = pickVisit(group2, (mark2) => pickMark(mark2, dx, dy) ? this.pick(mark2, x5, y5, dx, dy) : null);
    if (!hit2 && ix && (group2.fill || !fore && group2.stroke) && hitBackground(context3, group2, cx, cy)) {
      hit2 = group2;
    }
    context3.restore();
    return hit2 || null;
  });
}
function pickMark(mark2, x5, y5) {
  return (mark2.interactive !== false || mark2.marktype === "group") && mark2.bounds && mark2.bounds.contains(x5, y5);
}
var group = {
  type: "group",
  tag: "g",
  nested: false,
  attr,
  bound,
  draw,
  pick: pick$1,
  isect: intersectRect,
  content,
  background,
  foreground
};
var metadata = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  version: "1.1"
};
function getImage(item, renderer) {
  var image3 = item.image;
  if (!image3 || item.url && item.url !== image3.url) {
    image3 = {
      complete: false,
      width: 0,
      height: 0
    };
    renderer.loadImage(item.url).then((image4) => {
      item.image = image4;
      item.image.url = item.url;
    });
  }
  return image3;
}
function imageWidth(item, image3) {
  return item.width != null ? item.width : !image3 || !image3.width ? 0 : item.aspect !== false && item.height ? item.height * image3.width / image3.height : image3.width;
}
function imageHeight(item, image3) {
  return item.height != null ? item.height : !image3 || !image3.height ? 0 : item.aspect !== false && item.width ? item.width * image3.height / image3.width : image3.height;
}
function imageXOffset(align2, w3) {
  return align2 === "center" ? w3 / 2 : align2 === "right" ? w3 : 0;
}
function imageYOffset(baseline3, h3) {
  return baseline3 === "middle" ? h3 / 2 : baseline3 === "bottom" ? h3 : 0;
}
function attr$1(emit2, item, renderer) {
  const img = getImage(item, renderer), w3 = imageWidth(item, img), h3 = imageHeight(item, img), x5 = (item.x || 0) - imageXOffset(item.align, w3), y5 = (item.y || 0) - imageYOffset(item.baseline, h3), i = !img.src && img.toDataURL ? img.toDataURL() : img.src || "";
  emit2("href", i, metadata["xmlns:xlink"], "xlink:href");
  emit2("transform", translate(x5, y5));
  emit2("width", w3);
  emit2("height", h3);
  emit2("preserveAspectRatio", item.aspect === false ? "none" : "xMidYMid");
}
function bound$1(bounds2, item) {
  const img = item.image, w3 = imageWidth(item, img), h3 = imageHeight(item, img), x5 = (item.x || 0) - imageXOffset(item.align, w3), y5 = (item.y || 0) - imageYOffset(item.baseline, h3);
  return bounds2.set(x5, y5, x5 + w3, y5 + h3);
}
function draw$1(context3, scene, bounds2) {
  visit(scene, (item) => {
    if (bounds2 && !bounds2.intersects(item.bounds))
      return;
    const img = getImage(item, this);
    let w3 = imageWidth(item, img), h3 = imageHeight(item, img), x5 = (item.x || 0) - imageXOffset(item.align, w3), y5 = (item.y || 0) - imageYOffset(item.baseline, h3), opacity2, ar0, ar1, t;
    if (item.aspect !== false) {
      ar0 = img.width / img.height;
      ar1 = item.width / item.height;
      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {
        if (ar1 < ar0) {
          t = w3 / ar0;
          y5 += (h3 - t) / 2;
          h3 = t;
        } else {
          t = h3 * ar0;
          x5 += (w3 - t) / 2;
          w3 = t;
        }
      }
    }
    if (img.complete || img.toDataURL) {
      blend(context3, item);
      context3.globalAlpha = (opacity2 = item.opacity) != null ? opacity2 : 1;
      context3.imageSmoothingEnabled = item.smooth !== false;
      context3.drawImage(img, x5, y5, w3, h3);
    }
  });
}
var image = {
  type: "image",
  tag: "image",
  nested: false,
  attr: attr$1,
  bound: bound$1,
  draw: draw$1,
  pick: pick(),
  isect: truthy,
  get: getImage,
  xOffset: imageXOffset,
  yOffset: imageYOffset
};
var line$1 = markMultiItemPath("line", line, pickLine);
function attr$2(emit2, item) {
  var sx = item.scaleX || 1, sy = item.scaleY || 1;
  if (sx !== 1 || sy !== 1) {
    emit2("vector-effect", "non-scaling-stroke");
  }
  emit2("transform", transformItem(item));
  emit2("d", item.path);
}
function path2(context3, item) {
  var path3 = item.path;
  if (path3 == null)
    return true;
  var x5 = item.x || 0, y5 = item.y || 0, sx = item.scaleX || 1, sy = item.scaleY || 1, a2 = (item.angle || 0) * DegToRad, cache2 = item.pathCache;
  if (!cache2 || cache2.path !== path3) {
    (item.pathCache = cache2 = pathParse(path3)).path = path3;
  }
  if (a2 && context3.rotate && context3.translate) {
    context3.translate(x5, y5);
    context3.rotate(a2);
    pathRender(context3, cache2, 0, 0, sx, sy);
    context3.rotate(-a2);
    context3.translate(-x5, -y5);
  } else {
    pathRender(context3, cache2, x5, y5, sx, sy);
  }
}
function bound$2(bounds2, item) {
  return path2(boundContext(bounds2, item.angle), item) ? bounds2.set(0, 0, 0, 0) : boundStroke(bounds2, item, true);
}
var path$1 = {
  type: "path",
  tag: "path",
  nested: false,
  attr: attr$2,
  bound: bound$2,
  draw: drawAll(path2),
  pick: pickPath(path2),
  isect: intersectPath(path2)
};
function attr$3(emit2, item) {
  emit2("d", rectangle(null, item));
}
function bound$3(bounds2, item) {
  var x5, y5;
  return boundStroke(bounds2.set(x5 = item.x || 0, y5 = item.y || 0, x5 + item.width || 0, y5 + item.height || 0), item);
}
function draw$2(context3, item) {
  context3.beginPath();
  rectangle(context3, item);
}
var rect = {
  type: "rect",
  tag: "path",
  nested: false,
  attr: attr$3,
  bound: bound$3,
  draw: drawAll(draw$2),
  pick: pickPath(draw$2),
  isect: intersectRect
};
function attr$4(emit2, item) {
  emit2("transform", translateItem(item));
  emit2("x2", item.x2 != null ? item.x2 - (item.x || 0) : 0);
  emit2("y2", item.y2 != null ? item.y2 - (item.y || 0) : 0);
}
function bound$4(bounds2, item) {
  var x12, y12;
  return boundStroke(bounds2.set(x12 = item.x || 0, y12 = item.y || 0, item.x2 != null ? item.x2 : x12, item.y2 != null ? item.y2 : y12), item);
}
function path$2(context3, item, opacity2) {
  var x12, y12, x22, y22;
  if (item.stroke && stroke(context3, item, opacity2)) {
    x12 = item.x || 0;
    y12 = item.y || 0;
    x22 = item.x2 != null ? item.x2 : x12;
    y22 = item.y2 != null ? item.y2 : y12;
    context3.beginPath();
    context3.moveTo(x12, y12);
    context3.lineTo(x22, y22);
    return true;
  }
  return false;
}
function draw$3(context3, scene, bounds2) {
  visit(scene, (item) => {
    if (bounds2 && !bounds2.intersects(item.bounds))
      return;
    var opacity2 = item.opacity == null ? 1 : item.opacity;
    if (opacity2 && path$2(context3, item, opacity2)) {
      blend(context3, item);
      context3.stroke();
    }
  });
}
function hit(context3, item, x5, y5) {
  if (!context3.isPointInStroke)
    return false;
  return path$2(context3, item, 1) && context3.isPointInStroke(x5, y5);
}
var rule = {
  type: "rule",
  tag: "line",
  nested: false,
  attr: attr$4,
  bound: bound$4,
  draw: draw$3,
  pick: pick(hit),
  isect: intersectRule
};
var shape$1 = markItemPath("shape", shape);
var symbol$1 = markItemPath("symbol", symbol, intersectPoint);
var widthCache = lruCache();
var textMetrics = {
  height: fontSize,
  measureWidth,
  estimateWidth,
  width: estimateWidth,
  canvas: useCanvas
};
useCanvas(true);
function useCanvas(use) {
  textMetrics.width = use && context$1 ? measureWidth : estimateWidth;
}
function estimateWidth(item, text4) {
  return _estimateWidth(textValue(item, text4), fontSize(item));
}
function _estimateWidth(text4, currentFontHeight) {
  return ~~(0.8 * text4.length * currentFontHeight);
}
function measureWidth(item, text4) {
  return fontSize(item) <= 0 || !(text4 = textValue(item, text4)) ? 0 : _measureWidth(text4, font(item));
}
function _measureWidth(text4, currentFont) {
  const key2 = "(".concat(currentFont, ") ").concat(text4);
  let width2 = widthCache.get(key2);
  if (width2 === void 0) {
    context$1.font = currentFont;
    width2 = context$1.measureText(text4).width;
    widthCache.set(key2, width2);
  }
  return width2;
}
function fontSize(item) {
  return item.fontSize != null ? +item.fontSize || 0 : 11;
}
function lineHeight(item) {
  return item.lineHeight != null ? item.lineHeight : fontSize(item) + 2;
}
function lineArray(_) {
  return isArray(_) ? _.length > 1 ? _ : _[0] : _;
}
function textLines(item) {
  return lineArray(item.lineBreak && item.text && !isArray(item.text) ? item.text.split(item.lineBreak) : item.text);
}
function multiLineOffset(item) {
  const tl2 = textLines(item);
  return (isArray(tl2) ? tl2.length - 1 : 0) * lineHeight(item);
}
function textValue(item, line4) {
  const text4 = line4 == null ? "" : (line4 + "").trim();
  return item.limit > 0 && text4.length ? truncate2(item, text4) : text4;
}
function widthGetter(item) {
  if (textMetrics.width === measureWidth) {
    const currentFont = font(item);
    return (text4) => _measureWidth(text4, currentFont);
  } else {
    const currentFontHeight = fontSize(item);
    return (text4) => _estimateWidth(text4, currentFontHeight);
  }
}
function truncate2(item, text4) {
  var limit = +item.limit, width2 = widthGetter(item);
  if (width2(text4) < limit)
    return text4;
  var ellipsis = item.ellipsis || "\u2026", rtl = item.dir === "rtl", lo = 0, hi = text4.length, mid;
  limit -= width2(ellipsis);
  if (rtl) {
    while (lo < hi) {
      mid = lo + hi >>> 1;
      if (width2(text4.slice(mid)) > limit)
        lo = mid + 1;
      else
        hi = mid;
    }
    return ellipsis + text4.slice(lo);
  } else {
    while (lo < hi) {
      mid = 1 + (lo + hi >>> 1);
      if (width2(text4.slice(0, mid)) < limit)
        lo = mid;
      else
        hi = mid - 1;
    }
    return text4.slice(0, lo) + ellipsis;
  }
}
function fontFamily(item, quote) {
  var font3 = item.font;
  return (quote && font3 ? String(font3).replace(/"/g, "'") : font3) || "sans-serif";
}
function font(item, quote) {
  return "" + (item.fontStyle ? item.fontStyle + " " : "") + (item.fontVariant ? item.fontVariant + " " : "") + (item.fontWeight ? item.fontWeight + " " : "") + fontSize(item) + "px " + fontFamily(item, quote);
}
function offset$1(item) {
  var baseline3 = item.baseline, h3 = fontSize(item);
  return Math.round(baseline3 === "top" ? 0.79 * h3 : baseline3 === "middle" ? 0.3 * h3 : baseline3 === "bottom" ? -0.21 * h3 : baseline3 === "line-top" ? 0.29 * h3 + 0.5 * lineHeight(item) : baseline3 === "line-bottom" ? 0.29 * h3 - 0.5 * lineHeight(item) : 0);
}
var textAlign = {
  left: "start",
  center: "middle",
  right: "end"
};
var tempBounds = new Bounds();
function anchorPoint(item) {
  var x5 = item.x || 0, y5 = item.y || 0, r2 = item.radius || 0, t;
  if (r2) {
    t = (item.theta || 0) - HalfPi;
    x5 += r2 * Math.cos(t);
    y5 += r2 * Math.sin(t);
  }
  tempBounds.x1 = x5;
  tempBounds.y1 = y5;
  return tempBounds;
}
function attr$5(emit2, item) {
  var dx = item.dx || 0, dy = (item.dy || 0) + offset$1(item), p = anchorPoint(item), x5 = p.x1, y5 = p.y1, a2 = item.angle || 0, t;
  emit2("text-anchor", textAlign[item.align] || "start");
  if (a2) {
    t = translate(x5, y5) + " " + rotate(a2);
    if (dx || dy)
      t += " " + translate(dx, dy);
  } else {
    t = translate(x5 + dx, y5 + dy);
  }
  emit2("transform", t);
}
function bound$5(bounds2, item, mode) {
  var h3 = textMetrics.height(item), a2 = item.align, p = anchorPoint(item), x5 = p.x1, y5 = p.y1, dx = item.dx || 0, dy = (item.dy || 0) + offset$1(item) - Math.round(0.8 * h3), tl2 = textLines(item), w3;
  if (isArray(tl2)) {
    h3 += lineHeight(item) * (tl2.length - 1);
    w3 = tl2.reduce((w4, t) => Math.max(w4, textMetrics.width(item, t)), 0);
  } else {
    w3 = textMetrics.width(item, tl2);
  }
  if (a2 === "center") {
    dx -= w3 / 2;
  } else if (a2 === "right") {
    dx -= w3;
  } else
    ;
  bounds2.set(dx += x5, dy += y5, dx + w3, dy + h3);
  if (item.angle && !mode) {
    bounds2.rotate(item.angle * DegToRad, x5, y5);
  } else if (mode === 2) {
    return bounds2.rotatedPoints(item.angle * DegToRad, x5, y5);
  }
  return bounds2;
}
function draw$4(context3, scene, bounds2) {
  visit(scene, (item) => {
    var opacity2 = item.opacity == null ? 1 : item.opacity, p, x5, y5, i, lh, tl2, str;
    if (bounds2 && !bounds2.intersects(item.bounds) || opacity2 === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0)
      return;
    context3.font = font(item);
    context3.textAlign = item.align || "left";
    p = anchorPoint(item);
    x5 = p.x1, y5 = p.y1;
    if (item.angle) {
      context3.save();
      context3.translate(x5, y5);
      context3.rotate(item.angle * DegToRad);
      x5 = y5 = 0;
    }
    x5 += item.dx || 0;
    y5 += (item.dy || 0) + offset$1(item);
    tl2 = textLines(item);
    blend(context3, item);
    if (isArray(tl2)) {
      lh = lineHeight(item);
      for (i = 0; i < tl2.length; ++i) {
        str = textValue(item, tl2[i]);
        if (item.fill && fill(context3, item, opacity2)) {
          context3.fillText(str, x5, y5);
        }
        if (item.stroke && stroke(context3, item, opacity2)) {
          context3.strokeText(str, x5, y5);
        }
        y5 += lh;
      }
    } else {
      str = textValue(item, tl2);
      if (item.fill && fill(context3, item, opacity2)) {
        context3.fillText(str, x5, y5);
      }
      if (item.stroke && stroke(context3, item, opacity2)) {
        context3.strokeText(str, x5, y5);
      }
    }
    if (item.angle)
      context3.restore();
  });
}
function hit$1(context3, item, x5, y5, gx, gy) {
  if (item.fontSize <= 0)
    return false;
  if (!item.angle)
    return true;
  var p = anchorPoint(item), ax = p.x1, ay = p.y1, b2 = bound$5(tempBounds, item, 1), a2 = -item.angle * DegToRad, cos4 = Math.cos(a2), sin4 = Math.sin(a2), px2 = cos4 * gx - sin4 * gy + (ax - cos4 * ax + sin4 * ay), py2 = sin4 * gx + cos4 * gy + (ay - sin4 * ax - cos4 * ay);
  return b2.contains(px2, py2);
}
function intersectText(item, box) {
  const p = bound$5(tempBounds, item, 2);
  return intersectBoxLine(box, p[0], p[1], p[2], p[3]) || intersectBoxLine(box, p[0], p[1], p[4], p[5]) || intersectBoxLine(box, p[4], p[5], p[6], p[7]) || intersectBoxLine(box, p[2], p[3], p[6], p[7]);
}
var text = {
  type: "text",
  tag: "text",
  nested: false,
  attr: attr$5,
  bound: bound$5,
  draw: draw$4,
  pick: pick(hit$1),
  isect: intersectText
};
var trail$1 = markMultiItemPath("trail", trail, pickTrail);
var Marks = {
  arc: arc$1,
  area: area$1,
  group,
  image,
  line: line$1,
  path: path$1,
  rect,
  rule,
  shape: shape$1,
  symbol: symbol$1,
  text,
  trail: trail$1
};
function boundItem(item, func, opt) {
  var type2 = Marks[item.mark.marktype], bound2 = func || type2.bound;
  if (type2.nested)
    item = item.mark;
  return bound2(item.bounds || (item.bounds = new Bounds()), item, opt);
}
var DUMMY = {
  mark: null
};
function boundMark(mark2, bounds2, opt) {
  var type2 = Marks[mark2.marktype], bound2 = type2.bound, items2 = mark2.items, hasItems = items2 && items2.length, i, n, item, b2;
  if (type2.nested) {
    if (hasItems) {
      item = items2[0];
    } else {
      DUMMY.mark = mark2;
      item = DUMMY;
    }
    b2 = boundItem(item, bound2, opt);
    bounds2 = bounds2 && bounds2.union(b2) || b2;
    return bounds2;
  }
  bounds2 = bounds2 || mark2.bounds && mark2.bounds.clear() || new Bounds();
  if (hasItems) {
    for (i = 0, n = items2.length; i < n; ++i) {
      bounds2.union(boundItem(items2[i], bound2, opt));
    }
  }
  return mark2.bounds = bounds2;
}
var keys = [
  "marktype",
  "name",
  "role",
  "interactive",
  "clip",
  "items",
  "zindex",
  "x",
  "y",
  "width",
  "height",
  "align",
  "baseline",
  "fill",
  "fillOpacity",
  "opacity",
  "blend",
  "stroke",
  "strokeOpacity",
  "strokeWidth",
  "strokeCap",
  "strokeDash",
  "strokeDashOffset",
  "strokeForeground",
  "strokeOffset",
  "startAngle",
  "endAngle",
  "innerRadius",
  "outerRadius",
  "cornerRadius",
  "padAngle",
  "cornerRadiusTopLeft",
  "cornerRadiusTopRight",
  "cornerRadiusBottomLeft",
  "cornerRadiusBottomRight",
  "interpolate",
  "tension",
  "orient",
  "defined",
  "url",
  "aspect",
  "smooth",
  "path",
  "scaleX",
  "scaleY",
  "x2",
  "y2",
  "size",
  "shape",
  "text",
  "angle",
  "theta",
  "radius",
  "dir",
  "dx",
  "dy",
  "ellipsis",
  "limit",
  "lineBreak",
  "lineHeight",
  "font",
  "fontSize",
  "fontWeight",
  "fontStyle",
  "fontVariant",
  "description",
  "aria",
  "ariaRole",
  "ariaRoleDescription"
];
function sceneToJSON(scene, indent) {
  return JSON.stringify(scene, keys, indent);
}
function sceneFromJSON(json2) {
  const scene = typeof json2 === "string" ? JSON.parse(json2) : json2;
  return initialize(scene);
}
function initialize(scene) {
  var type2 = scene.marktype, items2 = scene.items, parent, i, n;
  if (items2) {
    for (i = 0, n = items2.length; i < n; ++i) {
      parent = type2 ? "mark" : "group";
      items2[i][parent] = scene;
      if (items2[i].zindex)
        items2[i][parent].zdirty = true;
      if ((type2 || parent) === "group")
        initialize(items2[i]);
    }
  }
  if (type2)
    boundMark(scene);
  return scene;
}
function Scenegraph(scene) {
  if (arguments.length) {
    this.root = sceneFromJSON(scene);
  } else {
    this.root = createMark({
      marktype: "group",
      name: "root",
      role: "frame"
    });
    this.root.items = [new GroupItem(this.root)];
  }
}
Scenegraph.prototype = {
  toJSON(indent) {
    return sceneToJSON(this.root, indent || 0);
  },
  mark(markdef, group2, index4) {
    group2 = group2 || this.root.items[0];
    const mark2 = createMark(markdef, group2);
    group2.items[index4] = mark2;
    if (mark2.zindex)
      mark2.group.zdirty = true;
    return mark2;
  }
};
function createMark(def2, group2) {
  const mark2 = {
    bounds: new Bounds(),
    clip: !!def2.clip,
    group: group2,
    interactive: def2.interactive === false ? false : true,
    items: [],
    marktype: def2.marktype,
    name: def2.name || void 0,
    role: def2.role || void 0,
    zindex: def2.zindex || 0
  };
  if (def2.aria != null) {
    mark2.aria = def2.aria;
  }
  if (def2.description) {
    mark2.description = def2.description;
  }
  return mark2;
}
function domCreate(doc, tag, ns) {
  if (!doc && typeof document !== "undefined" && document.createElement) {
    doc = document;
  }
  return doc ? ns ? doc.createElementNS(ns, tag) : doc.createElement(tag) : null;
}
function domFind(el, tag) {
  tag = tag.toLowerCase();
  var nodes = el.childNodes, i = 0, n = nodes.length;
  for (; i < n; ++i)
    if (nodes[i].tagName.toLowerCase() === tag) {
      return nodes[i];
    }
}
function domChild(el, index4, tag, ns) {
  var a2 = el.childNodes[index4], b2;
  if (!a2 || a2.tagName.toLowerCase() !== tag.toLowerCase()) {
    b2 = a2 || null;
    a2 = domCreate(el.ownerDocument, tag, ns);
    el.insertBefore(a2, b2);
  }
  return a2;
}
function domClear(el, index4) {
  var nodes = el.childNodes, curr = nodes.length;
  while (curr > index4)
    el.removeChild(nodes[--curr]);
  return el;
}
function cssClass(mark2) {
  return "mark-" + mark2.marktype + (mark2.role ? " role-" + mark2.role : "") + (mark2.name ? " " + mark2.name : "");
}
function point6(event2, el) {
  const rect3 = el.getBoundingClientRect();
  return [event2.clientX - rect3.left - (el.clientLeft || 0), event2.clientY - rect3.top - (el.clientTop || 0)];
}
function resolveItem(item, event2, el, origin) {
  var mark2 = item && item.mark, mdef, p;
  if (mark2 && (mdef = Marks[mark2.marktype]).tip) {
    p = point6(event2, el);
    p[0] -= origin[0];
    p[1] -= origin[1];
    while (item = item.mark.group) {
      p[0] -= item.x || 0;
      p[1] -= item.y || 0;
    }
    item = mdef.tip(mark2.items, p);
  }
  return item;
}
function Handler(customLoader, customTooltip) {
  this._active = null;
  this._handlers = {};
  this._loader = customLoader || loader();
  this._tooltip = customTooltip || defaultTooltip;
}
function defaultTooltip(handler, event2, item, value3) {
  handler.element().setAttribute("title", value3 || "");
}
Handler.prototype = {
  initialize(el, origin, obj) {
    this._el = el;
    this._obj = obj || null;
    return this.origin(origin);
  },
  element() {
    return this._el;
  },
  canvas() {
    return this._el && this._el.firstChild;
  },
  origin(origin) {
    if (arguments.length) {
      this._origin = origin || [0, 0];
      return this;
    } else {
      return this._origin.slice();
    }
  },
  scene(scene) {
    if (!arguments.length)
      return this._scene;
    this._scene = scene;
    return this;
  },
  on() {
  },
  off() {
  },
  _handlerIndex(h3, type2, handler) {
    for (let i = h3 ? h3.length : 0; --i >= 0; ) {
      if (h3[i].type === type2 && (!handler || h3[i].handler === handler)) {
        return i;
      }
    }
    return -1;
  },
  handlers(type2) {
    const h3 = this._handlers, a2 = [];
    if (type2) {
      a2.push(...h3[this.eventName(type2)]);
    } else {
      for (const k in h3) {
        a2.push(...h3[k]);
      }
    }
    return a2;
  },
  eventName(name4) {
    const i = name4.indexOf(".");
    return i < 0 ? name4 : name4.slice(0, i);
  },
  handleHref(event2, item, href2) {
    this._loader.sanitize(href2, {
      context: "href"
    }).then((opt) => {
      const e = new MouseEvent(event2.type, event2), a2 = domCreate(null, "a");
      for (const name4 in opt)
        a2.setAttribute(name4, opt[name4]);
      a2.dispatchEvent(e);
    }).catch(() => {
    });
  },
  handleTooltip(event2, item, show2) {
    if (item && item.tooltip != null) {
      item = resolveItem(item, event2, this.canvas(), this._origin);
      const value3 = show2 && item && item.tooltip || null;
      this._tooltip.call(this._obj, this, event2, item, value3);
    }
  },
  getItemBoundingClientRect(item) {
    const el = this.canvas();
    if (!el)
      return;
    const rect3 = el.getBoundingClientRect(), origin = this._origin, bounds2 = item.bounds, width2 = bounds2.width(), height2 = bounds2.height();
    let x5 = bounds2.x1 + origin[0] + rect3.left, y5 = bounds2.y1 + origin[1] + rect3.top;
    while (item.mark && (item = item.mark.group)) {
      x5 += item.x || 0;
      y5 += item.y || 0;
    }
    return {
      x: x5,
      y: y5,
      width: width2,
      height: height2,
      left: x5,
      top: y5,
      right: x5 + width2,
      bottom: y5 + height2
    };
  }
};
function Renderer(loader2) {
  this._el = null;
  this._bgcolor = null;
  this._loader = new ResourceLoader(loader2);
}
Renderer.prototype = {
  initialize(el, width2, height2, origin, scaleFactor) {
    this._el = el;
    return this.resize(width2, height2, origin, scaleFactor);
  },
  element() {
    return this._el;
  },
  canvas() {
    return this._el && this._el.firstChild;
  },
  background(bgcolor) {
    if (arguments.length === 0)
      return this._bgcolor;
    this._bgcolor = bgcolor;
    return this;
  },
  resize(width2, height2, origin, scaleFactor) {
    this._width = width2;
    this._height = height2;
    this._origin = origin || [0, 0];
    this._scale = scaleFactor || 1;
    return this;
  },
  dirty() {
  },
  render(scene) {
    const r2 = this;
    r2._call = function() {
      r2._render(scene);
    };
    r2._call();
    r2._call = null;
    return r2;
  },
  _render() {
  },
  renderAsync(scene) {
    const r2 = this.render(scene);
    return this._ready ? this._ready.then(() => r2) : Promise.resolve(r2);
  },
  _load(method2, uri) {
    var r2 = this, p = r2._loader[method2](uri);
    if (!r2._ready) {
      const call = r2._call;
      r2._ready = r2._loader.ready().then((redraw) => {
        if (redraw)
          call();
        r2._ready = null;
      });
    }
    return p;
  },
  sanitizeURL(uri) {
    return this._load("sanitizeURL", uri);
  },
  loadImage(uri) {
    return this._load("loadImage", uri);
  }
};
var KeyDownEvent = "keydown";
var KeyPressEvent = "keypress";
var KeyUpEvent = "keyup";
var DragEnterEvent = "dragenter";
var DragLeaveEvent = "dragleave";
var DragOverEvent = "dragover";
var MouseDownEvent = "mousedown";
var MouseUpEvent = "mouseup";
var MouseMoveEvent = "mousemove";
var MouseOutEvent = "mouseout";
var MouseOverEvent = "mouseover";
var ClickEvent = "click";
var DoubleClickEvent = "dblclick";
var WheelEvent = "wheel";
var MouseWheelEvent = "mousewheel";
var TouchStartEvent = "touchstart";
var TouchMoveEvent = "touchmove";
var TouchEndEvent = "touchend";
var Events = [KeyDownEvent, KeyPressEvent, KeyUpEvent, DragEnterEvent, DragLeaveEvent, DragOverEvent, MouseDownEvent, MouseUpEvent, MouseMoveEvent, MouseOutEvent, MouseOverEvent, ClickEvent, DoubleClickEvent, WheelEvent, MouseWheelEvent, TouchStartEvent, TouchMoveEvent, TouchEndEvent];
var TooltipShowEvent = MouseMoveEvent;
var TooltipHideEvent = MouseOutEvent;
var HrefEvent = ClickEvent;
function CanvasHandler(loader2, tooltip2) {
  Handler.call(this, loader2, tooltip2);
  this._down = null;
  this._touch = null;
  this._first = true;
  this._events = {};
}
var eventBundle = (type2) => type2 === TouchStartEvent || type2 === TouchMoveEvent || type2 === TouchEndEvent ? [TouchStartEvent, TouchMoveEvent, TouchEndEvent] : [type2];
function eventListenerCheck(handler, type2) {
  eventBundle(type2).forEach((_) => addEventListener(handler, _));
}
function addEventListener(handler, type2) {
  const canvas = handler.canvas();
  if (canvas && !handler._events[type2]) {
    handler._events[type2] = 1;
    canvas.addEventListener(type2, handler[type2] ? (evt) => handler[type2](evt) : (evt) => handler.fire(type2, evt));
  }
}
function move(moveEvent, overEvent, outEvent) {
  return function(evt) {
    const a2 = this._active, p = this.pickEvent(evt);
    if (p === a2) {
      this.fire(moveEvent, evt);
    } else {
      if (!a2 || !a2.exit) {
        this.fire(outEvent, evt);
      }
      this._active = p;
      this.fire(overEvent, evt);
      this.fire(moveEvent, evt);
    }
  };
}
function inactive(type2) {
  return function(evt) {
    this.fire(type2, evt);
    this._active = null;
  };
}
inherits(CanvasHandler, Handler, {
  initialize(el, origin, obj) {
    this._canvas = el && domFind(el, "canvas");
    [ClickEvent, MouseDownEvent, MouseMoveEvent, MouseOutEvent, DragLeaveEvent].forEach((type2) => eventListenerCheck(this, type2));
    return Handler.prototype.initialize.call(this, el, origin, obj);
  },
  canvas() {
    return this._canvas;
  },
  context() {
    return this._canvas.getContext("2d");
  },
  events: Events,
  DOMMouseScroll(evt) {
    this.fire(MouseWheelEvent, evt);
  },
  mousemove: move(MouseMoveEvent, MouseOverEvent, MouseOutEvent),
  dragover: move(DragOverEvent, DragEnterEvent, DragLeaveEvent),
  mouseout: inactive(MouseOutEvent),
  dragleave: inactive(DragLeaveEvent),
  mousedown(evt) {
    this._down = this._active;
    this.fire(MouseDownEvent, evt);
  },
  click(evt) {
    if (this._down === this._active) {
      this.fire(ClickEvent, evt);
      this._down = null;
    }
  },
  touchstart(evt) {
    this._touch = this.pickEvent(evt.changedTouches[0]);
    if (this._first) {
      this._active = this._touch;
      this._first = false;
    }
    this.fire(TouchStartEvent, evt, true);
  },
  touchmove(evt) {
    this.fire(TouchMoveEvent, evt, true);
  },
  touchend(evt) {
    this.fire(TouchEndEvent, evt, true);
    this._touch = null;
  },
  fire(type2, evt, touch2) {
    const a2 = touch2 ? this._touch : this._active, h3 = this._handlers[type2];
    evt.vegaType = type2;
    if (type2 === HrefEvent && a2 && a2.href) {
      this.handleHref(evt, a2, a2.href);
    } else if (type2 === TooltipShowEvent || type2 === TooltipHideEvent) {
      this.handleTooltip(evt, a2, type2 !== TooltipHideEvent);
    }
    if (h3) {
      for (let i = 0, len = h3.length; i < len; ++i) {
        h3[i].handler.call(this._obj, evt, a2);
      }
    }
  },
  on(type2, handler) {
    const name4 = this.eventName(type2), h3 = this._handlers, i = this._handlerIndex(h3[name4], type2, handler);
    if (i < 0) {
      eventListenerCheck(this, type2);
      (h3[name4] || (h3[name4] = [])).push({
        type: type2,
        handler
      });
    }
    return this;
  },
  off(type2, handler) {
    const name4 = this.eventName(type2), h3 = this._handlers[name4], i = this._handlerIndex(h3, type2, handler);
    if (i >= 0) {
      h3.splice(i, 1);
    }
    return this;
  },
  pickEvent(evt) {
    const p = point6(evt, this._canvas), o = this._origin;
    return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);
  },
  pick(scene, x5, y5, gx, gy) {
    const g = this.context(), mark2 = Marks[scene.marktype];
    return mark2.pick.call(this, g, scene, x5, y5, gx, gy);
  }
});
function devicePixelRatio() {
  return typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1;
}
var pixelRatio = devicePixelRatio();
function resize(canvas, width2, height2, origin, scaleFactor, opt) {
  const inDOM = typeof HTMLElement !== "undefined" && canvas instanceof HTMLElement && canvas.parentNode != null, context3 = canvas.getContext("2d"), ratio = inDOM ? pixelRatio : scaleFactor;
  canvas.width = width2 * ratio;
  canvas.height = height2 * ratio;
  for (const key2 in opt) {
    context3[key2] = opt[key2];
  }
  if (inDOM && ratio !== 1) {
    canvas.style.width = width2 + "px";
    canvas.style.height = height2 + "px";
  }
  context3.pixelRatio = ratio;
  context3.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);
  return canvas;
}
function CanvasRenderer(loader2) {
  Renderer.call(this, loader2);
  this._options = {};
  this._redraw = false;
  this._dirty = new Bounds();
  this._tempb = new Bounds();
}
var base = Renderer.prototype;
var viewBounds = (origin, width2, height2) => new Bounds().set(0, 0, width2, height2).translate(-origin[0], -origin[1]);
function clipToBounds(g, b2, origin) {
  b2.expand(1).round();
  if (g.pixelRatio % 1) {
    b2.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);
  }
  b2.translate(-(origin[0] % 1), -(origin[1] % 1));
  g.beginPath();
  g.rect(b2.x1, b2.y1, b2.width(), b2.height());
  g.clip();
  return b2;
}
inherits(CanvasRenderer, Renderer, {
  initialize(el, width2, height2, origin, scaleFactor, options2) {
    this._options = options2 || {};
    this._canvas = this._options.externalContext ? null : domCanvas(1, 1, this._options.type);
    if (el && this._canvas) {
      domClear(el, 0).appendChild(this._canvas);
      this._canvas.setAttribute("class", "marks");
    }
    return base.initialize.call(this, el, width2, height2, origin, scaleFactor);
  },
  resize(width2, height2, origin, scaleFactor) {
    base.resize.call(this, width2, height2, origin, scaleFactor);
    if (this._canvas) {
      resize(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
    } else {
      const ctx = this._options.externalContext;
      if (!ctx)
        error("CanvasRenderer is missing a valid canvas or context");
      ctx.scale(this._scale, this._scale);
      ctx.translate(this._origin[0], this._origin[1]);
    }
    this._redraw = true;
    return this;
  },
  canvas() {
    return this._canvas;
  },
  context() {
    return this._options.externalContext || (this._canvas ? this._canvas.getContext("2d") : null);
  },
  dirty(item) {
    const b2 = this._tempb.clear().union(item.bounds);
    let g = item.mark.group;
    while (g) {
      b2.translate(g.x || 0, g.y || 0);
      g = g.mark.group;
    }
    this._dirty.union(b2);
  },
  _render(scene) {
    const g = this.context(), o = this._origin, w3 = this._width, h3 = this._height, db = this._dirty, vb = viewBounds(o, w3, h3);
    g.save();
    const b2 = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds(g, vb.intersect(db), o);
    this.clear(-o[0], -o[1], w3, h3);
    this.draw(g, scene, b2);
    g.restore();
    db.clear();
    return this;
  },
  draw(ctx, scene, bounds2) {
    const mark2 = Marks[scene.marktype];
    if (scene.clip)
      clip$1(ctx, scene);
    mark2.draw.call(this, ctx, scene, bounds2);
    if (scene.clip)
      ctx.restore();
  },
  clear(x5, y5, w3, h3) {
    const opt = this._options, g = this.context();
    if (opt.type !== "pdf" && !opt.externalContext) {
      g.clearRect(x5, y5, w3, h3);
    }
    if (this._bgcolor != null) {
      g.fillStyle = this._bgcolor;
      g.fillRect(x5, y5, w3, h3);
    }
  }
});
function SVGHandler(loader2, tooltip2) {
  Handler.call(this, loader2, tooltip2);
  const h3 = this;
  h3._hrefHandler = listener(h3, (evt, item) => {
    if (item && item.href)
      h3.handleHref(evt, item, item.href);
  });
  h3._tooltipHandler = listener(h3, (evt, item) => {
    h3.handleTooltip(evt, item, evt.type !== TooltipHideEvent);
  });
}
var listener = (context3, handler) => (evt) => {
  let item = evt.target.__data__;
  item = Array.isArray(item) ? item[0] : item;
  evt.vegaType = evt.type;
  handler.call(context3._obj, evt, item);
};
inherits(SVGHandler, Handler, {
  initialize(el, origin, obj) {
    let svg = this._svg;
    if (svg) {
      svg.removeEventListener(HrefEvent, this._hrefHandler);
      svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);
      svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);
    }
    this._svg = svg = el && domFind(el, "svg");
    if (svg) {
      svg.addEventListener(HrefEvent, this._hrefHandler);
      svg.addEventListener(TooltipShowEvent, this._tooltipHandler);
      svg.addEventListener(TooltipHideEvent, this._tooltipHandler);
    }
    return Handler.prototype.initialize.call(this, el, origin, obj);
  },
  canvas() {
    return this._svg;
  },
  on(type2, handler) {
    const name4 = this.eventName(type2), h3 = this._handlers, i = this._handlerIndex(h3[name4], type2, handler);
    if (i < 0) {
      const x5 = {
        type: type2,
        handler,
        listener: listener(this, handler)
      };
      (h3[name4] || (h3[name4] = [])).push(x5);
      if (this._svg) {
        this._svg.addEventListener(name4, x5.listener);
      }
    }
    return this;
  },
  off(type2, handler) {
    const name4 = this.eventName(type2), h3 = this._handlers[name4], i = this._handlerIndex(h3, type2, handler);
    if (i >= 0) {
      if (this._svg) {
        this._svg.removeEventListener(name4, h3[i].listener);
      }
      h3.splice(i, 1);
    }
    return this;
  }
});
var ARIA_HIDDEN = "aria-hidden";
var ARIA_LABEL = "aria-label";
var ARIA_ROLE = "role";
var ARIA_ROLEDESCRIPTION = "aria-roledescription";
var GRAPHICS_OBJECT = "graphics-object";
var GRAPHICS_SYMBOL = "graphics-symbol";
var bundle = (role, roledesc, label) => ({
  [ARIA_ROLE]: role,
  [ARIA_ROLEDESCRIPTION]: roledesc,
  [ARIA_LABEL]: label || void 0
});
var AriaIgnore = toSet(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]);
var AriaGuides = {
  axis: {
    desc: "axis",
    caption: axisCaption
  },
  legend: {
    desc: "legend",
    caption: legendCaption
  },
  "title-text": {
    desc: "title",
    caption: (item) => "Title text '".concat(titleCaption(item), "'")
  },
  "title-subtitle": {
    desc: "subtitle",
    caption: (item) => "Subtitle text '".concat(titleCaption(item), "'")
  }
};
var AriaEncode = {
  ariaRole: ARIA_ROLE,
  ariaRoleDescription: ARIA_ROLEDESCRIPTION,
  description: ARIA_LABEL
};
function ariaItemAttributes(emit2, item) {
  const hide = item.aria === false;
  emit2(ARIA_HIDDEN, hide || void 0);
  if (hide || item.description == null) {
    for (const prop in AriaEncode) {
      emit2(AriaEncode[prop], void 0);
    }
  } else {
    const type2 = item.mark.marktype;
    emit2(ARIA_LABEL, item.description);
    emit2(ARIA_ROLE, item.ariaRole || (type2 === "group" ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL));
    emit2(ARIA_ROLEDESCRIPTION, item.ariaRoleDescription || "".concat(type2, " mark"));
  }
}
function ariaMarkAttributes(mark2) {
  return mark2.aria === false ? {
    [ARIA_HIDDEN]: true
  } : AriaIgnore[mark2.role] ? null : AriaGuides[mark2.role] ? ariaGuide(mark2, AriaGuides[mark2.role]) : ariaMark(mark2);
}
function ariaMark(mark2) {
  const type2 = mark2.marktype;
  const recurse2 = type2 === "group" || type2 === "text" || mark2.items.some((_) => _.description != null && _.aria !== false);
  return bundle(recurse2 ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL, "".concat(type2, " mark container"), mark2.description);
}
function ariaGuide(mark2, opt) {
  try {
    const item = mark2.items[0], caption = opt.caption || (() => "");
    return bundle(opt.role || GRAPHICS_SYMBOL, opt.desc, item.description || caption(item));
  } catch (err) {
    return null;
  }
}
function titleCaption(item) {
  return array(item.text).join(" ");
}
function axisCaption(item) {
  const datum3 = item.datum, orient3 = item.orient, title2 = datum3.title ? extractTitle(item) : null, ctx = item.context, scale7 = ctx.scales[datum3.scale].value, locale6 = ctx.dataflow.locale(), type2 = scale7.type, xy = orient3 === "left" || orient3 === "right" ? "Y" : "X";
  return "".concat(xy, "-axis") + (title2 ? " titled '".concat(title2, "'") : "") + " for a ".concat(isDiscrete(type2) ? "discrete" : type2, " scale") + " with ".concat(domainCaption(locale6, scale7, item));
}
function legendCaption(item) {
  const datum3 = item.datum, title2 = datum3.title ? extractTitle(item) : null, type2 = "".concat(datum3.type || "", " legend").trim(), scales2 = datum3.scales, props = Object.keys(scales2), ctx = item.context, scale7 = ctx.scales[scales2[props[0]]].value, locale6 = ctx.dataflow.locale();
  return capitalize(type2) + (title2 ? " titled '".concat(title2, "'") : "") + " for ".concat(channelCaption(props)) + " with ".concat(domainCaption(locale6, scale7, item));
}
function extractTitle(item) {
  try {
    return array(peek(item.items).items[0].text).join(" ");
  } catch (err) {
    return null;
  }
}
function channelCaption(props) {
  props = props.map((p) => p + (p === "fill" || p === "stroke" ? " color" : ""));
  return props.length < 2 ? props[0] : props.slice(0, -1).join(", ") + " and " + peek(props);
}
function capitalize(s) {
  return s.length ? s[0].toUpperCase() + s.slice(1) : s;
}
var innerText = (val) => (val + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
var attrText = (val) => innerText(val).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
function markup() {
  let buf = "", outer = "", inner = "";
  const stack3 = [], clear2 = () => outer = inner = "", push = (tag) => {
    if (outer) {
      buf += "".concat(outer, ">").concat(inner);
      clear2();
    }
    stack3.push(tag);
  }, attr2 = (name4, value3) => {
    if (value3 != null)
      outer += " ".concat(name4, '="').concat(attrText(value3), '"');
    return m2;
  }, m2 = {
    open(tag, ...attrs) {
      push(tag);
      outer = "<" + tag;
      for (const set6 of attrs) {
        for (const key2 in set6)
          attr2(key2, set6[key2]);
      }
      return m2;
    },
    close() {
      const tag = stack3.pop();
      if (outer) {
        buf += outer + (inner ? ">".concat(inner, "</").concat(tag, ">") : "/>");
      } else {
        buf += "</".concat(tag, ">");
      }
      clear2();
      return m2;
    },
    attr: attr2,
    text: (t) => (inner += innerText(t), m2),
    toString: () => buf
  };
  return m2;
}
var serializeXML = (node) => _serialize(markup(), node) + "";
function _serialize(m2, node) {
  m2.open(node.tagName);
  if (node.hasAttributes()) {
    const attrs = node.attributes, n = attrs.length;
    for (let i = 0; i < n; ++i) {
      m2.attr(attrs[i].name, attrs[i].value);
    }
  }
  if (node.hasChildNodes()) {
    const children4 = node.childNodes, n = children4.length;
    for (let i = 0; i < n; i++) {
      const child = children4[i];
      child.nodeType === 3 ? m2.text(child.nodeValue) : _serialize(m2, child);
    }
  }
  return m2.close();
}
var styles = {
  fill: "fill",
  fillOpacity: "fill-opacity",
  stroke: "stroke",
  strokeOpacity: "stroke-opacity",
  strokeWidth: "stroke-width",
  strokeCap: "stroke-linecap",
  strokeJoin: "stroke-linejoin",
  strokeDash: "stroke-dasharray",
  strokeDashOffset: "stroke-dashoffset",
  strokeMiterLimit: "stroke-miterlimit",
  opacity: "opacity",
  blend: "mix-blend-mode"
};
var rootAttributes = {
  fill: "none",
  "stroke-miterlimit": 10
};
var RootIndex = 0;
var xmlns = "http://www.w3.org/2000/xmlns/";
var svgns = metadata.xmlns;
function SVGRenderer(loader2) {
  Renderer.call(this, loader2);
  this._dirtyID = 0;
  this._dirty = [];
  this._svg = null;
  this._root = null;
  this._defs = null;
}
var base$1 = Renderer.prototype;
inherits(SVGRenderer, Renderer, {
  initialize(el, width2, height2, origin, scaleFactor) {
    this._defs = {};
    this._clearDefs();
    if (el) {
      this._svg = domChild(el, 0, "svg", svgns);
      this._svg.setAttributeNS(xmlns, "xmlns", svgns);
      this._svg.setAttributeNS(xmlns, "xmlns:xlink", metadata["xmlns:xlink"]);
      this._svg.setAttribute("version", metadata["version"]);
      this._svg.setAttribute("class", "marks");
      domClear(el, 1);
      this._root = domChild(this._svg, RootIndex, "g", svgns);
      setAttributes(this._root, rootAttributes);
      domClear(this._svg, RootIndex + 1);
    }
    this.background(this._bgcolor);
    return base$1.initialize.call(this, el, width2, height2, origin, scaleFactor);
  },
  background(bgcolor) {
    if (arguments.length && this._svg) {
      this._svg.style.setProperty("background-color", bgcolor);
    }
    return base$1.background.apply(this, arguments);
  },
  resize(width2, height2, origin, scaleFactor) {
    base$1.resize.call(this, width2, height2, origin, scaleFactor);
    if (this._svg) {
      setAttributes(this._svg, {
        width: this._width * this._scale,
        height: this._height * this._scale,
        viewBox: "0 0 ".concat(this._width, " ").concat(this._height)
      });
      this._root.setAttribute("transform", "translate(".concat(this._origin, ")"));
    }
    this._dirty = [];
    return this;
  },
  canvas() {
    return this._svg;
  },
  svg() {
    const svg = this._svg, bg = this._bgcolor;
    if (!svg)
      return null;
    let node;
    if (bg) {
      svg.removeAttribute("style");
      node = domChild(svg, RootIndex, "rect", svgns);
      setAttributes(node, {
        width: this._width,
        height: this._height,
        fill: bg
      });
    }
    const text4 = serializeXML(svg);
    if (bg) {
      svg.removeChild(node);
      this._svg.style.setProperty("background-color", bg);
    }
    return text4;
  },
  _render(scene) {
    if (this._dirtyCheck()) {
      if (this._dirtyAll)
        this._clearDefs();
      this.mark(this._root, scene);
      domClear(this._root, 1);
    }
    this.defs();
    this._dirty = [];
    ++this._dirtyID;
    return this;
  },
  dirty(item) {
    if (item.dirty !== this._dirtyID) {
      item.dirty = this._dirtyID;
      this._dirty.push(item);
    }
  },
  isDirty(item) {
    return this._dirtyAll || !item._svg || item.dirty === this._dirtyID;
  },
  _dirtyCheck() {
    this._dirtyAll = true;
    const items2 = this._dirty;
    if (!items2.length || !this._dirtyID)
      return true;
    const id4 = ++this._dirtyID;
    let item, mark2, type2, mdef, i, n, o;
    for (i = 0, n = items2.length; i < n; ++i) {
      item = items2[i];
      mark2 = item.mark;
      if (mark2.marktype !== type2) {
        type2 = mark2.marktype;
        mdef = Marks[type2];
      }
      if (mark2.zdirty && mark2.dirty !== id4) {
        this._dirtyAll = false;
        dirtyParents(item, id4);
        mark2.items.forEach((i2) => {
          i2.dirty = id4;
        });
      }
      if (mark2.zdirty)
        continue;
      if (item.exit) {
        if (mdef.nested && mark2.items.length) {
          o = mark2.items[0];
          if (o._svg)
            this._update(mdef, o._svg, o);
        } else if (item._svg) {
          o = item._svg.parentNode;
          if (o)
            o.removeChild(item._svg);
        }
        item._svg = null;
        continue;
      }
      item = mdef.nested ? mark2.items[0] : item;
      if (item._update === id4)
        continue;
      if (!item._svg || !item._svg.ownerSVGElement) {
        this._dirtyAll = false;
        dirtyParents(item, id4);
      } else {
        this._update(mdef, item._svg, item);
      }
      item._update = id4;
    }
    return !this._dirtyAll;
  },
  mark(el, scene, prev) {
    if (!this.isDirty(scene))
      return scene._svg;
    const svg = this._svg, mdef = Marks[scene.marktype], events4 = scene.interactive === false ? "none" : null, isGroup = mdef.tag === "g";
    let sibling = null, i = 0;
    const parent = bind(scene, el, prev, "g", svg);
    parent.setAttribute("class", cssClass(scene));
    const aria2 = ariaMarkAttributes(scene);
    for (const key2 in aria2)
      setAttribute(parent, key2, aria2[key2]);
    if (!isGroup) {
      setAttribute(parent, "pointer-events", events4);
    }
    setAttribute(parent, "clip-path", scene.clip ? clip(this, scene, scene.group) : null);
    const process2 = (item) => {
      const dirty = this.isDirty(item), node = bind(item, parent, sibling, mdef.tag, svg);
      if (dirty) {
        this._update(mdef, node, item);
        if (isGroup)
          recurse(this, node, item);
      }
      sibling = node;
      ++i;
    };
    if (mdef.nested) {
      if (scene.items.length)
        process2(scene.items[0]);
    } else {
      visit(scene, process2);
    }
    domClear(parent, i);
    return parent;
  },
  _update(mdef, el, item) {
    element = el;
    values = el.__values__;
    ariaItemAttributes(emit, item);
    mdef.attr(emit, item, this);
    const extra = mark_extras[mdef.type];
    if (extra)
      extra.call(this, mdef, el, item);
    if (element)
      this.style(element, item);
  },
  style(el, item) {
    if (item == null)
      return;
    for (const prop in styles) {
      let value3 = prop === "font" ? fontFamily(item) : item[prop];
      if (value3 === values[prop])
        continue;
      const name4 = styles[prop];
      if (value3 == null) {
        el.removeAttribute(name4);
      } else {
        if (isGradient(value3)) {
          value3 = gradientRef(value3, this._defs.gradient, href());
        }
        el.setAttribute(name4, value3 + "");
      }
      values[prop] = value3;
    }
  },
  defs() {
    const svg = this._svg, defs = this._defs;
    let el = defs.el, index4 = 0;
    for (const id4 in defs.gradient) {
      if (!el)
        defs.el = el = domChild(svg, RootIndex + 1, "defs", svgns);
      index4 = updateGradient(el, defs.gradient[id4], index4);
    }
    for (const id4 in defs.clipping) {
      if (!el)
        defs.el = el = domChild(svg, RootIndex + 1, "defs", svgns);
      index4 = updateClipping(el, defs.clipping[id4], index4);
    }
    if (el) {
      index4 === 0 ? (svg.removeChild(el), defs.el = null) : domClear(el, index4);
    }
  },
  _clearDefs() {
    const def2 = this._defs;
    def2.gradient = {};
    def2.clipping = {};
  }
});
function dirtyParents(item, id4) {
  for (; item && item.dirty !== id4; item = item.mark.group) {
    item.dirty = id4;
    if (item.mark && item.mark.dirty !== id4) {
      item.mark.dirty = id4;
    } else
      return;
  }
}
function updateGradient(el, grad, index4) {
  let i, n, stop2;
  if (grad.gradient === "radial") {
    let pt = domChild(el, index4++, "pattern", svgns);
    setAttributes(pt, {
      id: patternPrefix + grad.id,
      viewBox: "0,0,1,1",
      width: "100%",
      height: "100%",
      preserveAspectRatio: "xMidYMid slice"
    });
    pt = domChild(pt, 0, "rect", svgns);
    setAttributes(pt, {
      width: 1,
      height: 1,
      fill: "url(".concat(href(), "#").concat(grad.id, ")")
    });
    el = domChild(el, index4++, "radialGradient", svgns);
    setAttributes(el, {
      id: grad.id,
      fx: grad.x1,
      fy: grad.y1,
      fr: grad.r1,
      cx: grad.x2,
      cy: grad.y2,
      r: grad.r2
    });
  } else {
    el = domChild(el, index4++, "linearGradient", svgns);
    setAttributes(el, {
      id: grad.id,
      x1: grad.x1,
      x2: grad.x2,
      y1: grad.y1,
      y2: grad.y2
    });
  }
  for (i = 0, n = grad.stops.length; i < n; ++i) {
    stop2 = domChild(el, i, "stop", svgns);
    stop2.setAttribute("offset", grad.stops[i].offset);
    stop2.setAttribute("stop-color", grad.stops[i].color);
  }
  domClear(el, i);
  return index4;
}
function updateClipping(el, clip3, index4) {
  let mask;
  el = domChild(el, index4, "clipPath", svgns);
  el.setAttribute("id", clip3.id);
  if (clip3.path) {
    mask = domChild(el, 0, "path", svgns);
    mask.setAttribute("d", clip3.path);
  } else {
    mask = domChild(el, 0, "rect", svgns);
    setAttributes(mask, {
      x: 0,
      y: 0,
      width: clip3.width,
      height: clip3.height
    });
  }
  domClear(el, 1);
  return index4 + 1;
}
function recurse(renderer, el, group2) {
  el = el.lastChild.previousSibling;
  let prev, idx = 0;
  visit(group2, (item) => {
    prev = renderer.mark(el, item, prev);
    ++idx;
  });
  domClear(el, 1 + idx);
}
function bind(item, el, sibling, tag, svg) {
  let node = item._svg, doc;
  if (!node) {
    doc = el.ownerDocument;
    node = domCreate(doc, tag, svgns);
    item._svg = node;
    if (item.mark) {
      node.__data__ = item;
      node.__values__ = {
        fill: "default"
      };
      if (tag === "g") {
        const bg = domCreate(doc, "path", svgns);
        node.appendChild(bg);
        bg.__data__ = item;
        const cg = domCreate(doc, "g", svgns);
        node.appendChild(cg);
        cg.__data__ = item;
        const fg = domCreate(doc, "path", svgns);
        node.appendChild(fg);
        fg.__data__ = item;
        fg.__values__ = {
          fill: "default"
        };
      }
    }
  }
  if (node.ownerSVGElement !== svg || siblingCheck(node, sibling)) {
    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);
  }
  return node;
}
function siblingCheck(node, sibling) {
  return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling;
}
var element = null;
var values = null;
var mark_extras = {
  group(mdef, el, item) {
    const fg = element = el.childNodes[2];
    values = fg.__values__;
    mdef.foreground(emit, item, this);
    values = el.__values__;
    element = el.childNodes[1];
    mdef.content(emit, item, this);
    const bg = element = el.childNodes[0];
    mdef.background(emit, item, this);
    const value3 = item.mark.interactive === false ? "none" : null;
    if (value3 !== values.events) {
      setAttribute(fg, "pointer-events", value3);
      setAttribute(bg, "pointer-events", value3);
      values.events = value3;
    }
    if (item.strokeForeground && item.stroke) {
      const fill2 = item.fill;
      setAttribute(fg, "display", null);
      this.style(bg, item);
      setAttribute(bg, "stroke", null);
      if (fill2)
        item.fill = null;
      values = fg.__values__;
      this.style(fg, item);
      if (fill2)
        item.fill = fill2;
      element = null;
    } else {
      setAttribute(fg, "display", "none");
    }
  },
  image(mdef, el, item) {
    if (item.smooth === false) {
      setStyle(el, "image-rendering", "optimizeSpeed");
      setStyle(el, "image-rendering", "pixelated");
    } else {
      setStyle(el, "image-rendering", null);
    }
  },
  text(mdef, el, item) {
    const tl2 = textLines(item);
    let key2, value3, doc, lh;
    if (isArray(tl2)) {
      value3 = tl2.map((_) => textValue(item, _));
      key2 = value3.join("\n");
      if (key2 !== values.text) {
        domClear(el, 0);
        doc = el.ownerDocument;
        lh = lineHeight(item);
        value3.forEach((t, i) => {
          const ts2 = domCreate(doc, "tspan", svgns);
          ts2.__data__ = item;
          ts2.textContent = t;
          if (i) {
            ts2.setAttribute("x", 0);
            ts2.setAttribute("dy", lh);
          }
          el.appendChild(ts2);
        });
        values.text = key2;
      }
    } else {
      value3 = textValue(item, tl2);
      if (value3 !== values.text) {
        el.textContent = value3;
        values.text = value3;
      }
    }
    setAttribute(el, "font-family", fontFamily(item));
    setAttribute(el, "font-size", fontSize(item) + "px");
    setAttribute(el, "font-style", item.fontStyle);
    setAttribute(el, "font-variant", item.fontVariant);
    setAttribute(el, "font-weight", item.fontWeight);
  }
};
function emit(name4, value3, ns) {
  if (value3 === values[name4])
    return;
  if (ns) {
    setAttributeNS(element, name4, value3, ns);
  } else {
    setAttribute(element, name4, value3);
  }
  values[name4] = value3;
}
function setStyle(el, name4, value3) {
  if (value3 !== values[name4]) {
    if (value3 == null) {
      el.style.removeProperty(name4);
    } else {
      el.style.setProperty(name4, value3 + "");
    }
    values[name4] = value3;
  }
}
function setAttributes(el, attrs) {
  for (const key2 in attrs) {
    setAttribute(el, key2, attrs[key2]);
  }
}
function setAttribute(el, name4, value3) {
  if (value3 != null) {
    el.setAttribute(name4, value3);
  } else {
    el.removeAttribute(name4);
  }
}
function setAttributeNS(el, name4, value3, ns) {
  if (value3 != null) {
    el.setAttributeNS(ns, name4, value3);
  } else {
    el.removeAttributeNS(ns, name4);
  }
}
function href() {
  let loc;
  return typeof window === "undefined" ? "" : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;
}
function SVGStringRenderer(loader2) {
  Renderer.call(this, loader2);
  this._text = null;
  this._defs = {
    gradient: {},
    clipping: {}
  };
}
inherits(SVGStringRenderer, Renderer, {
  svg() {
    return this._text;
  },
  _render(scene) {
    const m2 = markup();
    m2.open("svg", extend({}, metadata, {
      class: "marks",
      width: this._width * this._scale,
      height: this._height * this._scale,
      viewBox: "0 0 ".concat(this._width, " ").concat(this._height)
    }));
    const bg = this._bgcolor;
    if (bg && bg !== "transparent" && bg !== "none") {
      m2.open("rect", {
        width: this._width,
        height: this._height,
        fill: bg
      }).close();
    }
    m2.open("g", rootAttributes, {
      transform: "translate(" + this._origin + ")"
    });
    this.mark(m2, scene);
    m2.close();
    this.defs(m2);
    this._text = m2.close() + "";
    return this;
  },
  mark(m2, scene) {
    const mdef = Marks[scene.marktype], tag = mdef.tag, attrList = [ariaItemAttributes, mdef.attr];
    m2.open("g", {
      class: cssClass(scene),
      "clip-path": scene.clip ? clip(this, scene, scene.group) : null
    }, ariaMarkAttributes(scene), {
      "pointer-events": tag !== "g" && scene.interactive === false ? "none" : null
    });
    const process2 = (item) => {
      const href2 = this.href(item);
      if (href2)
        m2.open("a", href2);
      m2.open(tag, this.attr(scene, item, attrList, tag !== "g" ? tag : null));
      if (tag === "text") {
        const tl2 = textLines(item);
        if (isArray(tl2)) {
          const attrs = {
            x: 0,
            dy: lineHeight(item)
          };
          for (let i = 0; i < tl2.length; ++i) {
            m2.open("tspan", i ? attrs : null).text(textValue(item, tl2[i])).close();
          }
        } else {
          m2.text(textValue(item, tl2));
        }
      } else if (tag === "g") {
        const fore = item.strokeForeground, fill2 = item.fill, stroke2 = item.stroke;
        if (fore && stroke2) {
          item.stroke = null;
        }
        m2.open("path", this.attr(scene, item, mdef.background, "bgrect")).close();
        m2.open("g", this.attr(scene, item, mdef.content));
        visit(item, (scene2) => this.mark(m2, scene2));
        m2.close();
        if (fore && stroke2) {
          if (fill2)
            item.fill = null;
          item.stroke = stroke2;
          m2.open("path", this.attr(scene, item, mdef.foreground, "bgrect")).close();
          if (fill2)
            item.fill = fill2;
        } else {
          m2.open("path", this.attr(scene, item, mdef.foreground, "bgfore")).close();
        }
      }
      m2.close();
      if (href2)
        m2.close();
    };
    if (mdef.nested) {
      if (scene.items && scene.items.length)
        process2(scene.items[0]);
    } else {
      visit(scene, process2);
    }
    return m2.close();
  },
  href(item) {
    const href2 = item.href;
    let attr2;
    if (href2) {
      if (attr2 = this._hrefs && this._hrefs[href2]) {
        return attr2;
      } else {
        this.sanitizeURL(href2).then((attr3) => {
          attr3["xlink:href"] = attr3.href;
          attr3.href = null;
          (this._hrefs || (this._hrefs = {}))[href2] = attr3;
        });
      }
    }
    return null;
  },
  attr(scene, item, attrs, tag) {
    const object2 = {}, emit2 = (name4, value3, ns, prefixed) => {
      object2[prefixed || name4] = value3;
    };
    if (Array.isArray(attrs)) {
      attrs.forEach((fn) => fn(emit2, item, this));
    } else {
      attrs(emit2, item, this);
    }
    if (tag) {
      style(object2, item, scene, tag, this._defs);
    }
    return object2;
  },
  defs(m2) {
    const gradient4 = this._defs.gradient, clipping = this._defs.clipping, count2 = Object.keys(gradient4).length + Object.keys(clipping).length;
    if (count2 === 0)
      return;
    m2.open("defs");
    for (const id4 in gradient4) {
      const def2 = gradient4[id4], stops = def2.stops;
      if (def2.gradient === "radial") {
        m2.open("pattern", {
          id: patternPrefix + id4,
          viewBox: "0,0,1,1",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "xMidYMid slice"
        });
        m2.open("rect", {
          width: "1",
          height: "1",
          fill: "url(#" + id4 + ")"
        }).close();
        m2.close();
        m2.open("radialGradient", {
          id: id4,
          fx: def2.x1,
          fy: def2.y1,
          fr: def2.r1,
          cx: def2.x2,
          cy: def2.y2,
          r: def2.r2
        });
      } else {
        m2.open("linearGradient", {
          id: id4,
          x1: def2.x1,
          x2: def2.x2,
          y1: def2.y1,
          y2: def2.y2
        });
      }
      for (let i = 0; i < stops.length; ++i) {
        m2.open("stop", {
          offset: stops[i].offset,
          "stop-color": stops[i].color
        }).close();
      }
      m2.close();
    }
    for (const id4 in clipping) {
      const def2 = clipping[id4];
      m2.open("clipPath", {
        id: id4
      });
      if (def2.path) {
        m2.open("path", {
          d: def2.path
        }).close();
      } else {
        m2.open("rect", {
          x: 0,
          y: 0,
          width: def2.width,
          height: def2.height
        }).close();
      }
      m2.close();
    }
    m2.close();
  }
});
function style(s, item, scene, tag, defs) {
  if (item == null)
    return s;
  if (tag === "bgrect" && scene.interactive === false) {
    s["pointer-events"] = "none";
  }
  if (tag === "bgfore") {
    if (scene.interactive === false) {
      s["pointer-events"] = "none";
    }
    s.display = "none";
    if (item.fill !== null)
      return s;
  }
  if (tag === "image" && item.smooth === false) {
    s.style = "image-rendering: optimizeSpeed; image-rendering: pixelated;";
  }
  if (tag === "text") {
    s["font-family"] = fontFamily(item);
    s["font-size"] = fontSize(item) + "px";
    s["font-style"] = item.fontStyle;
    s["font-variant"] = item.fontVariant;
    s["font-weight"] = item.fontWeight;
  }
  for (const prop in styles) {
    let value3 = item[prop];
    const name4 = styles[prop];
    if (value3 === "transparent" && (name4 === "fill" || name4 === "stroke"))
      ;
    else if (value3 != null) {
      if (isGradient(value3)) {
        value3 = gradientRef(value3, defs.gradient, "");
      }
      s[name4] = value3;
    }
  }
  return s;
}
var Canvas = "canvas";
var PNG = "png";
var SVG = "svg";
var None2 = "none";
var RenderType = {
  Canvas,
  PNG,
  SVG,
  None: None2
};
var modules = {};
modules[Canvas] = modules[PNG] = {
  renderer: CanvasRenderer,
  headless: CanvasRenderer,
  handler: CanvasHandler
};
modules[SVG] = {
  renderer: SVGRenderer,
  headless: SVGStringRenderer,
  handler: SVGHandler
};
modules[None2] = {};
function renderModule(name4, _) {
  name4 = String(name4 || "").toLowerCase();
  if (arguments.length > 1) {
    modules[name4] = _;
    return this;
  } else {
    return modules[name4];
  }
}
function intersect2(scene, bounds2, filter4) {
  const hits = [], box = new Bounds().union(bounds2), type2 = scene.marktype;
  return type2 ? intersectMark(scene, box, filter4, hits) : type2 === "group" ? intersectGroup(scene, box, filter4, hits) : error("Intersect scene must be mark node or group item.");
}
function intersectMark(mark2, box, filter4, hits) {
  if (visitMark(mark2, box, filter4)) {
    const items2 = mark2.items, type2 = mark2.marktype, n = items2.length;
    let i = 0;
    if (type2 === "group") {
      for (; i < n; ++i) {
        intersectGroup(items2[i], box, filter4, hits);
      }
    } else {
      for (const test2 = Marks[type2].isect; i < n; ++i) {
        const item = items2[i];
        if (intersectItem(item, box, test2))
          hits.push(item);
      }
    }
  }
  return hits;
}
function visitMark(mark2, box, filter4) {
  return mark2.bounds && box.intersects(mark2.bounds) && (mark2.marktype === "group" || mark2.interactive !== false && (!filter4 || filter4(mark2)));
}
function intersectGroup(group2, box, filter4, hits) {
  if (filter4 && filter4(group2.mark) && intersectItem(group2, box, Marks.group.isect)) {
    hits.push(group2);
  }
  const marks = group2.items, n = marks && marks.length;
  if (n) {
    const x5 = group2.x || 0, y5 = group2.y || 0;
    box.translate(-x5, -y5);
    for (let i = 0; i < n; ++i) {
      intersectMark(marks[i], box, filter4, hits);
    }
    box.translate(x5, y5);
  }
  return hits;
}
function intersectItem(item, box, test2) {
  const bounds2 = item.bounds;
  return box.encloses(bounds2) || box.intersects(bounds2) && test2(item, box);
}
var clipBounds = new Bounds();
function boundClip(mark2) {
  const clip3 = mark2.clip;
  if (isFunction(clip3)) {
    clip3(boundContext(clipBounds.clear()));
  } else if (clip3) {
    clipBounds.set(0, 0, mark2.group.width, mark2.group.height);
  } else
    return;
  mark2.bounds.intersect(clipBounds);
}
var TOLERANCE = 1e-9;
function sceneEqual(a2, b2, key2) {
  return a2 === b2 ? true : key2 === "path" ? pathEqual(a2, b2) : a2 instanceof Date && b2 instanceof Date ? +a2 === +b2 : isNumber(a2) && isNumber(b2) ? Math.abs(a2 - b2) <= TOLERANCE : !a2 || !b2 || !isObject(a2) && !isObject(b2) ? a2 == b2 : objectEqual(a2, b2);
}
function pathEqual(a2, b2) {
  return sceneEqual(pathParse(a2), pathParse(b2));
}
function objectEqual(a2, b2) {
  var ka = Object.keys(a2), kb = Object.keys(b2), key2, i;
  if (ka.length !== kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  for (i = ka.length - 1; i >= 0; i--) {
    key2 = ka[i];
    if (!sceneEqual(a2[key2], b2[key2], key2))
      return false;
  }
  return typeof a2 === typeof b2;
}
function resetSVGDefIds() {
  resetSVGClipId();
  resetSVGGradientId();
}

// node_modules/vega-view-transforms/build/vega-view-transforms.module.js
var Top = "top";
var Left = "left";
var Right = "right";
var Bottom = "bottom";
var TopLeft = "top-left";
var TopRight = "top-right";
var BottomLeft = "bottom-left";
var BottomRight = "bottom-right";
var Start = "start";
var Middle = "middle";
var End = "end";
var X = "x";
var Y = "y";
var Group = "group";
var AxisRole = "axis";
var TitleRole = "title";
var FrameRole = "frame";
var ScopeRole = "scope";
var LegendRole = "legend";
var RowHeader = "row-header";
var RowFooter = "row-footer";
var RowTitle = "row-title";
var ColHeader = "column-header";
var ColFooter = "column-footer";
var ColTitle = "column-title";
var Padding = "padding";
var Symbols = "symbol";
var Fit = "fit";
var FitX = "fit-x";
var FitY = "fit-y";
var Pad = "pad";
var None3 = "none";
var All = "all";
var Each = "each";
var Flush = "flush";
var Column = "column";
var Row = "row";
function Bound(params2) {
  Transform.call(this, null, params2);
}
inherits(Bound, Transform, {
  transform(_, pulse2) {
    const view = pulse2.dataflow, mark2 = _.mark, type2 = mark2.marktype, entry2 = Marks[type2], bound2 = entry2.bound;
    let markBounds = mark2.bounds, rebound;
    if (entry2.nested) {
      if (mark2.items.length)
        view.dirty(mark2.items[0]);
      markBounds = boundItem2(mark2, bound2);
      mark2.items.forEach((item) => {
        item.bounds.clear().union(markBounds);
      });
    } else if (type2 === Group || _.modified()) {
      pulse2.visit(pulse2.MOD, (item) => view.dirty(item));
      markBounds.clear();
      mark2.items.forEach((item) => markBounds.union(boundItem2(item, bound2)));
      switch (mark2.role) {
        case AxisRole:
        case LegendRole:
        case TitleRole:
          pulse2.reflow();
      }
    } else {
      rebound = pulse2.changed(pulse2.REM);
      pulse2.visit(pulse2.ADD, (item) => {
        markBounds.union(boundItem2(item, bound2));
      });
      pulse2.visit(pulse2.MOD, (item) => {
        rebound = rebound || markBounds.alignsWith(item.bounds);
        view.dirty(item);
        markBounds.union(boundItem2(item, bound2));
      });
      if (rebound) {
        markBounds.clear();
        mark2.items.forEach((item) => markBounds.union(item.bounds));
      }
    }
    boundClip(mark2);
    return pulse2.modifies("bounds");
  }
});
function boundItem2(item, bound2, opt) {
  return bound2(item.bounds.clear(), item, opt);
}
var COUNTER_NAME = ":vega_identifier:";
function Identifier(params2) {
  Transform.call(this, 0, params2);
}
Identifier.Definition = {
  type: "Identifier",
  metadata: {
    modifies: true
  },
  params: [{
    name: "as",
    type: "string",
    required: true
  }]
};
inherits(Identifier, Transform, {
  transform(_, pulse2) {
    const counter = getCounter(pulse2.dataflow), as = _.as;
    let id4 = counter.value;
    pulse2.visit(pulse2.ADD, (t) => t[as] = t[as] || ++id4);
    counter.set(this.value = id4);
    return pulse2;
  }
});
function getCounter(view) {
  return view._signals[COUNTER_NAME] || (view._signals[COUNTER_NAME] = view.add(0));
}
function Mark(params2) {
  Transform.call(this, null, params2);
}
inherits(Mark, Transform, {
  transform(_, pulse2) {
    let mark2 = this.value;
    if (!mark2) {
      mark2 = pulse2.dataflow.scenegraph().mark(_.markdef, lookup2(_), _.index);
      mark2.group.context = _.context;
      if (!_.context.group)
        _.context.group = mark2.group;
      mark2.source = this.source;
      mark2.clip = _.clip;
      mark2.interactive = _.interactive;
      this.value = mark2;
    }
    const Init = mark2.marktype === Group ? GroupItem : Item;
    pulse2.visit(pulse2.ADD, (item) => Init.call(item, mark2));
    if (_.modified("clip") || _.modified("interactive")) {
      mark2.clip = _.clip;
      mark2.interactive = !!_.interactive;
      mark2.zdirty = true;
      pulse2.reflow();
    }
    mark2.items = pulse2.source;
    return pulse2;
  }
});
function lookup2(_) {
  const g = _.groups, p = _.parent;
  return g && g.size === 1 ? g.get(Object.keys(g.object)[0]) : g && p ? g.lookup(p) : null;
}
function Overlap(params2) {
  Transform.call(this, null, params2);
}
var methods = {
  parity: (items2) => items2.filter((item, i) => i % 2 ? item.opacity = 0 : 1),
  greedy: (items2, sep) => {
    let a2;
    return items2.filter((b2, i) => !i || !intersect3(a2.bounds, b2.bounds, sep) ? (a2 = b2, 1) : b2.opacity = 0);
  }
};
var intersect3 = (a2, b2, sep) => sep > Math.max(b2.x1 - a2.x2, a2.x1 - b2.x2, b2.y1 - a2.y2, a2.y1 - b2.y2);
var hasOverlap = (items2, pad4) => {
  for (var i = 1, n = items2.length, a2 = items2[0].bounds, b2; i < n; a2 = b2, ++i) {
    if (intersect3(a2, b2 = items2[i].bounds, pad4))
      return true;
  }
};
var hasBounds = (item) => {
  const b2 = item.bounds;
  return b2.width() > 1 && b2.height() > 1;
};
var boundTest = (scale7, orient3, tolerance) => {
  var range5 = scale7.range(), b2 = new Bounds();
  if (orient3 === Top || orient3 === Bottom) {
    b2.set(range5[0], -Infinity, range5[1], Infinity);
  } else {
    b2.set(-Infinity, range5[0], Infinity, range5[1]);
  }
  b2.expand(tolerance || 1);
  return (item) => b2.encloses(item.bounds);
};
var reset = (source4) => {
  source4.forEach((item) => item.opacity = 1);
  return source4;
};
var reflow = (pulse2, _) => pulse2.reflow(_.modified()).modifies("opacity");
inherits(Overlap, Transform, {
  transform(_, pulse2) {
    const reduce2 = methods[_.method] || methods.parity, sep = _.separation || 0;
    let source4 = pulse2.materialize(pulse2.SOURCE).source, items2, test2;
    if (!source4 || !source4.length)
      return;
    if (!_.method) {
      if (_.modified("method")) {
        reset(source4);
        pulse2 = reflow(pulse2, _);
      }
      return pulse2;
    }
    source4 = source4.filter(hasBounds);
    if (!source4.length)
      return;
    if (_.sort) {
      source4 = source4.slice().sort(_.sort);
    }
    items2 = reset(source4);
    pulse2 = reflow(pulse2, _);
    if (items2.length >= 3 && hasOverlap(items2, sep)) {
      do {
        items2 = reduce2(items2, sep);
      } while (items2.length >= 3 && hasOverlap(items2, sep));
      if (items2.length < 3 && !peek(source4).opacity) {
        if (items2.length > 1)
          peek(items2).opacity = 0;
        peek(source4).opacity = 1;
      }
    }
    if (_.boundScale && _.boundTolerance >= 0) {
      test2 = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);
      source4.forEach((item) => {
        if (!test2(item))
          item.opacity = 0;
      });
    }
    const bounds2 = items2[0].mark.bounds.clear();
    source4.forEach((item) => {
      if (item.opacity)
        bounds2.union(item.bounds);
    });
    return pulse2;
  }
});
function Render(params2) {
  Transform.call(this, null, params2);
}
inherits(Render, Transform, {
  transform(_, pulse2) {
    const view = pulse2.dataflow;
    pulse2.visit(pulse2.ALL, (item) => view.dirty(item));
    if (pulse2.fields && pulse2.fields["zindex"]) {
      const item = pulse2.source && pulse2.source[0];
      if (item)
        item.mark.zdirty = true;
    }
  }
});
var tempBounds2 = new Bounds();
function set2(item, property2, value3) {
  return item[property2] === value3 ? 0 : (item[property2] = value3, 1);
}
function isYAxis(mark2) {
  var orient3 = mark2.items[0].orient;
  return orient3 === Left || orient3 === Right;
}
function axisIndices(datum3) {
  let index4 = +datum3.grid;
  return [
    datum3.ticks ? index4++ : -1,
    datum3.labels ? index4++ : -1,
    index4 + +datum3.domain
  ];
}
function axisLayout(view, axis, width2, height2) {
  var item = axis.items[0], datum3 = item.datum, delta = item.translate != null ? item.translate : 0.5, orient3 = item.orient, indices = axisIndices(datum3), range5 = item.range, offset4 = item.offset, position2 = item.position, minExtent = item.minExtent, maxExtent = item.maxExtent, title2 = datum3.title && item.items[indices[2]].items[0], titlePadding = item.titlePadding, bounds2 = item.bounds, dl = title2 && multiLineOffset(title2), x5 = 0, y5 = 0, i, s;
  tempBounds2.clear().union(bounds2);
  bounds2.clear();
  if ((i = indices[0]) > -1)
    bounds2.union(item.items[i].bounds);
  if ((i = indices[1]) > -1)
    bounds2.union(item.items[i].bounds);
  switch (orient3) {
    case Top:
      x5 = position2 || 0;
      y5 = -offset4;
      s = Math.max(minExtent, Math.min(maxExtent, -bounds2.y1));
      bounds2.add(0, -s).add(range5, 0);
      if (title2)
        axisTitleLayout(view, title2, s, titlePadding, dl, 0, -1, bounds2);
      break;
    case Left:
      x5 = -offset4;
      y5 = position2 || 0;
      s = Math.max(minExtent, Math.min(maxExtent, -bounds2.x1));
      bounds2.add(-s, 0).add(0, range5);
      if (title2)
        axisTitleLayout(view, title2, s, titlePadding, dl, 1, -1, bounds2);
      break;
    case Right:
      x5 = width2 + offset4;
      y5 = position2 || 0;
      s = Math.max(minExtent, Math.min(maxExtent, bounds2.x2));
      bounds2.add(0, 0).add(s, range5);
      if (title2)
        axisTitleLayout(view, title2, s, titlePadding, dl, 1, 1, bounds2);
      break;
    case Bottom:
      x5 = position2 || 0;
      y5 = height2 + offset4;
      s = Math.max(minExtent, Math.min(maxExtent, bounds2.y2));
      bounds2.add(0, 0).add(range5, s);
      if (title2)
        axisTitleLayout(view, title2, s, titlePadding, 0, 0, 1, bounds2);
      break;
    default:
      x5 = item.x;
      y5 = item.y;
  }
  boundStroke(bounds2.translate(x5, y5), item);
  if (set2(item, "x", x5 + delta) | set2(item, "y", y5 + delta)) {
    item.bounds = tempBounds2;
    view.dirty(item);
    item.bounds = bounds2;
    view.dirty(item);
  }
  return item.mark.bounds.clear().union(bounds2);
}
function axisTitleLayout(view, title2, offset4, pad4, dl, isYAxis2, sign3, bounds2) {
  const b2 = title2.bounds;
  if (title2.auto) {
    const v = sign3 * (offset4 + dl + pad4);
    let dx = 0, dy = 0;
    view.dirty(title2);
    isYAxis2 ? dx = (title2.x || 0) - (title2.x = v) : dy = (title2.y || 0) - (title2.y = v);
    title2.mark.bounds.clear().union(b2.translate(-dx, -dy));
    view.dirty(title2);
  }
  bounds2.union(b2);
}
var min3 = (a2, b2) => Math.floor(Math.min(a2, b2));
var max3 = (a2, b2) => Math.ceil(Math.max(a2, b2));
function gridLayoutGroups(group2) {
  var groups = group2.items, n = groups.length, i = 0, mark2, items2;
  const views = {
    marks: [],
    rowheaders: [],
    rowfooters: [],
    colheaders: [],
    colfooters: [],
    rowtitle: null,
    coltitle: null
  };
  for (; i < n; ++i) {
    mark2 = groups[i];
    items2 = mark2.items;
    if (mark2.marktype === Group) {
      switch (mark2.role) {
        case AxisRole:
        case LegendRole:
        case TitleRole:
          break;
        case RowHeader:
          views.rowheaders.push(...items2);
          break;
        case RowFooter:
          views.rowfooters.push(...items2);
          break;
        case ColHeader:
          views.colheaders.push(...items2);
          break;
        case ColFooter:
          views.colfooters.push(...items2);
          break;
        case RowTitle:
          views.rowtitle = items2[0];
          break;
        case ColTitle:
          views.coltitle = items2[0];
          break;
        default:
          views.marks.push(...items2);
      }
    }
  }
  return views;
}
function bboxFlush(item) {
  return new Bounds().set(0, 0, item.width || 0, item.height || 0);
}
function bboxFull(item) {
  const b2 = item.bounds.clone();
  return b2.empty() ? b2.set(0, 0, 0, 0) : b2.translate(-(item.x || 0), -(item.y || 0));
}
function get4(opt, key2, d) {
  const v = isObject(opt) ? opt[key2] : opt;
  return v != null ? v : d !== void 0 ? d : 0;
}
function offsetValue(v) {
  return v < 0 ? Math.ceil(-v) : 0;
}
function gridLayout(view, groups, opt) {
  var dirty = !opt.nodirty, bbox = opt.bounds === Flush ? bboxFlush : bboxFull, bounds2 = tempBounds2.set(0, 0, 0, 0), alignCol = get4(opt.align, Column), alignRow = get4(opt.align, Row), padCol = get4(opt.padding, Column), padRow = get4(opt.padding, Row), ncols = opt.columns || groups.length, nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols), n = groups.length, xOffset = Array(n), xExtent = Array(ncols), xMax = 0, yOffset = Array(n), yExtent = Array(nrows), yMax = 0, dx = Array(n), dy = Array(n), boxes = Array(n), m2, i, c2, r2, b2, g, px2, py2, x5, y5, offset4;
  for (i = 0; i < ncols; ++i)
    xExtent[i] = 0;
  for (i = 0; i < nrows; ++i)
    yExtent[i] = 0;
  for (i = 0; i < n; ++i) {
    g = groups[i];
    b2 = boxes[i] = bbox(g);
    g.x = g.x || 0;
    dx[i] = 0;
    g.y = g.y || 0;
    dy[i] = 0;
    c2 = i % ncols;
    r2 = ~~(i / ncols);
    xMax = Math.max(xMax, px2 = Math.ceil(b2.x2));
    yMax = Math.max(yMax, py2 = Math.ceil(b2.y2));
    xExtent[c2] = Math.max(xExtent[c2], px2);
    yExtent[r2] = Math.max(yExtent[r2], py2);
    xOffset[i] = padCol + offsetValue(b2.x1);
    yOffset[i] = padRow + offsetValue(b2.y1);
    if (dirty)
      view.dirty(groups[i]);
  }
  for (i = 0; i < n; ++i) {
    if (i % ncols === 0)
      xOffset[i] = 0;
    if (i < ncols)
      yOffset[i] = 0;
  }
  if (alignCol === Each) {
    for (c2 = 1; c2 < ncols; ++c2) {
      for (offset4 = 0, i = c2; i < n; i += ncols) {
        if (offset4 < xOffset[i])
          offset4 = xOffset[i];
      }
      for (i = c2; i < n; i += ncols) {
        xOffset[i] = offset4 + xExtent[c2 - 1];
      }
    }
  } else if (alignCol === All) {
    for (offset4 = 0, i = 0; i < n; ++i) {
      if (i % ncols && offset4 < xOffset[i])
        offset4 = xOffset[i];
    }
    for (i = 0; i < n; ++i) {
      if (i % ncols)
        xOffset[i] = offset4 + xMax;
    }
  } else {
    for (alignCol = false, c2 = 1; c2 < ncols; ++c2) {
      for (i = c2; i < n; i += ncols) {
        xOffset[i] += xExtent[c2 - 1];
      }
    }
  }
  if (alignRow === Each) {
    for (r2 = 1; r2 < nrows; ++r2) {
      for (offset4 = 0, i = r2 * ncols, m2 = i + ncols; i < m2; ++i) {
        if (offset4 < yOffset[i])
          offset4 = yOffset[i];
      }
      for (i = r2 * ncols; i < m2; ++i) {
        yOffset[i] = offset4 + yExtent[r2 - 1];
      }
    }
  } else if (alignRow === All) {
    for (offset4 = 0, i = ncols; i < n; ++i) {
      if (offset4 < yOffset[i])
        offset4 = yOffset[i];
    }
    for (i = ncols; i < n; ++i) {
      yOffset[i] = offset4 + yMax;
    }
  } else {
    for (alignRow = false, r2 = 1; r2 < nrows; ++r2) {
      for (i = r2 * ncols, m2 = i + ncols; i < m2; ++i) {
        yOffset[i] += yExtent[r2 - 1];
      }
    }
  }
  for (x5 = 0, i = 0; i < n; ++i) {
    x5 = xOffset[i] + (i % ncols ? x5 : 0);
    dx[i] += x5 - groups[i].x;
  }
  for (c2 = 0; c2 < ncols; ++c2) {
    for (y5 = 0, i = c2; i < n; i += ncols) {
      y5 += yOffset[i];
      dy[i] += y5 - groups[i].y;
    }
  }
  if (alignCol && get4(opt.center, Column) && nrows > 1) {
    for (i = 0; i < n; ++i) {
      b2 = alignCol === All ? xMax : xExtent[i % ncols];
      x5 = b2 - boxes[i].x2 - groups[i].x - dx[i];
      if (x5 > 0)
        dx[i] += x5 / 2;
    }
  }
  if (alignRow && get4(opt.center, Row) && ncols !== 1) {
    for (i = 0; i < n; ++i) {
      b2 = alignRow === All ? yMax : yExtent[~~(i / ncols)];
      y5 = b2 - boxes[i].y2 - groups[i].y - dy[i];
      if (y5 > 0)
        dy[i] += y5 / 2;
    }
  }
  for (i = 0; i < n; ++i) {
    bounds2.union(boxes[i].translate(dx[i], dy[i]));
  }
  x5 = get4(opt.anchor, X);
  y5 = get4(opt.anchor, Y);
  switch (get4(opt.anchor, Column)) {
    case End:
      x5 -= bounds2.width();
      break;
    case Middle:
      x5 -= bounds2.width() / 2;
  }
  switch (get4(opt.anchor, Row)) {
    case End:
      y5 -= bounds2.height();
      break;
    case Middle:
      y5 -= bounds2.height() / 2;
  }
  x5 = Math.round(x5);
  y5 = Math.round(y5);
  bounds2.clear();
  for (i = 0; i < n; ++i) {
    groups[i].mark.bounds.clear();
  }
  for (i = 0; i < n; ++i) {
    g = groups[i];
    g.x += dx[i] += x5;
    g.y += dy[i] += y5;
    bounds2.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));
    if (dirty)
      view.dirty(g);
  }
  return bounds2;
}
function trellisLayout(view, group2, opt) {
  var views = gridLayoutGroups(group2), groups = views.marks, bbox = opt.bounds === Flush ? boundFlush : boundFull, off = opt.offset, ncols = opt.columns || groups.length, nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols), cells = nrows * ncols, x5, y5, x22, y22, anchor, band2, offset4;
  const bounds2 = gridLayout(view, groups, opt);
  if (bounds2.empty())
    bounds2.set(0, 0, 0, 0);
  if (views.rowheaders) {
    band2 = get4(opt.headerBand, Row, null);
    x5 = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get4(off, "rowHeader"), min3, 0, bbox, "x1", 0, ncols, 1, band2);
  }
  if (views.colheaders) {
    band2 = get4(opt.headerBand, Column, null);
    y5 = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get4(off, "columnHeader"), min3, 1, bbox, "y1", 0, 1, ncols, band2);
  }
  if (views.rowfooters) {
    band2 = get4(opt.footerBand, Row, null);
    x22 = layoutHeaders(view, views.rowfooters, groups, ncols, nrows, get4(off, "rowFooter"), max3, 0, bbox, "x2", ncols - 1, ncols, 1, band2);
  }
  if (views.colfooters) {
    band2 = get4(opt.footerBand, Column, null);
    y22 = layoutHeaders(view, views.colfooters, groups, ncols, ncols, get4(off, "columnFooter"), max3, 1, bbox, "y2", cells - ncols, 1, ncols, band2);
  }
  if (views.rowtitle) {
    anchor = get4(opt.titleAnchor, Row);
    offset4 = get4(off, "rowTitle");
    offset4 = anchor === End ? x22 + offset4 : x5 - offset4;
    band2 = get4(opt.titleBand, Row, 0.5);
    layoutTitle(view, views.rowtitle, offset4, 0, bounds2, band2);
  }
  if (views.coltitle) {
    anchor = get4(opt.titleAnchor, Column);
    offset4 = get4(off, "columnTitle");
    offset4 = anchor === End ? y22 + offset4 : y5 - offset4;
    band2 = get4(opt.titleBand, Column, 0.5);
    layoutTitle(view, views.coltitle, offset4, 1, bounds2, band2);
  }
}
function boundFlush(item, field4) {
  return field4 === "x1" ? item.x || 0 : field4 === "y1" ? item.y || 0 : field4 === "x2" ? (item.x || 0) + (item.width || 0) : field4 === "y2" ? (item.y || 0) + (item.height || 0) : void 0;
}
function boundFull(item, field4) {
  return item.bounds[field4];
}
function layoutHeaders(view, headers, groups, ncols, limit, offset4, agg, isX2, bound2, bf, start, stride, back, band2) {
  var n = groups.length, init2 = 0, edge = 0, i, j, k, m2, b2, h3, g, x5, y5;
  if (!n)
    return init2;
  for (i = start; i < n; i += stride) {
    if (groups[i])
      init2 = agg(init2, bound2(groups[i], bf));
  }
  if (!headers.length)
    return init2;
  if (headers.length > limit) {
    view.warn("Grid headers exceed limit: " + limit);
    headers = headers.slice(0, limit);
  }
  init2 += offset4;
  for (j = 0, m2 = headers.length; j < m2; ++j) {
    view.dirty(headers[j]);
    headers[j].mark.bounds.clear();
  }
  for (i = start, j = 0, m2 = headers.length; j < m2; ++j, i += stride) {
    h3 = headers[j];
    b2 = h3.mark.bounds;
    for (k = i; k >= 0 && (g = groups[k]) == null; k -= back)
      ;
    if (isX2) {
      x5 = band2 == null ? g.x : Math.round(g.bounds.x1 + band2 * g.bounds.width());
      y5 = init2;
    } else {
      x5 = init2;
      y5 = band2 == null ? g.y : Math.round(g.bounds.y1 + band2 * g.bounds.height());
    }
    b2.union(h3.bounds.translate(x5 - (h3.x || 0), y5 - (h3.y || 0)));
    h3.x = x5;
    h3.y = y5;
    view.dirty(h3);
    edge = agg(edge, b2[bf]);
  }
  return edge;
}
function layoutTitle(view, g, offset4, isX2, bounds2, band2) {
  if (!g)
    return;
  view.dirty(g);
  var x5 = offset4, y5 = offset4;
  isX2 ? x5 = Math.round(bounds2.x1 + band2 * bounds2.width()) : y5 = Math.round(bounds2.y1 + band2 * bounds2.height());
  g.bounds.translate(x5 - (g.x || 0), y5 - (g.y || 0));
  g.mark.bounds.clear().union(g.bounds);
  g.x = x5;
  g.y = y5;
  view.dirty(g);
}
function lookup$1(config, orient3) {
  const opt = config[orient3] || {};
  return (key2, d) => opt[key2] != null ? opt[key2] : config[key2] != null ? config[key2] : d;
}
function offsets(legends, value3) {
  let max4 = -Infinity;
  legends.forEach((item) => {
    if (item.offset != null)
      max4 = Math.max(max4, item.offset);
  });
  return max4 > -Infinity ? max4 : value3;
}
function legendParams(g, orient3, config, xb, yb, w3, h3) {
  const _ = lookup$1(config, orient3), offset4 = offsets(g, _("offset", 0)), anchor = _("anchor", Start), mult2 = anchor === End ? 1 : anchor === Middle ? 0.5 : 0;
  const p = {
    align: Each,
    bounds: _("bounds", Flush),
    columns: _("direction") === "vertical" ? 1 : g.length,
    padding: _("margin", 8),
    center: _("center"),
    nodirty: true
  };
  switch (orient3) {
    case Left:
      p.anchor = {
        x: Math.floor(xb.x1) - offset4,
        column: End,
        y: mult2 * (h3 || xb.height() + 2 * xb.y1),
        row: anchor
      };
      break;
    case Right:
      p.anchor = {
        x: Math.ceil(xb.x2) + offset4,
        y: mult2 * (h3 || xb.height() + 2 * xb.y1),
        row: anchor
      };
      break;
    case Top:
      p.anchor = {
        y: Math.floor(yb.y1) - offset4,
        row: End,
        x: mult2 * (w3 || yb.width() + 2 * yb.x1),
        column: anchor
      };
      break;
    case Bottom:
      p.anchor = {
        y: Math.ceil(yb.y2) + offset4,
        x: mult2 * (w3 || yb.width() + 2 * yb.x1),
        column: anchor
      };
      break;
    case TopLeft:
      p.anchor = {
        x: offset4,
        y: offset4
      };
      break;
    case TopRight:
      p.anchor = {
        x: w3 - offset4,
        y: offset4,
        column: End
      };
      break;
    case BottomLeft:
      p.anchor = {
        x: offset4,
        y: h3 - offset4,
        row: End
      };
      break;
    case BottomRight:
      p.anchor = {
        x: w3 - offset4,
        y: h3 - offset4,
        column: End,
        row: End
      };
      break;
  }
  return p;
}
function legendLayout(view, legend) {
  var item = legend.items[0], datum3 = item.datum, orient3 = item.orient, bounds2 = item.bounds, x5 = item.x, y5 = item.y, w3, h3;
  item._bounds ? item._bounds.clear().union(bounds2) : item._bounds = bounds2.clone();
  bounds2.clear();
  legendGroupLayout(view, item, item.items[0].items[0]);
  bounds2 = legendBounds(item, bounds2);
  w3 = 2 * item.padding;
  h3 = 2 * item.padding;
  if (!bounds2.empty()) {
    w3 = Math.ceil(bounds2.width() + w3);
    h3 = Math.ceil(bounds2.height() + h3);
  }
  if (datum3.type === Symbols) {
    legendEntryLayout(item.items[0].items[0].items[0].items);
  }
  if (orient3 !== None3) {
    item.x = x5 = 0;
    item.y = y5 = 0;
  }
  item.width = w3;
  item.height = h3;
  boundStroke(bounds2.set(x5, y5, x5 + w3, y5 + h3), item);
  item.mark.bounds.clear().union(bounds2);
  return item;
}
function legendBounds(item, b2) {
  item.items.forEach((_) => b2.union(_.bounds));
  b2.x1 = item.padding;
  b2.y1 = item.padding;
  return b2;
}
function legendGroupLayout(view, item, entry2) {
  var pad4 = item.padding, ex = pad4 - entry2.x, ey = pad4 - entry2.y;
  if (!item.datum.title) {
    if (ex || ey)
      translate2(view, entry2, ex, ey);
  } else {
    var title2 = item.items[1].items[0], anchor = title2.anchor, tpad = item.titlePadding || 0, tx = pad4 - title2.x, ty = pad4 - title2.y;
    switch (title2.orient) {
      case Left:
        ex += Math.ceil(title2.bounds.width()) + tpad;
        break;
      case Right:
      case Bottom:
        break;
      default:
        ey += title2.bounds.height() + tpad;
    }
    if (ex || ey)
      translate2(view, entry2, ex, ey);
    switch (title2.orient) {
      case Left:
        ty += legendTitleOffset(item, entry2, title2, anchor, 1, 1);
        break;
      case Right:
        tx += legendTitleOffset(item, entry2, title2, End, 0, 0) + tpad;
        ty += legendTitleOffset(item, entry2, title2, anchor, 1, 1);
        break;
      case Bottom:
        tx += legendTitleOffset(item, entry2, title2, anchor, 0, 0);
        ty += legendTitleOffset(item, entry2, title2, End, -1, 0, 1) + tpad;
        break;
      default:
        tx += legendTitleOffset(item, entry2, title2, anchor, 0, 0);
    }
    if (tx || ty)
      translate2(view, title2, tx, ty);
    if ((tx = Math.round(title2.bounds.x1 - pad4)) < 0) {
      translate2(view, entry2, -tx, 0);
      translate2(view, title2, -tx, 0);
    }
  }
}
function legendTitleOffset(item, entry2, title2, anchor, y5, lr, noBar) {
  const grad = item.datum.type !== "symbol", vgrad = title2.datum.vgrad, e = grad && (lr || !vgrad) && !noBar ? entry2.items[0] : entry2, s = e.bounds[y5 ? "y2" : "x2"] - item.padding, u = vgrad && lr ? s : 0, v = vgrad && lr ? 0 : s, o = y5 <= 0 ? 0 : multiLineOffset(title2);
  return Math.round(anchor === Start ? u : anchor === End ? v - o : 0.5 * (s - o));
}
function translate2(view, item, dx, dy) {
  item.x += dx;
  item.y += dy;
  item.bounds.translate(dx, dy);
  item.mark.bounds.translate(dx, dy);
  view.dirty(item);
}
function legendEntryLayout(entries3) {
  const widths = entries3.reduce((w3, g) => {
    w3[g.column] = Math.max(g.bounds.x2 - g.x, w3[g.column] || 0);
    return w3;
  }, {});
  entries3.forEach((g) => {
    g.width = widths[g.column];
    g.height = g.bounds.y2 - g.y;
  });
}
function titleLayout(view, mark2, width2, height2, viewBounds2) {
  var group2 = mark2.items[0], frame2 = group2.frame, orient3 = group2.orient, anchor = group2.anchor, offset4 = group2.offset, padding3 = group2.padding, title2 = group2.items[0].items[0], subtitle = group2.items[1] && group2.items[1].items[0], end = orient3 === Left || orient3 === Right ? height2 : width2, start = 0, x5 = 0, y5 = 0, sx = 0, sy = 0, pos;
  if (frame2 !== Group) {
    orient3 === Left ? (start = viewBounds2.y2, end = viewBounds2.y1) : orient3 === Right ? (start = viewBounds2.y1, end = viewBounds2.y2) : (start = viewBounds2.x1, end = viewBounds2.x2);
  } else if (orient3 === Left) {
    start = height2, end = 0;
  }
  pos = anchor === Start ? start : anchor === End ? end : (start + end) / 2;
  if (subtitle && subtitle.text) {
    switch (orient3) {
      case Top:
      case Bottom:
        sy = title2.bounds.height() + padding3;
        break;
      case Left:
        sx = title2.bounds.width() + padding3;
        break;
      case Right:
        sx = -title2.bounds.width() - padding3;
        break;
    }
    tempBounds2.clear().union(subtitle.bounds);
    tempBounds2.translate(sx - (subtitle.x || 0), sy - (subtitle.y || 0));
    if (set2(subtitle, "x", sx) | set2(subtitle, "y", sy)) {
      view.dirty(subtitle);
      subtitle.bounds.clear().union(tempBounds2);
      subtitle.mark.bounds.clear().union(tempBounds2);
      view.dirty(subtitle);
    }
    tempBounds2.clear().union(subtitle.bounds);
  } else {
    tempBounds2.clear();
  }
  tempBounds2.union(title2.bounds);
  switch (orient3) {
    case Top:
      x5 = pos;
      y5 = viewBounds2.y1 - tempBounds2.height() - offset4;
      break;
    case Left:
      x5 = viewBounds2.x1 - tempBounds2.width() - offset4;
      y5 = pos;
      break;
    case Right:
      x5 = viewBounds2.x2 + tempBounds2.width() + offset4;
      y5 = pos;
      break;
    case Bottom:
      x5 = pos;
      y5 = viewBounds2.y2 + offset4;
      break;
    default:
      x5 = group2.x;
      y5 = group2.y;
  }
  if (set2(group2, "x", x5) | set2(group2, "y", y5)) {
    tempBounds2.translate(x5, y5);
    view.dirty(group2);
    group2.bounds.clear().union(tempBounds2);
    mark2.bounds.clear().union(tempBounds2);
    view.dirty(group2);
  }
  return group2.bounds;
}
function ViewLayout(params2) {
  Transform.call(this, null, params2);
}
inherits(ViewLayout, Transform, {
  transform(_, pulse2) {
    const view = pulse2.dataflow;
    _.mark.items.forEach((group2) => {
      if (_.layout)
        trellisLayout(view, group2, _.layout);
      layoutGroup(view, group2, _);
    });
    return shouldReflow(_.mark.group) ? pulse2.reflow() : pulse2;
  }
});
function shouldReflow(group2) {
  return group2 && group2.mark.role !== "legend-entry";
}
function layoutGroup(view, group2, _) {
  var items2 = group2.items, width2 = Math.max(0, group2.width || 0), height2 = Math.max(0, group2.height || 0), viewBounds2 = new Bounds().set(0, 0, width2, height2), xBounds = viewBounds2.clone(), yBounds = viewBounds2.clone(), legends = [], title2, mark2, orient3, b2, i, n;
  for (i = 0, n = items2.length; i < n; ++i) {
    mark2 = items2[i];
    switch (mark2.role) {
      case AxisRole:
        b2 = isYAxis(mark2) ? xBounds : yBounds;
        b2.union(axisLayout(view, mark2, width2, height2));
        break;
      case TitleRole:
        title2 = mark2;
        break;
      case LegendRole:
        legends.push(legendLayout(view, mark2));
        break;
      case FrameRole:
      case ScopeRole:
      case RowHeader:
      case RowFooter:
      case RowTitle:
      case ColHeader:
      case ColFooter:
      case ColTitle:
        xBounds.union(mark2.bounds);
        yBounds.union(mark2.bounds);
        break;
      default:
        viewBounds2.union(mark2.bounds);
    }
  }
  if (legends.length) {
    const l = {};
    legends.forEach((item) => {
      orient3 = item.orient || Right;
      if (orient3 !== None3)
        (l[orient3] || (l[orient3] = [])).push(item);
    });
    for (const orient4 in l) {
      const g = l[orient4];
      gridLayout(view, g, legendParams(g, orient4, _.legends, xBounds, yBounds, width2, height2));
    }
    legends.forEach((item) => {
      const b3 = item.bounds;
      if (!b3.equals(item._bounds)) {
        item.bounds = item._bounds;
        view.dirty(item);
        item.bounds = b3;
        view.dirty(item);
      }
      if (_.autosize && _.autosize.type === Fit) {
        switch (item.orient) {
          case Left:
          case Right:
            viewBounds2.add(b3.x1, 0).add(b3.x2, 0);
            break;
          case Top:
          case Bottom:
            viewBounds2.add(0, b3.y1).add(0, b3.y2);
        }
      } else {
        viewBounds2.union(b3);
      }
    });
  }
  viewBounds2.union(xBounds).union(yBounds);
  if (title2) {
    viewBounds2.union(titleLayout(view, title2, width2, height2, viewBounds2));
  }
  if (group2.clip) {
    viewBounds2.set(0, 0, group2.width || 0, group2.height || 0);
  }
  viewSizeLayout(view, group2, viewBounds2, _);
}
function viewSizeLayout(view, group2, viewBounds2, _) {
  const auto = _.autosize || {}, type2 = auto.type;
  if (view._autosize < 1 || !type2)
    return;
  let viewWidth2 = view._width, viewHeight2 = view._height, width2 = Math.max(0, group2.width || 0), left = Math.max(0, Math.ceil(-viewBounds2.x1)), height2 = Math.max(0, group2.height || 0), top = Math.max(0, Math.ceil(-viewBounds2.y1));
  const right = Math.max(0, Math.ceil(viewBounds2.x2 - width2)), bottom = Math.max(0, Math.ceil(viewBounds2.y2 - height2));
  if (auto.contains === Padding) {
    const padding3 = view.padding();
    viewWidth2 -= padding3.left + padding3.right;
    viewHeight2 -= padding3.top + padding3.bottom;
  }
  if (type2 === None3) {
    left = 0;
    top = 0;
    width2 = viewWidth2;
    height2 = viewHeight2;
  } else if (type2 === Fit) {
    width2 = Math.max(0, viewWidth2 - left - right);
    height2 = Math.max(0, viewHeight2 - top - bottom);
  } else if (type2 === FitX) {
    width2 = Math.max(0, viewWidth2 - left - right);
    viewHeight2 = height2 + top + bottom;
  } else if (type2 === FitY) {
    viewWidth2 = width2 + left + right;
    height2 = Math.max(0, viewHeight2 - top - bottom);
  } else if (type2 === Pad) {
    viewWidth2 = width2 + left + right;
    viewHeight2 = height2 + top + bottom;
  }
  view._resizeView(viewWidth2, viewHeight2, width2, height2, [left, top], auto.resize);
}

// node_modules/vega-encode/build/vega-encode.module.js
var vega_encode_module_exports = {};
__export(vega_encode_module_exports, {
  axisticks: () => AxisTicks,
  datajoin: () => DataJoin,
  encode: () => Encode,
  legendentries: () => LegendEntries,
  linkpath: () => LinkPath,
  pie: () => Pie,
  scale: () => Scale,
  sortitems: () => SortItems,
  stack: () => Stack
});
function AxisTicks(params2) {
  Transform.call(this, null, params2);
}
inherits(AxisTicks, Transform, {
  transform(_, pulse2) {
    if (this.value && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var locale6 = pulse2.dataflow.locale(), out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), ticks = this.value, scale7 = _.scale, tally = _.count == null ? _.values ? _.values.length : 10 : _.count, count2 = tickCount(scale7, tally, _.minstep), format8 = _.format || tickFormat2(locale6, scale7, count2, _.formatSpecifier, _.formatType, !!_.values), values4 = _.values ? validTicks(scale7, _.values, count2) : tickValues(scale7, count2);
    if (ticks)
      out.rem = ticks;
    ticks = values4.map((value3, i) => ingest({
      index: i / (values4.length - 1 || 1),
      value: value3,
      label: format8(value3)
    }));
    if (_.extra && ticks.length) {
      ticks.push(ingest({
        index: -1,
        extra: {
          value: ticks[0].value
        },
        label: ""
      }));
    }
    out.source = ticks;
    out.add = ticks;
    this.value = ticks;
    return out;
  }
});
function DataJoin(params2) {
  Transform.call(this, null, params2);
}
function defaultItemCreate() {
  return ingest({});
}
function newMap(key2) {
  const map4 = fastmap().test((t) => t.exit);
  map4.lookup = (t) => map4.get(key2(t));
  return map4;
}
inherits(DataJoin, Transform, {
  transform(_, pulse2) {
    var df = pulse2.dataflow, out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), item = _.item || defaultItemCreate, key2 = _.key || tupleid, map4 = this.value;
    if (isArray(out.encode)) {
      out.encode = null;
    }
    if (map4 && (_.modified("key") || pulse2.modified(key2))) {
      error("DataJoin does not support modified key function or fields.");
    }
    if (!map4) {
      pulse2 = pulse2.addAll();
      this.value = map4 = newMap(key2);
    }
    pulse2.visit(pulse2.ADD, (t) => {
      const k = key2(t);
      let x5 = map4.get(k);
      if (x5) {
        if (x5.exit) {
          map4.empty--;
          out.add.push(x5);
        } else {
          out.mod.push(x5);
        }
      } else {
        x5 = item(t);
        map4.set(k, x5);
        out.add.push(x5);
      }
      x5.datum = t;
      x5.exit = false;
    });
    pulse2.visit(pulse2.MOD, (t) => {
      const k = key2(t), x5 = map4.get(k);
      if (x5) {
        x5.datum = t;
        out.mod.push(x5);
      }
    });
    pulse2.visit(pulse2.REM, (t) => {
      const k = key2(t), x5 = map4.get(k);
      if (t === x5.datum && !x5.exit) {
        out.rem.push(x5);
        x5.exit = true;
        ++map4.empty;
      }
    });
    if (pulse2.changed(pulse2.ADD_MOD))
      out.modifies("datum");
    if (pulse2.clean() || _.clean && map4.empty > df.cleanThreshold) {
      df.runAfter(map4.clean);
    }
    return out;
  }
});
function Encode(params2) {
  Transform.call(this, null, params2);
}
inherits(Encode, Transform, {
  transform(_, pulse2) {
    var out = pulse2.fork(pulse2.ADD_REM), fmod = _.mod || false, encoders = _.encoders, encode15 = pulse2.encode;
    if (isArray(encode15)) {
      if (out.changed() || encode15.every((e) => encoders[e])) {
        encode15 = encode15[0];
        out.encode = null;
      } else {
        return pulse2.StopPropagation;
      }
    }
    var reenter = encode15 === "enter", update3 = encoders.update || falsy, enter = encoders.enter || falsy, exit = encoders.exit || falsy, set6 = (encode15 && !reenter ? encoders[encode15] : update3) || falsy;
    if (pulse2.changed(pulse2.ADD)) {
      pulse2.visit(pulse2.ADD, (t) => {
        enter(t, _);
        update3(t, _);
      });
      out.modifies(enter.output);
      out.modifies(update3.output);
      if (set6 !== falsy && set6 !== update3) {
        pulse2.visit(pulse2.ADD, (t) => {
          set6(t, _);
        });
        out.modifies(set6.output);
      }
    }
    if (pulse2.changed(pulse2.REM) && exit !== falsy) {
      pulse2.visit(pulse2.REM, (t) => {
        exit(t, _);
      });
      out.modifies(exit.output);
    }
    if (reenter || set6 !== falsy) {
      const flag2 = pulse2.MOD | (_.modified() ? pulse2.REFLOW : 0);
      if (reenter) {
        pulse2.visit(flag2, (t) => {
          const mod = enter(t, _) || fmod;
          if (set6(t, _) || mod)
            out.mod.push(t);
        });
        if (out.mod.length)
          out.modifies(enter.output);
      } else {
        pulse2.visit(flag2, (t) => {
          if (set6(t, _) || fmod)
            out.mod.push(t);
        });
      }
      if (out.mod.length)
        out.modifies(set6.output);
    }
    return out.changed() ? out : pulse2.StopPropagation;
  }
});
function LegendEntries(params2) {
  Transform.call(this, [], params2);
}
inherits(LegendEntries, Transform, {
  transform(_, pulse2) {
    if (this.value != null && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var locale6 = pulse2.dataflow.locale(), out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), items2 = this.value, type2 = _.type || SymbolLegend, scale7 = _.scale, limit = +_.limit, count2 = tickCount(scale7, _.count == null ? 5 : _.count, _.minstep), lskip = !!_.values || type2 === SymbolLegend, format8 = _.format || labelFormat(locale6, scale7, count2, type2, _.formatSpecifier, _.formatType, lskip), values4 = _.values || labelValues(scale7, count2), domain4, fraction, size, offset4, ellipsis;
    if (items2)
      out.rem = items2;
    if (type2 === SymbolLegend) {
      if (limit && values4.length > limit) {
        pulse2.dataflow.warn("Symbol legend count exceeds limit, filtering items.");
        items2 = values4.slice(0, limit - 1);
        ellipsis = true;
      } else {
        items2 = values4;
      }
      if (isFunction(size = _.size)) {
        if (!_.values && scale7(items2[0]) === 0) {
          items2 = items2.slice(1);
        }
        offset4 = items2.reduce((max4, value3) => Math.max(max4, size(value3, _)), 0);
      } else {
        size = constant(offset4 = size || 8);
      }
      items2 = items2.map((value3, index4) => ingest({
        index: index4,
        label: format8(value3, index4, items2),
        value: value3,
        offset: offset4,
        size: size(value3, _)
      }));
      if (ellipsis) {
        ellipsis = values4[items2.length];
        items2.push(ingest({
          index: items2.length,
          label: "\u2026".concat(values4.length - items2.length, " entries"),
          value: ellipsis,
          offset: offset4,
          size: size(ellipsis, _)
        }));
      }
    } else if (type2 === GradientLegend) {
      domain4 = scale7.domain(), fraction = scaleFraction(scale7, domain4[0], peek(domain4));
      if (values4.length < 3 && !_.values && domain4[0] !== peek(domain4)) {
        values4 = [domain4[0], peek(domain4)];
      }
      items2 = values4.map((value3, index4) => ingest({
        index: index4,
        label: format8(value3, index4, values4),
        value: value3,
        perc: fraction(value3)
      }));
    } else {
      size = values4.length - 1;
      fraction = labelFraction(scale7);
      items2 = values4.map((value3, index4) => ingest({
        index: index4,
        label: format8(value3, index4, values4),
        value: value3,
        perc: index4 ? fraction(value3) : 0,
        perc2: index4 === size ? 1 : fraction(values4[index4 + 1])
      }));
    }
    out.source = items2;
    out.add = items2;
    this.value = items2;
    return out;
  }
});
var sourceX = (t) => t.source.x;
var sourceY = (t) => t.source.y;
var targetX = (t) => t.target.x;
var targetY = (t) => t.target.y;
function LinkPath(params2) {
  Transform.call(this, {}, params2);
}
LinkPath.Definition = {
  type: "LinkPath",
  metadata: {
    modifies: true
  },
  params: [{
    name: "sourceX",
    type: "field",
    default: "source.x"
  }, {
    name: "sourceY",
    type: "field",
    default: "source.y"
  }, {
    name: "targetX",
    type: "field",
    default: "target.x"
  }, {
    name: "targetY",
    type: "field",
    default: "target.y"
  }, {
    name: "orient",
    type: "enum",
    default: "vertical",
    values: ["horizontal", "vertical", "radial"]
  }, {
    name: "shape",
    type: "enum",
    default: "line",
    values: ["line", "arc", "curve", "diagonal", "orthogonal"]
  }, {
    name: "require",
    type: "signal"
  }, {
    name: "as",
    type: "string",
    default: "path"
  }]
};
inherits(LinkPath, Transform, {
  transform(_, pulse2) {
    var sx = _.sourceX || sourceX, sy = _.sourceY || sourceY, tx = _.targetX || targetX, ty = _.targetY || targetY, as = _.as || "path", orient3 = _.orient || "vertical", shape2 = _.shape || "line", path3 = Paths.get(shape2 + "-" + orient3) || Paths.get(shape2);
    if (!path3) {
      error("LinkPath unsupported type: " + _.shape + (_.orient ? "-" + _.orient : ""));
    }
    pulse2.visit(pulse2.SOURCE, (t) => {
      t[as] = path3(sx(t), sy(t), tx(t), ty(t));
    });
    return pulse2.reflow(_.modified()).modifies(as);
  }
});
var line2 = (sx, sy, tx, ty) => "M" + sx + "," + sy + "L" + tx + "," + ty;
var lineR = (sa2, sr, ta, tr2) => line2(sr * Math.cos(sa2), sr * Math.sin(sa2), tr2 * Math.cos(ta), tr2 * Math.sin(ta));
var arc2 = (sx, sy, tx, ty) => {
  var dx = tx - sx, dy = ty - sy, rr = Math.sqrt(dx * dx + dy * dy) / 2, ra = 180 * Math.atan2(dy, dx) / Math.PI;
  return "M" + sx + "," + sy + "A" + rr + "," + rr + " " + ra + " 0 1 " + tx + "," + ty;
};
var arcR = (sa2, sr, ta, tr2) => arc2(sr * Math.cos(sa2), sr * Math.sin(sa2), tr2 * Math.cos(ta), tr2 * Math.sin(ta));
var curve = (sx, sy, tx, ty) => {
  const dx = tx - sx, dy = ty - sy, ix = 0.2 * (dx + dy), iy = 0.2 * (dy - dx);
  return "M" + sx + "," + sy + "C" + (sx + ix) + "," + (sy + iy) + " " + (tx + iy) + "," + (ty - ix) + " " + tx + "," + ty;
};
var curveR = (sa2, sr, ta, tr2) => curve(sr * Math.cos(sa2), sr * Math.sin(sa2), tr2 * Math.cos(ta), tr2 * Math.sin(ta));
var orthoX = (sx, sy, tx, ty) => "M" + sx + "," + sy + "V" + ty + "H" + tx;
var orthoY = (sx, sy, tx, ty) => "M" + sx + "," + sy + "H" + tx + "V" + ty;
var orthoR = (sa2, sr, ta, tr2) => {
  const sc = Math.cos(sa2), ss = Math.sin(sa2), tc = Math.cos(ta), ts2 = Math.sin(ta), sf = Math.abs(ta - sa2) > Math.PI ? ta <= sa2 : ta > sa2;
  return "M" + sr * sc + "," + sr * ss + "A" + sr + "," + sr + " 0 0," + (sf ? 1 : 0) + " " + sr * tc + "," + sr * ts2 + "L" + tr2 * tc + "," + tr2 * ts2;
};
var diagonalX = (sx, sy, tx, ty) => {
  const m2 = (sx + tx) / 2;
  return "M" + sx + "," + sy + "C" + m2 + "," + sy + " " + m2 + "," + ty + " " + tx + "," + ty;
};
var diagonalY = (sx, sy, tx, ty) => {
  const m2 = (sy + ty) / 2;
  return "M" + sx + "," + sy + "C" + sx + "," + m2 + " " + tx + "," + m2 + " " + tx + "," + ty;
};
var diagonalR = (sa2, sr, ta, tr2) => {
  const sc = Math.cos(sa2), ss = Math.sin(sa2), tc = Math.cos(ta), ts2 = Math.sin(ta), mr = (sr + tr2) / 2;
  return "M" + sr * sc + "," + sr * ss + "C" + mr * sc + "," + mr * ss + " " + mr * tc + "," + mr * ts2 + " " + tr2 * tc + "," + tr2 * ts2;
};
var Paths = fastmap({
  line: line2,
  "line-radial": lineR,
  arc: arc2,
  "arc-radial": arcR,
  curve,
  "curve-radial": curveR,
  "orthogonal-horizontal": orthoX,
  "orthogonal-vertical": orthoY,
  "orthogonal-radial": orthoR,
  "diagonal-horizontal": diagonalX,
  "diagonal-vertical": diagonalY,
  "diagonal-radial": diagonalR
});
function Pie(params2) {
  Transform.call(this, null, params2);
}
Pie.Definition = {
  type: "Pie",
  metadata: {
    modifies: true
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "startAngle",
    type: "number",
    default: 0
  }, {
    name: "endAngle",
    type: "number",
    default: 6.283185307179586
  }, {
    name: "sort",
    type: "boolean",
    default: false
  }, {
    name: "as",
    type: "string",
    array: true,
    length: 2,
    default: ["startAngle", "endAngle"]
  }]
};
inherits(Pie, Transform, {
  transform(_, pulse2) {
    var as = _.as || ["startAngle", "endAngle"], startAngle = as[0], endAngle = as[1], field4 = _.field || one, start = _.startAngle || 0, stop2 = _.endAngle != null ? _.endAngle : 2 * Math.PI, data4 = pulse2.source, values4 = data4.map(field4), n = values4.length, a2 = start, k = (stop2 - start) / sum(values4), index4 = range_default(n), i, t, v;
    if (_.sort) {
      index4.sort((a3, b2) => values4[a3] - values4[b2]);
    }
    for (i = 0; i < n; ++i) {
      v = values4[index4[i]];
      t = data4[index4[i]];
      t[startAngle] = a2;
      t[endAngle] = a2 += v * k;
    }
    this.value = values4;
    return pulse2.reflow(_.modified()).modifies(as);
  }
});
var DEFAULT_COUNT = 5;
function includeZero(scale7) {
  const type2 = scale7.type;
  return !scale7.bins && (type2 === Linear2 || type2 === Pow || type2 === Sqrt);
}
function includePad(type2) {
  return isContinuous(type2) && type2 !== Sequential;
}
var SKIP2 = toSet(["set", "modified", "clear", "type", "scheme", "schemeExtent", "schemeCount", "domain", "domainMin", "domainMid", "domainMax", "domainRaw", "domainImplicit", "nice", "zero", "bins", "range", "rangeStep", "round", "reverse", "interpolate", "interpolateGamma"]);
function Scale(params2) {
  Transform.call(this, null, params2);
  this.modified(true);
}
inherits(Scale, Transform, {
  transform(_, pulse2) {
    var df = pulse2.dataflow, scale$12 = this.value, key2 = scaleKey(_);
    if (!scale$12 || key2 !== scale$12.type) {
      this.value = scale$12 = scale(key2)();
    }
    for (key2 in _)
      if (!SKIP2[key2]) {
        if (key2 === "padding" && includePad(scale$12.type))
          continue;
        isFunction(scale$12[key2]) ? scale$12[key2](_[key2]) : df.warn("Unsupported scale property: " + key2);
      }
    configureRange(scale$12, _, configureBins(scale$12, _, configureDomain(scale$12, _, df)));
    return pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
  }
});
function scaleKey(_) {
  var t = _.type, d = "", n;
  if (t === Sequential)
    return Sequential + "-" + Linear2;
  if (isContinuousColor(_)) {
    n = _.rawDomain ? _.rawDomain.length : _.domain ? _.domain.length + +(_.domainMid != null) : 0;
    d = n === 2 ? Sequential + "-" : n === 3 ? Diverging + "-" : "";
  }
  return (d + t || Linear2).toLowerCase();
}
function isContinuousColor(_) {
  const t = _.type;
  return isContinuous(t) && t !== Time && t !== UTC && (_.scheme || _.range && _.range.length && _.range.every(isString));
}
function configureDomain(scale7, _, df) {
  const raw = rawDomain(scale7, _.domainRaw, df);
  if (raw > -1)
    return raw;
  var domain4 = _.domain, type2 = scale7.type, zero7 = _.zero || _.zero === void 0 && includeZero(scale7), n, mid;
  if (!domain4)
    return 0;
  if (includePad(type2) && _.padding && domain4[0] !== peek(domain4)) {
    domain4 = padDomain(type2, domain4, _.range, _.padding, _.exponent, _.constant);
  }
  if (zero7 || _.domainMin != null || _.domainMax != null || _.domainMid != null) {
    n = (domain4 = domain4.slice()).length - 1 || 1;
    if (zero7) {
      if (domain4[0] > 0)
        domain4[0] = 0;
      if (domain4[n] < 0)
        domain4[n] = 0;
    }
    if (_.domainMin != null)
      domain4[0] = _.domainMin;
    if (_.domainMax != null)
      domain4[n] = _.domainMax;
    if (_.domainMid != null) {
      mid = _.domainMid;
      const i = mid > domain4[n] ? n + 1 : mid < domain4[0] ? 0 : n;
      if (i !== n)
        df.warn("Scale domainMid exceeds domain min or max.", mid);
      domain4.splice(i, 0, mid);
    }
  }
  scale7.domain(domainCheck(type2, domain4, df));
  if (type2 === Ordinal) {
    scale7.unknown(_.domainImplicit ? implicit : void 0);
  }
  if (_.nice && scale7.nice) {
    scale7.nice(_.nice !== true && tickCount(scale7, _.nice) || null);
  }
  return domain4.length;
}
function rawDomain(scale7, raw, df) {
  if (raw) {
    scale7.domain(domainCheck(scale7.type, raw, df));
    return raw.length;
  } else {
    return -1;
  }
}
function padDomain(type2, domain4, range5, pad4, exponent, constant2) {
  var span2 = Math.abs(peek(range5) - range5[0]), frac = span2 / (span2 - 2 * pad4), d = type2 === Log ? zoomLog(domain4, null, frac) : type2 === Sqrt ? zoomPow(domain4, null, frac, 0.5) : type2 === Pow ? zoomPow(domain4, null, frac, exponent || 1) : type2 === Symlog ? zoomSymlog(domain4, null, frac, constant2 || 1) : zoomLinear(domain4, null, frac);
  domain4 = domain4.slice();
  domain4[0] = d[0];
  domain4[domain4.length - 1] = d[1];
  return domain4;
}
function domainCheck(type2, domain4, df) {
  if (isLogarithmic(type2)) {
    var s = Math.abs(domain4.reduce((s2, v) => s2 + (v < 0 ? -1 : v > 0 ? 1 : 0), 0));
    if (s !== domain4.length) {
      df.warn("Log scale domain includes zero: " + $(domain4));
    }
  }
  return domain4;
}
function configureBins(scale7, _, count2) {
  let bins2 = _.bins;
  if (bins2 && !isArray(bins2)) {
    const domain4 = scale7.domain(), lo = domain4[0], hi = peek(domain4), step = bins2.step;
    let start = bins2.start == null ? lo : bins2.start, stop2 = bins2.stop == null ? hi : bins2.stop;
    if (!step)
      error("Scale bins parameter missing step property.");
    if (start < lo)
      start = step * Math.ceil(lo / step);
    if (stop2 > hi)
      stop2 = step * Math.floor(hi / step);
    bins2 = range_default(start, stop2 + step / 2, step);
  }
  if (bins2) {
    scale7.bins = bins2;
  } else if (scale7.bins) {
    delete scale7.bins;
  }
  if (scale7.type === BinOrdinal) {
    if (!bins2) {
      scale7.bins = scale7.domain();
    } else if (!_.domain && !_.domainRaw) {
      scale7.domain(bins2);
      count2 = bins2.length;
    }
  }
  return count2;
}
function configureRange(scale7, _, count2) {
  var type2 = scale7.type, round = _.round || false, range5 = _.range;
  if (_.rangeStep != null) {
    range5 = configureRangeStep(type2, _, count2);
  } else if (_.scheme) {
    range5 = configureScheme(type2, _, count2);
    if (isFunction(range5)) {
      if (scale7.interpolator) {
        return scale7.interpolator(range5);
      } else {
        error("Scale type ".concat(type2, " does not support interpolating color schemes."));
      }
    }
  }
  if (range5 && isInterpolating(type2)) {
    return scale7.interpolator(interpolateColors(flip(range5, _.reverse), _.interpolate, _.interpolateGamma));
  }
  if (range5 && _.interpolate && scale7.interpolate) {
    scale7.interpolate(interpolate(_.interpolate, _.interpolateGamma));
  } else if (isFunction(scale7.round)) {
    scale7.round(round);
  } else if (isFunction(scale7.rangeRound)) {
    scale7.interpolate(round ? round_default : value_default);
  }
  if (range5)
    scale7.range(flip(range5, _.reverse));
}
function configureRangeStep(type2, _, count2) {
  if (type2 !== Band && type2 !== Point) {
    error("Only band and point scales support rangeStep.");
  }
  var outer = (_.paddingOuter != null ? _.paddingOuter : _.padding) || 0, inner = type2 === Point ? 1 : (_.paddingInner != null ? _.paddingInner : _.padding) || 0;
  return [0, _.rangeStep * bandSpace(count2, inner, outer)];
}
function configureScheme(type2, _, count2) {
  var extent2 = _.schemeExtent, name4, scheme$1;
  if (isArray(_.scheme)) {
    scheme$1 = interpolateColors(_.scheme, _.interpolate, _.interpolateGamma);
  } else {
    name4 = _.scheme.toLowerCase();
    scheme$1 = scheme(name4);
    if (!scheme$1)
      error("Unrecognized scheme name: ".concat(_.scheme));
  }
  count2 = type2 === Threshold ? count2 + 1 : type2 === BinOrdinal ? count2 - 1 : type2 === Quantile2 || type2 === Quantize ? +_.schemeCount || DEFAULT_COUNT : count2;
  return isInterpolating(type2) ? adjustScheme(scheme$1, extent2, _.reverse) : isFunction(scheme$1) ? quantizeInterpolator(adjustScheme(scheme$1, extent2), count2) : type2 === Ordinal ? scheme$1 : scheme$1.slice(0, count2);
}
function adjustScheme(scheme2, extent2, reverse4) {
  return isFunction(scheme2) && (extent2 || reverse4) ? interpolateRange(scheme2, flip(extent2 || [0, 1], reverse4)) : scheme2;
}
function flip(array5, reverse4) {
  return reverse4 ? array5.slice().reverse() : array5;
}
function SortItems(params2) {
  Transform.call(this, null, params2);
}
inherits(SortItems, Transform, {
  transform(_, pulse2) {
    const mod = _.modified("sort") || pulse2.changed(pulse2.ADD) || pulse2.modified(_.sort.fields) || pulse2.modified("datum");
    if (mod)
      pulse2.source.sort(stableCompare(_.sort));
    this.modified(mod);
    return pulse2;
  }
});
var Zero = "zero";
var Center = "center";
var Normalize = "normalize";
var DefOutput = ["y0", "y1"];
function Stack(params2) {
  Transform.call(this, null, params2);
}
Stack.Definition = {
  type: "Stack",
  metadata: {
    modifies: true
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "groupby",
    type: "field",
    array: true
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "offset",
    type: "enum",
    default: Zero,
    values: [Zero, Center, Normalize]
  }, {
    name: "as",
    type: "string",
    array: true,
    length: 2,
    default: DefOutput
  }]
};
inherits(Stack, Transform, {
  transform(_, pulse2) {
    var as = _.as || DefOutput, y06 = as[0], y12 = as[1], sort2 = stableCompare(_.sort), field4 = _.field || one, stack3 = _.offset === Center ? stackCenter : _.offset === Normalize ? stackNormalize : stackZero, groups, i, n, max4;
    groups = partition2(pulse2.source, _.groupby, sort2, field4);
    for (i = 0, n = groups.length, max4 = groups.max; i < n; ++i) {
      stack3(groups[i], max4, field4, y06, y12);
    }
    return pulse2.reflow(_.modified()).modifies(as);
  }
});
function stackCenter(group2, max4, field4, y06, y12) {
  var last = (max4 - group2.sum) / 2, m2 = group2.length, j = 0, t;
  for (; j < m2; ++j) {
    t = group2[j];
    t[y06] = last;
    t[y12] = last += Math.abs(field4(t));
  }
}
function stackNormalize(group2, max4, field4, y06, y12) {
  var scale7 = 1 / group2.sum, last = 0, m2 = group2.length, j = 0, v = 0, t;
  for (; j < m2; ++j) {
    t = group2[j];
    t[y06] = last;
    t[y12] = last = scale7 * (v += Math.abs(field4(t)));
  }
}
function stackZero(group2, max4, field4, y06, y12) {
  var lastPos = 0, lastNeg = 0, m2 = group2.length, j = 0, v, t;
  for (; j < m2; ++j) {
    t = group2[j];
    v = +field4(t);
    if (v < 0) {
      t[y06] = lastNeg;
      t[y12] = lastNeg += v;
    } else {
      t[y06] = lastPos;
      t[y12] = lastPos += v;
    }
  }
}
function partition2(data4, groupby, sort2, field4) {
  var groups = [], get6 = (f) => f(t), map4, i, n, m2, t, k, g, s, max4;
  if (groupby == null) {
    groups.push(data4.slice());
  } else {
    for (map4 = {}, i = 0, n = data4.length; i < n; ++i) {
      t = data4[i];
      k = groupby.map(get6);
      g = map4[k];
      if (!g) {
        map4[k] = g = [];
        groups.push(g);
      }
      g.push(t);
    }
  }
  for (k = 0, max4 = 0, m2 = groups.length; k < m2; ++k) {
    g = groups[k];
    for (i = 0, s = 0, n = g.length; i < n; ++i) {
      s += Math.abs(field4(g[i]));
    }
    g.sum = s;
    if (s > max4)
      max4 = s;
    if (sort2)
      g.sort(sort2);
  }
  groups.max = max4;
  return groups;
}

// node_modules/vega-geo/build/vega-geo.module.js
var vega_geo_module_exports = {};
__export(vega_geo_module_exports, {
  contour: () => Contour,
  geojson: () => GeoJSON,
  geopath: () => GeoPath,
  geopoint: () => GeoPoint,
  geoshape: () => GeoShape,
  graticule: () => Graticule,
  heatmap: () => Heatmap,
  isocontour: () => Isocontour,
  kde2d: () => KDE2D,
  projection: () => Projection
});

// node_modules/d3-geo/src/math.js
var epsilon4 = 1e-6;
var epsilon23 = 1e-12;
var pi3 = Math.PI;
var halfPi2 = pi3 / 2;
var quarterPi = pi3 / 4;
var tau3 = pi3 * 2;
var degrees3 = 180 / pi3;
var radians2 = pi3 / 180;
var abs2 = Math.abs;
var atan = Math.atan;
var atan22 = Math.atan2;
var cos2 = Math.cos;
var ceil = Math.ceil;
var exp3 = Math.exp;
var hypot = Math.hypot;
var log4 = Math.log;
var pow4 = Math.pow;
var sin2 = Math.sin;
var sign2 = Math.sign || function(x5) {
  return x5 > 0 ? 1 : x5 < 0 ? -1 : 0;
};
var sqrt3 = Math.sqrt;
var tan = Math.tan;
function acos2(x5) {
  return x5 > 1 ? 0 : x5 < -1 ? pi3 : Math.acos(x5);
}
function asin2(x5) {
  return x5 > 1 ? halfPi2 : x5 < -1 ? -halfPi2 : Math.asin(x5);
}

// node_modules/d3-geo/src/noop.js
function noop2() {
}

// node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream2) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream2);
  }
}
var streamObjectType = {
  Feature: function(object2, stream2) {
    streamGeometry(object2.geometry, stream2);
  },
  FeatureCollection: function(object2, stream2) {
    var features = object2.features, i = -1, n = features.length;
    while (++i < n)
      streamGeometry(features[i].geometry, stream2);
  }
};
var streamGeometryType = {
  Sphere: function(object2, stream2) {
    stream2.sphere();
  },
  Point: function(object2, stream2) {
    object2 = object2.coordinates;
    stream2.point(object2[0], object2[1], object2[2]);
  },
  MultiPoint: function(object2, stream2) {
    var coordinates = object2.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      object2 = coordinates[i], stream2.point(object2[0], object2[1], object2[2]);
  },
  LineString: function(object2, stream2) {
    streamLine(object2.coordinates, stream2, 0);
  },
  MultiLineString: function(object2, stream2) {
    var coordinates = object2.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      streamLine(coordinates[i], stream2, 0);
  },
  Polygon: function(object2, stream2) {
    streamPolygon(object2.coordinates, stream2);
  },
  MultiPolygon: function(object2, stream2) {
    var coordinates = object2.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      streamPolygon(coordinates[i], stream2);
  },
  GeometryCollection: function(object2, stream2) {
    var geometries = object2.geometries, i = -1, n = geometries.length;
    while (++i < n)
      streamGeometry(geometries[i], stream2);
  }
};
function streamLine(coordinates, stream2, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream2.lineStart();
  while (++i < n)
    coordinate = coordinates[i], stream2.point(coordinate[0], coordinate[1], coordinate[2]);
  stream2.lineEnd();
}
function streamPolygon(coordinates, stream2) {
  var i = -1, n = coordinates.length;
  stream2.polygonStart();
  while (++i < n)
    streamLine(coordinates[i], stream2, 1);
  stream2.polygonEnd();
}
function stream_default(object2, stream2) {
  if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
    streamObjectType[object2.type](object2, stream2);
  } else {
    streamGeometry(object2, stream2);
  }
}

// node_modules/d3-geo/src/area.js
var areaRingSum = new Adder();
var areaSum = new Adder();
var lambda00;
var phi00;
var lambda0;
var cosPhi0;
var sinPhi0;
var areaStream = {
  point: noop2,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: function() {
    areaRingSum = new Adder();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? tau3 + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = noop2;
  },
  sphere: function() {
    areaSum.add(tau3);
  }
};
function areaRingStart() {
  areaStream.point = areaPointFirst;
}
function areaRingEnd() {
  areaPoint(lambda00, phi00);
}
function areaPointFirst(lambda, phi2) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi2;
  lambda *= radians2, phi2 *= radians2;
  lambda0 = lambda, cosPhi0 = cos2(phi2 = phi2 / 2 + quarterPi), sinPhi0 = sin2(phi2);
}
function areaPoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  phi2 = phi2 / 2 + quarterPi;
  var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos2(phi2), sinPhi = sin2(phi2), k = sinPhi0 * sinPhi, u = cosPhi0 * cosPhi + k * cos2(adLambda), v = k * sdLambda * sin2(adLambda);
  areaRingSum.add(atan22(v, u));
  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}
function area_default2(object2) {
  areaSum = new Adder();
  stream_default(object2, areaStream);
  return areaSum * 2;
}

// node_modules/d3-geo/src/cartesian.js
function spherical(cartesian2) {
  return [atan22(cartesian2[1], cartesian2[0]), asin2(cartesian2[2])];
}
function cartesian(spherical2) {
  var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos2(phi2);
  return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2)];
}
function cartesianDot(a2, b2) {
  return a2[0] * b2[0] + a2[1] * b2[1] + a2[2] * b2[2];
}
function cartesianCross(a2, b2) {
  return [a2[1] * b2[2] - a2[2] * b2[1], a2[2] * b2[0] - a2[0] * b2[2], a2[0] * b2[1] - a2[1] * b2[0]];
}
function cartesianAddInPlace(a2, b2) {
  a2[0] += b2[0], a2[1] += b2[1], a2[2] += b2[2];
}
function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}
function cartesianNormalizeInPlace(d) {
  var l = sqrt3(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

// node_modules/d3-geo/src/bounds.js
var lambda02;
var phi0;
var lambda1;
var phi1;
var lambda2;
var lambda002;
var phi002;
var p0;
var deltaSum;
var ranges;
var range;
var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function() {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum = new Adder();
    areaStream.polygonStart();
  },
  polygonEnd: function() {
    areaStream.polygonEnd();
    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (areaRingSum < 0)
      lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    else if (deltaSum > epsilon4)
      phi1 = 90;
    else if (deltaSum < -epsilon4)
      phi0 = -90;
    range[0] = lambda02, range[1] = lambda1;
  },
  sphere: function() {
    lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
  }
};
function boundsPoint(lambda, phi2) {
  ranges.push(range = [lambda02 = lambda, lambda1 = lambda]);
  if (phi2 < phi0)
    phi0 = phi2;
  if (phi2 > phi1)
    phi1 = phi2;
}
function linePoint(lambda, phi2) {
  var p = cartesian([lambda * radians2, phi2 * radians2]);
  if (p0) {
    var normal = cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);
    cartesianNormalizeInPlace(inflection);
    inflection = spherical(inflection);
    var delta = lambda - lambda2, sign3 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees3 * sign3, phii, antimeridian = abs2(delta) > 180;
    if (antimeridian ^ (sign3 * lambda2 < lambdai && lambdai < sign3 * lambda)) {
      phii = inflection[1] * degrees3;
      if (phii > phi1)
        phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign3 * lambda2 < lambdai && lambdai < sign3 * lambda)) {
      phii = -inflection[1] * degrees3;
      if (phii < phi0)
        phi0 = phii;
    } else {
      if (phi2 < phi0)
        phi0 = phi2;
      if (phi2 > phi1)
        phi1 = phi2;
    }
    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda02, lambda) > angle(lambda02, lambda1))
          lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda02, lambda1))
          lambda02 = lambda;
      }
    } else {
      if (lambda1 >= lambda02) {
        if (lambda < lambda02)
          lambda02 = lambda;
        if (lambda > lambda1)
          lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda02, lambda) > angle(lambda02, lambda1))
            lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda02, lambda1))
            lambda02 = lambda;
        }
      }
    }
  } else {
    ranges.push(range = [lambda02 = lambda, lambda1 = lambda]);
  }
  if (phi2 < phi0)
    phi0 = phi2;
  if (phi2 > phi1)
    phi1 = phi2;
  p0 = p, lambda2 = lambda;
}
function boundsLineStart() {
  boundsStream.point = linePoint;
}
function boundsLineEnd() {
  range[0] = lambda02, range[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}
function boundsRingPoint(lambda, phi2) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(abs2(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda002 = lambda, phi002 = phi2;
  }
  areaStream.point(lambda, phi2);
  linePoint(lambda, phi2);
}
function boundsRingStart() {
  areaStream.lineStart();
}
function boundsRingEnd() {
  boundsRingPoint(lambda002, phi002);
  areaStream.lineEnd();
  if (abs2(deltaSum) > epsilon4)
    lambda02 = -(lambda1 = 180);
  range[0] = lambda02, range[1] = lambda1;
  p0 = null;
}
function angle(lambda03, lambda12) {
  return (lambda12 -= lambda03) < 0 ? lambda12 + 360 : lambda12;
}
function rangeCompare(a2, b2) {
  return a2[0] - b2[0];
}
function rangeContains(range5, x5) {
  return range5[0] <= range5[1] ? range5[0] <= x5 && x5 <= range5[1] : x5 < range5[0] || range5[1] < x5;
}
function bounds_default(feature2) {
  var i, n, a2, b2, merged, deltaMax, delta;
  phi1 = lambda1 = -(lambda02 = phi0 = Infinity);
  ranges = [];
  stream_default(feature2, boundsStream);
  if (n = ranges.length) {
    ranges.sort(rangeCompare);
    for (i = 1, a2 = ranges[0], merged = [a2]; i < n; ++i) {
      b2 = ranges[i];
      if (rangeContains(a2, b2[0]) || rangeContains(a2, b2[1])) {
        if (angle(a2[0], b2[1]) > angle(a2[0], a2[1]))
          a2[1] = b2[1];
        if (angle(b2[0], a2[1]) > angle(a2[0], a2[1]))
          a2[0] = b2[0];
      } else {
        merged.push(a2 = b2);
      }
    }
    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a2 = merged[n]; i <= n; a2 = b2, ++i) {
      b2 = merged[i];
      if ((delta = angle(a2[1], b2[0])) > deltaMax)
        deltaMax = delta, lambda02 = b2[0], lambda1 = a2[1];
    }
  }
  ranges = range = null;
  return lambda02 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda02, phi0], [lambda1, phi1]];
}

// node_modules/d3-geo/src/centroid.js
var W0;
var W1;
var X0;
var Y0;
var Z0;
var X1;
var Y1;
var Z1;
var X2;
var Y2;
var Z2;
var lambda003;
var phi003;
var x0;
var y0;
var z0;
var centroidStream = {
  sphere: noop2,
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};
function centroidPoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2);
  centroidPointCartesian(cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2));
}
function centroidPointCartesian(x5, y5, z) {
  ++W0;
  X0 += (x5 - X0) / W0;
  Y0 += (y5 - Y0) / W0;
  Z0 += (z - Z0) / W0;
}
function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}
function centroidLinePointFirst(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2);
  x0 = cosPhi * cos2(lambda);
  y0 = cosPhi * sin2(lambda);
  z0 = sin2(phi2);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}
function centroidLinePoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2), x5 = cosPhi * cos2(lambda), y5 = cosPhi * sin2(lambda), z = sin2(phi2), w3 = atan22(sqrt3((w3 = y0 * z - z0 * y5) * w3 + (w3 = z0 * x5 - x0 * z) * w3 + (w3 = x0 * y5 - y0 * x5) * w3), x0 * x5 + y0 * y5 + z0 * z);
  W1 += w3;
  X1 += w3 * (x0 + (x0 = x5));
  Y1 += w3 * (y0 + (y0 = y5));
  Z1 += w3 * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}
function centroidRingEnd() {
  centroidRingPoint(lambda003, phi003);
  centroidStream.point = centroidPoint;
}
function centroidRingPointFirst(lambda, phi2) {
  lambda003 = lambda, phi003 = phi2;
  lambda *= radians2, phi2 *= radians2;
  centroidStream.point = centroidRingPoint;
  var cosPhi = cos2(phi2);
  x0 = cosPhi * cos2(lambda);
  y0 = cosPhi * sin2(lambda);
  z0 = sin2(phi2);
  centroidPointCartesian(x0, y0, z0);
}
function centroidRingPoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2), x5 = cosPhi * cos2(lambda), y5 = cosPhi * sin2(lambda), z = sin2(phi2), cx = y0 * z - z0 * y5, cy = z0 * x5 - x0 * z, cz = x0 * y5 - y0 * x5, m2 = hypot(cx, cy, cz), w3 = asin2(m2), v = m2 && -w3 / m2;
  X2.add(v * cx);
  Y2.add(v * cy);
  Z2.add(v * cz);
  W1 += w3;
  X1 += w3 * (x0 + (x0 = x5));
  Y1 += w3 * (y0 + (y0 = y5));
  Z1 += w3 * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}
function centroid_default(object2) {
  W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = 0;
  X2 = new Adder();
  Y2 = new Adder();
  Z2 = new Adder();
  stream_default(object2, centroidStream);
  var x5 = +X2, y5 = +Y2, z = +Z2, m2 = hypot(x5, y5, z);
  if (m2 < epsilon23) {
    x5 = X1, y5 = Y1, z = Z1;
    if (W1 < epsilon4)
      x5 = X0, y5 = Y0, z = Z0;
    m2 = hypot(x5, y5, z);
    if (m2 < epsilon23)
      return [NaN, NaN];
  }
  return [atan22(y5, x5) * degrees3, asin2(z / m2) * degrees3];
}

// node_modules/d3-geo/src/compose.js
function compose_default(a2, b2) {
  function compose(x5, y5) {
    return x5 = a2(x5, y5), b2(x5[0], x5[1]);
  }
  if (a2.invert && b2.invert)
    compose.invert = function(x5, y5) {
      return x5 = b2.invert(x5, y5), x5 && a2.invert(x5[0], x5[1]);
    };
  return compose;
}

// node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi2) {
  return [abs2(lambda) > pi3 ? lambda + Math.round(-lambda / tau3) * tau3 : lambda, phi2];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau3) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi2) {
    return lambda += deltaLambda, [lambda > pi3 ? lambda - tau3 : lambda < -pi3 ? lambda + tau3 : lambda, phi2];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos2(deltaPhi), sinDeltaPhi = sin2(deltaPhi), cosDeltaGamma = cos2(deltaGamma), sinDeltaGamma = sin2(deltaGamma);
  function rotation(lambda, phi2) {
    var cosPhi = cos2(phi2), x5 = cos2(lambda) * cosPhi, y5 = sin2(lambda) * cosPhi, z = sin2(phi2), k = z * cosDeltaPhi + x5 * sinDeltaPhi;
    return [
      atan22(y5 * cosDeltaGamma - k * sinDeltaGamma, x5 * cosDeltaPhi - z * sinDeltaPhi),
      asin2(k * cosDeltaGamma + y5 * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi2) {
    var cosPhi = cos2(phi2), x5 = cos2(lambda) * cosPhi, y5 = sin2(lambda) * cosPhi, z = sin2(phi2), k = z * cosDeltaGamma - y5 * sinDeltaGamma;
    return [
      atan22(y5 * cosDeltaGamma + z * sinDeltaGamma, x5 * cosDeltaPhi + k * sinDeltaPhi),
      asin2(k * cosDeltaPhi - x5 * sinDeltaPhi)
    ];
  };
  return rotation;
}
function rotation_default(rotate2) {
  rotate2 = rotateRadians(rotate2[0] * radians2, rotate2[1] * radians2, rotate2.length > 2 ? rotate2[2] * radians2 : 0);
  function forward(coordinates) {
    coordinates = rotate2(coordinates[0] * radians2, coordinates[1] * radians2);
    return coordinates[0] *= degrees3, coordinates[1] *= degrees3, coordinates;
  }
  forward.invert = function(coordinates) {
    coordinates = rotate2.invert(coordinates[0] * radians2, coordinates[1] * radians2);
    return coordinates[0] *= degrees3, coordinates[1] *= degrees3, coordinates;
  };
  return forward;
}

// node_modules/d3-geo/src/circle.js
function circleStream(stream2, radius2, delta, direction, t04, t13) {
  if (!delta)
    return;
  var cosRadius = cos2(radius2), sinRadius = sin2(radius2), step = direction * delta;
  if (t04 == null) {
    t04 = radius2 + direction * tau3;
    t13 = radius2 - step / 2;
  } else {
    t04 = circleRadius(cosRadius, t04);
    t13 = circleRadius(cosRadius, t13);
    if (direction > 0 ? t04 < t13 : t04 > t13)
      t04 += direction * tau3;
  }
  for (var point8, t = t04; direction > 0 ? t > t13 : t < t13; t -= step) {
    point8 = spherical([cosRadius, -sinRadius * cos2(t), -sinRadius * sin2(t)]);
    stream2.point(point8[0], point8[1]);
  }
}
function circleRadius(cosRadius, point8) {
  point8 = cartesian(point8), point8[0] -= cosRadius;
  cartesianNormalizeInPlace(point8);
  var radius2 = acos2(-point8[1]);
  return ((-point8[2] < 0 ? -radius2 : radius2) + tau3 - epsilon4) % tau3;
}

// node_modules/d3-geo/src/clip/buffer.js
function buffer_default() {
  var lines = [], line4;
  return {
    point: function(x5, y5, m2) {
      line4.push([x5, y5, m2]);
    },
    lineStart: function() {
      lines.push(line4 = []);
    },
    lineEnd: noop2,
    rejoin: function() {
      if (lines.length > 1)
        lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line4 = null;
      return result;
    }
  };
}

// node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a2, b2) {
  return abs2(a2[0] - b2[0]) < epsilon4 && abs2(a2[1] - b2[1]) < epsilon4;
}

// node_modules/d3-geo/src/clip/rejoin.js
function Intersection(point8, points2, other, entry2) {
  this.x = point8;
  this.z = points2;
  this.o = other;
  this.e = entry2;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments2, compareIntersection2, startInside, interpolate3, stream2) {
  var subject = [], clip3 = [], i, n;
  segments2.forEach(function(segment) {
    if ((n2 = segment.length - 1) <= 0)
      return;
    var n2, p02 = segment[0], p1 = segment[n2], x5;
    if (pointEqual_default(p02, p1)) {
      if (!p02[2] && !p1[2]) {
        stream2.lineStart();
        for (i = 0; i < n2; ++i)
          stream2.point((p02 = segment[i])[0], p02[1]);
        stream2.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon4;
    }
    subject.push(x5 = new Intersection(p02, segment, null, true));
    clip3.push(x5.o = new Intersection(p02, null, x5, false));
    subject.push(x5 = new Intersection(p1, segment, null, false));
    clip3.push(x5.o = new Intersection(p1, null, x5, true));
  });
  if (!subject.length)
    return;
  clip3.sort(compareIntersection2);
  link(subject);
  link(clip3);
  for (i = 0, n = clip3.length; i < n; ++i) {
    clip3[i].e = startInside = !startInside;
  }
  var start = subject[0], points2, point8;
  while (1) {
    var current2 = start, isSubject = true;
    while (current2.v)
      if ((current2 = current2.n) === start)
        return;
    points2 = current2.z;
    stream2.lineStart();
    do {
      current2.v = current2.o.v = true;
      if (current2.e) {
        if (isSubject) {
          for (i = 0, n = points2.length; i < n; ++i)
            stream2.point((point8 = points2[i])[0], point8[1]);
        } else {
          interpolate3(current2.x, current2.n.x, 1, stream2);
        }
        current2 = current2.n;
      } else {
        if (isSubject) {
          points2 = current2.p.z;
          for (i = points2.length - 1; i >= 0; --i)
            stream2.point((point8 = points2[i])[0], point8[1]);
        } else {
          interpolate3(current2.x, current2.p.x, -1, stream2);
        }
        current2 = current2.p;
      }
      current2 = current2.o;
      points2 = current2.z;
      isSubject = !isSubject;
    } while (!current2.v);
    stream2.lineEnd();
  }
}
function link(array5) {
  if (!(n = array5.length))
    return;
  var n, i = 0, a2 = array5[0], b2;
  while (++i < n) {
    a2.n = b2 = array5[i];
    b2.p = a2;
    a2 = b2;
  }
  a2.n = b2 = array5[0];
  b2.p = a2;
}

// node_modules/d3-geo/src/polygonContains.js
function longitude(point8) {
  if (abs2(point8[0]) <= pi3)
    return point8[0];
  else
    return sign2(point8[0]) * ((abs2(point8[0]) + pi3) % tau3 - pi3);
}
function polygonContains_default(polygon, point8) {
  var lambda = longitude(point8), phi2 = point8[1], sinPhi = sin2(phi2), normal = [sin2(lambda), -cos2(lambda), 0], angle2 = 0, winding = 0;
  var sum2 = new Adder();
  if (sinPhi === 1)
    phi2 = halfPi2 + epsilon4;
  else if (sinPhi === -1)
    phi2 = -halfPi2 - epsilon4;
  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m2 = (ring = polygon[i]).length))
      continue;
    var ring, m2, point0 = ring[m2 - 1], lambda03 = longitude(point0), phi02 = point0[1] / 2 + quarterPi, sinPhi02 = sin2(phi02), cosPhi02 = cos2(phi02);
    for (var j = 0; j < m2; ++j, lambda03 = lambda12, sinPhi02 = sinPhi1, cosPhi02 = cosPhi1, point0 = point1) {
      var point1 = ring[j], lambda12 = longitude(point1), phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi12), cosPhi1 = cos2(phi12), delta = lambda12 - lambda03, sign3 = delta >= 0 ? 1 : -1, absDelta = sign3 * delta, antimeridian = absDelta > pi3, k = sinPhi02 * sinPhi1;
      sum2.add(atan22(k * sign3 * sin2(absDelta), cosPhi02 * cosPhi1 + k * cos2(absDelta)));
      angle2 += antimeridian ? delta + sign3 * tau3 : delta;
      if (antimeridian ^ lambda03 >= lambda ^ lambda12 >= lambda) {
        var arc4 = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc4);
        var intersection = cartesianCross(normal, arc4);
        cartesianNormalizeInPlace(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin2(intersection[2]);
        if (phi2 > phiArc || phi2 === phiArc && (arc4[0] || arc4[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle2 < -epsilon4 || angle2 < epsilon4 && sum2 < -epsilon23) ^ winding & 1;
}

// node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate3, start) {
  return function(sink) {
    var line4 = clipLine(sink), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments2, ring;
    var clip3 = {
      point: point8,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip3.point = pointRing;
        clip3.lineStart = ringStart;
        clip3.lineEnd = ringEnd;
        segments2 = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip3.point = point8;
        clip3.lineStart = lineStart;
        clip3.lineEnd = lineEnd;
        segments2 = merge2(segments2);
        var startInside = polygonContains_default(polygon, start);
        if (segments2.length) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments2, compareIntersection, startInside, interpolate3, sink);
        } else if (startInside) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate3(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted)
          sink.polygonEnd(), polygonStarted = false;
        segments2 = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate3(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point8(lambda, phi2) {
      if (pointVisible(lambda, phi2))
        sink.point(lambda, phi2);
    }
    function pointLine(lambda, phi2) {
      line4.point(lambda, phi2);
    }
    function lineStart() {
      clip3.point = pointLine;
      line4.lineStart();
    }
    function lineEnd() {
      clip3.point = point8;
      line4.lineEnd();
    }
    function pointRing(lambda, phi2) {
      ring.push([lambda, phi2]);
      ringSink.point(lambda, phi2);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m2, segment, point9;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n)
        return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m2 = segment.length - 1) > 0) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m2; ++i)
            sink.point((point9 = segment[i])[0], point9[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n > 1 && clean & 2)
        ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments2.push(ringSegments.filter(validSegment));
    }
    return clip3;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a2, b2) {
  return ((a2 = a2.x)[0] < 0 ? a2[1] - halfPi2 - epsilon4 : halfPi2 - a2[1]) - ((b2 = b2.x)[0] < 0 ? b2[1] - halfPi2 - epsilon4 : halfPi2 - b2[1]);
}

// node_modules/d3-geo/src/clip/antimeridian.js
var antimeridian_default = clip_default(function() {
  return true;
}, clipAntimeridianLine, clipAntimeridianInterpolate, [-pi3, -halfPi2]);
function clipAntimeridianLine(stream2) {
  var lambda03 = NaN, phi02 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream2.lineStart();
      clean = 1;
    },
    point: function(lambda12, phi12) {
      var sign1 = lambda12 > 0 ? pi3 : -pi3, delta = abs2(lambda12 - lambda03);
      if (abs2(delta - pi3) < epsilon4) {
        stream2.point(lambda03, phi02 = (phi02 + phi12) / 2 > 0 ? halfPi2 : -halfPi2);
        stream2.point(sign0, phi02);
        stream2.lineEnd();
        stream2.lineStart();
        stream2.point(sign1, phi02);
        stream2.point(lambda12, phi02);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi3) {
        if (abs2(lambda03 - sign0) < epsilon4)
          lambda03 -= sign0 * epsilon4;
        if (abs2(lambda12 - sign1) < epsilon4)
          lambda12 -= sign1 * epsilon4;
        phi02 = clipAntimeridianIntersect(lambda03, phi02, lambda12, phi12);
        stream2.point(sign0, phi02);
        stream2.lineEnd();
        stream2.lineStart();
        stream2.point(sign1, phi02);
        clean = 0;
      }
      stream2.point(lambda03 = lambda12, phi02 = phi12);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream2.lineEnd();
      lambda03 = phi02 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda03, phi02, lambda12, phi12) {
  var cosPhi02, cosPhi1, sinLambda0Lambda1 = sin2(lambda03 - lambda12);
  return abs2(sinLambda0Lambda1) > epsilon4 ? atan((sin2(phi02) * (cosPhi1 = cos2(phi12)) * sin2(lambda12) - sin2(phi12) * (cosPhi02 = cos2(phi02)) * sin2(lambda03)) / (cosPhi02 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi12) / 2;
}
function clipAntimeridianInterpolate(from, to, direction, stream2) {
  var phi2;
  if (from == null) {
    phi2 = direction * halfPi2;
    stream2.point(-pi3, phi2);
    stream2.point(0, phi2);
    stream2.point(pi3, phi2);
    stream2.point(pi3, 0);
    stream2.point(pi3, -phi2);
    stream2.point(0, -phi2);
    stream2.point(-pi3, -phi2);
    stream2.point(-pi3, 0);
    stream2.point(-pi3, phi2);
  } else if (abs2(from[0] - to[0]) > epsilon4) {
    var lambda = from[0] < to[0] ? pi3 : -pi3;
    phi2 = direction * lambda / 2;
    stream2.point(-lambda, phi2);
    stream2.point(0, phi2);
    stream2.point(lambda, phi2);
  } else {
    stream2.point(to[0], to[1]);
  }
}

// node_modules/d3-geo/src/clip/circle.js
function circle_default2(radius2) {
  var cr2 = cos2(radius2), delta = 6 * radians2, smallRadius = cr2 > 0, notHemisphere = abs2(cr2) > epsilon4;
  function interpolate3(from, to, direction, stream2) {
    circleStream(stream2, radius2, delta, direction, from, to);
  }
  function visible(lambda, phi2) {
    return cos2(lambda) * cos2(phi2) > cr2;
  }
  function clipLine(stream2) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi2) {
        var point1 = [lambda, phi2], point22, v = visible(lambda, phi2), c2 = smallRadius ? v ? 0 : code(lambda, phi2) : v ? code(lambda + (lambda < 0 ? pi3 : -pi3), phi2) : 0;
        if (!point0 && (v00 = v0 = v))
          stream2.lineStart();
        if (v !== v0) {
          point22 = intersect6(point0, point1);
          if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
            point1[2] = 1;
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            stream2.lineStart();
            point22 = intersect6(point1, point0);
            stream2.point(point22[0], point22[1]);
          } else {
            point22 = intersect6(point0, point1);
            stream2.point(point22[0], point22[1], 2);
            stream2.lineEnd();
          }
          point0 = point22;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          if (!(c2 & c0) && (t = intersect6(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream2.lineStart();
              stream2.point(t[0][0], t[0][1]);
              stream2.point(t[1][0], t[1][1]);
              stream2.lineEnd();
            } else {
              stream2.point(t[1][0], t[1][1]);
              stream2.lineEnd();
              stream2.lineStart();
              stream2.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v && (!point0 || !pointEqual_default(point0, point1))) {
          stream2.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c2;
      },
      lineEnd: function() {
        if (v0)
          stream2.lineEnd();
        point0 = null;
      },
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect6(a2, b2, two) {
    var pa2 = cartesian(a2), pb = cartesian(b2);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa2, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant)
      return !two && a2;
    var c1 = cr2 * n2n2 / determinant, c2 = -cr2 * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B2 = cartesianScale(n2, c2);
    cartesianAddInPlace(A5, B2);
    var u = n1xn2, w3 = cartesianDot(A5, u), uu = cartesianDot(u, u), t22 = w3 * w3 - uu * (cartesianDot(A5, A5) - 1);
    if (t22 < 0)
      return;
    var t = sqrt3(t22), q = cartesianScale(u, (-w3 - t) / uu);
    cartesianAddInPlace(q, A5);
    q = spherical(q);
    if (!two)
      return q;
    var lambda03 = a2[0], lambda12 = b2[0], phi02 = a2[1], phi12 = b2[1], z;
    if (lambda12 < lambda03)
      z = lambda03, lambda03 = lambda12, lambda12 = z;
    var delta2 = lambda12 - lambda03, polar = abs2(delta2 - pi3) < epsilon4, meridian = polar || delta2 < epsilon4;
    if (!polar && phi12 < phi02)
      z = phi02, phi02 = phi12, phi12 = z;
    if (meridian ? polar ? phi02 + phi12 > 0 ^ q[1] < (abs2(q[0] - lambda03) < epsilon4 ? phi02 : phi12) : phi02 <= q[1] && q[1] <= phi12 : delta2 > pi3 ^ (lambda03 <= q[0] && q[0] <= lambda12)) {
      var q1 = cartesianScale(u, (-w3 + t) / uu);
      cartesianAddInPlace(q1, A5);
      return [q, spherical(q1)];
    }
  }
  function code(lambda, phi2) {
    var r2 = smallRadius ? radius2 : pi3 - radius2, code2 = 0;
    if (lambda < -r2)
      code2 |= 1;
    else if (lambda > r2)
      code2 |= 2;
    if (phi2 < -r2)
      code2 |= 4;
    else if (phi2 > r2)
      code2 |= 8;
    return code2;
  }
  return clip_default(visible, clipLine, interpolate3, smallRadius ? [0, -radius2] : [-pi3, radius2 - pi3]);
}

// node_modules/d3-geo/src/clip/line.js
function line_default2(a2, b2, x06, y06, x12, y12) {
  var ax = a2[0], ay = a2[1], bx = b2[0], by = b2[1], t04 = 0, t13 = 1, dx = bx - ax, dy = by - ay, r2;
  r2 = x06 - ax;
  if (!dx && r2 > 0)
    return;
  r2 /= dx;
  if (dx < 0) {
    if (r2 < t04)
      return;
    if (r2 < t13)
      t13 = r2;
  } else if (dx > 0) {
    if (r2 > t13)
      return;
    if (r2 > t04)
      t04 = r2;
  }
  r2 = x12 - ax;
  if (!dx && r2 < 0)
    return;
  r2 /= dx;
  if (dx < 0) {
    if (r2 > t13)
      return;
    if (r2 > t04)
      t04 = r2;
  } else if (dx > 0) {
    if (r2 < t04)
      return;
    if (r2 < t13)
      t13 = r2;
  }
  r2 = y06 - ay;
  if (!dy && r2 > 0)
    return;
  r2 /= dy;
  if (dy < 0) {
    if (r2 < t04)
      return;
    if (r2 < t13)
      t13 = r2;
  } else if (dy > 0) {
    if (r2 > t13)
      return;
    if (r2 > t04)
      t04 = r2;
  }
  r2 = y12 - ay;
  if (!dy && r2 < 0)
    return;
  r2 /= dy;
  if (dy < 0) {
    if (r2 > t13)
      return;
    if (r2 > t04)
      t04 = r2;
  } else if (dy > 0) {
    if (r2 < t04)
      return;
    if (r2 < t13)
      t13 = r2;
  }
  if (t04 > 0)
    a2[0] = ax + t04 * dx, a2[1] = ay + t04 * dy;
  if (t13 < 1)
    b2[0] = ax + t13 * dx, b2[1] = ay + t13 * dy;
  return true;
}

// node_modules/d3-geo/src/clip/rectangle.js
var clipMax = 1e9;
var clipMin = -clipMax;
function clipRectangle(x06, y06, x12, y12) {
  function visible(x5, y5) {
    return x06 <= x5 && x5 <= x12 && y06 <= y5 && y5 <= y12;
  }
  function interpolate3(from, to, direction, stream2) {
    var a2 = 0, a1 = 0;
    if (from == null || (a2 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do
        stream2.point(a2 === 0 || a2 === 3 ? x06 : x12, a2 > 1 ? y12 : y06);
      while ((a2 = (a2 + direction + 4) % 4) !== a1);
    } else {
      stream2.point(to[0], to[1]);
    }
  }
  function corner(p, direction) {
    return abs2(p[0] - x06) < epsilon4 ? direction > 0 ? 0 : 3 : abs2(p[0] - x12) < epsilon4 ? direction > 0 ? 2 : 1 : abs2(p[1] - y06) < epsilon4 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
  }
  function compareIntersection2(a2, b2) {
    return comparePoint(a2.x, b2.x);
  }
  function comparePoint(a2, b2) {
    var ca = corner(a2, 1), cb = corner(b2, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b2[1] - a2[1] : ca === 1 ? a2[0] - b2[0] : ca === 2 ? a2[1] - b2[1] : b2[0] - a2[0];
  }
  return function(stream2) {
    var activeStream = stream2, bufferStream = buffer_default(), segments2, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
    var clipStream = {
      point: point8,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point8(x5, y5) {
      if (visible(x5, y5))
        activeStream.point(x5, y5);
    }
    function polygonInside() {
      var winding = 0;
      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring2 = polygon[i], j = 1, m2 = ring2.length, point9 = ring2[0], a0, a1, b0 = point9[0], b1 = point9[1]; j < m2; ++j) {
          a0 = b0, a1 = b1, point9 = ring2[j], b0 = point9[0], b1 = point9[1];
          if (a1 <= y12) {
            if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x06 - a0))
              ++winding;
          } else {
            if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x06 - a0))
              --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments2 = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments2 = merge2(segments2)).length;
      if (cleanInside || visible2) {
        stream2.polygonStart();
        if (cleanInside) {
          stream2.lineStart();
          interpolate3(null, null, 1, stream2);
          stream2.lineEnd();
        }
        if (visible2) {
          rejoin_default(segments2, compareIntersection2, startInside, interpolate3, stream2);
        }
        stream2.polygonEnd();
      }
      activeStream = stream2, segments2 = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint2;
      if (polygon)
        polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments2) {
        linePoint2(x__, y__);
        if (v__ && v_)
          bufferStream.rejoin();
        segments2.push(bufferStream.result());
      }
      clipStream.point = point8;
      if (v_)
        activeStream.lineEnd();
    }
    function linePoint2(x5, y5) {
      var v = visible(x5, y5);
      if (polygon)
        ring.push([x5, y5]);
      if (first) {
        x__ = x5, y__ = y5, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x5, y5);
        }
      } else {
        if (v && v_)
          activeStream.point(x5, y5);
        else {
          var a2 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b2 = [x5 = Math.max(clipMin, Math.min(clipMax, x5)), y5 = Math.max(clipMin, Math.min(clipMax, y5))];
          if (line_default2(a2, b2, x06, y06, x12, y12)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a2[0], a2[1]);
            }
            activeStream.point(b2[0], b2[1]);
            if (!v)
              activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x5, y5);
            clean = false;
          }
        }
      }
      x_ = x5, y_ = y5, v_ = v;
    }
    return clipStream;
  };
}

// node_modules/d3-geo/src/graticule.js
function graticuleX(y06, y12, dy) {
  var y5 = range_default(y06, y12 - epsilon4, dy).concat(y12);
  return function(x5) {
    return y5.map(function(y6) {
      return [x5, y6];
    });
  };
}
function graticuleY(x06, x12, dx) {
  var x5 = range_default(x06, x12 - epsilon4, dx).concat(x12);
  return function(y5) {
    return x5.map(function(x6) {
      return [x6, y5];
    });
  };
}
function graticule() {
  var x12, x06, X13, X03, y12, y06, Y13, Y03, dx = 10, dy = dx, DX = 90, DY = 360, x5, y5, X4, Y4, precision = 2.5;
  function graticule2() {
    return {type: "MultiLineString", coordinates: lines()};
  }
  function lines() {
    return range_default(ceil(X03 / DX) * DX, X13, DX).map(X4).concat(range_default(ceil(Y03 / DY) * DY, Y13, DY).map(Y4)).concat(range_default(ceil(x06 / dx) * dx, x12, dx).filter(function(x6) {
      return abs2(x6 % DX) > epsilon4;
    }).map(x5)).concat(range_default(ceil(y06 / dy) * dy, y12, dy).filter(function(y6) {
      return abs2(y6 % DY) > epsilon4;
    }).map(y5));
  }
  graticule2.lines = function() {
    return lines().map(function(coordinates) {
      return {type: "LineString", coordinates};
    });
  };
  graticule2.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X4(X03).concat(Y4(Y13).slice(1), X4(X13).reverse().slice(1), Y4(Y03).reverse().slice(1))
      ]
    };
  };
  graticule2.extent = function(_) {
    if (!arguments.length)
      return graticule2.extentMinor();
    return graticule2.extentMajor(_).extentMinor(_);
  };
  graticule2.extentMajor = function(_) {
    if (!arguments.length)
      return [[X03, Y03], [X13, Y13]];
    X03 = +_[0][0], X13 = +_[1][0];
    Y03 = +_[0][1], Y13 = +_[1][1];
    if (X03 > X13)
      _ = X03, X03 = X13, X13 = _;
    if (Y03 > Y13)
      _ = Y03, Y03 = Y13, Y13 = _;
    return graticule2.precision(precision);
  };
  graticule2.extentMinor = function(_) {
    if (!arguments.length)
      return [[x06, y06], [x12, y12]];
    x06 = +_[0][0], x12 = +_[1][0];
    y06 = +_[0][1], y12 = +_[1][1];
    if (x06 > x12)
      _ = x06, x06 = x12, x12 = _;
    if (y06 > y12)
      _ = y06, y06 = y12, y12 = _;
    return graticule2.precision(precision);
  };
  graticule2.step = function(_) {
    if (!arguments.length)
      return graticule2.stepMinor();
    return graticule2.stepMajor(_).stepMinor(_);
  };
  graticule2.stepMajor = function(_) {
    if (!arguments.length)
      return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule2;
  };
  graticule2.stepMinor = function(_) {
    if (!arguments.length)
      return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule2;
  };
  graticule2.precision = function(_) {
    if (!arguments.length)
      return precision;
    precision = +_;
    x5 = graticuleX(y06, y12, 90);
    y5 = graticuleY(x06, x12, precision);
    X4 = graticuleX(Y03, Y13, 90);
    Y4 = graticuleY(X03, X13, precision);
    return graticule2;
  };
  return graticule2.extentMajor([[-180, -90 + epsilon4], [180, 90 - epsilon4]]).extentMinor([[-180, -80 - epsilon4], [180, 80 + epsilon4]]);
}

// node_modules/d3-geo/src/identity.js
var identity_default4 = (x5) => x5;

// node_modules/d3-geo/src/path/area.js
var areaSum2 = new Adder();
var areaRingSum2 = new Adder();
var x00;
var y00;
var x02;
var y02;
var areaStream2 = {
  point: noop2,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: function() {
    areaStream2.lineStart = areaRingStart2;
    areaStream2.lineEnd = areaRingEnd2;
  },
  polygonEnd: function() {
    areaStream2.lineStart = areaStream2.lineEnd = areaStream2.point = noop2;
    areaSum2.add(abs2(areaRingSum2));
    areaRingSum2 = new Adder();
  },
  result: function() {
    var area4 = areaSum2 / 2;
    areaSum2 = new Adder();
    return area4;
  }
};
function areaRingStart2() {
  areaStream2.point = areaPointFirst2;
}
function areaPointFirst2(x5, y5) {
  areaStream2.point = areaPoint2;
  x00 = x02 = x5, y00 = y02 = y5;
}
function areaPoint2(x5, y5) {
  areaRingSum2.add(y02 * x5 - x02 * y5);
  x02 = x5, y02 = y5;
}
function areaRingEnd2() {
  areaPoint2(x00, y00);
}
var area_default3 = areaStream2;

// node_modules/d3-geo/src/path/bounds.js
var x03 = Infinity;
var y03 = x03;
var x1 = -x03;
var y1 = x1;
var boundsStream2 = {
  point: boundsPoint2,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: noop2,
  polygonEnd: noop2,
  result: function() {
    var bounds2 = [[x03, y03], [x1, y1]];
    x1 = y1 = -(y03 = x03 = Infinity);
    return bounds2;
  }
};
function boundsPoint2(x5, y5) {
  if (x5 < x03)
    x03 = x5;
  if (x5 > x1)
    x1 = x5;
  if (y5 < y03)
    y03 = y5;
  if (y5 > y1)
    y1 = y5;
}
var bounds_default2 = boundsStream2;

// node_modules/d3-geo/src/path/centroid.js
var X02 = 0;
var Y02 = 0;
var Z02 = 0;
var X12 = 0;
var Y12 = 0;
var Z12 = 0;
var X22 = 0;
var Y22 = 0;
var Z22 = 0;
var x002;
var y002;
var x04;
var y04;
var centroidStream2 = {
  point: centroidPoint2,
  lineStart: centroidLineStart2,
  lineEnd: centroidLineEnd2,
  polygonStart: function() {
    centroidStream2.lineStart = centroidRingStart2;
    centroidStream2.lineEnd = centroidRingEnd2;
  },
  polygonEnd: function() {
    centroidStream2.point = centroidPoint2;
    centroidStream2.lineStart = centroidLineStart2;
    centroidStream2.lineEnd = centroidLineEnd2;
  },
  result: function() {
    var centroid = Z22 ? [X22 / Z22, Y22 / Z22] : Z12 ? [X12 / Z12, Y12 / Z12] : Z02 ? [X02 / Z02, Y02 / Z02] : [NaN, NaN];
    X02 = Y02 = Z02 = X12 = Y12 = Z12 = X22 = Y22 = Z22 = 0;
    return centroid;
  }
};
function centroidPoint2(x5, y5) {
  X02 += x5;
  Y02 += y5;
  ++Z02;
}
function centroidLineStart2() {
  centroidStream2.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x5, y5) {
  centroidStream2.point = centroidPointLine;
  centroidPoint2(x04 = x5, y04 = y5);
}
function centroidPointLine(x5, y5) {
  var dx = x5 - x04, dy = y5 - y04, z = sqrt3(dx * dx + dy * dy);
  X12 += z * (x04 + x5) / 2;
  Y12 += z * (y04 + y5) / 2;
  Z12 += z;
  centroidPoint2(x04 = x5, y04 = y5);
}
function centroidLineEnd2() {
  centroidStream2.point = centroidPoint2;
}
function centroidRingStart2() {
  centroidStream2.point = centroidPointFirstRing;
}
function centroidRingEnd2() {
  centroidPointRing(x002, y002);
}
function centroidPointFirstRing(x5, y5) {
  centroidStream2.point = centroidPointRing;
  centroidPoint2(x002 = x04 = x5, y002 = y04 = y5);
}
function centroidPointRing(x5, y5) {
  var dx = x5 - x04, dy = y5 - y04, z = sqrt3(dx * dx + dy * dy);
  X12 += z * (x04 + x5) / 2;
  Y12 += z * (y04 + y5) / 2;
  Z12 += z;
  z = y04 * x5 - x04 * y5;
  X22 += z * (x04 + x5);
  Y22 += z * (y04 + y5);
  Z22 += z * 3;
  centroidPoint2(x04 = x5, y04 = y5);
}
var centroid_default2 = centroidStream2;

// node_modules/d3-geo/src/path/context.js
function PathContext(context3) {
  this._context = context3;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0)
      this._context.closePath();
    this._point = NaN;
  },
  point: function(x5, y5) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x5, y5);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x5, y5);
        break;
      }
      default: {
        this._context.moveTo(x5 + this._radius, y5);
        this._context.arc(x5, y5, this._radius, 0, tau3);
        break;
      }
    }
  },
  result: noop2
};

// node_modules/d3-geo/src/path/measure.js
var lengthSum = new Adder();
var lengthRing;
var x003;
var y003;
var x05;
var y05;
var lengthStream = {
  point: noop2,
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing)
      lengthPoint(x003, y003);
    lengthStream.point = noop2;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length3 = +lengthSum;
    lengthSum = new Adder();
    return length3;
  }
};
function lengthPointFirst(x5, y5) {
  lengthStream.point = lengthPoint;
  x003 = x05 = x5, y003 = y05 = y5;
}
function lengthPoint(x5, y5) {
  x05 -= x5, y05 -= y5;
  lengthSum.add(sqrt3(x05 * x05 + y05 * y05));
  x05 = x5, y05 = y5;
}
var measure_default = lengthStream;

// node_modules/d3-geo/src/path/string.js
function PathString() {
  this._string = [];
}
PathString.prototype = {
  _radius: 4.5,
  _circle: circle(4.5),
  pointRadius: function(_) {
    if ((_ = +_) !== this._radius)
      this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0)
      this._string.push("Z");
    this._point = NaN;
  },
  point: function(x5, y5) {
    switch (this._point) {
      case 0: {
        this._string.push("M", x5, ",", y5);
        this._point = 1;
        break;
      }
      case 1: {
        this._string.push("L", x5, ",", y5);
        break;
      }
      default: {
        if (this._circle == null)
          this._circle = circle(this._radius);
        this._string.push("M", x5, ",", y5, this._circle);
        break;
      }
    }
  },
  result: function() {
    if (this._string.length) {
      var result = this._string.join("");
      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};
function circle(radius2) {
  return "m0," + radius2 + "a" + radius2 + "," + radius2 + " 0 1,1 0," + -2 * radius2 + "a" + radius2 + "," + radius2 + " 0 1,1 0," + 2 * radius2 + "z";
}

// node_modules/d3-geo/src/path/index.js
function path_default2(projection3, context3) {
  var pointRadius = 4.5, projectionStream, contextStream;
  function path3(object2) {
    if (object2) {
      if (typeof pointRadius === "function")
        contextStream.pointRadius(+pointRadius.apply(this, arguments));
      stream_default(object2, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path3.area = function(object2) {
    stream_default(object2, projectionStream(area_default3));
    return area_default3.result();
  };
  path3.measure = function(object2) {
    stream_default(object2, projectionStream(measure_default));
    return measure_default.result();
  };
  path3.bounds = function(object2) {
    stream_default(object2, projectionStream(bounds_default2));
    return bounds_default2.result();
  };
  path3.centroid = function(object2) {
    stream_default(object2, projectionStream(centroid_default2));
    return centroid_default2.result();
  };
  path3.projection = function(_) {
    return arguments.length ? (projectionStream = _ == null ? (projection3 = null, identity_default4) : (projection3 = _).stream, path3) : projection3;
  };
  path3.context = function(_) {
    if (!arguments.length)
      return context3;
    contextStream = _ == null ? (context3 = null, new PathString()) : new PathContext(context3 = _);
    if (typeof pointRadius !== "function")
      contextStream.pointRadius(pointRadius);
    return path3;
  };
  path3.pointRadius = function(_) {
    if (!arguments.length)
      return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path3;
  };
  return path3.projection(projection3).context(context3);
}

// node_modules/d3-geo/src/transform.js
function transformer4(methods2) {
  return function(stream2) {
    var s = new TransformStream();
    for (var key2 in methods2)
      s[key2] = methods2[key2];
    s.stream = stream2;
    return s;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x5, y5) {
    this.stream.point(x5, y5);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};

// node_modules/d3-geo/src/projection/fit.js
function fit(projection3, fitBounds, object2) {
  var clip3 = projection3.clipExtent && projection3.clipExtent();
  projection3.scale(150).translate([0, 0]);
  if (clip3 != null)
    projection3.clipExtent(null);
  stream_default(object2, projection3.stream(bounds_default2));
  fitBounds(bounds_default2.result());
  if (clip3 != null)
    projection3.clipExtent(clip3);
  return projection3;
}
function fitExtent(projection3, extent2, object2) {
  return fit(projection3, function(b2) {
    var w3 = extent2[1][0] - extent2[0][0], h3 = extent2[1][1] - extent2[0][1], k = Math.min(w3 / (b2[1][0] - b2[0][0]), h3 / (b2[1][1] - b2[0][1])), x5 = +extent2[0][0] + (w3 - k * (b2[1][0] + b2[0][0])) / 2, y5 = +extent2[0][1] + (h3 - k * (b2[1][1] + b2[0][1])) / 2;
    projection3.scale(150 * k).translate([x5, y5]);
  }, object2);
}
function fitSize(projection3, size, object2) {
  return fitExtent(projection3, [[0, 0], size], object2);
}
function fitWidth(projection3, width2, object2) {
  return fit(projection3, function(b2) {
    var w3 = +width2, k = w3 / (b2[1][0] - b2[0][0]), x5 = (w3 - k * (b2[1][0] + b2[0][0])) / 2, y5 = -k * b2[0][1];
    projection3.scale(150 * k).translate([x5, y5]);
  }, object2);
}
function fitHeight(projection3, height2, object2) {
  return fit(projection3, function(b2) {
    var h3 = +height2, k = h3 / (b2[1][1] - b2[0][1]), x5 = -k * b2[0][0], y5 = (h3 - k * (b2[1][1] + b2[0][1])) / 2;
    projection3.scale(150 * k).translate([x5, y5]);
  }, object2);
}

// node_modules/d3-geo/src/projection/resample.js
var maxDepth = 16;
var cosMinDistance = cos2(30 * radians2);
function resample_default(project3, delta2) {
  return +delta2 ? resample(project3, delta2) : resampleNone(project3);
}
function resampleNone(project3) {
  return transformer4({
    point: function(x5, y5) {
      x5 = project3(x5, y5);
      this.stream.point(x5[0], x5[1]);
    }
  });
}
function resample(project3, delta2) {
  function resampleLineTo(x06, y06, lambda03, a0, b0, c0, x12, y12, lambda12, a1, b1, c1, depth, stream2) {
    var dx = x12 - x06, dy = y12 - y06, d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a2 = a0 + a1, b2 = b0 + b1, c2 = c0 + c1, m2 = sqrt3(a2 * a2 + b2 * b2 + c2 * c2), phi2 = asin2(c2 /= m2), lambda22 = abs2(abs2(c2) - 1) < epsilon4 || abs2(lambda03 - lambda12) < epsilon4 ? (lambda03 + lambda12) / 2 : atan22(b2, a2), p = project3(lambda22, phi2), x22 = p[0], y22 = p[1], dx2 = x22 - x06, dy2 = y22 - y06, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 || abs2((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x06, y06, lambda03, a0, b0, c0, x22, y22, lambda22, a2 /= m2, b2 /= m2, c2, depth, stream2);
        stream2.point(x22, y22);
        resampleLineTo(x22, y22, lambda22, a2, b2, c2, x12, y12, lambda12, a1, b1, c1, depth, stream2);
      }
    }
  }
  return function(stream2) {
    var lambda004, x004, y004, a00, b00, c00, lambda03, x06, y06, a0, b0, c0;
    var resampleStream = {
      point: point8,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream2.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream2.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point8(x5, y5) {
      x5 = project3(x5, y5);
      stream2.point(x5[0], x5[1]);
    }
    function lineStart() {
      x06 = NaN;
      resampleStream.point = linePoint2;
      stream2.lineStart();
    }
    function linePoint2(lambda, phi2) {
      var c2 = cartesian([lambda, phi2]), p = project3(lambda, phi2);
      resampleLineTo(x06, y06, lambda03, a0, b0, c0, x06 = p[0], y06 = p[1], lambda03 = lambda, a0 = c2[0], b0 = c2[1], c0 = c2[2], maxDepth, stream2);
      stream2.point(x06, y06);
    }
    function lineEnd() {
      resampleStream.point = point8;
      stream2.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi2) {
      linePoint2(lambda004 = lambda, phi2), x004 = x06, y004 = y06, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint2;
    }
    function ringEnd() {
      resampleLineTo(x06, y06, lambda03, a0, b0, c0, x004, y004, lambda004, a00, b00, c00, maxDepth, stream2);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}

// node_modules/d3-geo/src/projection/index.js
var transformRadians = transformer4({
  point: function(x5, y5) {
    this.stream.point(x5 * radians2, y5 * radians2);
  }
});
function transformRotate(rotate2) {
  return transformer4({
    point: function(x5, y5) {
      var r2 = rotate2(x5, y5);
      return this.stream.point(r2[0], r2[1]);
    }
  });
}
function scaleTranslate(k, dx, dy, sx, sy) {
  function transform4(x5, y5) {
    x5 *= sx;
    y5 *= sy;
    return [dx + k * x5, dy - k * y5];
  }
  transform4.invert = function(x5, y5) {
    return [(x5 - dx) / k * sx, (dy - y5) / k * sy];
  };
  return transform4;
}
function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
  if (!alpha)
    return scaleTranslate(k, dx, dy, sx, sy);
  var cosAlpha = cos2(alpha), sinAlpha = sin2(alpha), a2 = cosAlpha * k, b2 = sinAlpha * k, ai = cosAlpha / k, bi = sinAlpha / k, ci = (sinAlpha * dy - cosAlpha * dx) / k, fi = (sinAlpha * dx + cosAlpha * dy) / k;
  function transform4(x5, y5) {
    x5 *= sx;
    y5 *= sy;
    return [a2 * x5 - b2 * y5 + dx, dy - b2 * x5 - a2 * y5];
  }
  transform4.invert = function(x5, y5) {
    return [sx * (ai * x5 - bi * y5 + ci), sy * (fi - bi * x5 - ai * y5)];
  };
  return transform4;
}
function projection(project3) {
  return projectionMutator(function() {
    return project3;
  })();
}
function projectionMutator(projectAt) {
  var project3, k = 150, x5 = 480, y5 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate2, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x06 = null, y06, x12, y12, postclip = identity_default4, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache2, cacheStream;
  function projection3(point8) {
    return projectRotateTransform(point8[0] * radians2, point8[1] * radians2);
  }
  function invert3(point8) {
    point8 = projectRotateTransform.invert(point8[0], point8[1]);
    return point8 && [point8[0] * degrees3, point8[1] * degrees3];
  }
  projection3.stream = function(stream2) {
    return cache2 && cacheStream === stream2 ? cache2 : cache2 = transformRadians(transformRotate(rotate2)(preclip(projectResample(postclip(cacheStream = stream2)))));
  };
  projection3.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = void 0, reset3()) : preclip;
  };
  projection3.postclip = function(_) {
    return arguments.length ? (postclip = _, x06 = y06 = x12 = y12 = null, reset3()) : postclip;
  };
  projection3.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? circle_default2(theta = _ * radians2) : (theta = null, antimeridian_default), reset3()) : theta * degrees3;
  };
  projection3.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x06 = y06 = x12 = y12 = null, identity_default4) : clipRectangle(x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset3()) : x06 == null ? null : [[x06, y06], [x12, y12]];
  };
  projection3.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };
  projection3.translate = function(_) {
    return arguments.length ? (x5 = +_[0], y5 = +_[1], recenter()) : [x5, y5];
  };
  projection3.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * radians2, phi2 = _[1] % 360 * radians2, recenter()) : [lambda * degrees3, phi2 * degrees3];
  };
  projection3.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * radians2, deltaPhi = _[1] % 360 * radians2, deltaGamma = _.length > 2 ? _[2] % 360 * radians2 : 0, recenter()) : [deltaLambda * degrees3, deltaPhi * degrees3, deltaGamma * degrees3];
  };
  projection3.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * radians2, recenter()) : alpha * degrees3;
  };
  projection3.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
  };
  projection3.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
  };
  projection3.precision = function(_) {
    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _ * _), reset3()) : sqrt3(delta2);
  };
  projection3.fitExtent = function(extent2, object2) {
    return fitExtent(projection3, extent2, object2);
  };
  projection3.fitSize = function(size, object2) {
    return fitSize(projection3, size, object2);
  };
  projection3.fitWidth = function(width2, object2) {
    return fitWidth(projection3, width2, object2);
  };
  projection3.fitHeight = function(height2, object2) {
    return fitHeight(projection3, height2, object2);
  };
  function recenter() {
    var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project3(lambda, phi2)), transform4 = scaleTranslateRotate(k, x5 - center[0], y5 - center[1], sx, sy, alpha);
    rotate2 = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose_default(project3, transform4);
    projectRotateTransform = compose_default(rotate2, projectTransform);
    projectResample = resample_default(projectTransform, delta2);
    return reset3();
  }
  function reset3() {
    cache2 = cacheStream = null;
    return projection3;
  }
  return function() {
    project3 = projectAt.apply(this, arguments);
    projection3.invert = project3.invert && invert3;
    return recenter();
  };
}

// node_modules/d3-geo/src/projection/conic.js
function conicProjection(projectAt) {
  var phi02 = 0, phi12 = pi3 / 3, m2 = projectionMutator(projectAt), p = m2(phi02, phi12);
  p.parallels = function(_) {
    return arguments.length ? m2(phi02 = _[0] * radians2, phi12 = _[1] * radians2) : [phi02 * degrees3, phi12 * degrees3];
  };
  return p;
}

// node_modules/d3-geo/src/projection/cylindricalEqualArea.js
function cylindricalEqualAreaRaw(phi02) {
  var cosPhi02 = cos2(phi02);
  function forward(lambda, phi2) {
    return [lambda * cosPhi02, sin2(phi2) / cosPhi02];
  }
  forward.invert = function(x5, y5) {
    return [x5 / cosPhi02, asin2(y5 * cosPhi02)];
  };
  return forward;
}

// node_modules/d3-geo/src/projection/conicEqualArea.js
function conicEqualAreaRaw(y06, y12) {
  var sy0 = sin2(y06), n = (sy0 + sin2(y12)) / 2;
  if (abs2(n) < epsilon4)
    return cylindricalEqualAreaRaw(y06);
  var c2 = 1 + sy0 * (2 * n - sy0), r0 = sqrt3(c2) / n;
  function project3(x5, y5) {
    var r2 = sqrt3(c2 - 2 * n * sin2(y5)) / n;
    return [r2 * sin2(x5 *= n), r0 - r2 * cos2(x5)];
  }
  project3.invert = function(x5, y5) {
    var r0y = r0 - y5, l = atan22(x5, abs2(r0y)) * sign2(r0y);
    if (r0y * n < 0)
      l -= pi3 * sign2(x5) * sign2(r0y);
    return [l / n, asin2((c2 - (x5 * x5 + r0y * r0y) * n * n) / (2 * n))];
  };
  return project3;
}
function conicEqualArea_default() {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}

// node_modules/d3-geo/src/projection/albers.js
function albers_default() {
  return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}

// node_modules/d3-geo/src/projection/albersUsa.js
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x5, y5) {
      var i = -1;
      while (++i < n)
        streams[i].point(x5, y5);
    },
    sphere: function() {
      var i = -1;
      while (++i < n)
        streams[i].sphere();
    },
    lineStart: function() {
      var i = -1;
      while (++i < n)
        streams[i].lineStart();
    },
    lineEnd: function() {
      var i = -1;
      while (++i < n)
        streams[i].lineEnd();
    },
    polygonStart: function() {
      var i = -1;
      while (++i < n)
        streams[i].polygonStart();
    },
    polygonEnd: function() {
      var i = -1;
      while (++i < n)
        streams[i].polygonEnd();
    }
  };
}
function albersUsa_default() {
  var cache2, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point8, pointStream = {point: function(x5, y5) {
    point8 = [x5, y5];
  }};
  function albersUsa(coordinates) {
    var x5 = coordinates[0], y5 = coordinates[1];
    return point8 = null, (lower48Point.point(x5, y5), point8) || (alaskaPoint.point(x5, y5), point8) || (hawaiiPoint.point(x5, y5), point8);
  }
  albersUsa.invert = function(coordinates) {
    var k = lower48.scale(), t = lower48.translate(), x5 = (coordinates[0] - t[0]) / k, y5 = (coordinates[1] - t[1]) / k;
    return (y5 >= 0.12 && y5 < 0.234 && x5 >= -0.425 && x5 < -0.214 ? alaska : y5 >= 0.166 && y5 < 0.234 && x5 >= -0.214 && x5 < -0.115 ? hawaii : lower48).invert(coordinates);
  };
  albersUsa.stream = function(stream2) {
    return cache2 && cacheStream === stream2 ? cache2 : cache2 = multiplex([lower48.stream(cacheStream = stream2), alaska.stream(stream2), hawaii.stream(stream2)]);
  };
  albersUsa.precision = function(_) {
    if (!arguments.length)
      return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset3();
  };
  albersUsa.scale = function(_) {
    if (!arguments.length)
      return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };
  albersUsa.translate = function(_) {
    if (!arguments.length)
      return lower48.translate();
    var k = lower48.scale(), x5 = +_[0], y5 = +_[1];
    lower48Point = lower48.translate(_).clipExtent([[x5 - 0.455 * k, y5 - 0.238 * k], [x5 + 0.455 * k, y5 + 0.238 * k]]).stream(pointStream);
    alaskaPoint = alaska.translate([x5 - 0.307 * k, y5 + 0.201 * k]).clipExtent([[x5 - 0.425 * k + epsilon4, y5 + 0.12 * k + epsilon4], [x5 - 0.214 * k - epsilon4, y5 + 0.234 * k - epsilon4]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x5 - 0.205 * k, y5 + 0.212 * k]).clipExtent([[x5 - 0.214 * k + epsilon4, y5 + 0.166 * k + epsilon4], [x5 - 0.115 * k - epsilon4, y5 + 0.234 * k - epsilon4]]).stream(pointStream);
    return reset3();
  };
  albersUsa.fitExtent = function(extent2, object2) {
    return fitExtent(albersUsa, extent2, object2);
  };
  albersUsa.fitSize = function(size, object2) {
    return fitSize(albersUsa, size, object2);
  };
  albersUsa.fitWidth = function(width2, object2) {
    return fitWidth(albersUsa, width2, object2);
  };
  albersUsa.fitHeight = function(height2, object2) {
    return fitHeight(albersUsa, height2, object2);
  };
  function reset3() {
    cache2 = cacheStream = null;
    return albersUsa;
  }
  return albersUsa.scale(1070);
}

// node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale7) {
  return function(x5, y5) {
    var cx = cos2(x5), cy = cos2(y5), k = scale7(cx * cy);
    if (k === Infinity)
      return [2, 0];
    return [
      k * cy * sin2(x5),
      k * sin2(y5)
    ];
  };
}
function azimuthalInvert(angle2) {
  return function(x5, y5) {
    var z = sqrt3(x5 * x5 + y5 * y5), c2 = angle2(z), sc = sin2(c2), cc = cos2(c2);
    return [
      atan22(x5 * sc, z * cc),
      asin2(z && y5 * sc / z)
    ];
  };
}

// node_modules/d3-geo/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt3(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin2(z / 2);
});
function azimuthalEqualArea_default() {
  return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw = azimuthalRaw(function(c2) {
  return (c2 = acos2(c2)) && c2 / sin2(c2);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});
function azimuthalEquidistant_default() {
  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi2) {
  return [lambda, log4(tan((halfPi2 + phi2) / 2))];
}
mercatorRaw.invert = function(x5, y5) {
  return [x5, 2 * atan(exp3(y5)) - halfPi2];
};
function mercator_default() {
  return mercatorProjection(mercatorRaw).scale(961 / tau3);
}
function mercatorProjection(project3) {
  var m2 = projection(project3), center = m2.center, scale7 = m2.scale, translate4 = m2.translate, clipExtent = m2.clipExtent, x06 = null, y06, x12, y12;
  m2.scale = function(_) {
    return arguments.length ? (scale7(_), reclip()) : scale7();
  };
  m2.translate = function(_) {
    return arguments.length ? (translate4(_), reclip()) : translate4();
  };
  m2.center = function(_) {
    return arguments.length ? (center(_), reclip()) : center();
  };
  m2.clipExtent = function(_) {
    return arguments.length ? (_ == null ? x06 = y06 = x12 = y12 = null : (x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reclip()) : x06 == null ? null : [[x06, y06], [x12, y12]];
  };
  function reclip() {
    var k = pi3 * scale7(), t = m2(rotation_default(m2.rotate()).invert([0, 0]));
    return clipExtent(x06 == null ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project3 === mercatorRaw ? [[Math.max(t[0] - k, x06), y06], [Math.min(t[0] + k, x12), y12]] : [[x06, Math.max(t[1] - k, y06)], [x12, Math.min(t[1] + k, y12)]]);
  }
  return reclip();
}

// node_modules/d3-geo/src/projection/conicConformal.js
function tany(y5) {
  return tan((halfPi2 + y5) / 2);
}
function conicConformalRaw(y06, y12) {
  var cy0 = cos2(y06), n = y06 === y12 ? sin2(y06) : log4(cy0 / cos2(y12)) / log4(tany(y12) / tany(y06)), f = cy0 * pow4(tany(y06), n) / n;
  if (!n)
    return mercatorRaw;
  function project3(x5, y5) {
    if (f > 0) {
      if (y5 < -halfPi2 + epsilon4)
        y5 = -halfPi2 + epsilon4;
    } else {
      if (y5 > halfPi2 - epsilon4)
        y5 = halfPi2 - epsilon4;
    }
    var r2 = f / pow4(tany(y5), n);
    return [r2 * sin2(n * x5), f - r2 * cos2(n * x5)];
  }
  project3.invert = function(x5, y5) {
    var fy = f - y5, r2 = sign2(n) * sqrt3(x5 * x5 + fy * fy), l = atan22(x5, abs2(fy)) * sign2(fy);
    if (fy * n < 0)
      l -= pi3 * sign2(x5) * sign2(fy);
    return [l / n, 2 * atan(pow4(f / r2, 1 / n)) - halfPi2];
  };
  return project3;
}
function conicConformal_default() {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}

// node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi2) {
  return [lambda, phi2];
}
equirectangularRaw.invert = equirectangularRaw;
function equirectangular_default() {
  return projection(equirectangularRaw).scale(152.63);
}

// node_modules/d3-geo/src/projection/conicEquidistant.js
function conicEquidistantRaw(y06, y12) {
  var cy0 = cos2(y06), n = y06 === y12 ? sin2(y06) : (cy0 - cos2(y12)) / (y12 - y06), g = cy0 / n + y06;
  if (abs2(n) < epsilon4)
    return equirectangularRaw;
  function project3(x5, y5) {
    var gy = g - y5, nx = n * x5;
    return [gy * sin2(nx), g - gy * cos2(nx)];
  }
  project3.invert = function(x5, y5) {
    var gy = g - y5, l = atan22(x5, abs2(gy)) * sign2(gy);
    if (gy * n < 0)
      l -= pi3 * sign2(x5) * sign2(gy);
    return [l / n, g - sign2(n) * sqrt3(x5 * x5 + gy * gy)];
  };
  return project3;
}
function conicEquidistant_default() {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}

// node_modules/d3-geo/src/projection/equalEarth.js
var A1 = 1.340264;
var A2 = -0.081106;
var A3 = 893e-6;
var A4 = 3796e-6;
var M = sqrt3(3) / 2;
var iterations = 12;
function equalEarthRaw(lambda, phi2) {
  var l = asin2(M * sin2(phi2)), l2 = l * l, l6 = l2 * l2 * l2;
  return [
    lambda * cos2(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
  ];
}
equalEarthRaw.invert = function(x5, y5) {
  var l = y5, l2 = l * l, l6 = l2 * l2 * l2;
  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y5;
    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
    if (abs2(delta) < epsilon23)
      break;
  }
  return [
    M * x5 * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos2(l),
    asin2(sin2(l) / M)
  ];
};
function equalEarth_default() {
  return projection(equalEarthRaw).scale(177.158);
}

// node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x5, y5) {
  var cy = cos2(y5), k = cos2(x5) * cy;
  return [cy * sin2(x5) / k, sin2(y5) / k];
}
gnomonicRaw.invert = azimuthalInvert(atan);
function gnomonic_default() {
  return projection(gnomonicRaw).scale(144.049).clipAngle(60);
}

// node_modules/d3-geo/src/projection/identity.js
function identity_default5() {
  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca, sa2, x06 = null, y06, x12, y12, kx = 1, ky = 1, transform4 = transformer4({
    point: function(x5, y5) {
      var p = projection3([x5, y5]);
      this.stream.point(p[0], p[1]);
    }
  }), postclip = identity_default4, cache2, cacheStream;
  function reset3() {
    kx = k * sx;
    ky = k * sy;
    cache2 = cacheStream = null;
    return projection3;
  }
  function projection3(p) {
    var x5 = p[0] * kx, y5 = p[1] * ky;
    if (alpha) {
      var t = y5 * ca - x5 * sa2;
      x5 = x5 * ca + y5 * sa2;
      y5 = t;
    }
    return [x5 + tx, y5 + ty];
  }
  projection3.invert = function(p) {
    var x5 = p[0] - tx, y5 = p[1] - ty;
    if (alpha) {
      var t = y5 * ca + x5 * sa2;
      x5 = x5 * ca - y5 * sa2;
      y5 = t;
    }
    return [x5 / kx, y5 / ky];
  };
  projection3.stream = function(stream2) {
    return cache2 && cacheStream === stream2 ? cache2 : cache2 = transform4(postclip(cacheStream = stream2));
  };
  projection3.postclip = function(_) {
    return arguments.length ? (postclip = _, x06 = y06 = x12 = y12 = null, reset3()) : postclip;
  };
  projection3.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x06 = y06 = x12 = y12 = null, identity_default4) : clipRectangle(x06 = +_[0][0], y06 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset3()) : x06 == null ? null : [[x06, y06], [x12, y12]];
  };
  projection3.scale = function(_) {
    return arguments.length ? (k = +_, reset3()) : k;
  };
  projection3.translate = function(_) {
    return arguments.length ? (tx = +_[0], ty = +_[1], reset3()) : [tx, ty];
  };
  projection3.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * radians2, sa2 = sin2(alpha), ca = cos2(alpha), reset3()) : alpha * degrees3;
  };
  projection3.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, reset3()) : sx < 0;
  };
  projection3.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, reset3()) : sy < 0;
  };
  projection3.fitExtent = function(extent2, object2) {
    return fitExtent(projection3, extent2, object2);
  };
  projection3.fitSize = function(size, object2) {
    return fitSize(projection3, size, object2);
  };
  projection3.fitWidth = function(width2, object2) {
    return fitWidth(projection3, width2, object2);
  };
  projection3.fitHeight = function(height2, object2) {
    return fitHeight(projection3, height2, object2);
  };
  return projection3;
}

// node_modules/d3-geo/src/projection/naturalEarth1.js
function naturalEarth1Raw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
  return [
    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
  ];
}
naturalEarth1Raw.invert = function(x5, y5) {
  var phi2 = y5, i = 25, delta;
  do {
    var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
    phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y5) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
  } while (abs2(delta) > epsilon4 && --i > 0);
  return [
    x5 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
    phi2
  ];
};
function naturalEarth1_default() {
  return projection(naturalEarth1Raw).scale(175.295);
}

// node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x5, y5) {
  return [cos2(y5) * sin2(x5), sin2(y5)];
}
orthographicRaw.invert = azimuthalInvert(asin2);
function orthographic_default() {
  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon4);
}

// node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x5, y5) {
  var cy = cos2(y5), k = 1 + cos2(x5) * cy;
  return [cy * sin2(x5) / k, sin2(y5) / k];
}
stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});
function stereographic_default() {
  return projection(stereographicRaw).scale(250).clipAngle(142);
}

// node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi2) {
  return [log4(tan((halfPi2 + phi2) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x5, y5) {
  return [-y5, 2 * atan(exp3(x5)) - halfPi2];
};
function transverseMercator_default() {
  var m2 = mercatorProjection(transverseMercatorRaw), center = m2.center, rotate2 = m2.rotate;
  m2.center = function(_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };
  m2.rotate = function(_) {
    return arguments.length ? rotate2([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate2(), [_[0], _[1], _[2] - 90]);
  };
  return rotate2([0, 0, 90]).scale(159.155);
}

// node_modules/d3-geo-projection/src/math.js
var abs3 = Math.abs;
var cos3 = Math.cos;
var sin3 = Math.sin;
var epsilon5 = 1e-6;
var pi4 = Math.PI;
var halfPi3 = pi4 / 2;
var quarterPi2 = pi4 / 4;
var sqrt22 = sqrt4(2);
var sqrtPi = sqrt4(pi4);
var tau4 = pi4 * 2;
var degrees4 = 180 / pi4;
var radians3 = pi4 / 180;
function asin3(x5) {
  return x5 > 1 ? halfPi3 : x5 < -1 ? -halfPi3 : Math.asin(x5);
}
function sqrt4(x5) {
  return x5 > 0 ? Math.sqrt(x5) : 0;
}

// node_modules/d3-geo-projection/src/mollweide.js
function mollweideBromleyTheta(cp, phi2) {
  var cpsinPhi = cp * sin3(phi2), i = 30, delta;
  do
    phi2 -= delta = (phi2 + sin3(phi2) - cpsinPhi) / (1 + cos3(phi2));
  while (abs3(delta) > epsilon5 && --i > 0);
  return phi2 / 2;
}
function mollweideBromleyRaw(cx, cy, cp) {
  function forward(lambda, phi2) {
    return [cx * lambda * cos3(phi2 = mollweideBromleyTheta(cp, phi2)), cy * sin3(phi2)];
  }
  forward.invert = function(x5, y5) {
    return y5 = asin3(y5 / cy), [x5 / (cx * cos3(y5)), asin3((2 * y5 + sin3(2 * y5)) / cp)];
  };
  return forward;
}
var mollweideRaw = mollweideBromleyRaw(sqrt22 / halfPi3, sqrt22, pi4);
function mollweide_default() {
  return projection(mollweideRaw).scale(169.529);
}

// node_modules/vega-projection/build/vega-projection.module.js
var defaultPath = path_default2();
var projectionProperties = [
  "clipAngle",
  "clipExtent",
  "scale",
  "translate",
  "center",
  "rotate",
  "parallels",
  "precision",
  "reflectX",
  "reflectY",
  "coefficient",
  "distance",
  "fraction",
  "lobes",
  "parallel",
  "radius",
  "ratio",
  "spacing",
  "tilt"
];
function create2(type2, constructor) {
  return function projection3() {
    const p = constructor();
    p.type = type2;
    p.path = path_default2().projection(p);
    p.copy = p.copy || function() {
      const c2 = projection3();
      projectionProperties.forEach((prop) => {
        if (p[prop])
          c2[prop](p[prop]());
      });
      c2.path.pointRadius(p.path.pointRadius());
      return c2;
    };
    return p;
  };
}
function projection2(type2, proj) {
  if (!type2 || typeof type2 !== "string") {
    throw new Error("Projection type must be a name string.");
  }
  type2 = type2.toLowerCase();
  if (arguments.length > 1) {
    projections[type2] = create2(type2, proj);
    return this;
  } else {
    return projections[type2] || null;
  }
}
function getProjectionPath(proj) {
  return proj && proj.path || defaultPath;
}
var projections = {
  albers: albers_default,
  albersusa: albersUsa_default,
  azimuthalequalarea: azimuthalEqualArea_default,
  azimuthalequidistant: azimuthalEquidistant_default,
  conicconformal: conicConformal_default,
  conicequalarea: conicEqualArea_default,
  conicequidistant: conicEquidistant_default,
  equalEarth: equalEarth_default,
  equirectangular: equirectangular_default,
  gnomonic: gnomonic_default,
  identity: identity_default5,
  mercator: mercator_default,
  mollweide: mollweide_default,
  naturalEarth1: naturalEarth1_default,
  orthographic: orthographic_default,
  stereographic: stereographic_default,
  transversemercator: transverseMercator_default
};
for (const key2 in projections) {
  projection2(key2, projections[key2]);
}

// node_modules/vega-geo/build/vega-geo.module.js
function noop3() {
}
var cases = [[], [[[1, 1.5], [0.5, 1]]], [[[1.5, 1], [1, 1.5]]], [[[1.5, 1], [0.5, 1]]], [[[1, 0.5], [1.5, 1]]], [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]], [[[1, 0.5], [1, 1.5]]], [[[1, 0.5], [0.5, 1]]], [[[0.5, 1], [1, 0.5]]], [[[1, 1.5], [1, 0.5]]], [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]], [[[1.5, 1], [1, 0.5]]], [[[0.5, 1], [1.5, 1]]], [[[1, 1.5], [1.5, 1]]], [[[0.5, 1], [1, 1.5]]], []];
function contours() {
  var dx = 1, dy = 1, smooth = smoothLinear;
  function contours2(values4, tz) {
    return tz.map((value3) => contour(values4, value3));
  }
  function contour(values4, value3) {
    var polygons = [], holes = [];
    isorings(values4, value3, (ring) => {
      smooth(ring, values4, value3);
      if (area2(ring) > 0)
        polygons.push([ring]);
      else
        holes.push(ring);
    });
    holes.forEach((hole) => {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (contains((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });
    return {
      type: "MultiPolygon",
      value: value3,
      coordinates: polygons
    };
  }
  function isorings(values4, value3, callback) {
    var fragmentByStart = new Array(), fragmentByEnd = new Array(), x5, y5, t04, t13, t22, t32;
    x5 = y5 = -1;
    t13 = values4[0] >= value3;
    cases[t13 << 1].forEach(stitch);
    while (++x5 < dx - 1) {
      t04 = t13, t13 = values4[x5 + 1] >= value3;
      cases[t04 | t13 << 1].forEach(stitch);
    }
    cases[t13 << 0].forEach(stitch);
    while (++y5 < dy - 1) {
      x5 = -1;
      t13 = values4[y5 * dx + dx] >= value3;
      t22 = values4[y5 * dx] >= value3;
      cases[t13 << 1 | t22 << 2].forEach(stitch);
      while (++x5 < dx - 1) {
        t04 = t13, t13 = values4[y5 * dx + dx + x5 + 1] >= value3;
        t32 = t22, t22 = values4[y5 * dx + x5 + 1] >= value3;
        cases[t04 | t13 << 1 | t22 << 2 | t32 << 3].forEach(stitch);
      }
      cases[t13 | t22 << 3].forEach(stitch);
    }
    x5 = -1;
    t22 = values4[y5 * dx] >= value3;
    cases[t22 << 2].forEach(stitch);
    while (++x5 < dx - 1) {
      t32 = t22, t22 = values4[y5 * dx + x5 + 1] >= value3;
      cases[t22 << 2 | t32 << 3].forEach(stitch);
    }
    cases[t22 << 3].forEach(stitch);
    function stitch(line4) {
      var start = [line4[0][0] + x5, line4[0][1] + y5], end = [line4[1][0] + x5, line4[1][1] + y5], startIndex = index4(start), endIndex = index4(end), f, g;
      if (f = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f.end];
          delete fragmentByStart[g.start];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[f.start] = fragmentByEnd[g.end] = {
              start: f.start,
              end: g.end,
              ring: f.ring.concat(g.ring)
            };
          }
        } else {
          delete fragmentByEnd[f.end];
          f.ring.push(end);
          fragmentByEnd[f.end = endIndex] = f;
        }
      } else if (f = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f.start];
          delete fragmentByEnd[g.end];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f.end] = {
              start: g.start,
              end: f.end,
              ring: g.ring.concat(f.ring)
            };
          }
        } else {
          delete fragmentByStart[f.start];
          f.ring.unshift(start);
          fragmentByStart[f.start = startIndex] = f;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {
          start: startIndex,
          end: endIndex,
          ring: [start, end]
        };
      }
    }
  }
  function index4(point8) {
    return point8[0] * 2 + point8[1] * (dx + 1) * 4;
  }
  function smoothLinear(ring, values4, value3) {
    ring.forEach((point8) => {
      var x5 = point8[0], y5 = point8[1], xt = x5 | 0, yt = y5 | 0, v0, v1 = values4[yt * dx + xt];
      if (x5 > 0 && x5 < dx && xt === x5) {
        v0 = values4[yt * dx + xt - 1];
        point8[0] = x5 + (value3 - v0) / (v1 - v0) - 0.5;
      }
      if (y5 > 0 && y5 < dy && yt === y5) {
        v0 = values4[(yt - 1) * dx + xt];
        point8[1] = y5 + (value3 - v0) / (v1 - v0) - 0.5;
      }
    });
  }
  contours2.contour = contour;
  contours2.size = function(_) {
    if (!arguments.length)
      return [dx, dy];
    var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);
    if (!(_0 >= 0 && _1 >= 0))
      error("invalid size");
    return dx = _0, dy = _1, contours2;
  };
  contours2.smooth = function(_) {
    return arguments.length ? (smooth = _ ? smoothLinear : noop3, contours2) : smooth === smoothLinear;
  };
  return contours2;
}
function area2(ring) {
  var i = 0, n = ring.length, area4 = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
  while (++i < n)
    area4 += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  return area4;
}
function contains(ring, hole) {
  var i = -1, n = hole.length, c2;
  while (++i < n)
    if (c2 = ringContains(ring, hole[i]))
      return c2;
  return 0;
}
function ringContains(ring, point8) {
  var x5 = point8[0], y5 = point8[1], contains3 = -1;
  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi5 = ring[i], xi = pi5[0], yi = pi5[1], pj = ring[j], xj = pj[0], yj = pj[1];
    if (segmentContains(pi5, pj, point8))
      return 0;
    if (yi > y5 !== yj > y5 && x5 < (xj - xi) * (y5 - yi) / (yj - yi) + xi)
      contains3 = -contains3;
  }
  return contains3;
}
function segmentContains(a2, b2, c2) {
  var i;
  return collinear(a2, b2, c2) && within(a2[i = +(a2[0] === b2[0])], c2[i], b2[i]);
}
function collinear(a2, b2, c2) {
  return (b2[0] - a2[0]) * (c2[1] - a2[1]) === (c2[0] - a2[0]) * (b2[1] - a2[1]);
}
function within(p, q, r2) {
  return p <= q && q <= r2 || r2 <= q && q <= p;
}
function quantize2(k, nice3, zero7) {
  return function(values4) {
    var ex = extent(values4), start = zero7 ? Math.min(ex[0], 0) : ex[0], stop2 = ex[1], span2 = stop2 - start, step = nice3 ? tickStep(start, stop2, k) : span2 / (k + 1);
    return range_default(start + step, stop2, step);
  };
}
function Isocontour(params2) {
  Transform.call(this, null, params2);
}
Isocontour.Definition = {
  type: "Isocontour",
  metadata: {
    generates: true
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "thresholds",
    type: "number",
    array: true
  }, {
    name: "levels",
    type: "number"
  }, {
    name: "nice",
    type: "boolean",
    default: false
  }, {
    name: "resolve",
    type: "enum",
    values: ["shared", "independent"],
    default: "independent"
  }, {
    name: "zero",
    type: "boolean",
    default: true
  }, {
    name: "smooth",
    type: "boolean",
    default: true
  }, {
    name: "scale",
    type: "number",
    expr: true
  }, {
    name: "translate",
    type: "number",
    array: true,
    expr: true
  }, {
    name: "as",
    type: "string",
    null: true,
    default: "contour"
  }]
};
inherits(Isocontour, Transform, {
  transform(_, pulse2) {
    if (this.value && !pulse2.changed() && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), source4 = pulse2.materialize(pulse2.SOURCE).source, field4 = _.field || identity, contour = contours().smooth(_.smooth !== false), tz = _.thresholds || levels(source4, field4, _), as = _.as === null ? null : _.as || "contour", values4 = [];
    source4.forEach((t) => {
      const grid = field4(t);
      const paths = contour.size([grid.width, grid.height])(grid.values, isArray(tz) ? tz : tz(grid.values));
      transformPaths(paths, grid, t, _);
      paths.forEach((p) => {
        values4.push(rederive(t, ingest(as != null ? {
          [as]: p
        } : p)));
      });
    });
    if (this.value)
      out.rem = this.value;
    this.value = out.source = out.add = values4;
    return out;
  }
});
function levels(values4, f, _) {
  const q = quantize2(_.levels || 10, _.nice, _.zero !== false);
  return _.resolve !== "shared" ? q : q(values4.map((t) => max(f(t).values)));
}
function transformPaths(paths, grid, datum3, _) {
  let s = _.scale || grid.scale, t = _.translate || grid.translate;
  if (isFunction(s))
    s = s(datum3, _);
  if (isFunction(t))
    t = t(datum3, _);
  if ((s === 1 || s == null) && !t)
    return;
  const sx = (isNumber(s) ? s : s[0]) || 1, sy = (isNumber(s) ? s : s[1]) || 1, tx = t && t[0] || 0, ty = t && t[1] || 0;
  paths.forEach(transform2(grid, sx, sy, tx, ty));
}
function transform2(grid, sx, sy, tx, ty) {
  const x12 = grid.x1 || 0, y12 = grid.y1 || 0, flip2 = sx * sy < 0;
  function transformPolygon(coordinates) {
    coordinates.forEach(transformRing);
  }
  function transformRing(coordinates) {
    if (flip2)
      coordinates.reverse();
    coordinates.forEach(transformPoint);
  }
  function transformPoint(coordinates) {
    coordinates[0] = (coordinates[0] - x12) * sx + tx;
    coordinates[1] = (coordinates[1] - y12) * sy + ty;
  }
  return function(geometry) {
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  };
}
function radius(bw, data4, f) {
  const v = bw >= 0 ? bw : estimateBandwidth(data4, f);
  return Math.round((Math.sqrt(4 * v * v + 1) - 1) / 2);
}
function number4(_) {
  return isFunction(_) ? _ : constant(+_);
}
function density2D() {
  var x5 = (d) => d[0], y5 = (d) => d[1], weight = one, bandwidth3 = [-1, -1], dx = 960, dy = 500, k = 2;
  function density(data4, counts) {
    const rx = radius(bandwidth3[0], data4, x5) >> k, ry = radius(bandwidth3[1], data4, y5) >> k, ox = rx ? rx + 2 : 0, oy = ry ? ry + 2 : 0, n = 2 * ox + (dx >> k), m2 = 2 * oy + (dy >> k), values0 = new Float32Array(n * m2), values1 = new Float32Array(n * m2);
    let values4 = values0;
    data4.forEach((d) => {
      const xi = ox + (+x5(d) >> k), yi = oy + (+y5(d) >> k);
      if (xi >= 0 && xi < n && yi >= 0 && yi < m2) {
        values0[xi + yi * n] += +weight(d);
      }
    });
    if (rx > 0 && ry > 0) {
      blurX(n, m2, values0, values1, rx);
      blurY(n, m2, values1, values0, ry);
      blurX(n, m2, values0, values1, rx);
      blurY(n, m2, values1, values0, ry);
      blurX(n, m2, values0, values1, rx);
      blurY(n, m2, values1, values0, ry);
    } else if (rx > 0) {
      blurX(n, m2, values0, values1, rx);
      blurX(n, m2, values1, values0, rx);
      blurX(n, m2, values0, values1, rx);
      values4 = values1;
    } else if (ry > 0) {
      blurY(n, m2, values0, values1, ry);
      blurY(n, m2, values1, values0, ry);
      blurY(n, m2, values0, values1, ry);
      values4 = values1;
    }
    const s = counts ? Math.pow(2, -2 * k) : 1 / sum(values4);
    for (let i = 0, sz2 = n * m2; i < sz2; ++i)
      values4[i] *= s;
    return {
      values: values4,
      scale: 1 << k,
      width: n,
      height: m2,
      x1: ox,
      y1: oy,
      x2: ox + (dx >> k),
      y2: oy + (dy >> k)
    };
  }
  density.x = function(_) {
    return arguments.length ? (x5 = number4(_), density) : x5;
  };
  density.y = function(_) {
    return arguments.length ? (y5 = number4(_), density) : y5;
  };
  density.weight = function(_) {
    return arguments.length ? (weight = number4(_), density) : weight;
  };
  density.size = function(_) {
    if (!arguments.length)
      return [dx, dy];
    var _0 = +_[0], _1 = +_[1];
    if (!(_0 >= 0 && _1 >= 0))
      error("invalid size");
    return dx = _0, dy = _1, density;
  };
  density.cellSize = function(_) {
    if (!arguments.length)
      return 1 << k;
    if (!((_ = +_) >= 1))
      error("invalid cell size");
    k = Math.floor(Math.log(_) / Math.LN2);
    return density;
  };
  density.bandwidth = function(_) {
    if (!arguments.length)
      return bandwidth3;
    _ = array(_);
    if (_.length === 1)
      _ = [+_[0], +_[0]];
    if (_.length !== 2)
      error("invalid bandwidth");
    return bandwidth3 = _, density;
  };
  return density;
}
function blurX(n, m2, source4, target, r2) {
  const w3 = (r2 << 1) + 1;
  for (let j = 0; j < m2; ++j) {
    for (let i = 0, sr = 0; i < n + r2; ++i) {
      if (i < n) {
        sr += source4[i + j * n];
      }
      if (i >= r2) {
        if (i >= w3) {
          sr -= source4[i - w3 + j * n];
        }
        target[i - r2 + j * n] = sr / Math.min(i + 1, n - 1 + w3 - i, w3);
      }
    }
  }
}
function blurY(n, m2, source4, target, r2) {
  const w3 = (r2 << 1) + 1;
  for (let i = 0; i < n; ++i) {
    for (let j = 0, sr = 0; j < m2 + r2; ++j) {
      if (j < m2) {
        sr += source4[i + j * n];
      }
      if (j >= r2) {
        if (j >= w3) {
          sr -= source4[i + (j - w3) * n];
        }
        target[i + (j - r2) * n] = sr / Math.min(j + 1, m2 - 1 + w3 - j, w3);
      }
    }
  }
}
function KDE2D(params2) {
  Transform.call(this, null, params2);
}
KDE2D.Definition = {
  type: "KDE2D",
  metadata: {
    generates: true
  },
  params: [{
    name: "size",
    type: "number",
    array: true,
    length: 2,
    required: true
  }, {
    name: "x",
    type: "field",
    required: true
  }, {
    name: "y",
    type: "field",
    required: true
  }, {
    name: "weight",
    type: "field"
  }, {
    name: "groupby",
    type: "field",
    array: true
  }, {
    name: "cellSize",
    type: "number"
  }, {
    name: "bandwidth",
    type: "number",
    array: true,
    length: 2
  }, {
    name: "counts",
    type: "boolean",
    default: false
  }, {
    name: "as",
    type: "string",
    default: "grid"
  }]
};
var PARAMS = ["x", "y", "weight", "size", "cellSize", "bandwidth"];
function params(obj, _) {
  PARAMS.forEach((param2) => _[param2] != null ? obj[param2](_[param2]) : 0);
  return obj;
}
inherits(KDE2D, Transform, {
  transform(_, pulse2) {
    if (this.value && !pulse2.changed() && !_.modified())
      return pulse2.StopPropagation;
    var out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), source4 = pulse2.materialize(pulse2.SOURCE).source, groups = partition3(source4, _.groupby), names = (_.groupby || []).map(accessorName), kde2 = params(density2D(), _), as = _.as || "grid", values4 = [];
    function set6(t, vals2) {
      for (let i = 0; i < names.length; ++i)
        t[names[i]] = vals2[i];
      return t;
    }
    values4 = groups.map((g) => ingest(set6({
      [as]: kde2(g, _.counts)
    }, g.dims)));
    if (this.value)
      out.rem = this.value;
    this.value = out.source = out.add = values4;
    return out;
  }
});
function partition3(data4, groupby) {
  var groups = [], get6 = (f) => f(t), map4, i, n, t, k, g;
  if (groupby == null) {
    groups.push(data4);
  } else {
    for (map4 = {}, i = 0, n = data4.length; i < n; ++i) {
      t = data4[i];
      k = groupby.map(get6);
      g = map4[k];
      if (!g) {
        map4[k] = g = [];
        g.dims = k;
        groups.push(g);
      }
      g.push(t);
    }
  }
  return groups;
}
function Contour(params2) {
  Transform.call(this, null, params2);
}
Contour.Definition = {
  type: "Contour",
  metadata: {
    generates: true
  },
  params: [{
    name: "size",
    type: "number",
    array: true,
    length: 2,
    required: true
  }, {
    name: "values",
    type: "number",
    array: true
  }, {
    name: "x",
    type: "field"
  }, {
    name: "y",
    type: "field"
  }, {
    name: "weight",
    type: "field"
  }, {
    name: "cellSize",
    type: "number"
  }, {
    name: "bandwidth",
    type: "number"
  }, {
    name: "count",
    type: "number"
  }, {
    name: "nice",
    type: "boolean",
    default: false
  }, {
    name: "thresholds",
    type: "number",
    array: true
  }, {
    name: "smooth",
    type: "boolean",
    default: true
  }]
};
inherits(Contour, Transform, {
  transform(_, pulse2) {
    if (this.value && !pulse2.changed() && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), contour = contours().smooth(_.smooth !== false), values4 = _.values, thresh = _.thresholds || quantize2(_.count || 10, _.nice, !!values4), size = _.size, grid, post;
    if (!values4) {
      values4 = pulse2.materialize(pulse2.SOURCE).source;
      grid = params(density2D(), _)(values4, true);
      post = transform2(grid, grid.scale || 1, grid.scale || 1, 0, 0);
      size = [grid.width, grid.height];
      values4 = grid.values;
    }
    thresh = isArray(thresh) ? thresh : thresh(values4);
    values4 = contour.size(size)(values4, thresh);
    if (post)
      values4.forEach(post);
    if (this.value)
      out.rem = this.value;
    this.value = out.source = out.add = (values4 || []).map(ingest);
    return out;
  }
});
var Feature = "Feature";
var FeatureCollection = "FeatureCollection";
var MultiPoint = "MultiPoint";
function GeoJSON(params2) {
  Transform.call(this, null, params2);
}
GeoJSON.Definition = {
  type: "GeoJSON",
  metadata: {},
  params: [{
    name: "fields",
    type: "field",
    array: true,
    length: 2
  }, {
    name: "geojson",
    type: "field"
  }]
};
inherits(GeoJSON, Transform, {
  transform(_, pulse2) {
    var features = this._features, points2 = this._points, fields = _.fields, lon = fields && fields[0], lat = fields && fields[1], geojson = _.geojson || !fields && identity, flag2 = pulse2.ADD, mod;
    mod = _.modified() || pulse2.changed(pulse2.REM) || pulse2.modified(accessorFields(geojson)) || lon && pulse2.modified(accessorFields(lon)) || lat && pulse2.modified(accessorFields(lat));
    if (!this.value || mod) {
      flag2 = pulse2.SOURCE;
      this._features = features = [];
      this._points = points2 = [];
    }
    if (geojson) {
      pulse2.visit(flag2, (t) => features.push(geojson(t)));
    }
    if (lon && lat) {
      pulse2.visit(flag2, (t) => {
        var x5 = lon(t), y5 = lat(t);
        if (x5 != null && y5 != null && (x5 = +x5) === x5 && (y5 = +y5) === y5) {
          points2.push([x5, y5]);
        }
      });
      features = features.concat({
        type: Feature,
        geometry: {
          type: MultiPoint,
          coordinates: points2
        }
      });
    }
    this.value = {
      type: FeatureCollection,
      features
    };
  }
});
function GeoPath(params2) {
  Transform.call(this, null, params2);
}
GeoPath.Definition = {
  type: "GeoPath",
  metadata: {
    modifies: true
  },
  params: [{
    name: "projection",
    type: "projection"
  }, {
    name: "field",
    type: "field"
  }, {
    name: "pointRadius",
    type: "number",
    expr: true
  }, {
    name: "as",
    type: "string",
    default: "path"
  }]
};
inherits(GeoPath, Transform, {
  transform(_, pulse2) {
    var out = pulse2.fork(pulse2.ALL), path3 = this.value, field4 = _.field || identity, as = _.as || "path", flag2 = out.SOURCE;
    if (!path3 || _.modified()) {
      this.value = path3 = getProjectionPath(_.projection);
      out.materialize().reflow();
    } else {
      flag2 = field4 === identity || pulse2.modified(field4.fields) ? out.ADD_MOD : out.ADD;
    }
    const prev = initPath(path3, _.pointRadius);
    out.visit(flag2, (t) => t[as] = path3(field4(t)));
    path3.pointRadius(prev);
    return out.modifies(as);
  }
});
function initPath(path3, pointRadius) {
  const prev = path3.pointRadius();
  path3.context(null);
  if (pointRadius != null) {
    path3.pointRadius(pointRadius);
  }
  return prev;
}
function GeoPoint(params2) {
  Transform.call(this, null, params2);
}
GeoPoint.Definition = {
  type: "GeoPoint",
  metadata: {
    modifies: true
  },
  params: [{
    name: "projection",
    type: "projection",
    required: true
  }, {
    name: "fields",
    type: "field",
    array: true,
    required: true,
    length: 2
  }, {
    name: "as",
    type: "string",
    array: true,
    length: 2,
    default: ["x", "y"]
  }]
};
inherits(GeoPoint, Transform, {
  transform(_, pulse2) {
    var proj = _.projection, lon = _.fields[0], lat = _.fields[1], as = _.as || ["x", "y"], x5 = as[0], y5 = as[1], mod;
    function set6(t) {
      const xy = proj([lon(t), lat(t)]);
      if (xy) {
        t[x5] = xy[0];
        t[y5] = xy[1];
      } else {
        t[x5] = void 0;
        t[y5] = void 0;
      }
    }
    if (_.modified()) {
      pulse2 = pulse2.materialize().reflow(true).visit(pulse2.SOURCE, set6);
    } else {
      mod = pulse2.modified(lon.fields) || pulse2.modified(lat.fields);
      pulse2.visit(mod ? pulse2.ADD_MOD : pulse2.ADD, set6);
    }
    return pulse2.modifies(as);
  }
});
function GeoShape(params2) {
  Transform.call(this, null, params2);
}
GeoShape.Definition = {
  type: "GeoShape",
  metadata: {
    modifies: true,
    nomod: true
  },
  params: [{
    name: "projection",
    type: "projection"
  }, {
    name: "field",
    type: "field",
    default: "datum"
  }, {
    name: "pointRadius",
    type: "number",
    expr: true
  }, {
    name: "as",
    type: "string",
    default: "shape"
  }]
};
inherits(GeoShape, Transform, {
  transform(_, pulse2) {
    var out = pulse2.fork(pulse2.ALL), shape2 = this.value, as = _.as || "shape", flag2 = out.ADD;
    if (!shape2 || _.modified()) {
      this.value = shape2 = shapeGenerator(getProjectionPath(_.projection), _.field || field("datum"), _.pointRadius);
      out.materialize().reflow();
      flag2 = out.SOURCE;
    }
    out.visit(flag2, (t) => t[as] = shape2);
    return out.modifies(as);
  }
});
function shapeGenerator(path3, field4, pointRadius) {
  const shape2 = pointRadius == null ? (_) => path3(field4(_)) : (_) => {
    var prev = path3.pointRadius(), value3 = path3.pointRadius(pointRadius)(field4(_));
    path3.pointRadius(prev);
    return value3;
  };
  shape2.context = (_) => {
    path3.context(_);
    return shape2;
  };
  return shape2;
}
function Graticule(params2) {
  Transform.call(this, [], params2);
  this.generator = graticule();
}
Graticule.Definition = {
  type: "Graticule",
  metadata: {
    changes: true,
    generates: true
  },
  params: [{
    name: "extent",
    type: "array",
    array: true,
    length: 2,
    content: {
      type: "number",
      array: true,
      length: 2
    }
  }, {
    name: "extentMajor",
    type: "array",
    array: true,
    length: 2,
    content: {
      type: "number",
      array: true,
      length: 2
    }
  }, {
    name: "extentMinor",
    type: "array",
    array: true,
    length: 2,
    content: {
      type: "number",
      array: true,
      length: 2
    }
  }, {
    name: "step",
    type: "number",
    array: true,
    length: 2
  }, {
    name: "stepMajor",
    type: "number",
    array: true,
    length: 2,
    default: [90, 360]
  }, {
    name: "stepMinor",
    type: "number",
    array: true,
    length: 2,
    default: [10, 10]
  }, {
    name: "precision",
    type: "number",
    default: 2.5
  }]
};
inherits(Graticule, Transform, {
  transform(_, pulse2) {
    var src = this.value, gen = this.generator, t;
    if (!src.length || _.modified()) {
      for (const prop in _) {
        if (isFunction(gen[prop])) {
          gen[prop](_[prop]);
        }
      }
    }
    t = gen();
    if (src.length) {
      pulse2.mod.push(replace(src[0], t));
    } else {
      pulse2.add.push(ingest(t));
    }
    src[0] = t;
    return pulse2;
  }
});
function Heatmap(params2) {
  Transform.call(this, null, params2);
}
Heatmap.Definition = {
  type: "heatmap",
  metadata: {
    modifies: true
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "color",
    type: "string",
    expr: true
  }, {
    name: "opacity",
    type: "number",
    expr: true
  }, {
    name: "resolve",
    type: "enum",
    values: ["shared", "independent"],
    default: "independent"
  }, {
    name: "as",
    type: "string",
    default: "image"
  }]
};
inherits(Heatmap, Transform, {
  transform(_, pulse2) {
    if (!pulse2.changed() && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var source4 = pulse2.materialize(pulse2.SOURCE).source, shared = _.resolve === "shared", field4 = _.field || identity, opacity2 = opacity_(_.opacity, _), color5 = color_(_.color, _), as = _.as || "image", obj = {
      $x: 0,
      $y: 0,
      $value: 0,
      $max: shared ? max(source4.map((t) => max(field4(t).values))) : 0
    };
    source4.forEach((t) => {
      const v = field4(t);
      const o = extend({}, t, obj);
      if (!shared)
        o.$max = max(v.values || []);
      t[as] = toCanvas(v, o, color5.dep ? color5 : constant(color5(o)), opacity2.dep ? opacity2 : constant(opacity2(o)));
    });
    return pulse2.reflow(true).modifies(as);
  }
});
function color_(color5, _) {
  let f;
  if (isFunction(color5)) {
    f = (obj) => rgb(color5(obj, _));
    f.dep = dependency(color5);
  } else {
    f = constant(rgb(color5 || "#888"));
  }
  return f;
}
function opacity_(opacity2, _) {
  let f;
  if (isFunction(opacity2)) {
    f = (obj) => opacity2(obj, _);
    f.dep = dependency(opacity2);
  } else if (opacity2) {
    f = constant(opacity2);
  } else {
    f = (obj) => obj.$value / obj.$max || 0;
    f.dep = true;
  }
  return f;
}
function dependency(f) {
  if (!isFunction(f))
    return false;
  const set6 = toSet(accessorFields(f));
  return set6.$x || set6.$y || set6.$value || set6.$max;
}
function toCanvas(grid, obj, color5, opacity2) {
  const n = grid.width, m2 = grid.height, x12 = grid.x1 || 0, y12 = grid.y1 || 0, x22 = grid.x2 || n, y22 = grid.y2 || m2, val = grid.values, value3 = val ? (i) => val[i] : zero, can = domCanvas(x22 - x12, y22 - y12), ctx = can.getContext("2d"), img = ctx.getImageData(0, 0, x22 - x12, y22 - y12), pix = img.data;
  for (let j = y12, k = 0; j < y22; ++j) {
    obj.$y = j - y12;
    for (let i = x12, r2 = j * n; i < x22; ++i, k += 4) {
      obj.$x = i - x12;
      obj.$value = value3(i + r2);
      const v = color5(obj);
      pix[k + 0] = v.r;
      pix[k + 1] = v.g;
      pix[k + 2] = v.b;
      pix[k + 3] = ~~(255 * opacity2(obj));
    }
  }
  ctx.putImageData(img, 0, 0);
  return can;
}
function Projection(params2) {
  Transform.call(this, null, params2);
  this.modified(true);
}
inherits(Projection, Transform, {
  transform(_, pulse2) {
    let proj = this.value;
    if (!proj || _.modified("type")) {
      this.value = proj = create3(_.type);
      projectionProperties.forEach((prop) => {
        if (_[prop] != null)
          set3(proj, prop, _[prop]);
      });
    } else {
      projectionProperties.forEach((prop) => {
        if (_.modified(prop))
          set3(proj, prop, _[prop]);
      });
    }
    if (_.pointRadius != null)
      proj.path.pointRadius(_.pointRadius);
    if (_.fit)
      fit2(proj, _);
    return pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
  }
});
function fit2(proj, _) {
  const data4 = collectGeoJSON(_.fit);
  _.extent ? proj.fitExtent(_.extent, data4) : _.size ? proj.fitSize(_.size, data4) : 0;
}
function create3(type2) {
  const constructor = projection2((type2 || "mercator").toLowerCase());
  if (!constructor)
    error("Unrecognized projection type: " + type2);
  return constructor();
}
function set3(proj, key2, value3) {
  if (isFunction(proj[key2]))
    proj[key2](value3);
}
function collectGeoJSON(data4) {
  data4 = array(data4);
  return data4.length === 1 ? data4[0] : {
    type: FeatureCollection,
    features: data4.reduce((a2, f) => a2.concat(featurize(f)), [])
  };
}
function featurize(f) {
  return f.type === FeatureCollection ? f.features : array(f).filter((d) => d != null).map((d) => d.type === Feature ? d : {
    type: Feature,
    geometry: d
  });
}

// node_modules/vega-force/build/vega-force.module.js
var vega_force_module_exports = {};
__export(vega_force_module_exports, {
  force: () => Force
});

// node_modules/d3-force/src/center.js
function center_default(x5, y5) {
  var nodes, strength = 1;
  if (x5 == null)
    x5 = 0;
  if (y5 == null)
    y5 = 0;
  function force() {
    var i, n = nodes.length, node, sx = 0, sy = 0;
    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }
    for (sx = (sx / n - x5) * strength, sy = (sy / n - y5) * strength, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }
  force.initialize = function(_) {
    nodes = _;
  };
  force.x = function(_) {
    return arguments.length ? (x5 = +_, force) : x5;
  };
  force.y = function(_) {
    return arguments.length ? (y5 = +_, force) : y5;
  };
  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };
  return force;
}

// node_modules/d3-quadtree/src/add.js
function add_default(d) {
  const x5 = +this._x.call(null, d), y5 = +this._y.call(null, d);
  return add4(this.cover(x5, y5), x5, y5, d);
}
function add4(tree, x5, y5, d) {
  if (isNaN(x5) || isNaN(y5))
    return tree;
  var parent, node = tree._root, leaf = {data: d}, x06 = tree._x0, y06 = tree._y0, x12 = tree._x1, y12 = tree._y1, xm, ym, xp, yp, right, bottom, i, j;
  if (!node)
    return tree._root = leaf, tree;
  while (node.length) {
    if (right = x5 >= (xm = (x06 + x12) / 2))
      x06 = xm;
    else
      x12 = xm;
    if (bottom = y5 >= (ym = (y06 + y12) / 2))
      y06 = ym;
    else
      y12 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right]))
      return parent[i] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x5 === xp && y5 === yp)
    return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x5 >= (xm = (x06 + x12) / 2))
      x06 = xm;
    else
      x12 = xm;
    if (bottom = y5 >= (ym = (y06 + y12) / 2))
      y06 = ym;
    else
      y12 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));
  return parent[j] = node, parent[i] = leaf, tree;
}
function addAll(data4) {
  var d, i, n = data4.length, x5, y5, xz = new Array(n), yz = new Array(n), x06 = Infinity, y06 = Infinity, x12 = -Infinity, y12 = -Infinity;
  for (i = 0; i < n; ++i) {
    if (isNaN(x5 = +this._x.call(null, d = data4[i])) || isNaN(y5 = +this._y.call(null, d)))
      continue;
    xz[i] = x5;
    yz[i] = y5;
    if (x5 < x06)
      x06 = x5;
    if (x5 > x12)
      x12 = x5;
    if (y5 < y06)
      y06 = y5;
    if (y5 > y12)
      y12 = y5;
  }
  if (x06 > x12 || y06 > y12)
    return this;
  this.cover(x06, y06).cover(x12, y12);
  for (i = 0; i < n; ++i) {
    add4(this, xz[i], yz[i], data4[i]);
  }
  return this;
}

// node_modules/d3-quadtree/src/cover.js
function cover_default(x5, y5) {
  if (isNaN(x5 = +x5) || isNaN(y5 = +y5))
    return this;
  var x06 = this._x0, y06 = this._y0, x12 = this._x1, y12 = this._y1;
  if (isNaN(x06)) {
    x12 = (x06 = Math.floor(x5)) + 1;
    y12 = (y06 = Math.floor(y5)) + 1;
  } else {
    var z = x12 - x06 || 1, node = this._root, parent, i;
    while (x06 > x5 || x5 >= x12 || y06 > y5 || y5 >= y12) {
      i = (y5 < y06) << 1 | x5 < x06;
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0:
          x12 = x06 + z, y12 = y06 + z;
          break;
        case 1:
          x06 = x12 - z, y12 = y06 + z;
          break;
        case 2:
          x12 = x06 + z, y06 = y12 - z;
          break;
        case 3:
          x06 = x12 - z, y06 = y12 - z;
          break;
      }
    }
    if (this._root && this._root.length)
      this._root = node;
  }
  this._x0 = x06;
  this._y0 = y06;
  this._x1 = x12;
  this._y1 = y12;
  return this;
}

// node_modules/d3-quadtree/src/data.js
function data_default() {
  var data4 = [];
  this.visit(function(node) {
    if (!node.length)
      do
        data4.push(node.data);
      while (node = node.next);
  });
  return data4;
}

// node_modules/d3-quadtree/src/extent.js
function extent_default(_) {
  return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}

// node_modules/d3-quadtree/src/quad.js
function quad_default(node, x06, y06, x12, y12) {
  this.node = node;
  this.x0 = x06;
  this.y0 = y06;
  this.x1 = x12;
  this.y1 = y12;
}

// node_modules/d3-quadtree/src/find.js
function find_default(x5, y5, radius2) {
  var data4, x06 = this._x0, y06 = this._y0, x12, y12, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q, i;
  if (node)
    quads.push(new quad_default(node, x06, y06, x32, y32));
  if (radius2 == null)
    radius2 = Infinity;
  else {
    x06 = x5 - radius2, y06 = y5 - radius2;
    x32 = x5 + radius2, y32 = y5 + radius2;
    radius2 *= radius2;
  }
  while (q = quads.pop()) {
    if (!(node = q.node) || (x12 = q.x0) > x32 || (y12 = q.y0) > y32 || (x22 = q.x1) < x06 || (y22 = q.y1) < y06)
      continue;
    if (node.length) {
      var xm = (x12 + x22) / 2, ym = (y12 + y22) / 2;
      quads.push(new quad_default(node[3], xm, ym, x22, y22), new quad_default(node[2], x12, ym, xm, y22), new quad_default(node[1], xm, y12, x22, ym), new quad_default(node[0], x12, y12, xm, ym));
      if (i = (y5 >= ym) << 1 | x5 >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    } else {
      var dx = x5 - +this._x.call(null, node.data), dy = y5 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
      if (d2 < radius2) {
        var d = Math.sqrt(radius2 = d2);
        x06 = x5 - d, y06 = y5 - d;
        x32 = x5 + d, y32 = y5 + d;
        data4 = node.data;
      }
    }
  }
  return data4;
}

// node_modules/d3-quadtree/src/remove.js
function remove_default(d) {
  if (isNaN(x5 = +this._x.call(null, d)) || isNaN(y5 = +this._y.call(null, d)))
    return this;
  var parent, node = this._root, retainer, previous, next, x06 = this._x0, y06 = this._y0, x12 = this._x1, y12 = this._y1, x5, y5, xm, ym, right, bottom, i, j;
  if (!node)
    return this;
  if (node.length)
    while (true) {
      if (right = x5 >= (xm = (x06 + x12) / 2))
        x06 = xm;
      else
        x12 = xm;
      if (bottom = y5 >= (ym = (y06 + y12) / 2))
        y06 = ym;
      else
        y12 = ym;
      if (!(parent = node, node = node[i = bottom << 1 | right]))
        return this;
      if (!node.length)
        break;
      if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3])
        retainer = parent, j = i;
    }
  while (node.data !== d)
    if (!(previous = node, node = node.next))
      return this;
  if (next = node.next)
    delete node.next;
  if (previous)
    return next ? previous.next = next : delete previous.next, this;
  if (!parent)
    return this._root = next, this;
  next ? parent[i] = next : delete parent[i];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer)
      retainer[j] = node;
    else
      this._root = node;
  }
  return this;
}
function removeAll(data4) {
  for (var i = 0, n = data4.length; i < n; ++i)
    this.remove(data4[i]);
  return this;
}

// node_modules/d3-quadtree/src/root.js
function root_default() {
  return this._root;
}

// node_modules/d3-quadtree/src/size.js
function size_default() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length)
      do
        ++size;
      while (node = node.next);
  });
  return size;
}

// node_modules/d3-quadtree/src/visit.js
function visit_default(callback) {
  var quads = [], q, node = this._root, child, x06, y06, x12, y12;
  if (node)
    quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x06 = q.x0, y06 = q.y0, x12 = q.x1, y12 = q.y1) && node.length) {
      var xm = (x06 + x12) / 2, ym = (y06 + y12) / 2;
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x12, y12));
      if (child = node[2])
        quads.push(new quad_default(child, x06, ym, xm, y12));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y06, x12, ym));
      if (child = node[0])
        quads.push(new quad_default(child, x06, y06, xm, ym));
    }
  }
  return this;
}

// node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default(callback) {
  var quads = [], next = [], q;
  if (this._root)
    quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x06 = q.x0, y06 = q.y0, x12 = q.x1, y12 = q.y1, xm = (x06 + x12) / 2, ym = (y06 + y12) / 2;
      if (child = node[0])
        quads.push(new quad_default(child, x06, y06, xm, ym));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y06, x12, ym));
      if (child = node[2])
        quads.push(new quad_default(child, x06, ym, xm, y12));
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x12, y12));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

// node_modules/d3-quadtree/src/x.js
function defaultX(d) {
  return d[0];
}
function x_default(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}

// node_modules/d3-quadtree/src/y.js
function defaultY(d) {
  return d[1];
}
function y_default(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}

// node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x5, y5) {
  var tree = new Quadtree(x5 == null ? defaultX : x5, y5 == null ? defaultY : y5, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x5, y5, x06, y06, x12, y12) {
  this._x = x5;
  this._y = y5;
  this._x0 = x06;
  this._y0 = y06;
  this._x1 = x12;
  this._y1 = y12;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy5 = {data: leaf.data}, next = copy5;
  while (leaf = leaf.next)
    next = next.next = {data: leaf.data};
  return copy5;
}
var treeProto = quadtree.prototype = Quadtree.prototype;
treeProto.copy = function() {
  var copy5 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
  if (!node)
    return copy5;
  if (!node.length)
    return copy5._root = leaf_copy(node), copy5;
  nodes = [{source: node, target: copy5._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length)
          nodes.push({source: child, target: node.target[i] = new Array(4)});
        else
          node.target[i] = leaf_copy(child);
      }
    }
  }
  return copy5;
};
treeProto.add = add_default;
treeProto.addAll = addAll;
treeProto.cover = cover_default;
treeProto.data = data_default;
treeProto.extent = extent_default;
treeProto.find = find_default;
treeProto.remove = remove_default;
treeProto.removeAll = removeAll;
treeProto.root = root_default;
treeProto.size = size_default;
treeProto.visit = visit_default;
treeProto.visitAfter = visitAfter_default;
treeProto.x = x_default;
treeProto.y = y_default;

// node_modules/d3-force/src/constant.js
function constant_default3(x5) {
  return function() {
    return x5;
  };
}

// node_modules/d3-force/src/jiggle.js
function jiggle_default(random2) {
  return (random2() - 0.5) * 1e-6;
}

// node_modules/d3-force/src/collide.js
function x3(d) {
  return d.x + d.vx;
}
function y3(d) {
  return d.y + d.vy;
}
function collide_default(radius2) {
  var nodes, radii, random2, strength = 1, iterations2 = 1;
  if (typeof radius2 !== "function")
    radius2 = constant_default3(radius2 == null ? 1 : +radius2);
  function force() {
    var i, n = nodes.length, tree, node, xi, yi, ri, ri2;
    for (var k = 0; k < iterations2; ++k) {
      tree = quadtree(nodes, x3, y3).visitAfter(prepare2);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply2);
      }
    }
    function apply2(quad2, x06, y06, x12, y12) {
      var data4 = quad2.data, rj = quad2.r, r2 = ri + rj;
      if (data4) {
        if (data4.index > node.index) {
          var x5 = xi - data4.x - data4.vx, y5 = yi - data4.y - data4.vy, l = x5 * x5 + y5 * y5;
          if (l < r2 * r2) {
            if (x5 === 0)
              x5 = jiggle_default(random2), l += x5 * x5;
            if (y5 === 0)
              y5 = jiggle_default(random2), l += y5 * y5;
            l = (r2 - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x5 *= l) * (r2 = (rj *= rj) / (ri2 + rj));
            node.vy += (y5 *= l) * r2;
            data4.vx -= x5 * (r2 = 1 - r2);
            data4.vy -= y5 * r2;
          }
        }
        return;
      }
      return x06 > xi + r2 || x12 < xi - r2 || y06 > yi + r2 || y12 < yi - r2;
    }
  }
  function prepare2(quad2) {
    if (quad2.data)
      return quad2.r = radii[quad2.data.index];
    for (var i = quad2.r = 0; i < 4; ++i) {
      if (quad2[i] && quad2[i].r > quad2.r) {
        quad2.r = quad2[i].r;
      }
    }
  }
  function initialize3() {
    if (!nodes)
      return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i)
      node = nodes[i], radii[node.index] = +radius2(node, i, nodes);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random2 = _random;
    initialize3();
  };
  force.iterations = function(_) {
    return arguments.length ? (iterations2 = +_, force) : iterations2;
  };
  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };
  force.radius = function(_) {
    return arguments.length ? (radius2 = typeof _ === "function" ? _ : constant_default3(+_), initialize3(), force) : radius2;
  };
  return force;
}

// node_modules/d3-force/src/link.js
function index(d) {
  return d.index;
}
function find2(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node)
    throw new Error("node not found: " + nodeId);
  return node;
}
function link_default(links) {
  var id4 = index, strength = defaultStrength, strengths, distance = constant_default3(30), distances, nodes, count2, bias, random2, iterations2 = 1;
  if (links == null)
    links = [];
  function defaultStrength(link2) {
    return 1 / Math.min(count2[link2.source.index], count2[link2.target.index]);
  }
  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations2; ++k) {
      for (var i = 0, link2, source4, target, x5, y5, l, b2; i < n; ++i) {
        link2 = links[i], source4 = link2.source, target = link2.target;
        x5 = target.x + target.vx - source4.x - source4.vx || jiggle_default(random2);
        y5 = target.y + target.vy - source4.y - source4.vy || jiggle_default(random2);
        l = Math.sqrt(x5 * x5 + y5 * y5);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x5 *= l, y5 *= l;
        target.vx -= x5 * (b2 = bias[i]);
        target.vy -= y5 * b2;
        source4.vx += x5 * (b2 = 1 - b2);
        source4.vy += y5 * b2;
      }
    }
  }
  function initialize3() {
    if (!nodes)
      return;
    var i, n = nodes.length, m2 = links.length, nodeById = new Map(nodes.map((d, i2) => [id4(d, i2, nodes), d])), link2;
    for (i = 0, count2 = new Array(n); i < m2; ++i) {
      link2 = links[i], link2.index = i;
      if (typeof link2.source !== "object")
        link2.source = find2(nodeById, link2.source);
      if (typeof link2.target !== "object")
        link2.target = find2(nodeById, link2.target);
      count2[link2.source.index] = (count2[link2.source.index] || 0) + 1;
      count2[link2.target.index] = (count2[link2.target.index] || 0) + 1;
    }
    for (i = 0, bias = new Array(m2); i < m2; ++i) {
      link2 = links[i], bias[i] = count2[link2.source.index] / (count2[link2.source.index] + count2[link2.target.index]);
    }
    strengths = new Array(m2), initializeStrength();
    distances = new Array(m2), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes)
      return;
    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }
  function initializeDistance() {
    if (!nodes)
      return;
    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random2 = _random;
    initialize3();
  };
  force.links = function(_) {
    return arguments.length ? (links = _, initialize3(), force) : links;
  };
  force.id = function(_) {
    return arguments.length ? (id4 = _, force) : id4;
  };
  force.iterations = function(_) {
    return arguments.length ? (iterations2 = +_, force) : iterations2;
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default3(+_), initializeStrength(), force) : strength;
  };
  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : constant_default3(+_), initializeDistance(), force) : distance;
  };
  return force;
}

// node_modules/d3-dispatch/src/dispatch.js
var noop4 = {value: () => {
}};
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types3) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name4 = "", i = t.indexOf(".");
    if (i >= 0)
      name4 = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types3.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return {type: t, name: name4};
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n)
        if ((t = (typename = T[i]).type) && (t = get5(_[t], typename.name)))
          return t;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type)
        _[t] = set4(_[t], typename.name, callback);
      else if (callback == null)
        for (t in _)
          _[t] = set4(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy5 = {}, _ = this._;
    for (var t in _)
      copy5[t] = _[t].slice();
    return new Dispatch(copy5);
  },
  call: function(type2, that) {
    if ((n = arguments.length - 2) > 0)
      for (var args = new Array(n), i = 0, n, t; i < n; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (t = this._[type2], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  },
  apply: function(type2, that, args) {
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (var t = this._[type2], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  }
};
function get5(type2, name4) {
  for (var i = 0, n = type2.length, c2; i < n; ++i) {
    if ((c2 = type2[i]).name === name4) {
      return c2.value;
    }
  }
}
function set4(type2, name4, callback) {
  for (var i = 0, n = type2.length; i < n; ++i) {
    if (type2[i].name === name4) {
      type2[i] = noop4, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type2.push({name: name4, value: callback});
  return type2;
}
var dispatch_default = dispatch;

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time4) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time4 = (time4 == null ? now() : +time4) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time4;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time4) {
  var t = new Timer();
  t.restart(callback, delay, time4);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0)
      t._call.call(null, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t04, t13 = taskHead, t22, time4 = Infinity;
  while (t13) {
    if (t13._call) {
      if (time4 > t13._time)
        time4 = t13._time;
      t04 = t13, t13 = t13._next;
    } else {
      t22 = t13._next, t13._next = null;
      t13 = t04 ? t04._next = t22 : taskHead = t22;
    }
  }
  taskTail = t04;
  sleep(time4);
}
function sleep(time4) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time4 - clockNow;
  if (delay > 24) {
    if (time4 < Infinity)
      timeout = setTimeout(wake, time4 - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-timer/src/interval.js
function interval_default(callback, delay, time4) {
  var t = new Timer(), total = delay;
  if (delay == null)
    return t.restart(callback, delay, time4), t;
  t._restart = t.restart;
  t.restart = function(callback2, delay2, time5) {
    delay2 = +delay2, time5 = time5 == null ? now() : +time5;
    t._restart(function tick2(elapsed) {
      elapsed += total;
      t._restart(tick2, total += delay2, time5);
      callback2(elapsed);
    }, delay2, time5);
  };
  t.restart(callback, delay, time4);
  return t;
}

// node_modules/d3-force/src/lcg.js
var a = 1664525;
var c = 1013904223;
var m = 4294967296;
function lcg_default() {
  let s = 1;
  return () => (s = (a * s + c) % m) / m;
}

// node_modules/d3-force/src/simulation.js
function x4(d) {
  return d.x;
}
function y4(d) {
  return d.y;
}
var initialRadius = 10;
var initialAngle = Math.PI * (3 - Math.sqrt(5));
function simulation_default(nodes) {
  var simulation2, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = new Map(), stepper = timer(step), event2 = dispatch_default("tick", "end"), random2 = lcg_default();
  if (nodes == null)
    nodes = [];
  function step() {
    tick2();
    event2.call("tick", simulation2);
    if (alpha < alphaMin) {
      stepper.stop();
      event2.call("end", simulation2);
    }
  }
  function tick2(iterations2) {
    var i, n = nodes.length, node;
    if (iterations2 === void 0)
      iterations2 = 1;
    for (var k = 0; k < iterations2; ++k) {
      alpha += (alphaTarget - alpha) * alphaDecay;
      forces.forEach(function(force) {
        force(alpha);
      });
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null)
          node.x += node.vx *= velocityDecay;
        else
          node.x = node.fx, node.vx = 0;
        if (node.fy == null)
          node.y += node.vy *= velocityDecay;
        else
          node.y = node.fy, node.vy = 0;
      }
    }
    return simulation2;
  }
  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null)
        node.x = node.fx;
      if (node.fy != null)
        node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius2 = initialRadius * Math.sqrt(0.5 + i), angle2 = i * initialAngle;
        node.x = radius2 * Math.cos(angle2);
        node.y = radius2 * Math.sin(angle2);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize)
      force.initialize(nodes, random2);
    return force;
  }
  initializeNodes();
  return simulation2 = {
    tick: tick2,
    restart: function() {
      return stepper.restart(step), simulation2;
    },
    stop: function() {
      return stepper.stop(), simulation2;
    },
    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation2) : nodes;
    },
    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation2) : alpha;
    },
    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation2) : alphaMin;
    },
    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation2) : +alphaDecay;
    },
    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation2) : alphaTarget;
    },
    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation2) : 1 - velocityDecay;
    },
    randomSource: function(_) {
      return arguments.length ? (random2 = _, forces.forEach(initializeForce), simulation2) : random2;
    },
    force: function(name4, _) {
      return arguments.length > 1 ? (_ == null ? forces.delete(name4) : forces.set(name4, initializeForce(_)), simulation2) : forces.get(name4);
    },
    find: function(x5, y5, radius2) {
      var i = 0, n = nodes.length, dx, dy, d2, node, closest;
      if (radius2 == null)
        radius2 = Infinity;
      else
        radius2 *= radius2;
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x5 - node.x;
        dy = y5 - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius2)
          closest = node, radius2 = d2;
      }
      return closest;
    },
    on: function(name4, _) {
      return arguments.length > 1 ? (event2.on(name4, _), simulation2) : event2.on(name4);
    }
  };
}

// node_modules/d3-force/src/manyBody.js
function manyBody_default() {
  var nodes, node, random2, alpha, strength = constant_default3(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
  function force(_) {
    var i, n = nodes.length, tree = quadtree(nodes, x4, y4).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n; ++i)
      node = nodes[i], tree.visit(apply2);
  }
  function initialize3() {
    if (!nodes)
      return;
    var i, n = nodes.length, node2;
    strengths = new Array(n);
    for (i = 0; i < n; ++i)
      node2 = nodes[i], strengths[node2.index] = +strength(node2, i, nodes);
  }
  function accumulate(quad2) {
    var strength2 = 0, q, c2, weight = 0, x5, y5, i;
    if (quad2.length) {
      for (x5 = y5 = i = 0; i < 4; ++i) {
        if ((q = quad2[i]) && (c2 = Math.abs(q.value))) {
          strength2 += q.value, weight += c2, x5 += c2 * q.x, y5 += c2 * q.y;
        }
      }
      quad2.x = x5 / weight;
      quad2.y = y5 / weight;
    } else {
      q = quad2;
      q.x = q.data.x;
      q.y = q.data.y;
      do
        strength2 += strengths[q.data.index];
      while (q = q.next);
    }
    quad2.value = strength2;
  }
  function apply2(quad2, x12, _, x22) {
    if (!quad2.value)
      return true;
    var x5 = quad2.x - node.x, y5 = quad2.y - node.y, w3 = x22 - x12, l = x5 * x5 + y5 * y5;
    if (w3 * w3 / theta2 < l) {
      if (l < distanceMax2) {
        if (x5 === 0)
          x5 = jiggle_default(random2), l += x5 * x5;
        if (y5 === 0)
          y5 = jiggle_default(random2), l += y5 * y5;
        if (l < distanceMin2)
          l = Math.sqrt(distanceMin2 * l);
        node.vx += x5 * quad2.value * alpha / l;
        node.vy += y5 * quad2.value * alpha / l;
      }
      return true;
    } else if (quad2.length || l >= distanceMax2)
      return;
    if (quad2.data !== node || quad2.next) {
      if (x5 === 0)
        x5 = jiggle_default(random2), l += x5 * x5;
      if (y5 === 0)
        y5 = jiggle_default(random2), l += y5 * y5;
      if (l < distanceMin2)
        l = Math.sqrt(distanceMin2 * l);
    }
    do
      if (quad2.data !== node) {
        w3 = strengths[quad2.data.index] * alpha / l;
        node.vx += x5 * w3;
        node.vy += y5 * w3;
      }
    while (quad2 = quad2.next);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random2 = _random;
    initialize3();
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default3(+_), initialize3(), force) : strength;
  };
  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };
  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };
  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };
  return force;
}

// node_modules/d3-force/src/x.js
function x_default2(x5) {
  var strength = constant_default3(0.1), nodes, strengths, xz;
  if (typeof x5 !== "function")
    x5 = constant_default3(x5 == null ? 0 : +x5);
  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }
  function initialize3() {
    if (!nodes)
      return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x5(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_) {
    nodes = _;
    initialize3();
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default3(+_), initialize3(), force) : strength;
  };
  force.x = function(_) {
    return arguments.length ? (x5 = typeof _ === "function" ? _ : constant_default3(+_), initialize3(), force) : x5;
  };
  return force;
}

// node_modules/d3-force/src/y.js
function y_default2(y5) {
  var strength = constant_default3(0.1), nodes, strengths, yz;
  if (typeof y5 !== "function")
    y5 = constant_default3(y5 == null ? 0 : +y5);
  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }
  function initialize3() {
    if (!nodes)
      return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y5(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_) {
    nodes = _;
    initialize3();
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default3(+_), initialize3(), force) : strength;
  };
  force.y = function(_) {
    return arguments.length ? (y5 = typeof _ === "function" ? _ : constant_default3(+_), initialize3(), force) : y5;
  };
  return force;
}

// node_modules/vega-force/build/vega-force.module.js
var ForceMap = {
  center: center_default,
  collide: collide_default,
  nbody: manyBody_default,
  link: link_default,
  x: x_default2,
  y: y_default2
};
var Forces = "forces";
var ForceParams = ["alpha", "alphaMin", "alphaTarget", "velocityDecay", "forces"];
var ForceConfig = ["static", "iterations"];
var ForceOutput = ["x", "y", "vx", "vy"];
function Force(params2) {
  Transform.call(this, null, params2);
}
Force.Definition = {
  type: "Force",
  metadata: {
    modifies: true
  },
  params: [{
    name: "static",
    type: "boolean",
    default: false
  }, {
    name: "restart",
    type: "boolean",
    default: false
  }, {
    name: "iterations",
    type: "number",
    default: 300
  }, {
    name: "alpha",
    type: "number",
    default: 1
  }, {
    name: "alphaMin",
    type: "number",
    default: 1e-3
  }, {
    name: "alphaTarget",
    type: "number",
    default: 0
  }, {
    name: "velocityDecay",
    type: "number",
    default: 0.4
  }, {
    name: "forces",
    type: "param",
    array: true,
    params: [{
      key: {
        force: "center"
      },
      params: [{
        name: "x",
        type: "number",
        default: 0
      }, {
        name: "y",
        type: "number",
        default: 0
      }]
    }, {
      key: {
        force: "collide"
      },
      params: [{
        name: "radius",
        type: "number",
        expr: true
      }, {
        name: "strength",
        type: "number",
        default: 0.7
      }, {
        name: "iterations",
        type: "number",
        default: 1
      }]
    }, {
      key: {
        force: "nbody"
      },
      params: [{
        name: "strength",
        type: "number",
        default: -30
      }, {
        name: "theta",
        type: "number",
        default: 0.9
      }, {
        name: "distanceMin",
        type: "number",
        default: 1
      }, {
        name: "distanceMax",
        type: "number"
      }]
    }, {
      key: {
        force: "link"
      },
      params: [{
        name: "links",
        type: "data"
      }, {
        name: "id",
        type: "field"
      }, {
        name: "distance",
        type: "number",
        default: 30,
        expr: true
      }, {
        name: "strength",
        type: "number",
        expr: true
      }, {
        name: "iterations",
        type: "number",
        default: 1
      }]
    }, {
      key: {
        force: "x"
      },
      params: [{
        name: "strength",
        type: "number",
        default: 0.1
      }, {
        name: "x",
        type: "field"
      }]
    }, {
      key: {
        force: "y"
      },
      params: [{
        name: "strength",
        type: "number",
        default: 0.1
      }, {
        name: "y",
        type: "field"
      }]
    }]
  }, {
    name: "as",
    type: "string",
    array: true,
    modify: false,
    default: ForceOutput
  }]
};
inherits(Force, Transform, {
  transform(_, pulse2) {
    var sim = this.value, change2 = pulse2.changed(pulse2.ADD_REM), params2 = _.modified(ForceParams), iters = _.iterations || 300;
    if (!sim) {
      this.value = sim = simulation(pulse2.source, _);
      sim.on("tick", rerun(pulse2.dataflow, this));
      if (!_.static) {
        change2 = true;
        sim.tick();
      }
      pulse2.modifies("index");
    } else {
      if (change2) {
        pulse2.modifies("index");
        sim.nodes(pulse2.source);
      }
      if (params2 || pulse2.changed(pulse2.MOD)) {
        setup(sim, _, 0, pulse2);
      }
    }
    if (params2 || change2 || _.modified(ForceConfig) || pulse2.changed() && _.restart) {
      sim.alpha(Math.max(sim.alpha(), _.alpha || 1)).alphaDecay(1 - Math.pow(sim.alphaMin(), 1 / iters));
      if (_.static) {
        for (sim.stop(); --iters >= 0; )
          sim.tick();
      } else {
        if (sim.stopped())
          sim.restart();
        if (!change2)
          return pulse2.StopPropagation;
      }
    }
    return this.finish(_, pulse2);
  },
  finish(_, pulse2) {
    const dataflow = pulse2.dataflow;
    for (let args = this._argops, j = 0, m2 = args.length, arg; j < m2; ++j) {
      arg = args[j];
      if (arg.name !== Forces || arg.op._argval.force !== "link") {
        continue;
      }
      for (var ops2 = arg.op._argops, i = 0, n = ops2.length, op; i < n; ++i) {
        if (ops2[i].name === "links" && (op = ops2[i].op.source)) {
          dataflow.pulse(op, dataflow.changeset().reflow());
          break;
        }
      }
    }
    return pulse2.reflow(_.modified()).modifies(ForceOutput);
  }
});
function rerun(df, op) {
  return () => df.touch(op).run();
}
function simulation(nodes, _) {
  const sim = simulation_default(nodes), stop2 = sim.stop, restart = sim.restart;
  let stopped = false;
  sim.stopped = () => stopped;
  sim.restart = () => (stopped = false, restart());
  sim.stop = () => (stopped = true, stop2());
  return setup(sim, _, true).on("end", () => stopped = true);
}
function setup(sim, _, init2, pulse2) {
  var f = array(_.forces), i, n, p, name4;
  for (i = 0, n = ForceParams.length; i < n; ++i) {
    p = ForceParams[i];
    if (p !== Forces && _.modified(p))
      sim[p](_[p]);
  }
  for (i = 0, n = f.length; i < n; ++i) {
    name4 = Forces + i;
    p = init2 || _.modified(Forces, i) ? getForce(f[i]) : pulse2 && modified(f[i], pulse2) ? sim.force(name4) : null;
    if (p)
      sim.force(name4, p);
  }
  for (n = sim.numForces || 0; i < n; ++i) {
    sim.force(Forces + i, null);
  }
  sim.numForces = f.length;
  return sim;
}
function modified(f, pulse2) {
  var k, v;
  for (k in f) {
    if (isFunction(v = f[k]) && pulse2.modified(accessorFields(v)))
      return 1;
  }
  return 0;
}
function getForce(_) {
  var f, p;
  if (!has(ForceMap, _.force)) {
    error("Unrecognized force: " + _.force);
  }
  f = ForceMap[_.force]();
  for (p in _) {
    if (isFunction(f[p]))
      setForceParam(f[p], _[p], _);
  }
  return f;
}
function setForceParam(f, v, _) {
  f(isFunction(v) ? (d) => v(d, _) : v);
}

// node_modules/vega-hierarchy/build/vega-hierarchy.module.js
var vega_hierarchy_module_exports = {};
__export(vega_hierarchy_module_exports, {
  nest: () => Nest,
  pack: () => Pack,
  partition: () => Partition,
  stratify: () => Stratify,
  tree: () => Tree,
  treelinks: () => TreeLinks,
  treemap: () => Treemap
});

// node_modules/d3-hierarchy/src/cluster.js
function defaultSeparation(a2, b2) {
  return a2.parent === b2.parent ? 1 : 2;
}
function meanX(children4) {
  return children4.reduce(meanXReduce, 0) / children4.length;
}
function meanXReduce(x5, c2) {
  return x5 + c2.x;
}
function maxY(children4) {
  return 1 + children4.reduce(maxYReduce, 0);
}
function maxYReduce(y5, c2) {
  return Math.max(y5, c2.y);
}
function leafLeft(node) {
  var children4;
  while (children4 = node.children)
    node = children4[0];
  return node;
}
function leafRight(node) {
  var children4;
  while (children4 = node.children)
    node = children4[children4.length - 1];
  return node;
}
function cluster_default() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
  function cluster(root2) {
    var previousNode, x5 = 0;
    root2.eachAfter(function(node) {
      var children4 = node.children;
      if (children4) {
        node.x = meanX(children4);
        node.y = maxY(children4);
      } else {
        node.x = previousNode ? x5 += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left = leafLeft(root2), right = leafRight(root2), x06 = left.x - separation(left, right) / 2, x12 = right.x + separation(right, left) / 2;
    return root2.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root2.x) * dx;
      node.y = (root2.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x06) / (x12 - x06) * dx;
      node.y = (1 - (root2.y ? node.y / root2.y : 1)) * dy;
    });
  }
  cluster.separation = function(x5) {
    return arguments.length ? (separation = x5, cluster) : separation;
  };
  cluster.size = function(x5) {
    return arguments.length ? (nodeSize = false, dx = +x5[0], dy = +x5[1], cluster) : nodeSize ? null : [dx, dy];
  };
  cluster.nodeSize = function(x5) {
    return arguments.length ? (nodeSize = true, dx = +x5[0], dy = +x5[1], cluster) : nodeSize ? [dx, dy] : null;
  };
  return cluster;
}

// node_modules/d3-hierarchy/src/hierarchy/count.js
function count(node) {
  var sum2 = 0, children4 = node.children, i = children4 && children4.length;
  if (!i)
    sum2 = 1;
  else
    while (--i >= 0)
      sum2 += children4[i].value;
  node.value = sum2;
}
function count_default() {
  return this.eachAfter(count);
}

// node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default(callback, that) {
  let index4 = -1;
  for (const node of this) {
    callback.call(that, node, ++index4, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
  var node = this, nodes = [node], children4, i, index4 = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index4, this);
    if (children4 = node.children) {
      for (i = children4.length - 1; i >= 0; --i) {
        nodes.push(children4[i]);
      }
    }
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
  var node = this, nodes = [node], next = [], children4, i, n, index4 = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children4 = node.children) {
      for (i = 0, n = children4.length; i < n; ++i) {
        nodes.push(children4[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index4, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default2(callback, that) {
  let index4 = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index4, this)) {
      return node;
    }
  }
}

// node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default(value3) {
  return this.eachAfter(function(node) {
    var sum2 = +value3(node.data) || 0, children4 = node.children, i = children4 && children4.length;
    while (--i >= 0)
      sum2 += children4[i].value;
    node.value = sum2;
  });
}

// node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default(compare4) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare4);
    }
  });
}

// node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default3(end) {
  var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a2, b2) {
  if (a2 === b2)
    return a2;
  var aNodes = a2.ancestors(), bNodes = b2.ancestors(), c2 = null;
  a2 = aNodes.pop();
  b2 = bNodes.pop();
  while (a2 === b2) {
    c2 = a2;
    a2 = aNodes.pop();
    b2 = bNodes.pop();
  }
  return c2;
}

// node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

// node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  return Array.from(this);
}

// node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

// node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root2 = this, links = [];
  root2.each(function(node) {
    if (node !== root2) {
      links.push({source: node.parent, target: node});
    }
  });
  return links;
}

// node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default() {
  var node = this, current2, next = [node], children4, i, n;
  do {
    current2 = next.reverse(), next = [];
    while (node = current2.pop()) {
      yield node;
      if (children4 = node.children) {
        for (i = 0, n = children4.length; i < n; ++i) {
          next.push(children4[i]);
        }
      }
    }
  } while (next.length);
}

// node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data4, children4) {
  if (data4 instanceof Map) {
    data4 = [void 0, data4];
    if (children4 === void 0)
      children4 = mapChildren;
  } else if (children4 === void 0) {
    children4 = objectChildren;
  }
  var root2 = new Node(data4), node, nodes = [root2], child, childs, i, n;
  while (node = nodes.pop()) {
    if ((childs = children4(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root2.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d) {
  return d.children;
}
function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0)
    node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height2 = 0;
  do
    node.height = height2;
  while ((node = node.parent) && node.height < ++height2);
}
function Node(data4) {
  this.data = data4;
  this.depth = this.height = 0;
  this.parent = null;
}
Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: count_default,
  each: each_default,
  eachAfter: eachAfter_default,
  eachBefore: eachBefore_default,
  find: find_default2,
  sum: sum_default,
  sort: sort_default,
  path: path_default3,
  ancestors: ancestors_default,
  descendants: descendants_default,
  leaves: leaves_default,
  links: links_default,
  copy: node_copy,
  [Symbol.iterator]: iterator_default
};

// node_modules/d3-hierarchy/src/array.js
function array_default3(x5) {
  return typeof x5 === "object" && "length" in x5 ? x5 : Array.from(x5);
}
function shuffle(array5) {
  var m2 = array5.length, t, i;
  while (m2) {
    i = Math.random() * m2-- | 0;
    t = array5[m2];
    array5[m2] = array5[i];
    array5[i] = t;
  }
  return array5;
}

// node_modules/d3-hierarchy/src/pack/enclose.js
function enclose_default(circles) {
  var i = 0, n = (circles = shuffle(Array.from(circles))).length, B2 = [], p, e;
  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p))
      ++i;
    else
      e = encloseBasis(B2 = extendBasis(B2, p)), i = 0;
  }
  return e;
}
function extendBasis(B2, p) {
  var i, j;
  if (enclosesWeakAll(p, B2))
    return [p];
  for (i = 0; i < B2.length; ++i) {
    if (enclosesNot(p, B2[i]) && enclosesWeakAll(encloseBasis2(B2[i], p), B2)) {
      return [B2[i], p];
    }
  }
  for (i = 0; i < B2.length - 1; ++i) {
    for (j = i + 1; j < B2.length; ++j) {
      if (enclosesNot(encloseBasis2(B2[i], B2[j]), p) && enclosesNot(encloseBasis2(B2[i], p), B2[j]) && enclosesNot(encloseBasis2(B2[j], p), B2[i]) && enclosesWeakAll(encloseBasis3(B2[i], B2[j], p), B2)) {
        return [B2[i], B2[j], p];
      }
    }
  }
  throw new Error();
}
function enclosesNot(a2, b2) {
  var dr = a2.r - b2.r, dx = b2.x - a2.x, dy = b2.y - a2.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a2, b2) {
  var dr = a2.r - b2.r + Math.max(a2.r, b2.r, 1) * 1e-9, dx = b2.x - a2.x, dy = b2.y - a2.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a2, B2) {
  for (var i = 0; i < B2.length; ++i) {
    if (!enclosesWeak(a2, B2[i])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B2) {
  switch (B2.length) {
    case 1:
      return encloseBasis1(B2[0]);
    case 2:
      return encloseBasis2(B2[0], B2[1]);
    case 3:
      return encloseBasis3(B2[0], B2[1], B2[2]);
  }
}
function encloseBasis1(a2) {
  return {
    x: a2.x,
    y: a2.y,
    r: a2.r
  };
}
function encloseBasis2(a2, b2) {
  var x12 = a2.x, y12 = a2.y, r1 = a2.r, x22 = b2.x, y22 = b2.y, r2 = b2.r, x21 = x22 - x12, y21 = y22 - y12, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x12 + x22 + x21 / l * r21) / 2,
    y: (y12 + y22 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}
function encloseBasis3(a2, b2, c2) {
  var x12 = a2.x, y12 = a2.y, r1 = a2.r, x22 = b2.x, y22 = b2.y, r2 = b2.r, x32 = c2.x, y32 = c2.y, r3 = c2.r, a22 = x12 - x22, a3 = x12 - x32, b22 = y12 - y22, b3 = y12 - y32, c22 = r2 - r1, c3 = r3 - r1, d1 = x12 * x12 + y12 * y12 - r1 * r1, d2 = d1 - x22 * x22 - y22 * y22 + r2 * r2, d3 = d1 - x32 * x32 - y32 * y32 + r3 * r3, ab = a3 * b22 - a22 * b3, xa = (b22 * d3 - b3 * d2) / (ab * 2) - x12, xb = (b3 * c22 - b22 * c3) / ab, ya = (a3 * d2 - a22 * d3) / (ab * 2) - y12, yb = (a22 * c3 - a3 * c22) / ab, A5 = xb * xb + yb * yb - 1, B2 = 2 * (r1 + xa * xb + ya * yb), C3 = xa * xa + ya * ya - r1 * r1, r4 = -(A5 ? (B2 + Math.sqrt(B2 * B2 - 4 * A5 * C3)) / (2 * A5) : C3 / B2);
  return {
    x: x12 + xa + xb * r4,
    y: y12 + ya + yb * r4,
    r: r4
  };
}

// node_modules/d3-hierarchy/src/pack/siblings.js
function place(b2, a2, c2) {
  var dx = b2.x - a2.x, x5, a22, dy = b2.y - a2.y, y5, b22, d2 = dx * dx + dy * dy;
  if (d2) {
    a22 = a2.r + c2.r, a22 *= a22;
    b22 = b2.r + c2.r, b22 *= b22;
    if (a22 > b22) {
      x5 = (d2 + b22 - a22) / (2 * d2);
      y5 = Math.sqrt(Math.max(0, b22 / d2 - x5 * x5));
      c2.x = b2.x - x5 * dx - y5 * dy;
      c2.y = b2.y - x5 * dy + y5 * dx;
    } else {
      x5 = (d2 + a22 - b22) / (2 * d2);
      y5 = Math.sqrt(Math.max(0, a22 / d2 - x5 * x5));
      c2.x = a2.x + x5 * dx - y5 * dy;
      c2.y = a2.y + x5 * dy + y5 * dx;
    }
  } else {
    c2.x = a2.x + c2.r;
    c2.y = a2.y;
  }
}
function intersects(a2, b2) {
  var dr = a2.r + b2.r - 1e-6, dx = b2.x - a2.x, dy = b2.y - a2.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
  var a2 = node._, b2 = node.next._, ab = a2.r + b2.r, dx = (a2.x * b2.r + b2.x * a2.r) / ab, dy = (a2.y * b2.r + b2.y * a2.r) / ab;
  return dx * dx + dy * dy;
}
function Node2(circle3) {
  this._ = circle3;
  this.next = null;
  this.previous = null;
}
function packEnclose(circles) {
  if (!(n = (circles = array_default3(circles)).length))
    return 0;
  var a2, b2, c2, n, aa, ca, i, j, k, sj, sk;
  a2 = circles[0], a2.x = 0, a2.y = 0;
  if (!(n > 1))
    return a2.r;
  b2 = circles[1], a2.x = -b2.r, b2.x = a2.r, b2.y = 0;
  if (!(n > 2))
    return a2.r + b2.r;
  place(b2, a2, c2 = circles[2]);
  a2 = new Node2(a2), b2 = new Node2(b2), c2 = new Node2(c2);
  a2.next = c2.previous = b2;
  b2.next = a2.previous = c2;
  c2.next = b2.previous = a2;
  pack:
    for (i = 3; i < n; ++i) {
      place(a2._, b2._, c2 = circles[i]), c2 = new Node2(c2);
      j = b2.next, k = a2.previous, sj = b2._.r, sk = a2._.r;
      do {
        if (sj <= sk) {
          if (intersects(j._, c2._)) {
            b2 = j, a2.next = b2, b2.previous = a2, --i;
            continue pack;
          }
          sj += j._.r, j = j.next;
        } else {
          if (intersects(k._, c2._)) {
            a2 = k, a2.next = b2, b2.previous = a2, --i;
            continue pack;
          }
          sk += k._.r, k = k.previous;
        }
      } while (j !== k.next);
      c2.previous = a2, c2.next = b2, a2.next = b2.previous = b2 = c2;
      aa = score(a2);
      while ((c2 = c2.next) !== b2) {
        if ((ca = score(c2)) < aa) {
          a2 = c2, aa = ca;
        }
      }
      b2 = a2.next;
    }
  a2 = [b2._], c2 = b2;
  while ((c2 = c2.next) !== b2)
    a2.push(c2._);
  c2 = enclose_default(a2);
  for (i = 0; i < n; ++i)
    a2 = circles[i], a2.x -= c2.x, a2.y -= c2.y;
  return c2.r;
}

// node_modules/d3-hierarchy/src/accessors.js
function optional(f) {
  return f == null ? null : required(f);
}
function required(f) {
  if (typeof f !== "function")
    throw new Error();
  return f;
}

// node_modules/d3-hierarchy/src/constant.js
function constantZero() {
  return 0;
}
function constant_default4(x5) {
  return function() {
    return x5;
  };
}

// node_modules/d3-hierarchy/src/pack/index.js
function defaultRadius(d) {
  return Math.sqrt(d.value);
}
function pack_default() {
  var radius2 = null, dx = 1, dy = 1, padding3 = constantZero;
  function pack(root2) {
    root2.x = dx / 2, root2.y = dy / 2;
    if (radius2) {
      root2.eachBefore(radiusLeaf(radius2)).eachAfter(packChildren(padding3, 0.5)).eachBefore(translateChild(1));
    } else {
      root2.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildren(constantZero, 1)).eachAfter(packChildren(padding3, root2.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root2.r)));
    }
    return root2;
  }
  pack.radius = function(x5) {
    return arguments.length ? (radius2 = optional(x5), pack) : radius2;
  };
  pack.size = function(x5) {
    return arguments.length ? (dx = +x5[0], dy = +x5[1], pack) : [dx, dy];
  };
  pack.padding = function(x5) {
    return arguments.length ? (padding3 = typeof x5 === "function" ? x5 : constant_default4(+x5), pack) : padding3;
  };
  return pack;
}
function radiusLeaf(radius2) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius2(node) || 0);
    }
  };
}
function packChildren(padding3, k) {
  return function(node) {
    if (children4 = node.children) {
      var children4, i, n = children4.length, r2 = padding3(node) * k || 0, e;
      if (r2)
        for (i = 0; i < n; ++i)
          children4[i].r += r2;
      e = packEnclose(children4);
      if (r2)
        for (i = 0; i < n; ++i)
          children4[i].r -= r2;
      node.r = e + r2;
    }
  };
}
function translateChild(k) {
  return function(node) {
    var parent = node.parent;
    node.r *= k;
    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}

// node_modules/d3-hierarchy/src/treemap/round.js
function round_default2(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

// node_modules/d3-hierarchy/src/treemap/dice.js
function dice_default(parent, x06, y06, x12, y12) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (x12 - x06) / parent.value;
  while (++i < n) {
    node = nodes[i], node.y0 = y06, node.y1 = y12;
    node.x0 = x06, node.x1 = x06 += node.value * k;
  }
}

// node_modules/d3-hierarchy/src/partition.js
function partition_default() {
  var dx = 1, dy = 1, padding3 = 0, round = false;
  function partition5(root2) {
    var n = root2.height + 1;
    root2.x0 = root2.y0 = padding3;
    root2.x1 = dx;
    root2.y1 = dy / n;
    root2.eachBefore(positionNode(dy, n));
    if (round)
      root2.eachBefore(round_default2);
    return root2;
  }
  function positionNode(dy2, n) {
    return function(node) {
      if (node.children) {
        dice_default(node, node.x0, dy2 * (node.depth + 1) / n, node.x1, dy2 * (node.depth + 2) / n);
      }
      var x06 = node.x0, y06 = node.y0, x12 = node.x1 - padding3, y12 = node.y1 - padding3;
      if (x12 < x06)
        x06 = x12 = (x06 + x12) / 2;
      if (y12 < y06)
        y06 = y12 = (y06 + y12) / 2;
      node.x0 = x06;
      node.y0 = y06;
      node.x1 = x12;
      node.y1 = y12;
    };
  }
  partition5.round = function(x5) {
    return arguments.length ? (round = !!x5, partition5) : round;
  };
  partition5.size = function(x5) {
    return arguments.length ? (dx = +x5[0], dy = +x5[1], partition5) : [dx, dy];
  };
  partition5.padding = function(x5) {
    return arguments.length ? (padding3 = +x5, partition5) : padding3;
  };
  return partition5;
}

// node_modules/d3-hierarchy/src/stratify.js
var preroot = {depth: -1};
var ambiguous = {};
function defaultId(d) {
  return d.id;
}
function defaultParentId(d) {
  return d.parentId;
}
function stratify_default() {
  var id4 = defaultId, parentId = defaultParentId;
  function stratify(data4) {
    var nodes = Array.from(data4), n = nodes.length, d, i, root2, parent, node, nodeId, nodeKey, nodeByKey = new Map();
    for (i = 0; i < n; ++i) {
      d = nodes[i], node = nodes[i] = new Node(d);
      if ((nodeId = id4(d, i, data4)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = parentId(d, i, data4)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }
    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent)
          throw new Error("missing: " + nodeId);
        if (parent === ambiguous)
          throw new Error("ambiguous: " + nodeId);
        if (parent.children)
          parent.children.push(node);
        else
          parent.children = [node];
        node.parent = parent;
      } else {
        if (root2)
          throw new Error("multiple roots");
        root2 = node;
      }
    }
    if (!root2)
      throw new Error("no root");
    root2.parent = preroot;
    root2.eachBefore(function(node2) {
      node2.depth = node2.parent.depth + 1;
      --n;
    }).eachBefore(computeHeight);
    root2.parent = null;
    if (n > 0)
      throw new Error("cycle");
    return root2;
  }
  stratify.id = function(x5) {
    return arguments.length ? (id4 = required(x5), stratify) : id4;
  };
  stratify.parentId = function(x5) {
    return arguments.length ? (parentId = required(x5), stratify) : parentId;
  };
  return stratify;
}

// node_modules/d3-hierarchy/src/tree.js
function defaultSeparation2(a2, b2) {
  return a2.parent === b2.parent ? 1 : 2;
}
function nextLeft(v) {
  var children4 = v.children;
  return children4 ? children4[0] : v.t;
}
function nextRight(v) {
  var children4 = v.children;
  return children4 ? children4[children4.length - 1] : v.t;
}
function moveSubtree(wm, wp, shift) {
  var change2 = shift / (wp.i - wm.i);
  wp.c -= change2;
  wp.s += shift;
  wm.c += change2;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v) {
  var shift = 0, change2 = 0, children4 = v.children, i = children4.length, w3;
  while (--i >= 0) {
    w3 = children4[i];
    w3.z += shift;
    w3.m += shift;
    shift += w3.s + (change2 += w3.c);
  }
}
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}
function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i;
}
TreeNode.prototype = Object.create(Node.prototype);
function treeRoot(root2) {
  var tree = new TreeNode(root2, 0), node, nodes = [tree], child, children4, i, n;
  while (node = nodes.pop()) {
    if (children4 = node._.children) {
      node.children = new Array(n = children4.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children4[i], i));
        child.parent = node;
      }
    }
  }
  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}
function tree_default() {
  var separation = defaultSeparation2, dx = 1, dy = 1, nodeSize = null;
  function tree(root2) {
    var t = treeRoot(root2);
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);
    if (nodeSize)
      root2.eachBefore(sizeNode);
    else {
      var left = root2, right = root2, bottom = root2;
      root2.eachBefore(function(node) {
        if (node.x < left.x)
          left = node;
        if (node.x > right.x)
          right = node;
        if (node.depth > bottom.depth)
          bottom = node;
      });
      var s = left === right ? 1 : separation(left, right) / 2, tx = s - left.x, kx = dx / (right.x + s + tx), ky = dy / (bottom.depth || 1);
      root2.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }
    return root2;
  }
  function firstWalk(v) {
    var children4 = v.children, siblings = v.parent.children, w3 = v.i ? siblings[v.i - 1] : null;
    if (children4) {
      executeShifts(v);
      var midpoint = (children4[0].z + children4[children4.length - 1].z) / 2;
      if (w3) {
        v.z = w3.z + separation(v._, w3._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w3) {
      v.z = w3.z + separation(v._, w3._);
    }
    v.parent.A = apportion(v, w3, v.parent.A || siblings[0]);
  }
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }
  function apportion(v, w3, ancestor) {
    if (w3) {
      var vip = v, vop = v, vim = w3, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree.separation = function(x5) {
    return arguments.length ? (separation = x5, tree) : separation;
  };
  tree.size = function(x5) {
    return arguments.length ? (nodeSize = false, dx = +x5[0], dy = +x5[1], tree) : nodeSize ? null : [dx, dy];
  };
  tree.nodeSize = function(x5) {
    return arguments.length ? (nodeSize = true, dx = +x5[0], dy = +x5[1], tree) : nodeSize ? [dx, dy] : null;
  };
  return tree;
}

// node_modules/d3-hierarchy/src/treemap/slice.js
function slice_default(parent, x06, y06, x12, y12) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (y12 - y06) / parent.value;
  while (++i < n) {
    node = nodes[i], node.x0 = x06, node.x1 = x12;
    node.y0 = y06, node.y1 = y06 += node.value * k;
  }
}

// node_modules/d3-hierarchy/src/treemap/squarify.js
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x06, y06, x12, y12) {
  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value3 = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n) {
    dx = x12 - x06, dy = y12 - y06;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value3 * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue)
        minValue = nodeValue;
      if (nodeValue > maxValue)
        maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
    if (row.dice)
      dice_default(row, x06, y06, x12, value3 ? y06 += dy * sumValue / value3 : y12);
    else
      slice_default(row, x06, y06, value3 ? x06 += dx * sumValue / value3 : x12, y12);
    value3 -= sumValue, i0 = i1;
  }
  return rows;
}
var squarify_default = function custom9(ratio) {
  function squarify(parent, x06, y06, x12, y12) {
    squarifyRatio(ratio, parent, x06, y06, x12, y12);
  }
  squarify.ratio = function(x5) {
    return custom9((x5 = +x5) > 1 ? x5 : 1);
  };
  return squarify;
}(phi);

// node_modules/d3-hierarchy/src/treemap/index.js
function treemap_default() {
  var tile = squarify_default, round = false, dx = 1, dy = 1, paddingStack = [0], paddingInner2 = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap(root2) {
    root2.x0 = root2.y0 = 0;
    root2.x1 = dx;
    root2.y1 = dy;
    root2.eachBefore(positionNode);
    paddingStack = [0];
    if (round)
      root2.eachBefore(round_default2);
    return root2;
  }
  function positionNode(node) {
    var p = paddingStack[node.depth], x06 = node.x0 + p, y06 = node.y0 + p, x12 = node.x1 - p, y12 = node.y1 - p;
    if (x12 < x06)
      x06 = x12 = (x06 + x12) / 2;
    if (y12 < y06)
      y06 = y12 = (y06 + y12) / 2;
    node.x0 = x06;
    node.y0 = y06;
    node.x1 = x12;
    node.y1 = y12;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner2(node) / 2;
      x06 += paddingLeft(node) - p;
      y06 += paddingTop(node) - p;
      x12 -= paddingRight(node) - p;
      y12 -= paddingBottom(node) - p;
      if (x12 < x06)
        x06 = x12 = (x06 + x12) / 2;
      if (y12 < y06)
        y06 = y12 = (y06 + y12) / 2;
      tile(node, x06, y06, x12, y12);
    }
  }
  treemap.round = function(x5) {
    return arguments.length ? (round = !!x5, treemap) : round;
  };
  treemap.size = function(x5) {
    return arguments.length ? (dx = +x5[0], dy = +x5[1], treemap) : [dx, dy];
  };
  treemap.tile = function(x5) {
    return arguments.length ? (tile = required(x5), treemap) : tile;
  };
  treemap.padding = function(x5) {
    return arguments.length ? treemap.paddingInner(x5).paddingOuter(x5) : treemap.paddingInner();
  };
  treemap.paddingInner = function(x5) {
    return arguments.length ? (paddingInner2 = typeof x5 === "function" ? x5 : constant_default4(+x5), treemap) : paddingInner2;
  };
  treemap.paddingOuter = function(x5) {
    return arguments.length ? treemap.paddingTop(x5).paddingRight(x5).paddingBottom(x5).paddingLeft(x5) : treemap.paddingTop();
  };
  treemap.paddingTop = function(x5) {
    return arguments.length ? (paddingTop = typeof x5 === "function" ? x5 : constant_default4(+x5), treemap) : paddingTop;
  };
  treemap.paddingRight = function(x5) {
    return arguments.length ? (paddingRight = typeof x5 === "function" ? x5 : constant_default4(+x5), treemap) : paddingRight;
  };
  treemap.paddingBottom = function(x5) {
    return arguments.length ? (paddingBottom = typeof x5 === "function" ? x5 : constant_default4(+x5), treemap) : paddingBottom;
  };
  treemap.paddingLeft = function(x5) {
    return arguments.length ? (paddingLeft = typeof x5 === "function" ? x5 : constant_default4(+x5), treemap) : paddingLeft;
  };
  return treemap;
}

// node_modules/d3-hierarchy/src/treemap/binary.js
function binary_default(parent, x06, y06, x12, y12) {
  var nodes = parent.children, i, n = nodes.length, sum2, sums = new Array(n + 1);
  for (sums[0] = sum2 = i = 0; i < n; ++i) {
    sums[i + 1] = sum2 += nodes[i].value;
  }
  partition5(0, n, parent.value, x06, y06, x12, y12);
  function partition5(i2, j, value3, x07, y07, x13, y13) {
    if (i2 >= j - 1) {
      var node = nodes[i2];
      node.x0 = x07, node.y0 = y07;
      node.x1 = x13, node.y1 = y13;
      return;
    }
    var valueOffset = sums[i2], valueTarget = value3 / 2 + valueOffset, k = i2 + 1, hi = j - 1;
    while (k < hi) {
      var mid = k + hi >>> 1;
      if (sums[mid] < valueTarget)
        k = mid + 1;
      else
        hi = mid;
    }
    if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i2 + 1 < k)
      --k;
    var valueLeft = sums[k] - valueOffset, valueRight = value3 - valueLeft;
    if (x13 - x07 > y13 - y07) {
      var xk = value3 ? (x07 * valueRight + x13 * valueLeft) / value3 : x13;
      partition5(i2, k, valueLeft, x07, y07, xk, y13);
      partition5(k, j, valueRight, xk, y07, x13, y13);
    } else {
      var yk = value3 ? (y07 * valueRight + y13 * valueLeft) / value3 : y13;
      partition5(i2, k, valueLeft, x07, y07, x13, yk);
      partition5(k, j, valueRight, x07, yk, x13, y13);
    }
  }
}

// node_modules/d3-hierarchy/src/treemap/sliceDice.js
function sliceDice_default(parent, x06, y06, x12, y12) {
  (parent.depth & 1 ? slice_default : dice_default)(parent, x06, y06, x12, y12);
}

// node_modules/d3-hierarchy/src/treemap/resquarify.js
var resquarify_default = function custom10(ratio) {
  function resquarify(parent, x06, y06, x12, y12) {
    if ((rows = parent._squarify) && rows.ratio === ratio) {
      var rows, row, nodes, i, j = -1, n, m2 = rows.length, value3 = parent.value;
      while (++j < m2) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i)
          row.value += nodes[i].value;
        if (row.dice)
          dice_default(row, x06, y06, x12, value3 ? y06 += (y12 - y06) * row.value / value3 : y12);
        else
          slice_default(row, x06, y06, value3 ? x06 += (x12 - x06) * row.value / value3 : x12, y12);
        value3 -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x06, y06, x12, y12);
      rows.ratio = ratio;
    }
  }
  resquarify.ratio = function(x5) {
    return custom10((x5 = +x5) > 1 ? x5 : 1);
  };
  return resquarify;
}(phi);

// node_modules/vega-hierarchy/build/vega-hierarchy.module.js
function lookup3(tree, key2, filter4) {
  const map4 = {};
  tree.each((node) => {
    const t = node.data;
    if (filter4(t))
      map4[key2(t)] = node;
  });
  tree.lookup = map4;
  return tree;
}
function Nest(params2) {
  Transform.call(this, null, params2);
}
Nest.Definition = {
  type: "Nest",
  metadata: {
    treesource: true,
    changes: true
  },
  params: [{
    name: "keys",
    type: "field",
    array: true
  }, {
    name: "generate",
    type: "boolean"
  }]
};
var children = (n) => n.values;
inherits(Nest, Transform, {
  transform(_, pulse2) {
    if (!pulse2.source) {
      error("Nest transform requires an upstream data source.");
    }
    var gen = _.generate, mod = _.modified(), out = pulse2.clone(), tree = this.value;
    if (!tree || mod || pulse2.changed()) {
      if (tree) {
        tree.each((node) => {
          if (node.children && isTuple(node.data)) {
            out.rem.push(node.data);
          }
        });
      }
      this.value = tree = hierarchy({
        values: array(_.keys).reduce((n, k) => {
          n.key(k);
          return n;
        }, nest()).entries(out.source)
      }, children);
      if (gen) {
        tree.each((node) => {
          if (node.children) {
            node = ingest(node.data);
            out.add.push(node);
            out.source.push(node);
          }
        });
      }
      lookup3(tree, tupleid, tupleid);
    }
    out.source.root = tree;
    return out;
  }
});
function nest() {
  const keys4 = [], nest2 = {
    entries: (array5) => entries3(apply2(array5, 0), 0),
    key: (d) => (keys4.push(d), nest2)
  };
  function apply2(array5, depth) {
    if (depth >= keys4.length) {
      return array5;
    }
    const n = array5.length, key2 = keys4[depth++], valuesByKey = {}, result = {};
    let i = -1, keyValue, value3, values4;
    while (++i < n) {
      keyValue = key2(value3 = array5[i]) + "";
      if (values4 = valuesByKey[keyValue]) {
        values4.push(value3);
      } else {
        valuesByKey[keyValue] = [value3];
      }
    }
    for (keyValue in valuesByKey) {
      result[keyValue] = apply2(valuesByKey[keyValue], depth);
    }
    return result;
  }
  function entries3(map4, depth) {
    if (++depth > keys4.length)
      return map4;
    const array5 = [];
    for (const key2 in map4) {
      array5.push({
        key: key2,
        values: entries3(map4[key2], depth)
      });
    }
    return array5;
  }
  return nest2;
}
function HierarchyLayout(params2) {
  Transform.call(this, null, params2);
}
var defaultSeparation3 = (a2, b2) => a2.parent === b2.parent ? 1 : 2;
inherits(HierarchyLayout, Transform, {
  transform(_, pulse2) {
    if (!pulse2.source || !pulse2.source.root) {
      error(this.constructor.name + " transform requires a backing tree data source.");
    }
    const layout = this.layout(_.method), fields = this.fields, root2 = pulse2.source.root, as = _.as || fields;
    if (_.field)
      root2.sum(_.field);
    else
      root2.count();
    if (_.sort)
      root2.sort(stableCompare(_.sort, (d) => d.data));
    setParams(layout, this.params, _);
    if (layout.separation) {
      layout.separation(_.separation !== false ? defaultSeparation3 : one);
    }
    try {
      this.value = layout(root2);
    } catch (err) {
      error(err);
    }
    root2.each((node) => setFields(node, fields, as));
    return pulse2.reflow(_.modified()).modifies(as).modifies("leaf");
  }
});
function setParams(layout, params2, _) {
  for (let p, i = 0, n = params2.length; i < n; ++i) {
    p = params2[i];
    if (p in _)
      layout[p](_[p]);
  }
}
function setFields(node, fields, as) {
  const t = node.data, n = fields.length - 1;
  for (let i = 0; i < n; ++i) {
    t[as[i]] = node[fields[i]];
  }
  t[as[n]] = node.children ? node.children.length : 0;
}
var Output2 = ["x", "y", "r", "depth", "children"];
function Pack(params2) {
  HierarchyLayout.call(this, params2);
}
Pack.Definition = {
  type: "Pack",
  metadata: {
    tree: true,
    modifies: true
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "padding",
    type: "number",
    default: 0
  }, {
    name: "radius",
    type: "field",
    default: null
  }, {
    name: "size",
    type: "number",
    array: true,
    length: 2
  }, {
    name: "as",
    type: "string",
    array: true,
    length: Output2.length,
    default: Output2
  }]
};
inherits(Pack, HierarchyLayout, {
  layout: pack_default,
  params: ["radius", "size", "padding"],
  fields: Output2
});
var Output$1 = ["x0", "y0", "x1", "y1", "depth", "children"];
function Partition(params2) {
  HierarchyLayout.call(this, params2);
}
Partition.Definition = {
  type: "Partition",
  metadata: {
    tree: true,
    modifies: true
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "padding",
    type: "number",
    default: 0
  }, {
    name: "round",
    type: "boolean",
    default: false
  }, {
    name: "size",
    type: "number",
    array: true,
    length: 2
  }, {
    name: "as",
    type: "string",
    array: true,
    length: Output$1.length,
    default: Output$1
  }]
};
inherits(Partition, HierarchyLayout, {
  layout: partition_default,
  params: ["size", "round", "padding"],
  fields: Output$1
});
function Stratify(params2) {
  Transform.call(this, null, params2);
}
Stratify.Definition = {
  type: "Stratify",
  metadata: {
    treesource: true
  },
  params: [{
    name: "key",
    type: "field",
    required: true
  }, {
    name: "parentKey",
    type: "field",
    required: true
  }]
};
inherits(Stratify, Transform, {
  transform(_, pulse2) {
    if (!pulse2.source) {
      error("Stratify transform requires an upstream data source.");
    }
    let tree = this.value;
    const mod = _.modified(), out = pulse2.fork(pulse2.ALL).materialize(pulse2.SOURCE), run2 = !tree || mod || pulse2.changed(pulse2.ADD_REM) || pulse2.modified(_.key.fields) || pulse2.modified(_.parentKey.fields);
    out.source = out.source.slice();
    if (run2) {
      tree = out.source.length ? lookup3(stratify_default().id(_.key).parentId(_.parentKey)(out.source), _.key, truthy) : lookup3(stratify_default()([{}]), _.key, _.key);
    }
    out.source.root = this.value = tree;
    return out;
  }
});
var Layouts = {
  tidy: tree_default,
  cluster: cluster_default
};
var Output$2 = ["x", "y", "depth", "children"];
function Tree(params2) {
  HierarchyLayout.call(this, params2);
}
Tree.Definition = {
  type: "Tree",
  metadata: {
    tree: true,
    modifies: true
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "method",
    type: "enum",
    default: "tidy",
    values: ["tidy", "cluster"]
  }, {
    name: "size",
    type: "number",
    array: true,
    length: 2
  }, {
    name: "nodeSize",
    type: "number",
    array: true,
    length: 2
  }, {
    name: "separation",
    type: "boolean",
    default: true
  }, {
    name: "as",
    type: "string",
    array: true,
    length: Output$2.length,
    default: Output$2
  }]
};
inherits(Tree, HierarchyLayout, {
  layout(method2) {
    const m2 = method2 || "tidy";
    if (has(Layouts, m2))
      return Layouts[m2]();
    else
      error("Unrecognized Tree layout method: " + m2);
  },
  params: ["size", "nodeSize"],
  fields: Output$2
});
function TreeLinks(params2) {
  Transform.call(this, [], params2);
}
TreeLinks.Definition = {
  type: "TreeLinks",
  metadata: {
    tree: true,
    generates: true,
    changes: true
  },
  params: []
};
inherits(TreeLinks, Transform, {
  transform(_, pulse2) {
    const links = this.value, tree = pulse2.source && pulse2.source.root, out = pulse2.fork(pulse2.NO_SOURCE), lut = {};
    if (!tree)
      error("TreeLinks transform requires a tree data source.");
    if (pulse2.changed(pulse2.ADD_REM)) {
      out.rem = links;
      pulse2.visit(pulse2.SOURCE, (t) => lut[tupleid(t)] = 1);
      tree.each((node) => {
        const t = node.data, p = node.parent && node.parent.data;
        if (p && lut[tupleid(t)] && lut[tupleid(p)]) {
          out.add.push(ingest({
            source: p,
            target: t
          }));
        }
      });
      this.value = out.add;
    } else if (pulse2.changed(pulse2.MOD)) {
      pulse2.visit(pulse2.MOD, (t) => lut[tupleid(t)] = 1);
      links.forEach((link2) => {
        if (lut[tupleid(link2.source)] || lut[tupleid(link2.target)]) {
          out.mod.push(link2);
        }
      });
    }
    return out;
  }
});
var Tiles = {
  binary: binary_default,
  dice: dice_default,
  slice: slice_default,
  slicedice: sliceDice_default,
  squarify: squarify_default,
  resquarify: resquarify_default
};
var Output$3 = ["x0", "y0", "x1", "y1", "depth", "children"];
function Treemap(params2) {
  HierarchyLayout.call(this, params2);
}
Treemap.Definition = {
  type: "Treemap",
  metadata: {
    tree: true,
    modifies: true
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "method",
    type: "enum",
    default: "squarify",
    values: ["squarify", "resquarify", "binary", "dice", "slice", "slicedice"]
  }, {
    name: "padding",
    type: "number",
    default: 0
  }, {
    name: "paddingInner",
    type: "number",
    default: 0
  }, {
    name: "paddingOuter",
    type: "number",
    default: 0
  }, {
    name: "paddingTop",
    type: "number",
    default: 0
  }, {
    name: "paddingRight",
    type: "number",
    default: 0
  }, {
    name: "paddingBottom",
    type: "number",
    default: 0
  }, {
    name: "paddingLeft",
    type: "number",
    default: 0
  }, {
    name: "ratio",
    type: "number",
    default: 1.618033988749895
  }, {
    name: "round",
    type: "boolean",
    default: false
  }, {
    name: "size",
    type: "number",
    array: true,
    length: 2
  }, {
    name: "as",
    type: "string",
    array: true,
    length: Output$3.length,
    default: Output$3
  }]
};
inherits(Treemap, HierarchyLayout, {
  layout() {
    const x5 = treemap_default();
    x5.ratio = (_) => {
      const t = x5.tile();
      if (t.ratio)
        x5.tile(t.ratio(_));
    };
    x5.method = (_) => {
      if (has(Tiles, _))
        x5.tile(Tiles[_]);
      else
        error("Unrecognized Treemap layout method: " + _);
    };
    return x5;
  },
  params: ["method", "ratio", "size", "round", "padding", "paddingInner", "paddingOuter", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
  fields: Output$3
});

// node_modules/vega-label/build/vega-label.module.js
var vega_label_module_exports = {};
__export(vega_label_module_exports, {
  label: () => Label
});
var ALPHA_MASK = 4278190080;
var INSIDE_OPACITY_IN_ALPHA = 268435456;
var INSIDE_OPACITY = 0.0625;
function baseBitmaps($3, data4) {
  const bitmap = $3.bitmap();
  (data4 || []).forEach((d) => bitmap.set($3(d.boundary[0]), $3(d.boundary[3])));
  return [bitmap, void 0];
}
function markBitmaps($3, avoidMarks, labelInside, isGroupArea) {
  const width2 = $3.width, height2 = $3.height, border = labelInside || isGroupArea, context3 = domCanvas(width2, height2).getContext("2d");
  avoidMarks.forEach((items2) => draw2(context3, items2, border));
  const buffer = new Uint32Array(context3.getImageData(0, 0, width2, height2).data.buffer), layer1 = $3.bitmap(), layer2 = border && $3.bitmap();
  let x5, y5, u, v, alpha;
  for (y5 = 0; y5 < height2; ++y5) {
    for (x5 = 0; x5 < width2; ++x5) {
      alpha = buffer[y5 * width2 + x5] & ALPHA_MASK;
      if (alpha) {
        u = $3(x5);
        v = $3(y5);
        if (!isGroupArea)
          layer1.set(u, v);
        if (border && alpha ^ INSIDE_OPACITY_IN_ALPHA)
          layer2.set(u, v);
      }
    }
  }
  return [layer1, layer2];
}
function draw2(context3, items2, interior) {
  if (!items2.length)
    return;
  const type2 = items2[0].mark.marktype;
  if (type2 === "group") {
    items2.forEach((group2) => {
      group2.items.forEach((mark2) => draw2(context3, mark2.items, interior));
    });
  } else {
    Marks[type2].draw(context3, {
      items: interior ? items2.map(prepare) : items2
    });
  }
}
function prepare(source4) {
  const item = rederive(source4, {});
  if (item.stroke) {
    item.strokeOpacity = 1;
  }
  if (item.fill) {
    item.fillOpacity = INSIDE_OPACITY;
    item.stroke = "#000";
    item.strokeOpacity = 1;
    item.strokeWidth = 2;
  }
  return item;
}
var DIV = 5;
var MOD2 = 31;
var SIZE = 32;
var RIGHT0 = new Uint32Array(SIZE + 1);
var RIGHT1 = new Uint32Array(SIZE + 1);
RIGHT1[0] = 0;
RIGHT0[0] = ~RIGHT1[0];
for (let i = 1; i <= SIZE; ++i) {
  RIGHT1[i] = RIGHT1[i - 1] << 1 | 1;
  RIGHT0[i] = ~RIGHT1[i];
}
function Bitmap(w3, h3) {
  const array5 = new Uint32Array(~~((w3 * h3 + SIZE) / SIZE));
  function _set(index4, mask) {
    array5[index4] |= mask;
  }
  function _clear(index4, mask) {
    array5[index4] &= mask;
  }
  return {
    array: array5,
    get: (x5, y5) => {
      const index4 = y5 * w3 + x5;
      return array5[index4 >>> DIV] & 1 << (index4 & MOD2);
    },
    set: (x5, y5) => {
      const index4 = y5 * w3 + x5;
      _set(index4 >>> DIV, 1 << (index4 & MOD2));
    },
    clear: (x5, y5) => {
      const index4 = y5 * w3 + x5;
      _clear(index4 >>> DIV, ~(1 << (index4 & MOD2)));
    },
    getRange: (x5, y5, x22, y22) => {
      let r2 = y22, start, end, indexStart, indexEnd;
      for (; r2 >= y5; --r2) {
        start = r2 * w3 + x5;
        end = r2 * w3 + x22;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;
        if (indexStart === indexEnd) {
          if (array5[indexStart] & RIGHT0[start & MOD2] & RIGHT1[(end & MOD2) + 1]) {
            return true;
          }
        } else {
          if (array5[indexStart] & RIGHT0[start & MOD2])
            return true;
          if (array5[indexEnd] & RIGHT1[(end & MOD2) + 1])
            return true;
          for (let i = indexStart + 1; i < indexEnd; ++i) {
            if (array5[i])
              return true;
          }
        }
      }
      return false;
    },
    setRange: (x5, y5, x22, y22) => {
      let start, end, indexStart, indexEnd, i;
      for (; y5 <= y22; ++y5) {
        start = y5 * w3 + x5;
        end = y5 * w3 + x22;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;
        if (indexStart === indexEnd) {
          _set(indexStart, RIGHT0[start & MOD2] & RIGHT1[(end & MOD2) + 1]);
        } else {
          _set(indexStart, RIGHT0[start & MOD2]);
          _set(indexEnd, RIGHT1[(end & MOD2) + 1]);
          for (i = indexStart + 1; i < indexEnd; ++i)
            _set(i, 4294967295);
        }
      }
    },
    clearRange: (x5, y5, x22, y22) => {
      let start, end, indexStart, indexEnd, i;
      for (; y5 <= y22; ++y5) {
        start = y5 * w3 + x5;
        end = y5 * w3 + x22;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;
        if (indexStart === indexEnd) {
          _clear(indexStart, RIGHT1[start & MOD2] | RIGHT0[(end & MOD2) + 1]);
        } else {
          _clear(indexStart, RIGHT1[start & MOD2]);
          _clear(indexEnd, RIGHT0[(end & MOD2) + 1]);
          for (i = indexStart + 1; i < indexEnd; ++i)
            _clear(i, 0);
        }
      }
    },
    outOfBounds: (x5, y5, x22, y22) => x5 < 0 || y5 < 0 || y22 >= h3 || x22 >= w3
  };
}
function scaler(width2, height2, padding3) {
  const ratio = Math.max(1, Math.sqrt(width2 * height2 / 1e6)), w3 = ~~((width2 + 2 * padding3 + ratio) / ratio), h3 = ~~((height2 + 2 * padding3 + ratio) / ratio), scale7 = (_) => ~~((_ + padding3) / ratio);
  scale7.invert = (_) => _ * ratio - padding3;
  scale7.bitmap = () => Bitmap(w3, h3);
  scale7.ratio = ratio;
  scale7.padding = padding3;
  scale7.width = width2;
  scale7.height = height2;
  return scale7;
}
function placeAreaLabelNaive($3, bitmaps, avoidBaseMark, markIndex) {
  const width2 = $3.width, height2 = $3.height;
  return function(d) {
    const items2 = d.datum.datum.items[markIndex].items, n = items2.length, textHeight = d.datum.fontSize, textWidth = textMetrics.width(d.datum, d.datum.text);
    let maxAreaWidth = 0, x12, x22, y12, y22, x5, y5, areaWidth;
    for (let i = 0; i < n; ++i) {
      x12 = items2[i].x;
      y12 = items2[i].y;
      x22 = items2[i].x2 === void 0 ? x12 : items2[i].x2;
      y22 = items2[i].y2 === void 0 ? y12 : items2[i].y2;
      x5 = (x12 + x22) / 2;
      y5 = (y12 + y22) / 2;
      areaWidth = Math.abs(x22 - x12 + y22 - y12);
      if (areaWidth >= maxAreaWidth) {
        maxAreaWidth = areaWidth;
        d.x = x5;
        d.y = y5;
      }
    }
    x5 = textWidth / 2;
    y5 = textHeight / 2;
    x12 = d.x - x5;
    x22 = d.x + x5;
    y12 = d.y - y5;
    y22 = d.y + y5;
    d.align = "center";
    if (x12 < 0 && x22 <= width2) {
      d.align = "left";
    } else if (0 <= x12 && width2 < x22) {
      d.align = "right";
    }
    d.baseline = "middle";
    if (y12 < 0 && y22 <= height2) {
      d.baseline = "top";
    } else if (0 <= y12 && height2 < y22) {
      d.baseline = "bottom";
    }
    return true;
  };
}
function outOfBounds(x5, y5, textWidth, textHeight, width2, height2) {
  let r2 = textWidth / 2;
  return x5 - r2 < 0 || x5 + r2 > width2 || y5 - (r2 = textHeight / 2) < 0 || y5 + r2 > height2;
}
function collision($3, x5, y5, textHeight, textWidth, h3, bm0, bm1) {
  const w3 = textWidth * h3 / (textHeight * 2), x12 = $3(x5 - w3), x22 = $3(x5 + w3), y12 = $3(y5 - (h3 = h3 / 2)), y22 = $3(y5 + h3);
  return bm0.outOfBounds(x12, y12, x22, y22) || bm0.getRange(x12, y12, x22, y22) || bm1 && bm1.getRange(x12, y12, x22, y22);
}
function placeAreaLabelReducedSearch($3, bitmaps, avoidBaseMark, markIndex) {
  const width2 = $3.width, height2 = $3.height, bm0 = bitmaps[0], bm1 = bitmaps[1];
  function tryLabel(_x, _y, maxSize, textWidth, textHeight) {
    const x5 = $3.invert(_x), y5 = $3.invert(_y);
    let lo = maxSize, hi = height2, mid;
    if (!outOfBounds(x5, y5, textWidth, textHeight, width2, height2) && !collision($3, x5, y5, textHeight, textWidth, lo, bm0, bm1) && !collision($3, x5, y5, textHeight, textWidth, textHeight, bm0, null)) {
      while (hi - lo >= 1) {
        mid = (lo + hi) / 2;
        if (collision($3, x5, y5, textHeight, textWidth, mid, bm0, bm1)) {
          hi = mid;
        } else {
          lo = mid;
        }
      }
      if (lo > maxSize) {
        return [x5, y5, lo, true];
      }
    }
  }
  return function(d) {
    const items2 = d.datum.datum.items[markIndex].items, n = items2.length, textHeight = d.datum.fontSize, textWidth = textMetrics.width(d.datum, d.datum.text);
    let maxSize = avoidBaseMark ? textHeight : 0, labelPlaced = false, labelPlaced2 = false, maxAreaWidth = 0, x12, x22, y12, y22, x5, y5, _x, _y, _x1, _xMid, _x2, _y1, _yMid, _y2, areaWidth, result, swapTmp;
    for (let i = 0; i < n; ++i) {
      x12 = items2[i].x;
      y12 = items2[i].y;
      x22 = items2[i].x2 === void 0 ? x12 : items2[i].x2;
      y22 = items2[i].y2 === void 0 ? y12 : items2[i].y2;
      if (x12 > x22) {
        swapTmp = x12;
        x12 = x22;
        x22 = swapTmp;
      }
      if (y12 > y22) {
        swapTmp = y12;
        y12 = y22;
        y22 = swapTmp;
      }
      _x1 = $3(x12);
      _x2 = $3(x22);
      _xMid = ~~((_x1 + _x2) / 2);
      _y1 = $3(y12);
      _y2 = $3(y22);
      _yMid = ~~((_y1 + _y2) / 2);
      for (_x = _xMid; _x >= _x1; --_x) {
        for (_y = _yMid; _y >= _y1; --_y) {
          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);
          if (result) {
            [d.x, d.y, maxSize, labelPlaced] = result;
          }
        }
      }
      for (_x = _xMid; _x <= _x2; ++_x) {
        for (_y = _yMid; _y <= _y2; ++_y) {
          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);
          if (result) {
            [d.x, d.y, maxSize, labelPlaced] = result;
          }
        }
      }
      if (!labelPlaced && !avoidBaseMark) {
        areaWidth = Math.abs(x22 - x12 + y22 - y12);
        x5 = (x12 + x22) / 2;
        y5 = (y12 + y22) / 2;
        if (areaWidth >= maxAreaWidth && !outOfBounds(x5, y5, textWidth, textHeight, width2, height2) && !collision($3, x5, y5, textHeight, textWidth, textHeight, bm0, null)) {
          maxAreaWidth = areaWidth;
          d.x = x5;
          d.y = y5;
          labelPlaced2 = true;
        }
      }
    }
    if (labelPlaced || labelPlaced2) {
      x5 = textWidth / 2;
      y5 = textHeight / 2;
      bm0.setRange($3(d.x - x5), $3(d.y - y5), $3(d.x + x5), $3(d.y + y5));
      d.align = "center";
      d.baseline = "middle";
      return true;
    } else {
      return false;
    }
  };
}
var X_DIR = [-1, -1, 1, 1];
var Y_DIR = [-1, 1, -1, 1];
function placeAreaLabelFloodFill($3, bitmaps, avoidBaseMark, markIndex) {
  const width2 = $3.width, height2 = $3.height, bm0 = bitmaps[0], bm1 = bitmaps[1], bm2 = $3.bitmap();
  return function(d) {
    const items2 = d.datum.datum.items[markIndex].items, n = items2.length, textHeight = d.datum.fontSize, textWidth = textMetrics.width(d.datum, d.datum.text), stack3 = [];
    let maxSize = avoidBaseMark ? textHeight : 0, labelPlaced = false, labelPlaced2 = false, maxAreaWidth = 0, x12, x22, y12, y22, x5, y5, _x, _y, lo, hi, mid, areaWidth;
    for (let i = 0; i < n; ++i) {
      x12 = items2[i].x;
      y12 = items2[i].y;
      x22 = items2[i].x2 === void 0 ? x12 : items2[i].x2;
      y22 = items2[i].y2 === void 0 ? y12 : items2[i].y2;
      stack3.push([$3((x12 + x22) / 2), $3((y12 + y22) / 2)]);
      while (stack3.length) {
        [_x, _y] = stack3.pop();
        if (bm0.get(_x, _y) || bm1.get(_x, _y) || bm2.get(_x, _y))
          continue;
        bm2.set(_x, _y);
        for (let j = 0; j < 4; ++j) {
          x5 = _x + X_DIR[j];
          y5 = _y + Y_DIR[j];
          if (!bm2.outOfBounds(x5, y5, x5, y5))
            stack3.push([x5, y5]);
        }
        x5 = $3.invert(_x);
        y5 = $3.invert(_y);
        lo = maxSize;
        hi = height2;
        if (!outOfBounds(x5, y5, textWidth, textHeight, width2, height2) && !collision($3, x5, y5, textHeight, textWidth, lo, bm0, bm1) && !collision($3, x5, y5, textHeight, textWidth, textHeight, bm0, null)) {
          while (hi - lo >= 1) {
            mid = (lo + hi) / 2;
            if (collision($3, x5, y5, textHeight, textWidth, mid, bm0, bm1)) {
              hi = mid;
            } else {
              lo = mid;
            }
          }
          if (lo > maxSize) {
            d.x = x5;
            d.y = y5;
            maxSize = lo;
            labelPlaced = true;
          }
        }
      }
      if (!labelPlaced && !avoidBaseMark) {
        areaWidth = Math.abs(x22 - x12 + y22 - y12);
        x5 = (x12 + x22) / 2;
        y5 = (y12 + y22) / 2;
        if (areaWidth >= maxAreaWidth && !outOfBounds(x5, y5, textWidth, textHeight, width2, height2) && !collision($3, x5, y5, textHeight, textWidth, textHeight, bm0, null)) {
          maxAreaWidth = areaWidth;
          d.x = x5;
          d.y = y5;
          labelPlaced2 = true;
        }
      }
    }
    if (labelPlaced || labelPlaced2) {
      x5 = textWidth / 2;
      y5 = textHeight / 2;
      bm0.setRange($3(d.x - x5), $3(d.y - y5), $3(d.x + x5), $3(d.y + y5));
      d.align = "center";
      d.baseline = "middle";
      return true;
    } else {
      return false;
    }
  };
}
var Aligns = ["right", "center", "left"];
var Baselines = ["bottom", "middle", "top"];
function placeMarkLabel($3, bitmaps, anchors, offsets2) {
  const width2 = $3.width, height2 = $3.height, bm0 = bitmaps[0], bm1 = bitmaps[1], n = offsets2.length;
  return function(d) {
    const boundary = d.boundary, textHeight = d.datum.fontSize;
    if (boundary[2] < 0 || boundary[5] < 0 || boundary[0] > width2 || boundary[3] > height2) {
      return false;
    }
    let textWidth = 0, dx, dy, isInside, sizeFactor, insideFactor, x12, x22, y12, y22, xc, yc, _x1, _x2, _y1, _y2;
    for (let i = 0; i < n; ++i) {
      dx = (anchors[i] & 3) - 1;
      dy = (anchors[i] >>> 2 & 3) - 1;
      isInside = dx === 0 && dy === 0 || offsets2[i] < 0;
      sizeFactor = dx && dy ? Math.SQRT1_2 : 1;
      insideFactor = offsets2[i] < 0 ? -1 : 1;
      x12 = boundary[1 + dx] + offsets2[i] * dx * sizeFactor;
      yc = boundary[4 + dy] + insideFactor * textHeight * dy / 2 + offsets2[i] * dy * sizeFactor;
      y12 = yc - textHeight / 2;
      y22 = yc + textHeight / 2;
      _x1 = $3(x12);
      _y1 = $3(y12);
      _y2 = $3(y22);
      if (!textWidth) {
        if (!test(_x1, _x1, _y1, _y2, bm0, bm1, x12, x12, y12, y22, boundary, isInside)) {
          continue;
        } else {
          textWidth = textMetrics.width(d.datum, d.datum.text);
        }
      }
      xc = x12 + insideFactor * textWidth * dx / 2;
      x12 = xc - textWidth / 2;
      x22 = xc + textWidth / 2;
      _x1 = $3(x12);
      _x2 = $3(x22);
      if (test(_x1, _x2, _y1, _y2, bm0, bm1, x12, x22, y12, y22, boundary, isInside)) {
        d.x = !dx ? xc : dx * insideFactor < 0 ? x22 : x12;
        d.y = !dy ? yc : dy * insideFactor < 0 ? y22 : y12;
        d.align = Aligns[dx * insideFactor + 1];
        d.baseline = Baselines[dy * insideFactor + 1];
        bm0.setRange(_x1, _y1, _x2, _y2);
        return true;
      }
    }
    return false;
  };
}
function test(_x1, _x2, _y1, _y2, bm0, bm1, x12, x22, y12, y22, boundary, isInside) {
  return !(bm0.outOfBounds(_x1, _y1, _x2, _y2) || (isInside && bm1 ? bm1.getRange(_x1, _y1, _x2, _y2) || !isInMarkBound(x12, y12, x22, y22, boundary) : bm0.getRange(_x1, _y1, _x2, _y2)));
}
function isInMarkBound(x12, y12, x22, y22, boundary) {
  return boundary[0] <= x12 && x22 <= boundary[2] && boundary[3] <= y12 && y22 <= boundary[5];
}
var TOP = 0;
var MIDDLE = 4;
var BOTTOM = 8;
var LEFT = 0;
var CENTER = 1;
var RIGHT = 2;
var anchorCode = {
  "top-left": TOP + LEFT,
  top: TOP + CENTER,
  "top-right": TOP + RIGHT,
  left: MIDDLE + LEFT,
  middle: MIDDLE + CENTER,
  right: MIDDLE + RIGHT,
  "bottom-left": BOTTOM + LEFT,
  bottom: BOTTOM + CENTER,
  "bottom-right": BOTTOM + RIGHT
};
var placeAreaLabel = {
  naive: placeAreaLabelNaive,
  "reduced-search": placeAreaLabelReducedSearch,
  floodfill: placeAreaLabelFloodFill
};
function labelLayout(texts, size, compare4, offset4, anchor, avoidMarks, avoidBaseMark, lineAnchor, markIndex, padding3, method2) {
  if (!texts.length)
    return texts;
  const positions = Math.max(offset4.length, anchor.length), offsets2 = getOffsets(offset4, positions), anchors = getAnchors(anchor, positions), marktype = markType(texts[0].datum), grouptype = marktype === "group" && texts[0].datum.items[markIndex].marktype, isGroupArea = grouptype === "area", boundary = markBoundary(marktype, grouptype, lineAnchor, markIndex), $3 = scaler(size[0], size[1], padding3), isNaiveGroupArea = isGroupArea && method2 === "naive";
  const data4 = texts.map((d) => ({
    datum: d,
    opacity: 0,
    x: void 0,
    y: void 0,
    align: void 0,
    baseline: void 0,
    boundary: boundary(d)
  }));
  let bitmaps;
  if (!isNaiveGroupArea) {
    if (compare4) {
      data4.sort((a2, b2) => compare4(a2.datum, b2.datum));
    }
    let labelInside = false;
    for (let i = 0; i < anchors.length && !labelInside; ++i) {
      labelInside = anchors[i] === 5 || offsets2[i] < 0;
    }
    if (marktype && (avoidBaseMark || isGroupArea)) {
      avoidMarks = [texts.map((d) => d.datum)].concat(avoidMarks);
    }
    bitmaps = avoidMarks.length ? markBitmaps($3, avoidMarks, labelInside, isGroupArea) : baseBitmaps($3, avoidBaseMark && data4);
  }
  const place2 = isGroupArea ? placeAreaLabel[method2]($3, bitmaps, avoidBaseMark, markIndex) : placeMarkLabel($3, bitmaps, anchors, offsets2);
  data4.forEach((d) => d.opacity = +place2(d));
  return data4;
}
function getOffsets(_, count2) {
  const offsets2 = new Float64Array(count2), n = _.length;
  for (let i = 0; i < n; ++i)
    offsets2[i] = _[i] || 0;
  for (let i = n; i < count2; ++i)
    offsets2[i] = offsets2[n - 1];
  return offsets2;
}
function getAnchors(_, count2) {
  const anchors = new Int8Array(count2), n = _.length;
  for (let i = 0; i < n; ++i)
    anchors[i] |= anchorCode[_[i]];
  for (let i = n; i < count2; ++i)
    anchors[i] = anchors[n - 1];
  return anchors;
}
function markType(item) {
  return item && item.mark && item.mark.marktype;
}
function markBoundary(marktype, grouptype, lineAnchor, markIndex) {
  const xy = (d) => [d.x, d.x, d.x, d.y, d.y, d.y];
  if (!marktype) {
    return xy;
  } else if (marktype === "line" || marktype === "area") {
    return (d) => xy(d.datum);
  } else if (grouptype === "line") {
    return (d) => {
      const items2 = d.datum.items[markIndex].items;
      return xy(items2.length ? items2[lineAnchor === "start" ? 0 : items2.length - 1] : {
        x: NaN,
        y: NaN
      });
    };
  } else {
    return (d) => {
      const b2 = d.datum.bounds;
      return [b2.x1, (b2.x1 + b2.x2) / 2, b2.x2, b2.y1, (b2.y1 + b2.y2) / 2, b2.y2];
    };
  }
}
var Output3 = ["x", "y", "opacity", "align", "baseline"];
var Anchors = ["top-left", "left", "bottom-left", "top", "bottom", "top-right", "right", "bottom-right"];
function Label(params2) {
  Transform.call(this, null, params2);
}
Label.Definition = {
  type: "Label",
  metadata: {
    modifies: true
  },
  params: [{
    name: "size",
    type: "number",
    array: true,
    length: 2,
    required: true
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "anchor",
    type: "string",
    array: true,
    default: Anchors
  }, {
    name: "offset",
    type: "number",
    array: true,
    default: [1]
  }, {
    name: "padding",
    type: "number",
    default: 0
  }, {
    name: "lineAnchor",
    type: "string",
    values: ["start", "end"],
    default: "end"
  }, {
    name: "markIndex",
    type: "number",
    default: 0
  }, {
    name: "avoidBaseMark",
    type: "boolean",
    default: true
  }, {
    name: "avoidMarks",
    type: "data",
    array: true
  }, {
    name: "method",
    type: "string",
    default: "naive"
  }, {
    name: "as",
    type: "string",
    array: true,
    length: Output3.length,
    default: Output3
  }]
};
inherits(Label, Transform, {
  transform(_, pulse2) {
    function modp(param2) {
      const p = _[param2];
      return isFunction(p) && pulse2.modified(p.fields);
    }
    const mod = _.modified();
    if (!(mod || pulse2.changed(pulse2.ADD_REM) || modp("sort")))
      return;
    if (!_.size || _.size.length !== 2) {
      error("Size parameter should be specified as a [width, height] array.");
    }
    const as = _.as || Output3;
    labelLayout(pulse2.materialize(pulse2.SOURCE).source, _.size, _.sort, array(_.offset || 1), array(_.anchor || Anchors), _.avoidMarks || [], _.avoidBaseMark === false ? false : true, _.lineAnchor || "end", _.markIndex || 0, _.padding || 0, _.method || "naive").forEach((l) => {
      const t = l.datum;
      t[as[0]] = l.x;
      t[as[1]] = l.y;
      t[as[2]] = l.opacity;
      t[as[3]] = l.align;
      t[as[4]] = l.baseline;
    });
    return pulse2.reflow(mod).modifies(as);
  }
});

// node_modules/vega-regression/build/vega-regression.module.js
var vega_regression_module_exports = {};
__export(vega_regression_module_exports, {
  loess: () => Loess,
  regression: () => Regression
});
function partition4(data4, groupby) {
  var groups = [], get6 = function(f) {
    return f(t);
  }, map4, i, n, t, k, g;
  if (groupby == null) {
    groups.push(data4);
  } else {
    for (map4 = {}, i = 0, n = data4.length; i < n; ++i) {
      t = data4[i];
      k = groupby.map(get6);
      g = map4[k];
      if (!g) {
        map4[k] = g = [];
        g.dims = k;
        groups.push(g);
      }
      g.push(t);
    }
  }
  return groups;
}
function Loess(params2) {
  Transform.call(this, null, params2);
}
Loess.Definition = {
  type: "Loess",
  metadata: {
    generates: true
  },
  params: [{
    name: "x",
    type: "field",
    required: true
  }, {
    name: "y",
    type: "field",
    required: true
  }, {
    name: "groupby",
    type: "field",
    array: true
  }, {
    name: "bandwidth",
    type: "number",
    default: 0.3
  }, {
    name: "as",
    type: "string",
    array: true
  }]
};
inherits(Loess, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    if (!this.value || pulse2.changed() || _.modified()) {
      const source4 = pulse2.materialize(pulse2.SOURCE).source, groups = partition4(source4, _.groupby), names = (_.groupby || []).map(accessorName), m2 = names.length, as = _.as || [accessorName(_.x), accessorName(_.y)], values4 = [];
      groups.forEach((g) => {
        loess(g, _.x, _.y, _.bandwidth || 0.3).forEach((p) => {
          const t = {};
          for (let i = 0; i < m2; ++i) {
            t[names[i]] = g.dims[i];
          }
          t[as[0]] = p[0];
          t[as[1]] = p[1];
          values4.push(ingest(t));
        });
      });
      if (this.value)
        out.rem = this.value;
      this.value = out.add = out.source = values4;
    }
    return out;
  }
});
var Methods2 = {
  linear,
  log: log2,
  exp: exp2,
  pow: pow2,
  quad,
  poly
};
var degreesOfFreedom = (method2, order) => method2 === "poly" ? order : method2 === "quad" ? 2 : 1;
function Regression(params2) {
  Transform.call(this, null, params2);
}
Regression.Definition = {
  type: "Regression",
  metadata: {
    generates: true
  },
  params: [{
    name: "x",
    type: "field",
    required: true
  }, {
    name: "y",
    type: "field",
    required: true
  }, {
    name: "groupby",
    type: "field",
    array: true
  }, {
    name: "method",
    type: "string",
    default: "linear",
    values: Object.keys(Methods2)
  }, {
    name: "order",
    type: "number",
    default: 3
  }, {
    name: "extent",
    type: "number",
    array: true,
    length: 2
  }, {
    name: "params",
    type: "boolean",
    default: false
  }, {
    name: "as",
    type: "string",
    array: true
  }]
};
inherits(Regression, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    if (!this.value || pulse2.changed() || _.modified()) {
      const source4 = pulse2.materialize(pulse2.SOURCE).source, groups = partition4(source4, _.groupby), names = (_.groupby || []).map(accessorName), method2 = _.method || "linear", order = _.order || 3, dof = degreesOfFreedom(method2, order), as = _.as || [accessorName(_.x), accessorName(_.y)], fit3 = Methods2[method2], values4 = [];
      let domain4 = _.extent;
      if (!has(Methods2, method2)) {
        error("Invalid regression method: " + method2);
      }
      if (domain4 != null) {
        if (method2 === "log" && domain4[0] <= 0) {
          pulse2.dataflow.warn("Ignoring extent with values <= 0 for log regression.");
          domain4 = null;
        }
      }
      groups.forEach((g) => {
        const n = g.length;
        if (n <= dof) {
          pulse2.dataflow.warn("Skipping regression with more parameters than data points.");
          return;
        }
        const model = fit3(g, _.x, _.y, order);
        if (_.params) {
          values4.push(ingest({
            keys: g.dims,
            coef: model.coef,
            rSquared: model.rSquared
          }));
          return;
        }
        const dom = domain4 || extent(g, _.x), add6 = (p) => {
          const t = {};
          for (let i = 0; i < names.length; ++i) {
            t[names[i]] = g.dims[i];
          }
          t[as[0]] = p[0];
          t[as[1]] = p[1];
          values4.push(ingest(t));
        };
        if (method2 === "linear") {
          dom.forEach((x5) => add6([x5, model.predict(x5)]));
        } else {
          sampleCurve(model.predict, dom, 25, 200).forEach(add6);
        }
      });
      if (this.value)
        out.rem = this.value;
      this.value = out.add = out.source = values4;
    }
    return out;
  }
});

// node_modules/vega-voronoi/build/vega-voronoi.module.js
var vega_voronoi_module_exports = {};
__export(vega_voronoi_module_exports, {
  voronoi: () => Voronoi2
});

// node_modules/delaunator/index.js
var EPSILON2 = Math.pow(2, -52);
var EDGE_STACK = new Uint32Array(512);
var Delaunator = class {
  static from(points2, getX = defaultGetX, getY = defaultGetY) {
    const n = points2.length;
    const coords = new Float64Array(n * 2);
    for (let i = 0; i < n; i++) {
      const p = points2[i];
      coords[2 * i] = getX(p);
      coords[2 * i + 1] = getY(p);
    }
    return new Delaunator(coords);
  }
  constructor(coords) {
    const n = coords.length >> 1;
    if (n > 0 && typeof coords[0] !== "number")
      throw new Error("Expected coords to contain numbers.");
    this.coords = coords;
    const maxTriangles = Math.max(2 * n - 5, 0);
    this._triangles = new Uint32Array(maxTriangles * 3);
    this._halfedges = new Int32Array(maxTriangles * 3);
    this._hashSize = Math.ceil(Math.sqrt(n));
    this._hullPrev = new Uint32Array(n);
    this._hullNext = new Uint32Array(n);
    this._hullTri = new Uint32Array(n);
    this._hullHash = new Int32Array(this._hashSize).fill(-1);
    this._ids = new Uint32Array(n);
    this._dists = new Float64Array(n);
    this.update();
  }
  update() {
    const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} = this;
    const n = coords.length >> 1;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY2 = -Infinity;
    for (let i = 0; i < n; i++) {
      const x5 = coords[2 * i];
      const y5 = coords[2 * i + 1];
      if (x5 < minX)
        minX = x5;
      if (y5 < minY)
        minY = y5;
      if (x5 > maxX)
        maxX = x5;
      if (y5 > maxY2)
        maxY2 = y5;
      this._ids[i] = i;
    }
    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY2) / 2;
    let minDist = Infinity;
    let i0, i1, i2;
    for (let i = 0; i < n; i++) {
      const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
      if (d < minDist) {
        i0 = i;
        minDist = d;
      }
    }
    const i0x = coords[2 * i0];
    const i0y = coords[2 * i0 + 1];
    minDist = Infinity;
    for (let i = 0; i < n; i++) {
      if (i === i0)
        continue;
      const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
      if (d < minDist && d > 0) {
        i1 = i;
        minDist = d;
      }
    }
    let i1x = coords[2 * i1];
    let i1y = coords[2 * i1 + 1];
    let minRadius = Infinity;
    for (let i = 0; i < n; i++) {
      if (i === i0 || i === i1)
        continue;
      const r2 = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
      if (r2 < minRadius) {
        i2 = i;
        minRadius = r2;
      }
    }
    let i2x = coords[2 * i2];
    let i2y = coords[2 * i2 + 1];
    if (minRadius === Infinity) {
      for (let i = 0; i < n; i++) {
        this._dists[i] = coords[2 * i] - coords[0] || coords[2 * i + 1] - coords[1];
      }
      quicksort(this._ids, this._dists, 0, n - 1);
      const hull = new Uint32Array(n);
      let j = 0;
      for (let i = 0, d0 = -Infinity; i < n; i++) {
        const id4 = this._ids[i];
        if (this._dists[id4] > d0) {
          hull[j++] = id4;
          d0 = this._dists[id4];
        }
      }
      this.hull = hull.subarray(0, j);
      this.triangles = new Uint32Array(0);
      this.halfedges = new Uint32Array(0);
      return;
    }
    if (orient(i0x, i0y, i1x, i1y, i2x, i2y)) {
      const i = i1;
      const x5 = i1x;
      const y5 = i1y;
      i1 = i2;
      i1x = i2x;
      i1y = i2y;
      i2 = i;
      i2x = x5;
      i2y = y5;
    }
    const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
    this._cx = center.x;
    this._cy = center.y;
    for (let i = 0; i < n; i++) {
      this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
    }
    quicksort(this._ids, this._dists, 0, n - 1);
    this._hullStart = i0;
    let hullSize = 3;
    hullNext[i0] = hullPrev[i2] = i1;
    hullNext[i1] = hullPrev[i0] = i2;
    hullNext[i2] = hullPrev[i1] = i0;
    hullTri[i0] = 0;
    hullTri[i1] = 1;
    hullTri[i2] = 2;
    hullHash.fill(-1);
    hullHash[this._hashKey(i0x, i0y)] = i0;
    hullHash[this._hashKey(i1x, i1y)] = i1;
    hullHash[this._hashKey(i2x, i2y)] = i2;
    this.trianglesLen = 0;
    this._addTriangle(i0, i1, i2, -1, -1, -1);
    for (let k = 0, xp, yp; k < this._ids.length; k++) {
      const i = this._ids[k];
      const x5 = coords[2 * i];
      const y5 = coords[2 * i + 1];
      if (k > 0 && Math.abs(x5 - xp) <= EPSILON2 && Math.abs(y5 - yp) <= EPSILON2)
        continue;
      xp = x5;
      yp = y5;
      if (i === i0 || i === i1 || i === i2)
        continue;
      let start = 0;
      for (let j = 0, key2 = this._hashKey(x5, y5); j < this._hashSize; j++) {
        start = hullHash[(key2 + j) % this._hashSize];
        if (start !== -1 && start !== hullNext[start])
          break;
      }
      start = hullPrev[start];
      let e = start, q;
      while (q = hullNext[e], !orient(x5, y5, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1])) {
        e = q;
        if (e === start) {
          e = -1;
          break;
        }
      }
      if (e === -1)
        continue;
      let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);
      hullTri[i] = this._legalize(t + 2);
      hullTri[e] = t;
      hullSize++;
      let n2 = hullNext[e];
      while (q = hullNext[n2], orient(x5, y5, coords[2 * n2], coords[2 * n2 + 1], coords[2 * q], coords[2 * q + 1])) {
        t = this._addTriangle(n2, i, q, hullTri[i], -1, hullTri[n2]);
        hullTri[i] = this._legalize(t + 2);
        hullNext[n2] = n2;
        hullSize--;
        n2 = q;
      }
      if (e === start) {
        while (q = hullPrev[e], orient(x5, y5, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1])) {
          t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
          this._legalize(t + 2);
          hullTri[q] = t;
          hullNext[e] = e;
          hullSize--;
          e = q;
        }
      }
      this._hullStart = hullPrev[i] = e;
      hullNext[e] = hullPrev[n2] = i;
      hullNext[i] = n2;
      hullHash[this._hashKey(x5, y5)] = i;
      hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
    }
    this.hull = new Uint32Array(hullSize);
    for (let i = 0, e = this._hullStart; i < hullSize; i++) {
      this.hull[i] = e;
      e = hullNext[e];
    }
    this.triangles = this._triangles.subarray(0, this.trianglesLen);
    this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }
  _hashKey(x5, y5) {
    return Math.floor(pseudoAngle(x5 - this._cx, y5 - this._cy) * this._hashSize) % this._hashSize;
  }
  _legalize(a2) {
    const {_triangles: triangles, _halfedges: halfedges, coords} = this;
    let i = 0;
    let ar = 0;
    while (true) {
      const b2 = halfedges[a2];
      const a0 = a2 - a2 % 3;
      ar = a0 + (a2 + 2) % 3;
      if (b2 === -1) {
        if (i === 0)
          break;
        a2 = EDGE_STACK[--i];
        continue;
      }
      const b0 = b2 - b2 % 3;
      const al = a0 + (a2 + 1) % 3;
      const bl2 = b0 + (b2 + 2) % 3;
      const p02 = triangles[ar];
      const pr = triangles[a2];
      const pl = triangles[al];
      const p1 = triangles[bl2];
      const illegal = inCircle(coords[2 * p02], coords[2 * p02 + 1], coords[2 * pr], coords[2 * pr + 1], coords[2 * pl], coords[2 * pl + 1], coords[2 * p1], coords[2 * p1 + 1]);
      if (illegal) {
        triangles[a2] = p1;
        triangles[b2] = p02;
        const hbl = halfedges[bl2];
        if (hbl === -1) {
          let e = this._hullStart;
          do {
            if (this._hullTri[e] === bl2) {
              this._hullTri[e] = a2;
              break;
            }
            e = this._hullPrev[e];
          } while (e !== this._hullStart);
        }
        this._link(a2, hbl);
        this._link(b2, halfedges[ar]);
        this._link(ar, bl2);
        const br2 = b0 + (b2 + 1) % 3;
        if (i < EDGE_STACK.length) {
          EDGE_STACK[i++] = br2;
        }
      } else {
        if (i === 0)
          break;
        a2 = EDGE_STACK[--i];
      }
    }
    return ar;
  }
  _link(a2, b2) {
    this._halfedges[a2] = b2;
    if (b2 !== -1)
      this._halfedges[b2] = a2;
  }
  _addTriangle(i0, i1, i2, a2, b2, c2) {
    const t = this.trianglesLen;
    this._triangles[t] = i0;
    this._triangles[t + 1] = i1;
    this._triangles[t + 2] = i2;
    this._link(t, a2);
    this._link(t + 1, b2);
    this._link(t + 2, c2);
    this.trianglesLen += 3;
    return t;
  }
};
var delaunator_default = Delaunator;
function pseudoAngle(dx, dy) {
  const p = dx / (Math.abs(dx) + Math.abs(dy));
  return (dy > 0 ? 3 - p : 1 + p) / 4;
}
function dist(ax, ay, bx, by) {
  const dx = ax - bx;
  const dy = ay - by;
  return dx * dx + dy * dy;
}
function orientIfSure(px2, py2, rx, ry, qx, qy) {
  const l = (ry - py2) * (qx - px2);
  const r2 = (rx - px2) * (qy - py2);
  return Math.abs(l - r2) >= 33306690738754716e-32 * Math.abs(l + r2) ? l - r2 : 0;
}
function orient(rx, ry, qx, qy, px2, py2) {
  const sign3 = orientIfSure(px2, py2, rx, ry, qx, qy) || orientIfSure(rx, ry, qx, qy, px2, py2) || orientIfSure(qx, qy, px2, py2, rx, ry);
  return sign3 < 0;
}
function inCircle(ax, ay, bx, by, cx, cy, px2, py2) {
  const dx = ax - px2;
  const dy = ay - py2;
  const ex = bx - px2;
  const ey = by - py2;
  const fx = cx - px2;
  const fy = cy - py2;
  const ap = dx * dx + dy * dy;
  const bp = ex * ex + ey * ey;
  const cp = fx * fx + fy * fy;
  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}
function circumradius(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl2 = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x5 = (ey * bl2 - dy * cl) * d;
  const y5 = (dx * cl - ex * bl2) * d;
  return x5 * x5 + y5 * y5;
}
function circumcenter(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl2 = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x5 = ax + (ey * bl2 - dy * cl) * d;
  const y5 = ay + (dx * cl - ex * bl2) * d;
  return {x: x5, y: y5};
}
function quicksort(ids, dists, left, right) {
  if (right - left <= 20) {
    for (let i = left + 1; i <= right; i++) {
      const temp2 = ids[i];
      const tempDist = dists[temp2];
      let j = i - 1;
      while (j >= left && dists[ids[j]] > tempDist)
        ids[j + 1] = ids[j--];
      ids[j + 1] = temp2;
    }
  } else {
    const median = left + right >> 1;
    let i = left + 1;
    let j = right;
    swap2(ids, median, i);
    if (dists[ids[left]] > dists[ids[right]])
      swap2(ids, left, right);
    if (dists[ids[i]] > dists[ids[right]])
      swap2(ids, i, right);
    if (dists[ids[left]] > dists[ids[i]])
      swap2(ids, left, i);
    const temp2 = ids[i];
    const tempDist = dists[temp2];
    while (true) {
      do
        i++;
      while (dists[ids[i]] < tempDist);
      do
        j--;
      while (dists[ids[j]] > tempDist);
      if (j < i)
        break;
      swap2(ids, i, j);
    }
    ids[left + 1] = ids[j];
    ids[j] = temp2;
    if (right - i + 1 >= j - left) {
      quicksort(ids, dists, i, right);
      quicksort(ids, dists, left, j - 1);
    } else {
      quicksort(ids, dists, left, j - 1);
      quicksort(ids, dists, i, right);
    }
  }
}
function swap2(arr, i, j) {
  const tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function defaultGetX(p) {
  return p[0];
}
function defaultGetY(p) {
  return p[1];
}

// node_modules/d3-delaunay/src/path.js
var epsilon6 = 1e-6;
var Path2 = class {
  constructor() {
    this._x0 = this._y0 = this._x1 = this._y1 = null;
    this._ = "";
  }
  moveTo(x5, y5) {
    this._ += `M${this._x0 = this._x1 = +x5},${this._y0 = this._y1 = +y5}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  }
  lineTo(x5, y5) {
    this._ += `L${this._x1 = +x5},${this._y1 = +y5}`;
  }
  arc(x5, y5, r2) {
    x5 = +x5, y5 = +y5, r2 = +r2;
    const x06 = x5 + r2;
    const y06 = y5;
    if (r2 < 0)
      throw new Error("negative radius");
    if (this._x1 === null)
      this._ += `M${x06},${y06}`;
    else if (Math.abs(this._x1 - x06) > epsilon6 || Math.abs(this._y1 - y06) > epsilon6)
      this._ += "L" + x06 + "," + y06;
    if (!r2)
      return;
    this._ += `A${r2},${r2},0,1,1,${x5 - r2},${y5}A${r2},${r2},0,1,1,${this._x1 = x06},${this._y1 = y06}`;
  }
  rect(x5, y5, w3, h3) {
    this._ += `M${this._x0 = this._x1 = +x5},${this._y0 = this._y1 = +y5}h${+w3}v${+h3}h${-w3}Z`;
  }
  value() {
    return this._ || null;
  }
};
var path_default4 = Path2;

// node_modules/d3-delaunay/src/polygon.js
var Polygon = class {
  constructor() {
    this._ = [];
  }
  moveTo(x5, y5) {
    this._.push([x5, y5]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(x5, y5) {
    this._.push([x5, y5]);
  }
  value() {
    return this._.length ? this._ : null;
  }
};
var polygon_default = Polygon;

// node_modules/d3-delaunay/src/voronoi.js
var Voronoi = class {
  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin)))
      throw new Error("invalid bounds");
    this.delaunay = delaunay;
    this._circumcenters = new Float64Array(delaunay.points.length * 2);
    this.vectors = new Float64Array(delaunay.points.length * 2);
    this.xmax = xmax, this.xmin = xmin;
    this.ymax = ymax, this.ymin = ymin;
    this._init();
  }
  update() {
    this.delaunay.update();
    this._init();
    return this;
  }
  _init() {
    const {delaunay: {points: points2, hull, triangles}, vectors} = this;
    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
    for (let i = 0, j = 0, n = triangles.length, x5, y5; i < n; i += 3, j += 2) {
      const t13 = triangles[i] * 2;
      const t22 = triangles[i + 1] * 2;
      const t32 = triangles[i + 2] * 2;
      const x13 = points2[t13];
      const y13 = points2[t13 + 1];
      const x22 = points2[t22];
      const y22 = points2[t22 + 1];
      const x32 = points2[t32];
      const y32 = points2[t32 + 1];
      const dx = x22 - x13;
      const dy = y22 - y13;
      const ex = x32 - x13;
      const ey = y32 - y13;
      const bl2 = dx * dx + dy * dy;
      const cl = ex * ex + ey * ey;
      const ab = (dx * ey - dy * ex) * 2;
      if (!ab) {
        x5 = (x13 + x32) / 2 - 1e8 * ey;
        y5 = (y13 + y32) / 2 + 1e8 * ex;
      } else if (Math.abs(ab) < 1e-8) {
        x5 = (x13 + x32) / 2;
        y5 = (y13 + y32) / 2;
      } else {
        const d = 1 / ab;
        x5 = x13 + (ey * bl2 - dy * cl) * d;
        y5 = y13 + (dx * cl - ex * bl2) * d;
      }
      circumcenters[j] = x5;
      circumcenters[j + 1] = y5;
    }
    let h3 = hull[hull.length - 1];
    let p02, p1 = h3 * 4;
    let x06, x12 = points2[2 * h3];
    let y06, y12 = points2[2 * h3 + 1];
    vectors.fill(0);
    for (let i = 0; i < hull.length; ++i) {
      h3 = hull[i];
      p02 = p1, x06 = x12, y06 = y12;
      p1 = h3 * 4, x12 = points2[2 * h3], y12 = points2[2 * h3 + 1];
      vectors[p02 + 2] = vectors[p1] = y06 - y12;
      vectors[p02 + 3] = vectors[p1 + 1] = x12 - x06;
    }
  }
  render(context3) {
    const buffer = context3 == null ? context3 = new path_default4() : void 0;
    const {delaunay: {halfedges, inedges, hull}, circumcenters, vectors} = this;
    if (hull.length <= 1)
      return null;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i)
        continue;
      const ti = Math.floor(i / 3) * 2;
      const tj = Math.floor(j / 3) * 2;
      const xi = circumcenters[ti];
      const yi = circumcenters[ti + 1];
      const xj = circumcenters[tj];
      const yj = circumcenters[tj + 1];
      this._renderSegment(xi, yi, xj, yj, context3);
    }
    let h0, h1 = hull[hull.length - 1];
    for (let i = 0; i < hull.length; ++i) {
      h0 = h1, h1 = hull[i];
      const t = Math.floor(inedges[h1] / 3) * 2;
      const x5 = circumcenters[t];
      const y5 = circumcenters[t + 1];
      const v = h0 * 4;
      const p = this._project(x5, y5, vectors[v + 2], vectors[v + 3]);
      if (p)
        this._renderSegment(x5, y5, p[0], p[1], context3);
    }
    return buffer && buffer.value();
  }
  renderBounds(context3) {
    const buffer = context3 == null ? context3 = new path_default4() : void 0;
    context3.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
    return buffer && buffer.value();
  }
  renderCell(i, context3) {
    const buffer = context3 == null ? context3 = new path_default4() : void 0;
    const points2 = this._clip(i);
    if (points2 === null || !points2.length)
      return;
    context3.moveTo(points2[0], points2[1]);
    let n = points2.length;
    while (points2[0] === points2[n - 2] && points2[1] === points2[n - 1] && n > 1)
      n -= 2;
    for (let i2 = 2; i2 < n; i2 += 2) {
      if (points2[i2] !== points2[i2 - 2] || points2[i2 + 1] !== points2[i2 - 1])
        context3.lineTo(points2[i2], points2[i2 + 1]);
    }
    context3.closePath();
    return buffer && buffer.value();
  }
  *cellPolygons() {
    const {delaunay: {points: points2}} = this;
    for (let i = 0, n = points2.length / 2; i < n; ++i) {
      const cell2 = this.cellPolygon(i);
      if (cell2)
        cell2.index = i, yield cell2;
    }
  }
  cellPolygon(i) {
    const polygon = new polygon_default();
    this.renderCell(i, polygon);
    return polygon.value();
  }
  _renderSegment(x06, y06, x12, y12, context3) {
    let S;
    const c0 = this._regioncode(x06, y06);
    const c1 = this._regioncode(x12, y12);
    if (c0 === 0 && c1 === 0) {
      context3.moveTo(x06, y06);
      context3.lineTo(x12, y12);
    } else if (S = this._clipSegment(x06, y06, x12, y12, c0, c1)) {
      context3.moveTo(S[0], S[1]);
      context3.lineTo(S[2], S[3]);
    }
  }
  contains(i, x5, y5) {
    if ((x5 = +x5, x5 !== x5) || (y5 = +y5, y5 !== y5))
      return false;
    return this.delaunay._step(i, x5, y5) === i;
  }
  *neighbors(i) {
    const ci = this._clip(i);
    if (ci)
      for (const j of this.delaunay.neighbors(i)) {
        const cj = this._clip(j);
        if (cj)
          loop:
            for (let ai = 0, li = ci.length; ai < li; ai += 2) {
              for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
                if (ci[ai] == cj[aj] && ci[ai + 1] == cj[aj + 1] && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]) {
                  yield j;
                  break loop;
                }
              }
            }
      }
  }
  _cell(i) {
    const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;
    const e0 = inedges[i];
    if (e0 === -1)
      return null;
    const points2 = [];
    let e = e0;
    do {
      const t = Math.floor(e / 3);
      points2.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i)
        break;
      e = halfedges[e];
    } while (e !== e0 && e !== -1);
    return points2;
  }
  _clip(i) {
    if (i === 0 && this.delaunay.hull.length === 1) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    const points2 = this._cell(i);
    if (points2 === null)
      return null;
    const {vectors: V} = this;
    const v = i * 4;
    return V[v] || V[v + 1] ? this._clipInfinite(i, points2, V[v], V[v + 1], V[v + 2], V[v + 3]) : this._clipFinite(i, points2);
  }
  _clipFinite(i, points2) {
    const n = points2.length;
    let P = null;
    let x06, y06, x12 = points2[n - 2], y12 = points2[n - 1];
    let c0, c1 = this._regioncode(x12, y12);
    let e0, e1;
    for (let j = 0; j < n; j += 2) {
      x06 = x12, y06 = y12, x12 = points2[j], y12 = points2[j + 1];
      c0 = c1, c1 = this._regioncode(x12, y12);
      if (c0 === 0 && c1 === 0) {
        e0 = e1, e1 = 0;
        if (P)
          P.push(x12, y12);
        else
          P = [x12, y12];
      } else {
        let S, sx0, sy0, sx1, sy1;
        if (c0 === 0) {
          if ((S = this._clipSegment(x06, y06, x12, y12, c0, c1)) === null)
            continue;
          [sx0, sy0, sx1, sy1] = S;
        } else {
          if ((S = this._clipSegment(x12, y12, x06, y06, c1, c0)) === null)
            continue;
          [sx1, sy1, sx0, sy0] = S;
          e0 = e1, e1 = this._edgecode(sx0, sy0);
          if (e0 && e1)
            this._edge(i, e0, e1, P, P.length);
          if (P)
            P.push(sx0, sy0);
          else
            P = [sx0, sy0];
        }
        e0 = e1, e1 = this._edgecode(sx1, sy1);
        if (e0 && e1)
          this._edge(i, e0, e1, P, P.length);
        if (P)
          P.push(sx1, sy1);
        else
          P = [sx1, sy1];
      }
    }
    if (P) {
      e0 = e1, e1 = this._edgecode(P[0], P[1]);
      if (e0 && e1)
        this._edge(i, e0, e1, P, P.length);
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    return P;
  }
  _clipSegment(x06, y06, x12, y12, c0, c1) {
    while (true) {
      if (c0 === 0 && c1 === 0)
        return [x06, y06, x12, y12];
      if (c0 & c1)
        return null;
      let x5, y5, c2 = c0 || c1;
      if (c2 & 8)
        x5 = x06 + (x12 - x06) * (this.ymax - y06) / (y12 - y06), y5 = this.ymax;
      else if (c2 & 4)
        x5 = x06 + (x12 - x06) * (this.ymin - y06) / (y12 - y06), y5 = this.ymin;
      else if (c2 & 2)
        y5 = y06 + (y12 - y06) * (this.xmax - x06) / (x12 - x06), x5 = this.xmax;
      else
        y5 = y06 + (y12 - y06) * (this.xmin - x06) / (x12 - x06), x5 = this.xmin;
      if (c0)
        x06 = x5, y06 = y5, c0 = this._regioncode(x06, y06);
      else
        x12 = x5, y12 = y5, c1 = this._regioncode(x12, y12);
    }
  }
  _clipInfinite(i, points2, vx0, vy0, vxn, vyn) {
    let P = Array.from(points2), p;
    if (p = this._project(P[0], P[1], vx0, vy0))
      P.unshift(p[0], p[1]);
    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn))
      P.push(p[0], p[1]);
    if (P = this._clipFinite(i, P)) {
      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
        if (c0 && c1)
          j = this._edge(i, c0, c1, P, j), n = P.length;
      }
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
    }
    return P;
  }
  _edge(i, e0, e1, P, j) {
    while (e0 !== e1) {
      let x5, y5;
      switch (e0) {
        case 5:
          e0 = 4;
          continue;
        case 4:
          e0 = 6, x5 = this.xmax, y5 = this.ymin;
          break;
        case 6:
          e0 = 2;
          continue;
        case 2:
          e0 = 10, x5 = this.xmax, y5 = this.ymax;
          break;
        case 10:
          e0 = 8;
          continue;
        case 8:
          e0 = 9, x5 = this.xmin, y5 = this.ymax;
          break;
        case 9:
          e0 = 1;
          continue;
        case 1:
          e0 = 5, x5 = this.xmin, y5 = this.ymin;
          break;
      }
      if ((P[j] !== x5 || P[j + 1] !== y5) && this.contains(i, x5, y5)) {
        P.splice(j, 0, x5, y5), j += 2;
      }
    }
    if (P.length > 4) {
      for (let i2 = 0; i2 < P.length; i2 += 2) {
        const j2 = (i2 + 2) % P.length, k = (i2 + 4) % P.length;
        if (P[i2] === P[j2] && P[j2] === P[k] || P[i2 + 1] === P[j2 + 1] && P[j2 + 1] === P[k + 1])
          P.splice(j2, 2), i2 -= 2;
      }
    }
    return j;
  }
  _project(x06, y06, vx, vy) {
    let t = Infinity, c2, x5, y5;
    if (vy < 0) {
      if (y06 <= this.ymin)
        return null;
      if ((c2 = (this.ymin - y06) / vy) < t)
        y5 = this.ymin, x5 = x06 + (t = c2) * vx;
    } else if (vy > 0) {
      if (y06 >= this.ymax)
        return null;
      if ((c2 = (this.ymax - y06) / vy) < t)
        y5 = this.ymax, x5 = x06 + (t = c2) * vx;
    }
    if (vx > 0) {
      if (x06 >= this.xmax)
        return null;
      if ((c2 = (this.xmax - x06) / vx) < t)
        x5 = this.xmax, y5 = y06 + (t = c2) * vy;
    } else if (vx < 0) {
      if (x06 <= this.xmin)
        return null;
      if ((c2 = (this.xmin - x06) / vx) < t)
        x5 = this.xmin, y5 = y06 + (t = c2) * vy;
    }
    return [x5, y5];
  }
  _edgecode(x5, y5) {
    return (x5 === this.xmin ? 1 : x5 === this.xmax ? 2 : 0) | (y5 === this.ymin ? 4 : y5 === this.ymax ? 8 : 0);
  }
  _regioncode(x5, y5) {
    return (x5 < this.xmin ? 1 : x5 > this.xmax ? 2 : 0) | (y5 < this.ymin ? 4 : y5 > this.ymax ? 8 : 0);
  }
};
var voronoi_default = Voronoi;

// node_modules/d3-delaunay/src/delaunay.js
var tau5 = 2 * Math.PI;
var pow5 = Math.pow;
function pointX(p) {
  return p[0];
}
function pointY(p) {
  return p[1];
}
function collinear2(d) {
  const {triangles, coords} = d;
  for (let i = 0; i < triangles.length; i += 3) {
    const a2 = 2 * triangles[i], b2 = 2 * triangles[i + 1], c2 = 2 * triangles[i + 2], cross2 = (coords[c2] - coords[a2]) * (coords[b2 + 1] - coords[a2 + 1]) - (coords[b2] - coords[a2]) * (coords[c2 + 1] - coords[a2 + 1]);
    if (cross2 > 1e-10)
      return false;
  }
  return true;
}
function jitter(x5, y5, r2) {
  return [x5 + Math.sin(x5 + y5) * r2, y5 + Math.cos(x5 - y5) * r2];
}
var Delaunay = class {
  static from(points2, fx = pointX, fy = pointY, that) {
    return new Delaunay("length" in points2 ? flatArray(points2, fx, fy, that) : Float64Array.from(flatIterable(points2, fx, fy, that)));
  }
  constructor(points2) {
    this._delaunator = new delaunator_default(points2);
    this.inedges = new Int32Array(points2.length / 2);
    this._hullIndex = new Int32Array(points2.length / 2);
    this.points = this._delaunator.coords;
    this._init();
  }
  update() {
    this._delaunator.update();
    this._init();
    return this;
  }
  _init() {
    const d = this._delaunator, points2 = this.points;
    if (d.hull && d.hull.length > 2 && collinear2(d)) {
      this.collinear = Int32Array.from({length: points2.length / 2}, (_, i) => i).sort((i, j) => points2[2 * i] - points2[2 * j] || points2[2 * i + 1] - points2[2 * j + 1]);
      const e = this.collinear[0], f = this.collinear[this.collinear.length - 1], bounds2 = [points2[2 * e], points2[2 * e + 1], points2[2 * f], points2[2 * f + 1]], r2 = 1e-8 * Math.hypot(bounds2[3] - bounds2[1], bounds2[2] - bounds2[0]);
      for (let i = 0, n = points2.length / 2; i < n; ++i) {
        const p = jitter(points2[2 * i], points2[2 * i + 1], r2);
        points2[2 * i] = p[0];
        points2[2 * i + 1] = p[1];
      }
      this._delaunator = new delaunator_default(points2);
    } else {
      delete this.collinear;
    }
    const halfedges = this.halfedges = this._delaunator.halfedges;
    const hull = this.hull = this._delaunator.hull;
    const triangles = this.triangles = this._delaunator.triangles;
    const inedges = this.inedges.fill(-1);
    const hullIndex = this._hullIndex.fill(-1);
    for (let e = 0, n = halfedges.length; e < n; ++e) {
      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
      if (halfedges[e] === -1 || inedges[p] === -1)
        inedges[p] = e;
    }
    for (let i = 0, n = hull.length; i < n; ++i) {
      hullIndex[hull[i]] = i;
    }
    if (hull.length <= 2 && hull.length > 0) {
      this.triangles = new Int32Array(3).fill(-1);
      this.halfedges = new Int32Array(3).fill(-1);
      this.triangles[0] = hull[0];
      this.triangles[1] = hull[1];
      this.triangles[2] = hull[1];
      inedges[hull[0]] = 1;
      if (hull.length === 2)
        inedges[hull[1]] = 0;
    }
  }
  voronoi(bounds2) {
    return new voronoi_default(this, bounds2);
  }
  *neighbors(i) {
    const {inedges, hull, _hullIndex, halfedges, triangles, collinear: collinear3} = this;
    if (collinear3) {
      const l = collinear3.indexOf(i);
      if (l > 0)
        yield collinear3[l - 1];
      if (l < collinear3.length - 1)
        yield collinear3[l + 1];
      return;
    }
    const e0 = inedges[i];
    if (e0 === -1)
      return;
    let e = e0, p02 = -1;
    do {
      yield p02 = triangles[e];
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i)
        return;
      e = halfedges[e];
      if (e === -1) {
        const p = hull[(_hullIndex[i] + 1) % hull.length];
        if (p !== p02)
          yield p;
        return;
      }
    } while (e !== e0);
  }
  find(x5, y5, i = 0) {
    if ((x5 = +x5, x5 !== x5) || (y5 = +y5, y5 !== y5))
      return -1;
    const i0 = i;
    let c2;
    while ((c2 = this._step(i, x5, y5)) >= 0 && c2 !== i && c2 !== i0)
      i = c2;
    return c2;
  }
  _step(i, x5, y5) {
    const {inedges, hull, _hullIndex, halfedges, triangles, points: points2} = this;
    if (inedges[i] === -1 || !points2.length)
      return (i + 1) % (points2.length >> 1);
    let c2 = i;
    let dc = pow5(x5 - points2[i * 2], 2) + pow5(y5 - points2[i * 2 + 1], 2);
    const e0 = inedges[i];
    let e = e0;
    do {
      let t = triangles[e];
      const dt = pow5(x5 - points2[t * 2], 2) + pow5(y5 - points2[t * 2 + 1], 2);
      if (dt < dc)
        dc = dt, c2 = t;
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i)
        break;
      e = halfedges[e];
      if (e === -1) {
        e = hull[(_hullIndex[i] + 1) % hull.length];
        if (e !== t) {
          if (pow5(x5 - points2[e * 2], 2) + pow5(y5 - points2[e * 2 + 1], 2) < dc)
            return e;
        }
        break;
      }
    } while (e !== e0);
    return c2;
  }
  render(context3) {
    const buffer = context3 == null ? context3 = new path_default4() : void 0;
    const {points: points2, halfedges, triangles} = this;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i)
        continue;
      const ti = triangles[i] * 2;
      const tj = triangles[j] * 2;
      context3.moveTo(points2[ti], points2[ti + 1]);
      context3.lineTo(points2[tj], points2[tj + 1]);
    }
    this.renderHull(context3);
    return buffer && buffer.value();
  }
  renderPoints(context3, r2 = 2) {
    const buffer = context3 == null ? context3 = new path_default4() : void 0;
    const {points: points2} = this;
    for (let i = 0, n = points2.length; i < n; i += 2) {
      const x5 = points2[i], y5 = points2[i + 1];
      context3.moveTo(x5 + r2, y5);
      context3.arc(x5, y5, r2, 0, tau5);
    }
    return buffer && buffer.value();
  }
  renderHull(context3) {
    const buffer = context3 == null ? context3 = new path_default4() : void 0;
    const {hull, points: points2} = this;
    const h3 = hull[0] * 2, n = hull.length;
    context3.moveTo(points2[h3], points2[h3 + 1]);
    for (let i = 1; i < n; ++i) {
      const h4 = 2 * hull[i];
      context3.lineTo(points2[h4], points2[h4 + 1]);
    }
    context3.closePath();
    return buffer && buffer.value();
  }
  hullPolygon() {
    const polygon = new polygon_default();
    this.renderHull(polygon);
    return polygon.value();
  }
  renderTriangle(i, context3) {
    const buffer = context3 == null ? context3 = new path_default4() : void 0;
    const {points: points2, triangles} = this;
    const t04 = triangles[i *= 3] * 2;
    const t13 = triangles[i + 1] * 2;
    const t22 = triangles[i + 2] * 2;
    context3.moveTo(points2[t04], points2[t04 + 1]);
    context3.lineTo(points2[t13], points2[t13 + 1]);
    context3.lineTo(points2[t22], points2[t22 + 1]);
    context3.closePath();
    return buffer && buffer.value();
  }
  *trianglePolygons() {
    const {triangles} = this;
    for (let i = 0, n = triangles.length / 3; i < n; ++i) {
      yield this.trianglePolygon(i);
    }
  }
  trianglePolygon(i) {
    const polygon = new polygon_default();
    this.renderTriangle(i, polygon);
    return polygon.value();
  }
};
var delaunay_default = Delaunay;
function flatArray(points2, fx, fy, that) {
  const n = points2.length;
  const array5 = new Float64Array(n * 2);
  for (let i = 0; i < n; ++i) {
    const p = points2[i];
    array5[i * 2] = fx.call(that, p, i, points2);
    array5[i * 2 + 1] = fy.call(that, p, i, points2);
  }
  return array5;
}
function* flatIterable(points2, fx, fy, that) {
  let i = 0;
  for (const p of points2) {
    yield fx.call(that, p, i, points2);
    yield fy.call(that, p, i, points2);
    ++i;
  }
}

// node_modules/vega-voronoi/build/vega-voronoi.module.js
function Voronoi2(params2) {
  Transform.call(this, null, params2);
}
Voronoi2.Definition = {
  type: "Voronoi",
  metadata: {
    modifies: true
  },
  params: [{
    name: "x",
    type: "field",
    required: true
  }, {
    name: "y",
    type: "field",
    required: true
  }, {
    name: "size",
    type: "number",
    array: true,
    length: 2
  }, {
    name: "extent",
    type: "array",
    array: true,
    length: 2,
    default: [[-1e5, -1e5], [1e5, 1e5]],
    content: {
      type: "number",
      array: true,
      length: 2
    }
  }, {
    name: "as",
    type: "string",
    default: "path"
  }]
};
var defaultExtent = [-1e5, -1e5, 1e5, 1e5];
inherits(Voronoi2, Transform, {
  transform(_, pulse2) {
    const as = _.as || "path", data4 = pulse2.source;
    if (!data4 || !data4.length)
      return pulse2;
    let s = _.size;
    s = s ? [0, 0, s[0], s[1]] : (s = _.extent) ? [s[0][0], s[0][1], s[1][0], s[1][1]] : defaultExtent;
    const voronoi = this.value = delaunay_default.from(data4, _.x, _.y).voronoi(s);
    for (let i = 0, n = data4.length; i < n; ++i) {
      const polygon = voronoi.cellPolygon(i);
      data4[i][as] = polygon ? toPathString(polygon) : null;
    }
    return pulse2.reflow(_.modified()).modifies(as);
  }
});
function toPathString(p) {
  const x5 = p[0][0], y5 = p[0][1];
  let n = p.length - 1;
  for (; p[n][0] === x5 && p[n][1] === y5; --n)
    ;
  return "M" + p.slice(0, n + 1).join("L") + "Z";
}

// node_modules/vega-wordcloud/build/vega-wordcloud.module.js
var vega_wordcloud_module_exports = {};
__export(vega_wordcloud_module_exports, {
  wordcloud: () => Wordcloud
});
var cloudRadians = Math.PI / 180;
var cw = 1 << 11 >> 5;
var ch = 1 << 11;
function cloud() {
  var size = [256, 256], text4, font3, fontSize2, fontStyle, fontWeight, rotate2, padding3, spiral = archimedeanSpiral, words = [], random2 = Math.random, cloud2 = {};
  cloud2.layout = function() {
    var contextAndRatio = getContext2(domCanvas()), board = zeroArray((size[0] >> 5) * size[1]), bounds2 = null, n = words.length, i = -1, tags = [], data4 = words.map((d2) => ({
      text: text4(d2),
      font: font3(d2),
      style: fontStyle(d2),
      weight: fontWeight(d2),
      rotate: rotate2(d2),
      size: ~~(fontSize2(d2) + 1e-14),
      padding: padding3(d2),
      xoff: 0,
      yoff: 0,
      x1: 0,
      y1: 0,
      x0: 0,
      y0: 0,
      hasText: false,
      sprite: null,
      datum: d2
    })).sort((a2, b2) => b2.size - a2.size);
    while (++i < n) {
      var d = data4[i];
      d.x = size[0] * (random2() + 0.5) >> 1;
      d.y = size[1] * (random2() + 0.5) >> 1;
      cloudSprite(contextAndRatio, d, data4, i);
      if (d.hasText && place2(board, d, bounds2)) {
        tags.push(d);
        if (bounds2)
          cloudBounds(bounds2, d);
        else
          bounds2 = [{
            x: d.x + d.x0,
            y: d.y + d.y0
          }, {
            x: d.x + d.x1,
            y: d.y + d.y1
          }];
        d.x -= size[0] >> 1;
        d.y -= size[1] >> 1;
      }
    }
    return tags;
  };
  function getContext2(canvas) {
    canvas.width = canvas.height = 1;
    var ratio = Math.sqrt(canvas.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
    canvas.width = (cw << 5) / ratio;
    canvas.height = ch / ratio;
    var context3 = canvas.getContext("2d");
    context3.fillStyle = context3.strokeStyle = "red";
    context3.textAlign = "center";
    return {
      context: context3,
      ratio
    };
  }
  function place2(board, tag, bounds2) {
    var startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]), s = spiral(size), dt = random2() < 0.5 ? 1 : -1, t = -dt, dxdy, dx, dy;
    while (dxdy = s(t += dt)) {
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta)
        break;
      tag.x = startX + dx;
      tag.y = startY + dy;
      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1])
        continue;
      if (!bounds2 || !cloudCollide(tag, board, size[0])) {
        if (!bounds2 || collideRects(tag, bounds2)) {
          var sprite = tag.sprite, w3 = tag.width >> 5, sw = size[0] >> 5, lx2 = tag.x - (w3 << 4), sx = lx2 & 127, msx = 32 - sx, h3 = tag.y1 - tag.y0, x5 = (tag.y + tag.y0) * sw + (lx2 >> 5), last;
          for (var j = 0; j < h3; j++) {
            last = 0;
            for (var i = 0; i <= w3; i++) {
              board[x5 + i] |= last << msx | (i < w3 ? (last = sprite[j * w3 + i]) >>> sx : 0);
            }
            x5 += sw;
          }
          tag.sprite = null;
          return true;
        }
      }
    }
    return false;
  }
  cloud2.words = function(_) {
    if (arguments.length) {
      words = _;
      return cloud2;
    } else {
      return words;
    }
  };
  cloud2.size = function(_) {
    if (arguments.length) {
      size = [+_[0], +_[1]];
      return cloud2;
    } else {
      return size;
    }
  };
  cloud2.font = function(_) {
    if (arguments.length) {
      font3 = functor(_);
      return cloud2;
    } else {
      return font3;
    }
  };
  cloud2.fontStyle = function(_) {
    if (arguments.length) {
      fontStyle = functor(_);
      return cloud2;
    } else {
      return fontStyle;
    }
  };
  cloud2.fontWeight = function(_) {
    if (arguments.length) {
      fontWeight = functor(_);
      return cloud2;
    } else {
      return fontWeight;
    }
  };
  cloud2.rotate = function(_) {
    if (arguments.length) {
      rotate2 = functor(_);
      return cloud2;
    } else {
      return rotate2;
    }
  };
  cloud2.text = function(_) {
    if (arguments.length) {
      text4 = functor(_);
      return cloud2;
    } else {
      return text4;
    }
  };
  cloud2.spiral = function(_) {
    if (arguments.length) {
      spiral = spirals[_] || _;
      return cloud2;
    } else {
      return spiral;
    }
  };
  cloud2.fontSize = function(_) {
    if (arguments.length) {
      fontSize2 = functor(_);
      return cloud2;
    } else {
      return fontSize2;
    }
  };
  cloud2.padding = function(_) {
    if (arguments.length) {
      padding3 = functor(_);
      return cloud2;
    } else {
      return padding3;
    }
  };
  cloud2.random = function(_) {
    if (arguments.length) {
      random2 = _;
      return cloud2;
    } else {
      return random2;
    }
  };
  return cloud2;
}
function cloudSprite(contextAndRatio, d, data4, di) {
  if (d.sprite)
    return;
  var c2 = contextAndRatio.context, ratio = contextAndRatio.ratio;
  c2.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  var x5 = 0, y5 = 0, maxh = 0, n = data4.length, w3, w32, h3, i, j;
  --di;
  while (++di < n) {
    d = data4[di];
    c2.save();
    c2.font = d.style + " " + d.weight + " " + ~~((d.size + 1) / ratio) + "px " + d.font;
    w3 = c2.measureText(d.text + "m").width * ratio;
    h3 = d.size << 1;
    if (d.rotate) {
      var sr = Math.sin(d.rotate * cloudRadians), cr2 = Math.cos(d.rotate * cloudRadians), wcr = w3 * cr2, wsr = w3 * sr, hcr = h3 * cr2, hsr = h3 * sr;
      w3 = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
      h3 = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w3 = w3 + 31 >> 5 << 5;
    }
    if (h3 > maxh)
      maxh = h3;
    if (x5 + w3 >= cw << 5) {
      x5 = 0;
      y5 += maxh;
      maxh = 0;
    }
    if (y5 + h3 >= ch)
      break;
    c2.translate((x5 + (w3 >> 1)) / ratio, (y5 + (h3 >> 1)) / ratio);
    if (d.rotate)
      c2.rotate(d.rotate * cloudRadians);
    c2.fillText(d.text, 0, 0);
    if (d.padding) {
      c2.lineWidth = 2 * d.padding;
      c2.strokeText(d.text, 0, 0);
    }
    c2.restore();
    d.width = w3;
    d.height = h3;
    d.xoff = x5;
    d.yoff = y5;
    d.x1 = w3 >> 1;
    d.y1 = h3 >> 1;
    d.x0 = -d.x1;
    d.y0 = -d.y1;
    d.hasText = true;
    x5 += w3;
  }
  var pixels = c2.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
  while (--di >= 0) {
    d = data4[di];
    if (!d.hasText)
      continue;
    w3 = d.width;
    w32 = w3 >> 5;
    h3 = d.y1 - d.y0;
    for (i = 0; i < h3 * w32; i++)
      sprite[i] = 0;
    x5 = d.xoff;
    if (x5 == null)
      return;
    y5 = d.yoff;
    var seen = 0, seenRow = -1;
    for (j = 0; j < h3; j++) {
      for (i = 0; i < w3; i++) {
        var k = w32 * j + (i >> 5), m2 = pixels[(y5 + j) * (cw << 5) + (x5 + i) << 2] ? 1 << 31 - i % 32 : 0;
        sprite[k] |= m2;
        seen |= m2;
      }
      if (seen)
        seenRow = j;
      else {
        d.y0++;
        h3--;
        j--;
        y5++;
      }
    }
    d.y1 = d.y0 + seenRow;
    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
  }
}
function cloudCollide(tag, board, sw) {
  sw >>= 5;
  var sprite = tag.sprite, w3 = tag.width >> 5, lx2 = tag.x - (w3 << 4), sx = lx2 & 127, msx = 32 - sx, h3 = tag.y1 - tag.y0, x5 = (tag.y + tag.y0) * sw + (lx2 >> 5), last;
  for (var j = 0; j < h3; j++) {
    last = 0;
    for (var i = 0; i <= w3; i++) {
      if ((last << msx | (i < w3 ? (last = sprite[j * w3 + i]) >>> sx : 0)) & board[x5 + i])
        return true;
    }
    x5 += sw;
  }
  return false;
}
function cloudBounds(bounds2, d) {
  var b0 = bounds2[0], b1 = bounds2[1];
  if (d.x + d.x0 < b0.x)
    b0.x = d.x + d.x0;
  if (d.y + d.y0 < b0.y)
    b0.y = d.y + d.y0;
  if (d.x + d.x1 > b1.x)
    b1.x = d.x + d.x1;
  if (d.y + d.y1 > b1.y)
    b1.y = d.y + d.y1;
}
function collideRects(a2, b2) {
  return a2.x + a2.x1 > b2[0].x && a2.x + a2.x0 < b2[1].x && a2.y + a2.y1 > b2[0].y && a2.y + a2.y0 < b2[1].y;
}
function archimedeanSpiral(size) {
  var e = size[0] / size[1];
  return function(t) {
    return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
  };
}
function rectangularSpiral(size) {
  var dy = 4, dx = dy * size[0] / size[1], x5 = 0, y5 = 0;
  return function(t) {
    var sign3 = t < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * sign3 * t) - sign3 & 3) {
      case 0:
        x5 += dx;
        break;
      case 1:
        y5 += dy;
        break;
      case 2:
        x5 -= dx;
        break;
      default:
        y5 -= dy;
        break;
    }
    return [x5, y5];
  };
}
function zeroArray(n) {
  var a2 = [], i = -1;
  while (++i < n)
    a2[i] = 0;
  return a2;
}
function functor(d) {
  return typeof d === "function" ? d : function() {
    return d;
  };
}
var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};
var Output4 = ["x", "y", "font", "fontSize", "fontStyle", "fontWeight", "angle"];
var Params2 = ["text", "font", "rotate", "fontSize", "fontStyle", "fontWeight"];
function Wordcloud(params2) {
  Transform.call(this, cloud(), params2);
}
Wordcloud.Definition = {
  type: "Wordcloud",
  metadata: {
    modifies: true
  },
  params: [{
    name: "size",
    type: "number",
    array: true,
    length: 2
  }, {
    name: "font",
    type: "string",
    expr: true,
    default: "sans-serif"
  }, {
    name: "fontStyle",
    type: "string",
    expr: true,
    default: "normal"
  }, {
    name: "fontWeight",
    type: "string",
    expr: true,
    default: "normal"
  }, {
    name: "fontSize",
    type: "number",
    expr: true,
    default: 14
  }, {
    name: "fontSizeRange",
    type: "number",
    array: "nullable",
    default: [10, 50]
  }, {
    name: "rotate",
    type: "number",
    expr: true,
    default: 0
  }, {
    name: "text",
    type: "field"
  }, {
    name: "spiral",
    type: "string",
    values: ["archimedean", "rectangular"]
  }, {
    name: "padding",
    type: "number",
    expr: true
  }, {
    name: "as",
    type: "string",
    array: true,
    length: 7,
    default: Output4
  }]
};
inherits(Wordcloud, Transform, {
  transform(_, pulse2) {
    if (_.size && !(_.size[0] && _.size[1])) {
      error("Wordcloud size dimensions must be non-zero.");
    }
    function modp(param2) {
      const p = _[param2];
      return isFunction(p) && pulse2.modified(p.fields);
    }
    const mod = _.modified();
    if (!(mod || pulse2.changed(pulse2.ADD_REM) || Params2.some(modp)))
      return;
    const data4 = pulse2.materialize(pulse2.SOURCE).source, layout = this.value, as = _.as || Output4;
    let fontSize2 = _.fontSize || 14, range5;
    isFunction(fontSize2) ? range5 = _.fontSizeRange : fontSize2 = constant(fontSize2);
    if (range5) {
      const fsize = fontSize2, sizeScale = scale("sqrt")().domain(extent(data4, fsize)).range(range5);
      fontSize2 = (x5) => sizeScale(fsize(x5));
    }
    data4.forEach((t) => {
      t[as[0]] = NaN;
      t[as[1]] = NaN;
      t[as[3]] = 0;
    });
    const words = layout.words(data4).text(_.text).size(_.size || [500, 500]).padding(_.padding || 1).spiral(_.spiral || "archimedean").rotate(_.rotate || 0).font(_.font || "sans-serif").fontStyle(_.fontStyle || "normal").fontWeight(_.fontWeight || "normal").fontSize(fontSize2).random(random).layout();
    const size = layout.size(), dx = size[0] >> 1, dy = size[1] >> 1, n = words.length;
    for (let i = 0, w3, t; i < n; ++i) {
      w3 = words[i];
      t = w3.datum;
      t[as[0]] = w3.x + dx;
      t[as[1]] = w3.y + dy;
      t[as[2]] = w3.font;
      t[as[3]] = w3.size;
      t[as[4]] = w3.style;
      t[as[5]] = w3.weight;
      t[as[6]] = w3.rotate;
    }
    return pulse2.reflow(mod).modifies(as);
  }
});

// node_modules/vega-crossfilter/build/vega-crossfilter.module.js
var vega_crossfilter_module_exports = {};
__export(vega_crossfilter_module_exports, {
  crossfilter: () => CrossFilter,
  resolvefilter: () => ResolveFilter
});
var array8 = (n) => new Uint8Array(n);
var array16 = (n) => new Uint16Array(n);
var array32 = (n) => new Uint32Array(n);
function Bitmaps() {
  let width2 = 8, data4 = [], seen = array32(0), curr = array2(0, width2), prev = array2(0, width2);
  return {
    data: () => data4,
    seen: () => seen = lengthen(seen, data4.length),
    add(array5) {
      for (let i = 0, j = data4.length, n = array5.length, t; i < n; ++i) {
        t = array5[i];
        t._index = j++;
        data4.push(t);
      }
    },
    remove(num, map4) {
      const n = data4.length, copy5 = Array(n - num), reindex = data4;
      let t, i, j;
      for (i = 0; !map4[i] && i < n; ++i) {
        copy5[i] = data4[i];
        reindex[i] = i;
      }
      for (j = i; i < n; ++i) {
        t = data4[i];
        if (!map4[i]) {
          reindex[i] = j;
          curr[j] = curr[i];
          prev[j] = prev[i];
          copy5[j] = t;
          t._index = j++;
        } else {
          reindex[i] = -1;
        }
        curr[i] = 0;
      }
      data4 = copy5;
      return reindex;
    },
    size: () => data4.length,
    curr: () => curr,
    prev: () => prev,
    reset: (k) => prev[k] = curr[k],
    all: () => width2 < 257 ? 255 : width2 < 65537 ? 65535 : 4294967295,
    set(k, one6) {
      curr[k] |= one6;
    },
    clear(k, one6) {
      curr[k] &= ~one6;
    },
    resize(n, m2) {
      const k = curr.length;
      if (n > k || m2 > width2) {
        width2 = Math.max(m2, width2);
        curr = array2(n, width2, curr);
        prev = array2(n, width2);
      }
    }
  };
}
function lengthen(array5, length3, copy5) {
  if (array5.length >= length3)
    return array5;
  copy5 = copy5 || new array5.constructor(length3);
  copy5.set(array5);
  return copy5;
}
function array2(n, m2, array5) {
  const copy5 = (m2 < 257 ? array8 : m2 < 65537 ? array16 : array32)(n);
  if (array5)
    copy5.set(array5);
  return copy5;
}
function Dimension(index4, i, query) {
  const bit = 1 << i;
  return {
    one: bit,
    zero: ~bit,
    range: query.slice(),
    bisect: index4.bisect,
    index: index4.index,
    size: index4.size,
    onAdd(added, curr) {
      const dim = this, range5 = dim.bisect(dim.range, added.value), idx = added.index, lo = range5[0], hi = range5[1], n1 = idx.length;
      let i2;
      for (i2 = 0; i2 < lo; ++i2)
        curr[idx[i2]] |= bit;
      for (i2 = hi; i2 < n1; ++i2)
        curr[idx[i2]] |= bit;
      return dim;
    }
  };
}
function SortedIndex() {
  let index4 = array32(0), value3 = [], size = 0;
  function insert2(key2, data4, base2) {
    if (!data4.length)
      return [];
    const n0 = size, n1 = data4.length, addi = array32(n1);
    let addv = Array(n1), oldv, oldi, i;
    for (i = 0; i < n1; ++i) {
      addv[i] = key2(data4[i]);
      addi[i] = i;
    }
    addv = sort(addv, addi);
    if (n0) {
      oldv = value3;
      oldi = index4;
      value3 = Array(n0 + n1);
      index4 = array32(n0 + n1);
      merge3(base2, oldv, oldi, n0, addv, addi, n1, value3, index4);
    } else {
      if (base2 > 0)
        for (i = 0; i < n1; ++i) {
          addi[i] += base2;
        }
      value3 = addv;
      index4 = addi;
    }
    size = n0 + n1;
    return {
      index: addi,
      value: addv
    };
  }
  function remove3(num, map4) {
    const n = size;
    let idx, i, j;
    for (i = 0; !map4[index4[i]] && i < n; ++i)
      ;
    for (j = i; i < n; ++i) {
      if (!map4[idx = index4[i]]) {
        index4[j] = idx;
        value3[j] = value3[i];
        ++j;
      }
    }
    size = n - num;
  }
  function reindex(map4) {
    for (let i = 0, n = size; i < n; ++i) {
      index4[i] = map4[index4[i]];
    }
  }
  function bisect2(range5, array5) {
    let n;
    if (array5) {
      n = array5.length;
    } else {
      array5 = value3;
      n = size;
    }
    return [bisectLeft(array5, range5[0], 0, n), bisectRight(array5, range5[1], 0, n)];
  }
  return {
    insert: insert2,
    remove: remove3,
    bisect: bisect2,
    reindex,
    index: () => index4,
    size: () => size
  };
}
function sort(values4, index4) {
  values4.sort.call(index4, (a2, b2) => {
    const x5 = values4[a2], y5 = values4[b2];
    return x5 < y5 ? -1 : x5 > y5 ? 1 : 0;
  });
  return permute_default(values4, index4);
}
function merge3(base2, value0, index0, n0, value1, index1, n1, value3, index4) {
  let i0 = 0, i1 = 0, i;
  for (i = 0; i0 < n0 && i1 < n1; ++i) {
    if (value0[i0] < value1[i1]) {
      value3[i] = value0[i0];
      index4[i] = index0[i0++];
    } else {
      value3[i] = value1[i1];
      index4[i] = index1[i1++] + base2;
    }
  }
  for (; i0 < n0; ++i0, ++i) {
    value3[i] = value0[i0];
    index4[i] = index0[i0];
  }
  for (; i1 < n1; ++i1, ++i) {
    value3[i] = value1[i1];
    index4[i] = index1[i1] + base2;
  }
}
function CrossFilter(params2) {
  Transform.call(this, Bitmaps(), params2);
  this._indices = null;
  this._dims = null;
}
CrossFilter.Definition = {
  type: "CrossFilter",
  metadata: {},
  params: [{
    name: "fields",
    type: "field",
    array: true,
    required: true
  }, {
    name: "query",
    type: "array",
    array: true,
    required: true,
    content: {
      type: "number",
      array: true,
      length: 2
    }
  }]
};
inherits(CrossFilter, Transform, {
  transform(_, pulse2) {
    if (!this._dims) {
      return this.init(_, pulse2);
    } else {
      var init2 = _.modified("fields") || _.fields.some((f) => pulse2.modified(f.fields));
      return init2 ? this.reinit(_, pulse2) : this.eval(_, pulse2);
    }
  },
  init(_, pulse2) {
    const fields = _.fields, query = _.query, indices = this._indices = {}, dims = this._dims = [], m2 = query.length;
    let i = 0, key2, index4;
    for (; i < m2; ++i) {
      key2 = fields[i].fname;
      index4 = indices[key2] || (indices[key2] = SortedIndex());
      dims.push(Dimension(index4, i, query[i]));
    }
    return this.eval(_, pulse2);
  },
  reinit(_, pulse2) {
    const output3 = pulse2.materialize().fork(), fields = _.fields, query = _.query, indices = this._indices, dims = this._dims, bits = this.value, curr = bits.curr(), prev = bits.prev(), all = bits.all(), out = output3.rem = output3.add, mod = output3.mod, m2 = query.length, adds = {};
    let add6, index4, key2, mods, remMap, modMap, i, n, f;
    prev.set(curr);
    if (pulse2.rem.length) {
      remMap = this.remove(_, pulse2, output3);
    }
    if (pulse2.add.length) {
      bits.add(pulse2.add);
    }
    if (pulse2.mod.length) {
      modMap = {};
      for (mods = pulse2.mod, i = 0, n = mods.length; i < n; ++i) {
        modMap[mods[i]._index] = 1;
      }
    }
    for (i = 0; i < m2; ++i) {
      f = fields[i];
      if (!dims[i] || _.modified("fields", i) || pulse2.modified(f.fields)) {
        key2 = f.fname;
        if (!(add6 = adds[key2])) {
          indices[key2] = index4 = SortedIndex();
          adds[key2] = add6 = index4.insert(f, pulse2.source, 0);
        }
        dims[i] = Dimension(index4, i, query[i]).onAdd(add6, curr);
      }
    }
    for (i = 0, n = bits.data().length; i < n; ++i) {
      if (remMap[i]) {
        continue;
      } else if (prev[i] !== curr[i]) {
        out.push(i);
      } else if (modMap[i] && curr[i] !== all) {
        mod.push(i);
      }
    }
    bits.mask = (1 << m2) - 1;
    return output3;
  },
  eval(_, pulse2) {
    const output3 = pulse2.materialize().fork(), m2 = this._dims.length;
    let mask = 0;
    if (pulse2.rem.length) {
      this.remove(_, pulse2, output3);
      mask |= (1 << m2) - 1;
    }
    if (_.modified("query") && !_.modified("fields")) {
      mask |= this.update(_, pulse2, output3);
    }
    if (pulse2.add.length) {
      this.insert(_, pulse2, output3);
      mask |= (1 << m2) - 1;
    }
    if (pulse2.mod.length) {
      this.modify(pulse2, output3);
      mask |= (1 << m2) - 1;
    }
    this.value.mask = mask;
    return output3;
  },
  insert(_, pulse2, output3) {
    const tuples = pulse2.add, bits = this.value, dims = this._dims, indices = this._indices, fields = _.fields, adds = {}, out = output3.add, n = bits.size() + tuples.length, m2 = dims.length;
    let k = bits.size(), j, key2, add6;
    bits.resize(n, m2);
    bits.add(tuples);
    const curr = bits.curr(), prev = bits.prev(), all = bits.all();
    for (j = 0; j < m2; ++j) {
      key2 = fields[j].fname;
      add6 = adds[key2] || (adds[key2] = indices[key2].insert(fields[j], tuples, k));
      dims[j].onAdd(add6, curr);
    }
    for (; k < n; ++k) {
      prev[k] = all;
      if (curr[k] !== all)
        out.push(k);
    }
  },
  modify(pulse2, output3) {
    const out = output3.mod, bits = this.value, curr = bits.curr(), all = bits.all(), tuples = pulse2.mod;
    let i, n, k;
    for (i = 0, n = tuples.length; i < n; ++i) {
      k = tuples[i]._index;
      if (curr[k] !== all)
        out.push(k);
    }
  },
  remove(_, pulse2, output3) {
    const indices = this._indices, bits = this.value, curr = bits.curr(), prev = bits.prev(), all = bits.all(), map4 = {}, out = output3.rem, tuples = pulse2.rem;
    let i, n, k, f;
    for (i = 0, n = tuples.length; i < n; ++i) {
      k = tuples[i]._index;
      map4[k] = 1;
      prev[k] = f = curr[k];
      curr[k] = all;
      if (f !== all)
        out.push(k);
    }
    for (k in indices) {
      indices[k].remove(n, map4);
    }
    this.reindex(pulse2, n, map4);
    return map4;
  },
  reindex(pulse2, num, map4) {
    const indices = this._indices, bits = this.value;
    pulse2.runAfter(() => {
      const indexMap = bits.remove(num, map4);
      for (const key2 in indices)
        indices[key2].reindex(indexMap);
    });
  },
  update(_, pulse2, output3) {
    const dims = this._dims, query = _.query, stamp = pulse2.stamp, m2 = dims.length;
    let mask = 0, i, q;
    output3.filters = 0;
    for (q = 0; q < m2; ++q) {
      if (_.modified("query", q)) {
        i = q;
        ++mask;
      }
    }
    if (mask === 1) {
      mask = dims[i].one;
      this.incrementOne(dims[i], query[i], output3.add, output3.rem);
    } else {
      for (q = 0, mask = 0; q < m2; ++q) {
        if (!_.modified("query", q))
          continue;
        mask |= dims[q].one;
        this.incrementAll(dims[q], query[q], stamp, output3.add);
        output3.rem = output3.add;
      }
    }
    return mask;
  },
  incrementAll(dim, query, stamp, out) {
    const bits = this.value, seen = bits.seen(), curr = bits.curr(), prev = bits.prev(), index4 = dim.index(), old = dim.bisect(dim.range), range5 = dim.bisect(query), lo1 = range5[0], hi1 = range5[1], lo0 = old[0], hi0 = old[1], one6 = dim.one;
    let i, j, k;
    if (lo1 < lo0) {
      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
        k = index4[i];
        if (seen[k] !== stamp) {
          prev[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }
        curr[k] ^= one6;
      }
    } else if (lo1 > lo0) {
      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
        k = index4[i];
        if (seen[k] !== stamp) {
          prev[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }
        curr[k] ^= one6;
      }
    }
    if (hi1 > hi0) {
      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
        k = index4[i];
        if (seen[k] !== stamp) {
          prev[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }
        curr[k] ^= one6;
      }
    } else if (hi1 < hi0) {
      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
        k = index4[i];
        if (seen[k] !== stamp) {
          prev[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }
        curr[k] ^= one6;
      }
    }
    dim.range = query.slice();
  },
  incrementOne(dim, query, add6, rem2) {
    const bits = this.value, curr = bits.curr(), index4 = dim.index(), old = dim.bisect(dim.range), range5 = dim.bisect(query), lo1 = range5[0], hi1 = range5[1], lo0 = old[0], hi0 = old[1], one6 = dim.one;
    let i, j, k;
    if (lo1 < lo0) {
      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
        k = index4[i];
        curr[k] ^= one6;
        add6.push(k);
      }
    } else if (lo1 > lo0) {
      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
        k = index4[i];
        curr[k] ^= one6;
        rem2.push(k);
      }
    }
    if (hi1 > hi0) {
      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
        k = index4[i];
        curr[k] ^= one6;
        add6.push(k);
      }
    } else if (hi1 < hi0) {
      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
        k = index4[i];
        curr[k] ^= one6;
        rem2.push(k);
      }
    }
    dim.range = query.slice();
  }
});
function ResolveFilter(params2) {
  Transform.call(this, null, params2);
}
ResolveFilter.Definition = {
  type: "ResolveFilter",
  metadata: {},
  params: [{
    name: "ignore",
    type: "number",
    required: true,
    description: "A bit mask indicating which filters to ignore."
  }, {
    name: "filter",
    type: "object",
    required: true,
    description: "Per-tuple filter bitmaps from a CrossFilter transform."
  }]
};
inherits(ResolveFilter, Transform, {
  transform(_, pulse2) {
    const ignore = ~(_.ignore || 0), bitmap = _.filter, mask = bitmap.mask;
    if ((mask & ignore) === 0)
      return pulse2.StopPropagation;
    const output3 = pulse2.fork(pulse2.ALL), data4 = bitmap.data(), curr = bitmap.curr(), prev = bitmap.prev(), pass = (k) => !(curr[k] & ignore) ? data4[k] : null;
    output3.filter(output3.MOD, pass);
    if (!(mask & mask - 1)) {
      output3.filter(output3.ADD, pass);
      output3.filter(output3.REM, (k) => (curr[k] & ignore) === mask ? data4[k] : null);
    } else {
      output3.filter(output3.ADD, (k) => {
        const c2 = curr[k] & ignore, f = !c2 && c2 ^ prev[k] & ignore;
        return f ? data4[k] : null;
      });
      output3.filter(output3.REM, (k) => {
        const c2 = curr[k] & ignore, f = c2 && !(c2 ^ (c2 ^ prev[k] & ignore));
        return f ? data4[k] : null;
      });
    }
    return output3.filter(output3.SOURCE, (t) => pass(t._index));
  }
});

// node_modules/vega-expression/build/vega-expression.module.js
var RawCode = "RawCode";
var Literal = "Literal";
var Property = "Property";
var Identifier2 = "Identifier";
var ArrayExpression = "ArrayExpression";
var BinaryExpression = "BinaryExpression";
var CallExpression = "CallExpression";
var ConditionalExpression = "ConditionalExpression";
var LogicalExpression = "LogicalExpression";
var MemberExpression = "MemberExpression";
var ObjectExpression = "ObjectExpression";
var UnaryExpression = "UnaryExpression";
function ASTNode(type2) {
  this.type = type2;
}
ASTNode.prototype.visit = function(visitor) {
  let c2, i, n;
  if (visitor(this))
    return 1;
  for (c2 = children2(this), i = 0, n = c2.length; i < n; ++i) {
    if (c2[i].visit(visitor))
      return 1;
  }
};
function children2(node) {
  switch (node.type) {
    case ArrayExpression:
      return node.elements;
    case BinaryExpression:
    case LogicalExpression:
      return [node.left, node.right];
    case CallExpression:
      return [node.callee].concat(node.arguments);
    case ConditionalExpression:
      return [node.test, node.consequent, node.alternate];
    case MemberExpression:
      return [node.object, node.property];
    case ObjectExpression:
      return node.properties;
    case Property:
      return [node.key, node.value];
    case UnaryExpression:
      return [node.argument];
    case Identifier2:
    case Literal:
    case RawCode:
    default:
      return [];
  }
}
var TokenName;
var source2;
var index2;
var length;
var lookahead;
var TokenBooleanLiteral = 1;
var TokenEOF = 2;
var TokenIdentifier = 3;
var TokenKeyword = 4;
var TokenNullLiteral = 5;
var TokenNumericLiteral = 6;
var TokenPunctuator = 7;
var TokenStringLiteral = 8;
var TokenRegularExpression = 9;
TokenName = {};
TokenName[TokenBooleanLiteral] = "Boolean";
TokenName[TokenEOF] = "<end>";
TokenName[TokenIdentifier] = "Identifier";
TokenName[TokenKeyword] = "Keyword";
TokenName[TokenNullLiteral] = "Null";
TokenName[TokenNumericLiteral] = "Numeric";
TokenName[TokenPunctuator] = "Punctuator";
TokenName[TokenStringLiteral] = "String";
TokenName[TokenRegularExpression] = "RegularExpression";
var SyntaxArrayExpression = "ArrayExpression";
var SyntaxBinaryExpression = "BinaryExpression";
var SyntaxCallExpression = "CallExpression";
var SyntaxConditionalExpression = "ConditionalExpression";
var SyntaxIdentifier = "Identifier";
var SyntaxLiteral = "Literal";
var SyntaxLogicalExpression = "LogicalExpression";
var SyntaxMemberExpression = "MemberExpression";
var SyntaxObjectExpression = "ObjectExpression";
var SyntaxProperty = "Property";
var SyntaxUnaryExpression = "UnaryExpression";
var MessageUnexpectedToken = "Unexpected token %0";
var MessageUnexpectedNumber = "Unexpected number";
var MessageUnexpectedString = "Unexpected string";
var MessageUnexpectedIdentifier = "Unexpected identifier";
var MessageUnexpectedReserved = "Unexpected reserved word";
var MessageUnexpectedEOS = "Unexpected end of input";
var MessageInvalidRegExp = "Invalid regular expression";
var MessageUnterminatedRegExp = "Invalid regular expression: missing /";
var MessageStrictOctalLiteral = "Octal literals are not allowed in strict mode.";
var MessageStrictDuplicateProperty = "Duplicate data property in object literal not allowed in strict mode";
var ILLEGAL = "ILLEGAL";
var DISABLED = "Disabled.";
var RegexNonAsciiIdentifierStart = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
var RegexNonAsciiIdentifierPart = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
function assert(condition, message) {
  if (!condition) {
    throw new Error("ASSERT: " + message);
  }
}
function isDecimalDigit(ch2) {
  return ch2 >= 48 && ch2 <= 57;
}
function isHexDigit(ch2) {
  return "0123456789abcdefABCDEF".indexOf(ch2) >= 0;
}
function isOctalDigit(ch2) {
  return "01234567".indexOf(ch2) >= 0;
}
function isWhiteSpace(ch2) {
  return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(ch2) >= 0;
}
function isLineTerminator(ch2) {
  return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
}
function isIdentifierStart(ch2) {
  return ch2 === 36 || ch2 === 95 || ch2 >= 65 && ch2 <= 90 || ch2 >= 97 && ch2 <= 122 || ch2 === 92 || ch2 >= 128 && RegexNonAsciiIdentifierStart.test(String.fromCharCode(ch2));
}
function isIdentifierPart(ch2) {
  return ch2 === 36 || ch2 === 95 || ch2 >= 65 && ch2 <= 90 || ch2 >= 97 && ch2 <= 122 || ch2 >= 48 && ch2 <= 57 || ch2 === 92 || ch2 >= 128 && RegexNonAsciiIdentifierPart.test(String.fromCharCode(ch2));
}
var keywords = {
  if: 1,
  in: 1,
  do: 1,
  var: 1,
  for: 1,
  new: 1,
  try: 1,
  let: 1,
  this: 1,
  else: 1,
  case: 1,
  void: 1,
  with: 1,
  enum: 1,
  while: 1,
  break: 1,
  catch: 1,
  throw: 1,
  const: 1,
  yield: 1,
  class: 1,
  super: 1,
  return: 1,
  typeof: 1,
  delete: 1,
  switch: 1,
  export: 1,
  import: 1,
  public: 1,
  static: 1,
  default: 1,
  finally: 1,
  extends: 1,
  package: 1,
  private: 1,
  function: 1,
  continue: 1,
  debugger: 1,
  interface: 1,
  protected: 1,
  instanceof: 1,
  implements: 1
};
function skipComment() {
  while (index2 < length) {
    const ch2 = source2.charCodeAt(index2);
    if (isWhiteSpace(ch2) || isLineTerminator(ch2)) {
      ++index2;
    } else {
      break;
    }
  }
}
function scanHexEscape(prefix) {
  var i, len, ch2, code = 0;
  len = prefix === "u" ? 4 : 2;
  for (i = 0; i < len; ++i) {
    if (index2 < length && isHexDigit(source2[index2])) {
      ch2 = source2[index2++];
      code = code * 16 + "0123456789abcdef".indexOf(ch2.toLowerCase());
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
  }
  return String.fromCharCode(code);
}
function scanUnicodeCodePointEscape() {
  var ch2, code, cu1, cu2;
  ch2 = source2[index2];
  code = 0;
  if (ch2 === "}") {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  while (index2 < length) {
    ch2 = source2[index2++];
    if (!isHexDigit(ch2)) {
      break;
    }
    code = code * 16 + "0123456789abcdef".indexOf(ch2.toLowerCase());
  }
  if (code > 1114111 || ch2 !== "}") {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  cu1 = (code - 65536 >> 10) + 55296;
  cu2 = (code - 65536 & 1023) + 56320;
  return String.fromCharCode(cu1, cu2);
}
function getEscapedIdentifier() {
  var ch2, id4;
  ch2 = source2.charCodeAt(index2++);
  id4 = String.fromCharCode(ch2);
  if (ch2 === 92) {
    if (source2.charCodeAt(index2) !== 117) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
    ++index2;
    ch2 = scanHexEscape("u");
    if (!ch2 || ch2 === "\\" || !isIdentifierStart(ch2.charCodeAt(0))) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
    id4 = ch2;
  }
  while (index2 < length) {
    ch2 = source2.charCodeAt(index2);
    if (!isIdentifierPart(ch2)) {
      break;
    }
    ++index2;
    id4 += String.fromCharCode(ch2);
    if (ch2 === 92) {
      id4 = id4.substr(0, id4.length - 1);
      if (source2.charCodeAt(index2) !== 117) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
      ++index2;
      ch2 = scanHexEscape("u");
      if (!ch2 || ch2 === "\\" || !isIdentifierPart(ch2.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
      id4 += ch2;
    }
  }
  return id4;
}
function getIdentifier() {
  var start, ch2;
  start = index2++;
  while (index2 < length) {
    ch2 = source2.charCodeAt(index2);
    if (ch2 === 92) {
      index2 = start;
      return getEscapedIdentifier();
    }
    if (isIdentifierPart(ch2)) {
      ++index2;
    } else {
      break;
    }
  }
  return source2.slice(start, index2);
}
function scanIdentifier() {
  var start, id4, type2;
  start = index2;
  id4 = source2.charCodeAt(index2) === 92 ? getEscapedIdentifier() : getIdentifier();
  if (id4.length === 1) {
    type2 = TokenIdentifier;
  } else if (keywords.hasOwnProperty(id4)) {
    type2 = TokenKeyword;
  } else if (id4 === "null") {
    type2 = TokenNullLiteral;
  } else if (id4 === "true" || id4 === "false") {
    type2 = TokenBooleanLiteral;
  } else {
    type2 = TokenIdentifier;
  }
  return {
    type: type2,
    value: id4,
    start,
    end: index2
  };
}
function scanPunctuator() {
  var start = index2, code = source2.charCodeAt(index2), code2, ch1 = source2[index2], ch2, ch3, ch4;
  switch (code) {
    case 46:
    case 40:
    case 41:
    case 59:
    case 44:
    case 123:
    case 125:
    case 91:
    case 93:
    case 58:
    case 63:
    case 126:
      ++index2;
      return {
        type: TokenPunctuator,
        value: String.fromCharCode(code),
        start,
        end: index2
      };
    default:
      code2 = source2.charCodeAt(index2 + 1);
      if (code2 === 61) {
        switch (code) {
          case 43:
          case 45:
          case 47:
          case 60:
          case 62:
          case 94:
          case 124:
          case 37:
          case 38:
          case 42:
            index2 += 2;
            return {
              type: TokenPunctuator,
              value: String.fromCharCode(code) + String.fromCharCode(code2),
              start,
              end: index2
            };
          case 33:
          case 61:
            index2 += 2;
            if (source2.charCodeAt(index2) === 61) {
              ++index2;
            }
            return {
              type: TokenPunctuator,
              value: source2.slice(start, index2),
              start,
              end: index2
            };
        }
      }
  }
  ch4 = source2.substr(index2, 4);
  if (ch4 === ">>>=") {
    index2 += 4;
    return {
      type: TokenPunctuator,
      value: ch4,
      start,
      end: index2
    };
  }
  ch3 = ch4.substr(0, 3);
  if (ch3 === ">>>" || ch3 === "<<=" || ch3 === ">>=") {
    index2 += 3;
    return {
      type: TokenPunctuator,
      value: ch3,
      start,
      end: index2
    };
  }
  ch2 = ch3.substr(0, 2);
  if (ch1 === ch2[1] && "+-<>&|".indexOf(ch1) >= 0 || ch2 === "=>") {
    index2 += 2;
    return {
      type: TokenPunctuator,
      value: ch2,
      start,
      end: index2
    };
  }
  if (ch2 === "//") {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  if ("<>=!+-*%&|^/".indexOf(ch1) >= 0) {
    ++index2;
    return {
      type: TokenPunctuator,
      value: ch1,
      start,
      end: index2
    };
  }
  throwError({}, MessageUnexpectedToken, ILLEGAL);
}
function scanHexLiteral(start) {
  let number7 = "";
  while (index2 < length) {
    if (!isHexDigit(source2[index2])) {
      break;
    }
    number7 += source2[index2++];
  }
  if (number7.length === 0) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  if (isIdentifierStart(source2.charCodeAt(index2))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenNumericLiteral,
    value: parseInt("0x" + number7, 16),
    start,
    end: index2
  };
}
function scanOctalLiteral(start) {
  let number7 = "0" + source2[index2++];
  while (index2 < length) {
    if (!isOctalDigit(source2[index2])) {
      break;
    }
    number7 += source2[index2++];
  }
  if (isIdentifierStart(source2.charCodeAt(index2)) || isDecimalDigit(source2.charCodeAt(index2))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenNumericLiteral,
    value: parseInt(number7, 8),
    octal: true,
    start,
    end: index2
  };
}
function scanNumericLiteral() {
  var number7, start, ch2;
  ch2 = source2[index2];
  assert(isDecimalDigit(ch2.charCodeAt(0)) || ch2 === ".", "Numeric literal must start with a decimal digit or a decimal point");
  start = index2;
  number7 = "";
  if (ch2 !== ".") {
    number7 = source2[index2++];
    ch2 = source2[index2];
    if (number7 === "0") {
      if (ch2 === "x" || ch2 === "X") {
        ++index2;
        return scanHexLiteral(start);
      }
      if (isOctalDigit(ch2)) {
        return scanOctalLiteral(start);
      }
      if (ch2 && isDecimalDigit(ch2.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
    }
    while (isDecimalDigit(source2.charCodeAt(index2))) {
      number7 += source2[index2++];
    }
    ch2 = source2[index2];
  }
  if (ch2 === ".") {
    number7 += source2[index2++];
    while (isDecimalDigit(source2.charCodeAt(index2))) {
      number7 += source2[index2++];
    }
    ch2 = source2[index2];
  }
  if (ch2 === "e" || ch2 === "E") {
    number7 += source2[index2++];
    ch2 = source2[index2];
    if (ch2 === "+" || ch2 === "-") {
      number7 += source2[index2++];
    }
    if (isDecimalDigit(source2.charCodeAt(index2))) {
      while (isDecimalDigit(source2.charCodeAt(index2))) {
        number7 += source2[index2++];
      }
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
  }
  if (isIdentifierStart(source2.charCodeAt(index2))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenNumericLiteral,
    value: parseFloat(number7),
    start,
    end: index2
  };
}
function scanStringLiteral() {
  var str = "", quote, start, ch2, code, octal = false;
  quote = source2[index2];
  assert(quote === "'" || quote === '"', "String literal must starts with a quote");
  start = index2;
  ++index2;
  while (index2 < length) {
    ch2 = source2[index2++];
    if (ch2 === quote) {
      quote = "";
      break;
    } else if (ch2 === "\\") {
      ch2 = source2[index2++];
      if (!ch2 || !isLineTerminator(ch2.charCodeAt(0))) {
        switch (ch2) {
          case "u":
          case "x":
            if (source2[index2] === "{") {
              ++index2;
              str += scanUnicodeCodePointEscape();
            } else {
              str += scanHexEscape(ch2);
            }
            break;
          case "n":
            str += "\n";
            break;
          case "r":
            str += "\r";
            break;
          case "t":
            str += "	";
            break;
          case "b":
            str += "\b";
            break;
          case "f":
            str += "\f";
            break;
          case "v":
            str += "\v";
            break;
          default:
            if (isOctalDigit(ch2)) {
              code = "01234567".indexOf(ch2);
              if (code !== 0) {
                octal = true;
              }
              if (index2 < length && isOctalDigit(source2[index2])) {
                octal = true;
                code = code * 8 + "01234567".indexOf(source2[index2++]);
                if ("0123".indexOf(ch2) >= 0 && index2 < length && isOctalDigit(source2[index2])) {
                  code = code * 8 + "01234567".indexOf(source2[index2++]);
                }
              }
              str += String.fromCharCode(code);
            } else {
              str += ch2;
            }
            break;
        }
      } else {
        if (ch2 === "\r" && source2[index2] === "\n") {
          ++index2;
        }
      }
    } else if (isLineTerminator(ch2.charCodeAt(0))) {
      break;
    } else {
      str += ch2;
    }
  }
  if (quote !== "") {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenStringLiteral,
    value: str,
    octal,
    start,
    end: index2
  };
}
function testRegExp(pattern, flags) {
  let tmp = pattern;
  if (flags.indexOf("u") >= 0) {
    tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, ($0, $1) => {
      if (parseInt($1, 16) <= 1114111) {
        return "x";
      }
      throwError({}, MessageInvalidRegExp);
    }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
  }
  try {
    new RegExp(tmp);
  } catch (e) {
    throwError({}, MessageInvalidRegExp);
  }
  try {
    return new RegExp(pattern, flags);
  } catch (exception) {
    return null;
  }
}
function scanRegExpBody() {
  var ch2, str, classMarker, terminated, body;
  ch2 = source2[index2];
  assert(ch2 === "/", "Regular expression literal must start with a slash");
  str = source2[index2++];
  classMarker = false;
  terminated = false;
  while (index2 < length) {
    ch2 = source2[index2++];
    str += ch2;
    if (ch2 === "\\") {
      ch2 = source2[index2++];
      if (isLineTerminator(ch2.charCodeAt(0))) {
        throwError({}, MessageUnterminatedRegExp);
      }
      str += ch2;
    } else if (isLineTerminator(ch2.charCodeAt(0))) {
      throwError({}, MessageUnterminatedRegExp);
    } else if (classMarker) {
      if (ch2 === "]") {
        classMarker = false;
      }
    } else {
      if (ch2 === "/") {
        terminated = true;
        break;
      } else if (ch2 === "[") {
        classMarker = true;
      }
    }
  }
  if (!terminated) {
    throwError({}, MessageUnterminatedRegExp);
  }
  body = str.substr(1, str.length - 2);
  return {
    value: body,
    literal: str
  };
}
function scanRegExpFlags() {
  var ch2, str, flags;
  str = "";
  flags = "";
  while (index2 < length) {
    ch2 = source2[index2];
    if (!isIdentifierPart(ch2.charCodeAt(0))) {
      break;
    }
    ++index2;
    if (ch2 === "\\" && index2 < length) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    } else {
      flags += ch2;
      str += ch2;
    }
  }
  if (flags.search(/[^gimuy]/g) >= 0) {
    throwError({}, MessageInvalidRegExp, flags);
  }
  return {
    value: flags,
    literal: str
  };
}
function scanRegExp() {
  var start, body, flags, value3;
  lookahead = null;
  skipComment();
  start = index2;
  body = scanRegExpBody();
  flags = scanRegExpFlags();
  value3 = testRegExp(body.value, flags.value);
  return {
    literal: body.literal + flags.literal,
    value: value3,
    regex: {
      pattern: body.value,
      flags: flags.value
    },
    start,
    end: index2
  };
}
function isIdentifierName(token) {
  return token.type === TokenIdentifier || token.type === TokenKeyword || token.type === TokenBooleanLiteral || token.type === TokenNullLiteral;
}
function advance() {
  skipComment();
  if (index2 >= length) {
    return {
      type: TokenEOF,
      start: index2,
      end: index2
    };
  }
  const ch2 = source2.charCodeAt(index2);
  if (isIdentifierStart(ch2)) {
    return scanIdentifier();
  }
  if (ch2 === 40 || ch2 === 41 || ch2 === 59) {
    return scanPunctuator();
  }
  if (ch2 === 39 || ch2 === 34) {
    return scanStringLiteral();
  }
  if (ch2 === 46) {
    if (isDecimalDigit(source2.charCodeAt(index2 + 1))) {
      return scanNumericLiteral();
    }
    return scanPunctuator();
  }
  if (isDecimalDigit(ch2)) {
    return scanNumericLiteral();
  }
  return scanPunctuator();
}
function lex() {
  const token = lookahead;
  index2 = token.end;
  lookahead = advance();
  index2 = token.end;
  return token;
}
function peek2() {
  const pos = index2;
  lookahead = advance();
  index2 = pos;
}
function finishArrayExpression(elements) {
  const node = new ASTNode(SyntaxArrayExpression);
  node.elements = elements;
  return node;
}
function finishBinaryExpression(operator2, left, right) {
  const node = new ASTNode(operator2 === "||" || operator2 === "&&" ? SyntaxLogicalExpression : SyntaxBinaryExpression);
  node.operator = operator2;
  node.left = left;
  node.right = right;
  return node;
}
function finishCallExpression(callee, args) {
  const node = new ASTNode(SyntaxCallExpression);
  node.callee = callee;
  node.arguments = args;
  return node;
}
function finishConditionalExpression(test2, consequent, alternate) {
  const node = new ASTNode(SyntaxConditionalExpression);
  node.test = test2;
  node.consequent = consequent;
  node.alternate = alternate;
  return node;
}
function finishIdentifier(name4) {
  const node = new ASTNode(SyntaxIdentifier);
  node.name = name4;
  return node;
}
function finishLiteral(token) {
  const node = new ASTNode(SyntaxLiteral);
  node.value = token.value;
  node.raw = source2.slice(token.start, token.end);
  if (token.regex) {
    if (node.raw === "//") {
      node.raw = "/(?:)/";
    }
    node.regex = token.regex;
  }
  return node;
}
function finishMemberExpression(accessor3, object2, property2) {
  const node = new ASTNode(SyntaxMemberExpression);
  node.computed = accessor3 === "[";
  node.object = object2;
  node.property = property2;
  if (!node.computed)
    property2.member = true;
  return node;
}
function finishObjectExpression(properties) {
  const node = new ASTNode(SyntaxObjectExpression);
  node.properties = properties;
  return node;
}
function finishProperty(kind, key2, value3) {
  const node = new ASTNode(SyntaxProperty);
  node.key = key2;
  node.value = value3;
  node.kind = kind;
  return node;
}
function finishUnaryExpression(operator2, argument) {
  const node = new ASTNode(SyntaxUnaryExpression);
  node.operator = operator2;
  node.argument = argument;
  node.prefix = true;
  return node;
}
function throwError(token, messageFormat) {
  var error3, args = Array.prototype.slice.call(arguments, 2), msg = messageFormat.replace(/%(\d)/g, (whole, index4) => {
    assert(index4 < args.length, "Message reference must be in range");
    return args[index4];
  });
  error3 = new Error(msg);
  error3.index = index2;
  error3.description = msg;
  throw error3;
}
function throwUnexpected(token) {
  if (token.type === TokenEOF) {
    throwError(token, MessageUnexpectedEOS);
  }
  if (token.type === TokenNumericLiteral) {
    throwError(token, MessageUnexpectedNumber);
  }
  if (token.type === TokenStringLiteral) {
    throwError(token, MessageUnexpectedString);
  }
  if (token.type === TokenIdentifier) {
    throwError(token, MessageUnexpectedIdentifier);
  }
  if (token.type === TokenKeyword) {
    throwError(token, MessageUnexpectedReserved);
  }
  throwError(token, MessageUnexpectedToken, token.value);
}
function expect(value3) {
  const token = lex();
  if (token.type !== TokenPunctuator || token.value !== value3) {
    throwUnexpected(token);
  }
}
function match(value3) {
  return lookahead.type === TokenPunctuator && lookahead.value === value3;
}
function matchKeyword(keyword) {
  return lookahead.type === TokenKeyword && lookahead.value === keyword;
}
function parseArrayInitialiser() {
  const elements = [];
  index2 = lookahead.start;
  expect("[");
  while (!match("]")) {
    if (match(",")) {
      lex();
      elements.push(null);
    } else {
      elements.push(parseConditionalExpression());
      if (!match("]")) {
        expect(",");
      }
    }
  }
  lex();
  return finishArrayExpression(elements);
}
function parseObjectPropertyKey() {
  index2 = lookahead.start;
  const token = lex();
  if (token.type === TokenStringLiteral || token.type === TokenNumericLiteral) {
    if (token.octal) {
      throwError(token, MessageStrictOctalLiteral);
    }
    return finishLiteral(token);
  }
  return finishIdentifier(token.value);
}
function parseObjectProperty() {
  var token, key2, id4, value3;
  index2 = lookahead.start;
  token = lookahead;
  if (token.type === TokenIdentifier) {
    id4 = parseObjectPropertyKey();
    expect(":");
    value3 = parseConditionalExpression();
    return finishProperty("init", id4, value3);
  }
  if (token.type === TokenEOF || token.type === TokenPunctuator) {
    throwUnexpected(token);
  } else {
    key2 = parseObjectPropertyKey();
    expect(":");
    value3 = parseConditionalExpression();
    return finishProperty("init", key2, value3);
  }
}
function parseObjectInitialiser() {
  var properties = [], property2, name4, key2, map4 = {}, toString2 = String;
  index2 = lookahead.start;
  expect("{");
  while (!match("}")) {
    property2 = parseObjectProperty();
    if (property2.key.type === SyntaxIdentifier) {
      name4 = property2.key.name;
    } else {
      name4 = toString2(property2.key.value);
    }
    key2 = "$" + name4;
    if (Object.prototype.hasOwnProperty.call(map4, key2)) {
      throwError({}, MessageStrictDuplicateProperty);
    } else {
      map4[key2] = true;
    }
    properties.push(property2);
    if (!match("}")) {
      expect(",");
    }
  }
  expect("}");
  return finishObjectExpression(properties);
}
function parseGroupExpression() {
  expect("(");
  const expr2 = parseExpression();
  expect(")");
  return expr2;
}
var legalKeywords = {
  if: 1
};
function parsePrimaryExpression() {
  var type2, token, expr2;
  if (match("(")) {
    return parseGroupExpression();
  }
  if (match("[")) {
    return parseArrayInitialiser();
  }
  if (match("{")) {
    return parseObjectInitialiser();
  }
  type2 = lookahead.type;
  index2 = lookahead.start;
  if (type2 === TokenIdentifier || legalKeywords[lookahead.value]) {
    expr2 = finishIdentifier(lex().value);
  } else if (type2 === TokenStringLiteral || type2 === TokenNumericLiteral) {
    if (lookahead.octal) {
      throwError(lookahead, MessageStrictOctalLiteral);
    }
    expr2 = finishLiteral(lex());
  } else if (type2 === TokenKeyword) {
    throw new Error(DISABLED);
  } else if (type2 === TokenBooleanLiteral) {
    token = lex();
    token.value = token.value === "true";
    expr2 = finishLiteral(token);
  } else if (type2 === TokenNullLiteral) {
    token = lex();
    token.value = null;
    expr2 = finishLiteral(token);
  } else if (match("/") || match("/=")) {
    expr2 = finishLiteral(scanRegExp());
    peek2();
  } else {
    throwUnexpected(lex());
  }
  return expr2;
}
function parseArguments() {
  const args = [];
  expect("(");
  if (!match(")")) {
    while (index2 < length) {
      args.push(parseConditionalExpression());
      if (match(")")) {
        break;
      }
      expect(",");
    }
  }
  expect(")");
  return args;
}
function parseNonComputedProperty() {
  index2 = lookahead.start;
  const token = lex();
  if (!isIdentifierName(token)) {
    throwUnexpected(token);
  }
  return finishIdentifier(token.value);
}
function parseNonComputedMember() {
  expect(".");
  return parseNonComputedProperty();
}
function parseComputedMember() {
  expect("[");
  const expr2 = parseExpression();
  expect("]");
  return expr2;
}
function parseLeftHandSideExpressionAllowCall() {
  var expr2, args, property2;
  expr2 = parsePrimaryExpression();
  for (; ; ) {
    if (match(".")) {
      property2 = parseNonComputedMember();
      expr2 = finishMemberExpression(".", expr2, property2);
    } else if (match("(")) {
      args = parseArguments();
      expr2 = finishCallExpression(expr2, args);
    } else if (match("[")) {
      property2 = parseComputedMember();
      expr2 = finishMemberExpression("[", expr2, property2);
    } else {
      break;
    }
  }
  return expr2;
}
function parsePostfixExpression() {
  const expr2 = parseLeftHandSideExpressionAllowCall();
  if (lookahead.type === TokenPunctuator) {
    if (match("++") || match("--")) {
      throw new Error(DISABLED);
    }
  }
  return expr2;
}
function parseUnaryExpression() {
  var token, expr2;
  if (lookahead.type !== TokenPunctuator && lookahead.type !== TokenKeyword) {
    expr2 = parsePostfixExpression();
  } else if (match("++") || match("--")) {
    throw new Error(DISABLED);
  } else if (match("+") || match("-") || match("~") || match("!")) {
    token = lex();
    expr2 = parseUnaryExpression();
    expr2 = finishUnaryExpression(token.value, expr2);
  } else if (matchKeyword("delete") || matchKeyword("void") || matchKeyword("typeof")) {
    throw new Error(DISABLED);
  } else {
    expr2 = parsePostfixExpression();
  }
  return expr2;
}
function binaryPrecedence(token) {
  let prec = 0;
  if (token.type !== TokenPunctuator && token.type !== TokenKeyword) {
    return 0;
  }
  switch (token.value) {
    case "||":
      prec = 1;
      break;
    case "&&":
      prec = 2;
      break;
    case "|":
      prec = 3;
      break;
    case "^":
      prec = 4;
      break;
    case "&":
      prec = 5;
      break;
    case "==":
    case "!=":
    case "===":
    case "!==":
      prec = 6;
      break;
    case "<":
    case ">":
    case "<=":
    case ">=":
    case "instanceof":
    case "in":
      prec = 7;
      break;
    case "<<":
    case ">>":
    case ">>>":
      prec = 8;
      break;
    case "+":
    case "-":
      prec = 9;
      break;
    case "*":
    case "/":
    case "%":
      prec = 11;
      break;
  }
  return prec;
}
function parseBinaryExpression() {
  var marker, markers, expr2, token, prec, stack3, right, operator2, left, i;
  marker = lookahead;
  left = parseUnaryExpression();
  token = lookahead;
  prec = binaryPrecedence(token);
  if (prec === 0) {
    return left;
  }
  token.prec = prec;
  lex();
  markers = [marker, lookahead];
  right = parseUnaryExpression();
  stack3 = [left, token, right];
  while ((prec = binaryPrecedence(lookahead)) > 0) {
    while (stack3.length > 2 && prec <= stack3[stack3.length - 2].prec) {
      right = stack3.pop();
      operator2 = stack3.pop().value;
      left = stack3.pop();
      markers.pop();
      expr2 = finishBinaryExpression(operator2, left, right);
      stack3.push(expr2);
    }
    token = lex();
    token.prec = prec;
    stack3.push(token);
    markers.push(lookahead);
    expr2 = parseUnaryExpression();
    stack3.push(expr2);
  }
  i = stack3.length - 1;
  expr2 = stack3[i];
  markers.pop();
  while (i > 1) {
    markers.pop();
    expr2 = finishBinaryExpression(stack3[i - 1].value, stack3[i - 2], expr2);
    i -= 2;
  }
  return expr2;
}
function parseConditionalExpression() {
  var expr2, consequent, alternate;
  expr2 = parseBinaryExpression();
  if (match("?")) {
    lex();
    consequent = parseConditionalExpression();
    expect(":");
    alternate = parseConditionalExpression();
    expr2 = finishConditionalExpression(expr2, consequent, alternate);
  }
  return expr2;
}
function parseExpression() {
  const expr2 = parseConditionalExpression();
  if (match(",")) {
    throw new Error(DISABLED);
  }
  return expr2;
}
function parser(code) {
  source2 = code;
  index2 = 0;
  length = source2.length;
  lookahead = null;
  peek2();
  const expr2 = parseExpression();
  if (lookahead.type !== TokenEOF) {
    throw new Error("Unexpect token after expression.");
  }
  return expr2;
}
var Constants = {
  NaN: "NaN",
  E: "Math.E",
  LN2: "Math.LN2",
  LN10: "Math.LN10",
  LOG2E: "Math.LOG2E",
  LOG10E: "Math.LOG10E",
  PI: "Math.PI",
  SQRT1_2: "Math.SQRT1_2",
  SQRT2: "Math.SQRT2",
  MIN_VALUE: "Number.MIN_VALUE",
  MAX_VALUE: "Number.MAX_VALUE"
};
function Functions(codegen2) {
  function fncall(name4, args, cast, type2) {
    let obj = codegen2(args[0]);
    if (cast) {
      obj = cast + "(" + obj + ")";
      if (cast.lastIndexOf("new ", 0) === 0)
        obj = "(" + obj + ")";
    }
    return obj + "." + name4 + (type2 < 0 ? "" : type2 === 0 ? "()" : "(" + args.slice(1).map(codegen2).join(",") + ")");
  }
  function fn(name4, cast, type2) {
    return (args) => fncall(name4, args, cast, type2);
  }
  const DATE2 = "new Date", STRING = "String", REGEXP = "RegExp";
  return {
    isNaN: "Number.isNaN",
    isFinite: "Number.isFinite",
    abs: "Math.abs",
    acos: "Math.acos",
    asin: "Math.asin",
    atan: "Math.atan",
    atan2: "Math.atan2",
    ceil: "Math.ceil",
    cos: "Math.cos",
    exp: "Math.exp",
    floor: "Math.floor",
    log: "Math.log",
    max: "Math.max",
    min: "Math.min",
    pow: "Math.pow",
    random: "Math.random",
    round: "Math.round",
    sin: "Math.sin",
    sqrt: "Math.sqrt",
    tan: "Math.tan",
    clamp: function(args) {
      if (args.length < 3)
        error("Missing arguments to clamp function.");
      if (args.length > 3)
        error("Too many arguments to clamp function.");
      const a2 = args.map(codegen2);
      return "Math.max(" + a2[1] + ", Math.min(" + a2[2] + "," + a2[0] + "))";
    },
    now: "Date.now",
    utc: "Date.UTC",
    datetime: DATE2,
    date: fn("getDate", DATE2, 0),
    day: fn("getDay", DATE2, 0),
    year: fn("getFullYear", DATE2, 0),
    month: fn("getMonth", DATE2, 0),
    hours: fn("getHours", DATE2, 0),
    minutes: fn("getMinutes", DATE2, 0),
    seconds: fn("getSeconds", DATE2, 0),
    milliseconds: fn("getMilliseconds", DATE2, 0),
    time: fn("getTime", DATE2, 0),
    timezoneoffset: fn("getTimezoneOffset", DATE2, 0),
    utcdate: fn("getUTCDate", DATE2, 0),
    utcday: fn("getUTCDay", DATE2, 0),
    utcyear: fn("getUTCFullYear", DATE2, 0),
    utcmonth: fn("getUTCMonth", DATE2, 0),
    utchours: fn("getUTCHours", DATE2, 0),
    utcminutes: fn("getUTCMinutes", DATE2, 0),
    utcseconds: fn("getUTCSeconds", DATE2, 0),
    utcmilliseconds: fn("getUTCMilliseconds", DATE2, 0),
    length: fn("length", null, -1),
    parseFloat: "parseFloat",
    parseInt: "parseInt",
    upper: fn("toUpperCase", STRING, 0),
    lower: fn("toLowerCase", STRING, 0),
    substring: fn("substring", STRING),
    split: fn("split", STRING),
    trim: fn("trim", STRING, 0),
    regexp: REGEXP,
    test: fn("test", REGEXP),
    if: function(args) {
      if (args.length < 3)
        error("Missing arguments to if function.");
      if (args.length > 3)
        error("Too many arguments to if function.");
      const a2 = args.map(codegen2);
      return "(" + a2[0] + "?" + a2[1] + ":" + a2[2] + ")";
    }
  };
}
function stripQuotes(s) {
  const n = s && s.length - 1;
  return n && (s[0] === '"' && s[n] === '"' || s[0] === "'" && s[n] === "'") ? s.slice(1, -1) : s;
}
function codegen(opt) {
  opt = opt || {};
  const allowed = opt.allowed ? toSet(opt.allowed) : {}, forbidden = opt.forbidden ? toSet(opt.forbidden) : {}, constants2 = opt.constants || Constants, functions = (opt.functions || Functions)(visit2), globalvar = opt.globalvar, fieldvar = opt.fieldvar, outputGlobal = isFunction(globalvar) ? globalvar : (id4) => "".concat(globalvar, '["').concat(id4, '"]');
  let globals = {}, fields = {}, memberDepth = 0;
  function visit2(ast) {
    if (isString(ast))
      return ast;
    const generator = Generators[ast.type];
    if (generator == null)
      error("Unsupported type: " + ast.type);
    return generator(ast);
  }
  const Generators = {
    Literal: (n) => n.raw,
    Identifier: (n) => {
      const id4 = n.name;
      if (memberDepth > 0) {
        return id4;
      } else if (has(forbidden, id4)) {
        return error("Illegal identifier: " + id4);
      } else if (has(constants2, id4)) {
        return constants2[id4];
      } else if (has(allowed, id4)) {
        return id4;
      } else {
        globals[id4] = 1;
        return outputGlobal(id4);
      }
    },
    MemberExpression: (n) => {
      const d = !n.computed, o = visit2(n.object);
      if (d)
        memberDepth += 1;
      const p = visit2(n.property);
      if (o === fieldvar) {
        fields[stripQuotes(p)] = 1;
      }
      if (d)
        memberDepth -= 1;
      return o + (d ? "." + p : "[" + p + "]");
    },
    CallExpression: (n) => {
      if (n.callee.type !== "Identifier") {
        error("Illegal callee type: " + n.callee.type);
      }
      const callee = n.callee.name, args = n.arguments, fn = has(functions, callee) && functions[callee];
      if (!fn)
        error("Unrecognized function: " + callee);
      return isFunction(fn) ? fn(args) : fn + "(" + args.map(visit2).join(",") + ")";
    },
    ArrayExpression: (n) => "[" + n.elements.map(visit2).join(",") + "]",
    BinaryExpression: (n) => "(" + visit2(n.left) + " " + n.operator + " " + visit2(n.right) + ")",
    UnaryExpression: (n) => "(" + n.operator + visit2(n.argument) + ")",
    ConditionalExpression: (n) => "(" + visit2(n.test) + "?" + visit2(n.consequent) + ":" + visit2(n.alternate) + ")",
    LogicalExpression: (n) => "(" + visit2(n.left) + n.operator + visit2(n.right) + ")",
    ObjectExpression: (n) => "{" + n.properties.map(visit2).join(",") + "}",
    Property: (n) => {
      memberDepth += 1;
      const k = visit2(n.key);
      memberDepth -= 1;
      return k + ":" + visit2(n.value);
    }
  };
  function codegen2(ast) {
    const result = {
      code: visit2(ast),
      globals: Object.keys(globals),
      fields: Object.keys(fields)
    };
    globals = {};
    fields = {};
    return result;
  }
  codegen2.functions = functions;
  codegen2.constants = constants2;
  return codegen2;
}

// node_modules/vega-selections/build/vega-selection.module.js
function ascending3(a2, b2) {
  return a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
}
function bisector(f) {
  let delta = f;
  let compare4 = f;
  if (f.length === 1) {
    delta = (d, x5) => f(d) - x5;
    compare4 = ascendingComparator2(f);
  }
  function left(a2, x5, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a2.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare4(a2[mid], x5) < 0)
        lo = mid + 1;
      else
        hi = mid;
    }
    return lo;
  }
  function right(a2, x5, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a2.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare4(a2[mid], x5) > 0)
        hi = mid;
      else
        lo = mid + 1;
    }
    return lo;
  }
  function center(a2, x5, lo, hi) {
    if (lo == null)
      lo = 0;
    if (hi == null)
      hi = a2.length;
    const i = left(a2, x5, lo, hi - 1);
    return i > lo && delta(a2[i - 1], x5) > -delta(a2[i], x5) ? i - 1 : i;
  }
  return {
    left,
    center,
    right
  };
}
function ascendingComparator2(f) {
  return (d, x5) => ascending3(f(d), x5);
}
var Intersect = "intersect";
var Union = "union";
var VlMulti = "vlMulti";
var VlPoint = "vlPoint";
var Or = "or";
var And = "and";
var SELECTION_ID = "_vgsid_";
var TYPE_ENUM = "E";
var TYPE_RANGE_INC = "R";
var TYPE_RANGE_EXC = "R-E";
var TYPE_RANGE_LE = "R-LE";
var TYPE_RANGE_RE = "R-RE";
var UNIT_INDEX = "index:unit";
function testPoint(datum3, entry2) {
  var fields = entry2.fields, values4 = entry2.values, n = fields.length, i = 0, dval, f;
  for (; i < n; ++i) {
    f = fields[i];
    f.getter = field.getter || field(f.field);
    dval = f.getter(datum3);
    if (isDate(dval))
      dval = toNumber(dval);
    if (isDate(values4[i]))
      values4[i] = toNumber(values4[i]);
    if (isDate(values4[i][0]))
      values4[i] = values4[i].map(toNumber);
    if (f.type === TYPE_ENUM) {
      if (isArray(values4[i]) ? values4[i].indexOf(dval) < 0 : dval !== values4[i]) {
        return false;
      }
    } else {
      if (f.type === TYPE_RANGE_INC) {
        if (!inrange(dval, values4[i]))
          return false;
      } else if (f.type === TYPE_RANGE_RE) {
        if (!inrange(dval, values4[i], true, false))
          return false;
      } else if (f.type === TYPE_RANGE_EXC) {
        if (!inrange(dval, values4[i], false, false))
          return false;
      } else if (f.type === TYPE_RANGE_LE) {
        if (!inrange(dval, values4[i], false, true))
          return false;
      }
    }
  }
  return true;
}
function selectionTest(name4, datum3, op) {
  var data4 = this.context.data[name4], entries3 = data4 ? data4.values.value : [], unitIdx = data4 ? data4[UNIT_INDEX] && data4[UNIT_INDEX].value : void 0, intersect6 = op === Intersect, n = entries3.length, i = 0, entry2, miss, count2, unit2, b2;
  for (; i < n; ++i) {
    entry2 = entries3[i];
    if (unitIdx && intersect6) {
      miss = miss || {};
      count2 = miss[unit2 = entry2.unit] || 0;
      if (count2 === -1)
        continue;
      b2 = testPoint(datum3, entry2);
      miss[unit2] = b2 ? -1 : ++count2;
      if (b2 && unitIdx.size === 1)
        return true;
      if (!b2 && count2 === unitIdx.get(unit2).count)
        return false;
    } else {
      b2 = testPoint(datum3, entry2);
      if (intersect6 ^ b2)
        return b2;
    }
  }
  return n && intersect6;
}
var selectionId = field(SELECTION_ID);
var bisect = bisector(selectionId);
var bisectLeft2 = bisect.left;
var bisectRight2 = bisect.right;
function selectionIdTest(name4, datum3, op) {
  const data4 = this.context.data[name4], entries3 = data4 ? data4.values.value : [], unitIdx = data4 ? data4[UNIT_INDEX] && data4[UNIT_INDEX].value : void 0, intersect6 = op === Intersect, value3 = selectionId(datum3), index4 = bisectLeft2(entries3, value3);
  if (index4 === entries3.length)
    return false;
  if (selectionId(entries3[index4]) !== value3)
    return false;
  if (unitIdx && intersect6) {
    if (unitIdx.size === 1)
      return true;
    if (bisectRight2(entries3, value3) - index4 < unitIdx.size)
      return false;
  }
  return true;
}
function selectionTuples(array5, base2) {
  return array5.map((x5) => extend({
    values: base2.fields.map((f) => (f.getter || (f.getter = field(f.field)))(x5.datum))
  }, base2));
}
function selectionResolve(name4, op, isMulti, vl5) {
  var data4 = this.context.data[name4], entries3 = data4 ? data4.values.value : [], resolved = {}, multiRes = {}, types3 = {}, entry2, fields, values4, unit2, field4, res, resUnit, type2, union, n = entries3.length, i = 0, j, m2;
  for (; i < n; ++i) {
    entry2 = entries3[i];
    unit2 = entry2.unit;
    fields = entry2.fields;
    values4 = entry2.values;
    for (j = 0, m2 = fields.length; j < m2; ++j) {
      field4 = fields[j];
      res = resolved[field4.field] || (resolved[field4.field] = {});
      resUnit = res[unit2] || (res[unit2] = []);
      types3[field4.field] = type2 = field4.type.charAt(0);
      union = ops[type2 + "_union"];
      res[unit2] = union(resUnit, array(values4[j]));
    }
    if (isMulti) {
      resUnit = multiRes[unit2] || (multiRes[unit2] = []);
      resUnit.push(array(values4).reduce((obj, curr, j2) => (obj[fields[j2].field] = curr, obj), {}));
    }
  }
  op = op || Union;
  Object.keys(resolved).forEach((field5) => {
    resolved[field5] = Object.keys(resolved[field5]).map((unit3) => resolved[field5][unit3]).reduce((acc, curr) => acc === void 0 ? curr : ops[types3[field5] + "_" + op](acc, curr));
  });
  entries3 = Object.keys(multiRes);
  if (isMulti && entries3.length) {
    const key2 = vl5 ? VlPoint : VlMulti;
    resolved[key2] = op === Union ? {
      [Or]: entries3.reduce((acc, k) => (acc.push(...multiRes[k]), acc), [])
    } : {
      [And]: entries3.map((k) => ({
        [Or]: multiRes[k]
      }))
    };
  }
  return resolved;
}
var ops = {
  E_union: function(base2, value3) {
    if (!base2.length)
      return value3;
    var i = 0, n = value3.length;
    for (; i < n; ++i)
      if (base2.indexOf(value3[i]) < 0)
        base2.push(value3[i]);
    return base2;
  },
  E_intersect: function(base2, value3) {
    return !base2.length ? value3 : base2.filter((v) => value3.indexOf(v) >= 0);
  },
  R_union: function(base2, value3) {
    var lo = toNumber(value3[0]), hi = toNumber(value3[1]);
    if (lo > hi) {
      lo = value3[1];
      hi = value3[0];
    }
    if (!base2.length)
      return [lo, hi];
    if (base2[0] > lo)
      base2[0] = lo;
    if (base2[1] < hi)
      base2[1] = hi;
    return base2;
  },
  R_intersect: function(base2, value3) {
    var lo = toNumber(value3[0]), hi = toNumber(value3[1]);
    if (lo > hi) {
      lo = value3[1];
      hi = value3[0];
    }
    if (!base2.length)
      return [lo, hi];
    if (hi < base2[0] || base2[1] < lo) {
      return [];
    } else {
      if (base2[0] < lo)
        base2[0] = lo;
      if (base2[1] > hi)
        base2[1] = hi;
    }
    return base2;
  }
};
var DataPrefix = ":";
var IndexPrefix = "@";
function selectionVisitor(name4, args, scope, params2) {
  if (args[0].type !== Literal)
    error("First argument to selection functions must be a string literal.");
  const data4 = args[0].value, op = args.length >= 2 && peek(args).value, field4 = "unit", indexName = IndexPrefix + field4, dataName = DataPrefix + data4;
  if (op === Intersect && !has(params2, indexName)) {
    params2[indexName] = scope.getData(data4).indataRef(scope, field4);
  }
  if (!has(params2, dataName)) {
    params2[dataName] = scope.getData(data4).tuplesRef();
  }
}

// node_modules/vega-functions/build/vega-functions.module.js
function data(name4) {
  const data4 = this.context.data[name4];
  return data4 ? data4.values.value : [];
}
function indata(name4, field4, value3) {
  const index4 = this.context.data[name4]["index:" + field4], entry2 = index4 ? index4.value.get(value3) : void 0;
  return entry2 ? entry2.count : entry2;
}
function setdata(name4, tuples) {
  const df = this.context.dataflow, data4 = this.context.data[name4], input = data4.input;
  df.pulse(input, df.changeset().remove(truthy).insert(tuples));
  return 1;
}
function encode(item, name4, retval) {
  if (item) {
    const df = this.context.dataflow, target = item.mark.source;
    df.pulse(target, df.changeset().encode(item, name4));
  }
  return retval !== void 0 ? retval : item;
}
var wrap = (method2) => function(value3, spec) {
  const locale6 = this.context.dataflow.locale();
  return locale6[method2](spec)(value3);
};
var format5 = wrap("format");
var timeFormat2 = wrap("timeFormat");
var utcFormat2 = wrap("utcFormat");
var timeParse2 = wrap("timeParse");
var utcParse2 = wrap("utcParse");
var dateObj = new Date(2e3, 0, 1);
function time2(month2, day2, specifier) {
  if (!Number.isInteger(month2) || !Number.isInteger(day2))
    return "";
  dateObj.setYear(2e3);
  dateObj.setMonth(month2);
  dateObj.setDate(day2);
  return timeFormat2.call(this, dateObj, specifier);
}
function monthFormat(month2) {
  return time2.call(this, month2, 1, "%B");
}
function monthAbbrevFormat(month2) {
  return time2.call(this, month2, 1, "%b");
}
function dayFormat(day2) {
  return time2.call(this, 0, 2 + day2, "%A");
}
function dayAbbrevFormat(day2) {
  return time2.call(this, 0, 2 + day2, "%a");
}
var DataPrefix2 = ":";
var IndexPrefix2 = "@";
var ScalePrefix = "%";
var SignalPrefix = "$";
function dataVisitor(name4, args, scope, params2) {
  if (args[0].type !== Literal) {
    error("First argument to data functions must be a string literal.");
  }
  const data4 = args[0].value, dataName = DataPrefix2 + data4;
  if (!has(dataName, params2)) {
    try {
      params2[dataName] = scope.getData(data4).tuplesRef();
    } catch (err) {
    }
  }
}
function indataVisitor(name4, args, scope, params2) {
  if (args[0].type !== Literal)
    error("First argument to indata must be a string literal.");
  if (args[1].type !== Literal)
    error("Second argument to indata must be a string literal.");
  const data4 = args[0].value, field4 = args[1].value, indexName = IndexPrefix2 + field4;
  if (!has(indexName, params2)) {
    params2[indexName] = scope.getData(data4).indataRef(scope, field4);
  }
}
function scaleVisitor(name4, args, scope, params2) {
  if (args[0].type === Literal) {
    addScaleDependency(scope, params2, args[0].value);
  } else {
    for (name4 in scope.scales) {
      addScaleDependency(scope, params2, name4);
    }
  }
}
function addScaleDependency(scope, params2, name4) {
  const scaleName = ScalePrefix + name4;
  if (!has(params2, scaleName)) {
    try {
      params2[scaleName] = scope.scaleRef(name4);
    } catch (err) {
    }
  }
}
function getScale(name4, ctx) {
  let s;
  return isFunction(name4) ? name4 : isString(name4) ? (s = ctx.scales[name4]) && s.value : void 0;
}
function internalScaleFunctions(codegen2, fnctx, visitors) {
  fnctx.__bandwidth = (s) => s && s.bandwidth ? s.bandwidth() : 0;
  visitors._bandwidth = scaleVisitor;
  visitors._range = scaleVisitor;
  visitors._scale = scaleVisitor;
  const ref6 = (arg) => "_[" + (arg.type === Literal ? $(ScalePrefix + arg.value) : $(ScalePrefix) + "+" + codegen2(arg)) + "]";
  return {
    _bandwidth: (args) => "this.__bandwidth(".concat(ref6(args[0]), ")"),
    _range: (args) => "".concat(ref6(args[0]), ".range()"),
    _scale: (args) => "".concat(ref6(args[0]), "(").concat(codegen2(args[1]), ")")
  };
}
function geoMethod(methodName, globalMethod) {
  return function(projection3, geojson, group2) {
    if (projection3) {
      const p = getScale(projection3, (group2 || this).context);
      return p && p.path[methodName](geojson);
    } else {
      return globalMethod(geojson);
    }
  };
}
var geoArea = geoMethod("area", area_default2);
var geoBounds = geoMethod("bounds", bounds_default);
var geoCentroid = geoMethod("centroid", centroid_default);
function inScope(item) {
  const group2 = this.context.group;
  let value3 = false;
  if (group2)
    while (item) {
      if (item === group2) {
        value3 = true;
        break;
      }
      item = item.mark.group;
    }
  return value3;
}
function log5(df, method2, args) {
  try {
    df[method2].apply(df, ["EXPRESSION"].concat([].slice.call(args)));
  } catch (err) {
    df.warn(err);
  }
  return args[args.length - 1];
}
function warn() {
  return log5(this.context.dataflow, "warn", arguments);
}
function info() {
  return log5(this.context.dataflow, "info", arguments);
}
function debug() {
  return log5(this.context.dataflow, "debug", arguments);
}
function channel_luminance_value(channelValue) {
  const val = channelValue / 255;
  if (val <= 0.03928) {
    return val / 12.92;
  }
  return Math.pow((val + 0.055) / 1.055, 2.4);
}
function luminance(color5) {
  const c2 = rgb(color5), r2 = channel_luminance_value(c2.r), g = channel_luminance_value(c2.g), b2 = channel_luminance_value(c2.b);
  return 0.2126 * r2 + 0.7152 * g + 0.0722 * b2;
}
function contrast(color1, color22) {
  const lum1 = luminance(color1), lum2 = luminance(color22), lumL = Math.max(lum1, lum2), lumD = Math.min(lum1, lum2);
  return (lumL + 0.05) / (lumD + 0.05);
}
function merge4() {
  const args = [].slice.call(arguments);
  args.unshift({});
  return extend(...args);
}
function equal(a2, b2) {
  return a2 === b2 || a2 !== a2 && b2 !== b2 ? true : isArray(a2) ? isArray(b2) && a2.length === b2.length ? equalArray(a2, b2) : false : isObject(a2) && isObject(b2) ? equalObject(a2, b2) : false;
}
function equalArray(a2, b2) {
  for (let i = 0, n = a2.length; i < n; ++i) {
    if (!equal(a2[i], b2[i]))
      return false;
  }
  return true;
}
function equalObject(a2, b2) {
  for (const key2 in a2) {
    if (!equal(a2[key2], b2[key2]))
      return false;
  }
  return true;
}
function removePredicate(props) {
  return (_) => equalObject(props, _);
}
function modify(name4, insert2, remove3, toggle2, modify3, values4) {
  const df = this.context.dataflow, data4 = this.context.data[name4], input = data4.input, stamp = df.stamp();
  let changes = data4.changes, predicate, key2;
  if (df._trigger === false || !(input.value.length || insert2 || toggle2)) {
    return 0;
  }
  if (!changes || changes.stamp < stamp) {
    data4.changes = changes = df.changeset();
    changes.stamp = stamp;
    df.runAfter(() => {
      data4.modified = true;
      df.pulse(input, changes).run();
    }, true, 1);
  }
  if (remove3) {
    predicate = remove3 === true ? truthy : isArray(remove3) || isTuple(remove3) ? remove3 : removePredicate(remove3);
    changes.remove(predicate);
  }
  if (insert2) {
    changes.insert(insert2);
  }
  if (toggle2) {
    predicate = removePredicate(toggle2);
    if (input.value.some(predicate)) {
      changes.remove(predicate);
    } else {
      changes.insert(toggle2);
    }
  }
  if (modify3) {
    for (key2 in values4) {
      changes.modify(modify3, key2, values4[key2]);
    }
  }
  return 1;
}
function pinchDistance(event2) {
  const t = event2.touches, dx = t[0].clientX - t[1].clientX, dy = t[0].clientY - t[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}
function pinchAngle(event2) {
  const t = event2.touches;
  return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);
}
var accessors = {};
function pluck(data4, name4) {
  const accessor3 = accessors[name4] || (accessors[name4] = field(name4));
  return isArray(data4) ? data4.map(accessor3) : accessor3(data4);
}
function array3(seq) {
  return isArray(seq) || ArrayBuffer.isView(seq) ? seq : null;
}
function sequence2(seq) {
  return array3(seq) || (isString(seq) ? seq : null);
}
function join2(seq, ...args) {
  return array3(seq).join(...args);
}
function indexof(seq, ...args) {
  return sequence2(seq).indexOf(...args);
}
function lastindexof(seq, ...args) {
  return sequence2(seq).lastIndexOf(...args);
}
function slice3(seq, ...args) {
  return sequence2(seq).slice(...args);
}
function replace2(str, pattern, repl) {
  if (isFunction(repl))
    error("Function argument passed to replace.");
  return String(str).replace(pattern, repl);
}
function reverse(seq) {
  return array3(seq).slice().reverse();
}
function bandspace(count2, paddingInner2, paddingOuter2) {
  return bandSpace(count2 || 0, paddingInner2 || 0, paddingOuter2 || 0);
}
function bandwidth(name4, group2) {
  const s = getScale(name4, (group2 || this).context);
  return s && s.bandwidth ? s.bandwidth() : 0;
}
function copy3(name4, group2) {
  const s = getScale(name4, (group2 || this).context);
  return s ? s.copy() : void 0;
}
function domain(name4, group2) {
  const s = getScale(name4, (group2 || this).context);
  return s ? s.domain() : [];
}
function invert(name4, range5, group2) {
  const s = getScale(name4, (group2 || this).context);
  return !s ? void 0 : isArray(range5) ? (s.invertRange || s.invert)(range5) : (s.invert || s.invertExtent)(range5);
}
function range2(name4, group2) {
  const s = getScale(name4, (group2 || this).context);
  return s && s.range ? s.range() : [];
}
function scale3(name4, value3, group2) {
  const s = getScale(name4, (group2 || this).context);
  return s ? s(value3) : void 0;
}
function scaleGradient(scale7, p02, p1, count2, group2) {
  scale7 = getScale(scale7, (group2 || this).context);
  const gradient4 = Gradient(p02, p1);
  let stops = scale7.domain(), min4 = stops[0], max4 = peek(stops), fraction = identity;
  if (!(max4 - min4)) {
    scale7 = (scale7.interpolator ? scale("sequential")().interpolator(scale7.interpolator()) : scale("linear")().interpolate(scale7.interpolate()).range(scale7.range())).domain([min4 = 0, max4 = 1]);
  } else {
    fraction = scaleFraction(scale7, min4, max4);
  }
  if (scale7.ticks) {
    stops = scale7.ticks(+count2 || 15);
    if (min4 !== stops[0])
      stops.unshift(min4);
    if (max4 !== peek(stops))
      stops.push(max4);
  }
  stops.forEach((_) => gradient4.stop(fraction(_), scale7(_)));
  return gradient4;
}
function geoShape(projection3, geojson, group2) {
  const p = getScale(projection3, (group2 || this).context);
  return function(context3) {
    return p ? p.path.context(context3)(geojson) : "";
  };
}
function pathShape(path3) {
  let p = null;
  return function(context3) {
    return context3 ? pathRender(context3, p = p || pathParse(path3)) : path3;
  };
}
var datum = (d) => d.data;
function treeNodes(name4, context3) {
  const tree = data.call(context3, name4);
  return tree.root && tree.root.lookup || {};
}
function treePath(name4, source4, target) {
  const nodes = treeNodes(name4, this), s = nodes[source4], t = nodes[target];
  return s && t ? s.path(t).map(datum) : void 0;
}
function treeAncestors(name4, node) {
  const n = treeNodes(name4, this)[node];
  return n ? n.ancestors().map(datum) : void 0;
}
var _window = () => typeof window !== "undefined" && window || null;
function screen() {
  const w3 = _window();
  return w3 ? w3.screen : {};
}
function windowSize() {
  const w3 = _window();
  return w3 ? [w3.innerWidth, w3.innerHeight] : [void 0, void 0];
}
function containerSize() {
  const view = this.context.dataflow, el = view.container && view.container();
  return el ? [el.clientWidth, el.clientHeight] : [void 0, void 0];
}
function intersect4(b2, opt, group2) {
  if (!b2)
    return [];
  const [u, v] = b2, box = new Bounds().set(u[0], u[1], v[0], v[1]), scene = group2 || this.context.dataflow.scenegraph().root;
  return intersect2(scene, box, filter2(opt));
}
function filter2(opt) {
  let p = null;
  if (opt) {
    const types3 = array(opt.marktype), names = array(opt.markname);
    p = (_) => (!types3.length || types3.some((t) => _.marktype === t)) && (!names.length || names.some((s) => _.name === s));
  }
  return p;
}
var functionContext = {
  random() {
    return random();
  },
  cumulativeNormal,
  cumulativeLogNormal,
  cumulativeUniform,
  densityNormal,
  densityLogNormal,
  densityUniform,
  quantileNormal,
  quantileLogNormal,
  quantileUniform,
  sampleNormal,
  sampleLogNormal,
  sampleUniform,
  isArray,
  isBoolean,
  isDate,
  isDefined(_) {
    return _ !== void 0;
  },
  isNumber,
  isObject,
  isRegExp,
  isString,
  isTuple,
  isValid(_) {
    return _ != null && _ === _;
  },
  toBoolean,
  toDate,
  toNumber,
  toString,
  indexof,
  join: join2,
  lastindexof,
  replace: replace2,
  reverse,
  slice: slice3,
  flush,
  lerp,
  merge: merge4,
  pad,
  peek,
  pluck,
  span,
  inrange,
  truncate,
  rgb,
  lab,
  hcl,
  hsl,
  luminance,
  contrast,
  sequence: range_default,
  format: format5,
  utcFormat: utcFormat2,
  utcParse: utcParse2,
  utcOffset,
  utcSequence,
  timeFormat: timeFormat2,
  timeParse: timeParse2,
  timeOffset,
  timeSequence,
  timeUnitSpecifier,
  monthFormat,
  monthAbbrevFormat,
  dayFormat,
  dayAbbrevFormat,
  quarter,
  utcquarter,
  week,
  utcweek,
  dayofyear,
  utcdayofyear,
  warn,
  info,
  debug,
  extent,
  inScope,
  intersect: intersect4,
  clampRange,
  pinchDistance,
  pinchAngle,
  screen,
  containerSize,
  windowSize,
  bandspace,
  setdata,
  pathShape,
  panLinear,
  panLog,
  panPow,
  panSymlog,
  zoomLinear,
  zoomLog,
  zoomPow,
  zoomSymlog,
  encode,
  modify
};
var eventFunctions = ["view", "item", "group", "xy", "x", "y"];
var eventPrefix = "event.vega.";
var thisPrefix = "this.";
var astVisitors = {};
var codegenParams = {
  forbidden: ["_"],
  allowed: ["datum", "event", "item"],
  fieldvar: "datum",
  globalvar: (id4) => "_[".concat($(SignalPrefix + id4), "]"),
  functions: buildFunctions,
  constants: Constants,
  visitors: astVisitors
};
var codeGenerator = codegen(codegenParams);
function buildFunctions(codegen2) {
  const fn = Functions(codegen2);
  eventFunctions.forEach((name4) => fn[name4] = eventPrefix + name4);
  for (const name4 in functionContext) {
    fn[name4] = thisPrefix + name4;
  }
  extend(fn, internalScaleFunctions(codegen2, functionContext, astVisitors));
  return fn;
}
function expressionFunction(name4, fn, visitor) {
  if (arguments.length === 1) {
    return functionContext[name4];
  }
  functionContext[name4] = fn;
  if (visitor)
    astVisitors[name4] = visitor;
  if (codeGenerator)
    codeGenerator.functions[name4] = thisPrefix + name4;
  return this;
}
expressionFunction("bandwidth", bandwidth, scaleVisitor);
expressionFunction("copy", copy3, scaleVisitor);
expressionFunction("domain", domain, scaleVisitor);
expressionFunction("range", range2, scaleVisitor);
expressionFunction("invert", invert, scaleVisitor);
expressionFunction("scale", scale3, scaleVisitor);
expressionFunction("gradient", scaleGradient, scaleVisitor);
expressionFunction("geoArea", geoArea, scaleVisitor);
expressionFunction("geoBounds", geoBounds, scaleVisitor);
expressionFunction("geoCentroid", geoCentroid, scaleVisitor);
expressionFunction("geoShape", geoShape, scaleVisitor);
expressionFunction("indata", indata, indataVisitor);
expressionFunction("data", data, dataVisitor);
expressionFunction("treePath", treePath, dataVisitor);
expressionFunction("treeAncestors", treeAncestors, dataVisitor);
expressionFunction("vlSelectionTest", selectionTest, selectionVisitor);
expressionFunction("vlSelectionIdTest", selectionIdTest, selectionVisitor);
expressionFunction("vlSelectionResolve", selectionResolve, selectionVisitor);
expressionFunction("vlSelectionTuples", selectionTuples);
function parser2(expr2, scope) {
  const params2 = {};
  let ast;
  try {
    expr2 = isString(expr2) ? expr2 : $(expr2) + "";
    ast = parser(expr2);
  } catch (err) {
    error("Expression parse error: " + expr2);
  }
  ast.visit((node) => {
    if (node.type !== CallExpression)
      return;
    const name4 = node.callee.name, visit2 = codegenParams.visitors[name4];
    if (visit2)
      visit2(name4, node.arguments, scope, params2);
  });
  const gen = codeGenerator(ast);
  gen.globals.forEach((name4) => {
    const signalName = SignalPrefix + name4;
    if (!has(params2, signalName) && scope.getSignal(name4)) {
      params2[signalName] = scope.signalRef(name4);
    }
  });
  return {
    $expr: extend({
      code: gen.code
    }, scope.options.ast ? {
      ast
    } : null),
    $fields: gen.fields,
    $params: params2
  };
}

// node_modules/vega-runtime/build/vega-runtime.module.js
function parse4(spec) {
  const ctx = this, operators = spec.operators || [];
  if (spec.background) {
    ctx.background = spec.background;
  }
  if (spec.eventConfig) {
    ctx.eventConfig = spec.eventConfig;
  }
  if (spec.locale) {
    ctx.locale = spec.locale;
  }
  operators.forEach((entry2) => ctx.parseOperator(entry2));
  operators.forEach((entry2) => ctx.parseOperatorParameters(entry2));
  (spec.streams || []).forEach((entry2) => ctx.parseStream(entry2));
  (spec.updates || []).forEach((entry2) => ctx.parseUpdate(entry2));
  return ctx.resolve();
}
var Skip = toSet(["rule"]);
var Swap = toSet(["group", "image", "rect"]);
function adjustSpatial(encode15, marktype) {
  let code = "";
  if (Skip[marktype])
    return code;
  if (encode15.x2) {
    if (encode15.x) {
      if (Swap[marktype]) {
        code += "if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;";
      }
      code += "o.width=o.x2-o.x;";
    } else {
      code += "o.x=o.x2-(o.width||0);";
    }
  }
  if (encode15.xc) {
    code += "o.x=o.xc-(o.width||0)/2;";
  }
  if (encode15.y2) {
    if (encode15.y) {
      if (Swap[marktype]) {
        code += "if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;";
      }
      code += "o.height=o.y2-o.y;";
    } else {
      code += "o.y=o.y2-(o.height||0);";
    }
  }
  if (encode15.yc) {
    code += "o.y=o.yc-(o.height||0)/2;";
  }
  return code;
}
function canonicalType(type2) {
  return (type2 + "").toLowerCase();
}
function isOperator(type2) {
  return canonicalType(type2) === "operator";
}
function isCollect(type2) {
  return canonicalType(type2) === "collect";
}
function expression(ctx, args, code) {
  if (code[code.length - 1] !== ";") {
    code = "return(" + code + ");";
  }
  const fn = Function(...args.concat(code));
  return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;
}
function _compare(u, v, lt, gt) {
  return "((u = ".concat(u, ") < (v = ").concat(v, ") || u == null) && v != null ? ").concat(lt, "\n  : (u > v || v == null) && u != null ? ").concat(gt, "\n  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ").concat(lt, "\n  : v !== v && u === u ? ").concat(gt, " : ");
}
var expressionCodegen = {
  operator: (ctx, expr2) => expression(ctx, ["_"], expr2.code),
  parameter: (ctx, expr2) => expression(ctx, ["datum", "_"], expr2.code),
  event: (ctx, expr2) => expression(ctx, ["event"], expr2.code),
  handler: (ctx, expr2) => {
    const code = "var datum=event.item&&event.item.datum;return ".concat(expr2.code, ";");
    return expression(ctx, ["_", "event"], code);
  },
  encode: (ctx, encode15) => {
    const {
      marktype,
      channels
    } = encode15;
    let code = "var o=item,datum=o.datum,m=0,$;";
    for (const name4 in channels) {
      const o = "o[" + $(name4) + "]";
      code += "$=".concat(channels[name4].code, ";if(").concat(o, "!==$)").concat(o, "=$,m=1;");
    }
    code += adjustSpatial(channels, marktype);
    code += "return m;";
    return expression(ctx, ["item", "_"], code);
  },
  codegen: {
    get(path3) {
      const ref6 = "[".concat(path3.map($).join("]["), "]");
      const get6 = Function("_", "return _".concat(ref6, ";"));
      get6.path = ref6;
      return get6;
    },
    comparator(fields, orders) {
      let t;
      const map4 = (f, i) => {
        const o = orders[i];
        let u, v;
        if (f.path) {
          u = "a".concat(f.path);
          v = "b".concat(f.path);
        } else {
          (t = t || {})["f" + i] = f;
          u = "this.f".concat(i, "(a)");
          v = "this.f".concat(i, "(b)");
        }
        return _compare(u, v, -o, o);
      };
      const fn = Function("a", "b", "var u, v; return " + fields.map(map4).join("") + "0;");
      return t ? fn.bind(t) : fn;
    }
  }
};
function parseOperator(spec) {
  const ctx = this;
  if (isOperator(spec.type) || !spec.type) {
    ctx.operator(spec, spec.update ? ctx.operatorExpression(spec.update) : null);
  } else {
    ctx.transform(spec, spec.type);
  }
}
function parseOperatorParameters(spec) {
  const ctx = this;
  if (spec.params) {
    const op = ctx.get(spec.id);
    if (!op)
      error("Invalid operator id: " + spec.id);
    ctx.dataflow.connect(op, op.parameters(ctx.parseParameters(spec.params), spec.react, spec.initonly));
  }
}
function parseParameters(spec, params2) {
  params2 = params2 || {};
  const ctx = this;
  for (const key2 in spec) {
    const value3 = spec[key2];
    params2[key2] = isArray(value3) ? value3.map((v) => parseParameter(v, ctx, params2)) : parseParameter(value3, ctx, params2);
  }
  return params2;
}
function parseParameter(spec, ctx, params2) {
  if (!spec || !isObject(spec))
    return spec;
  for (let i = 0, n = PARSERS.length, p; i < n; ++i) {
    p = PARSERS[i];
    if (has(spec, p.key)) {
      return p.parse(spec, ctx, params2);
    }
  }
  return spec;
}
var PARSERS = [{
  key: "$ref",
  parse: getOperator
}, {
  key: "$key",
  parse: getKey
}, {
  key: "$expr",
  parse: getExpression
}, {
  key: "$field",
  parse: getField2
}, {
  key: "$encode",
  parse: getEncode
}, {
  key: "$compare",
  parse: getCompare
}, {
  key: "$context",
  parse: getContext
}, {
  key: "$subflow",
  parse: getSubflow
}, {
  key: "$tupleid",
  parse: getTupleId
}];
function getOperator(_, ctx) {
  return ctx.get(_.$ref) || error("Operator not defined: " + _.$ref);
}
function getExpression(_, ctx, params2) {
  if (_.$params) {
    ctx.parseParameters(_.$params, params2);
  }
  const k = "e:" + _.$expr.code + "_" + _.$name;
  return ctx.fn[k] || (ctx.fn[k] = accessor(ctx.parameterExpression(_.$expr), _.$fields, _.$name));
}
function getKey(_, ctx) {
  const k = "k:" + _.$key + "_" + !!_.$flat;
  return ctx.fn[k] || (ctx.fn[k] = key(_.$key, _.$flat, ctx.expr.codegen));
}
function getField2(_, ctx) {
  if (!_.$field)
    return null;
  const k = "f:" + _.$field + "_" + _.$name;
  return ctx.fn[k] || (ctx.fn[k] = field(_.$field, _.$name, ctx.expr.codegen));
}
function getCompare(_, ctx) {
  const k = "c:" + _.$compare + "_" + _.$order, c2 = array(_.$compare).map((_2) => _2 && _2.$tupleid ? tupleid : _2);
  return ctx.fn[k] || (ctx.fn[k] = compare2(c2, _.$order, ctx.expr.codegen));
}
function getEncode(_, ctx) {
  const spec = _.$encode, encode15 = {};
  for (const name4 in spec) {
    const enc = spec[name4];
    encode15[name4] = accessor(ctx.encodeExpression(enc.$expr), enc.$fields);
    encode15[name4].output = enc.$output;
  }
  return encode15;
}
function getContext(_, ctx) {
  return ctx;
}
function getSubflow(_, ctx) {
  const spec = _.$subflow;
  return function(dataflow, key2, parent) {
    const subctx = ctx.fork().parse(spec), op = subctx.get(spec.operators[0].id), p = subctx.signals.parent;
    if (p)
      p.set(parent);
    op.detachSubflow = () => ctx.detach(subctx);
    return op;
  };
}
function getTupleId() {
  return tupleid;
}
function parseStream(spec) {
  var ctx = this, filter4 = spec.filter != null ? ctx.eventExpression(spec.filter) : void 0, stream2 = spec.stream != null ? ctx.get(spec.stream) : void 0, args;
  if (spec.source) {
    stream2 = ctx.events(spec.source, spec.type, filter4);
  } else if (spec.merge) {
    args = spec.merge.map((_) => ctx.get(_));
    stream2 = args[0].merge.apply(args[0], args.slice(1));
  }
  if (spec.between) {
    args = spec.between.map((_) => ctx.get(_));
    stream2 = stream2.between(args[0], args[1]);
  }
  if (spec.filter) {
    stream2 = stream2.filter(filter4);
  }
  if (spec.throttle != null) {
    stream2 = stream2.throttle(+spec.throttle);
  }
  if (spec.debounce != null) {
    stream2 = stream2.debounce(+spec.debounce);
  }
  if (stream2 == null) {
    error("Invalid stream definition: " + JSON.stringify(spec));
  }
  if (spec.consume)
    stream2.consume(true);
  ctx.stream(spec, stream2);
}
function parseUpdate(spec) {
  var ctx = this, srcid = isObject(srcid = spec.source) ? srcid.$ref : srcid, source4 = ctx.get(srcid), target = null, update3 = spec.update, params2 = void 0;
  if (!source4)
    error("Source not defined: " + spec.source);
  target = spec.target && spec.target.$expr ? ctx.eventExpression(spec.target.$expr) : ctx.get(spec.target);
  if (update3 && update3.$expr) {
    if (update3.$params) {
      params2 = ctx.parseParameters(update3.$params);
    }
    update3 = ctx.handlerExpression(update3.$expr);
  }
  ctx.update(spec, source4, target, update3, params2);
}
var SKIP3 = {
  skip: true
};
function getState(options2) {
  var ctx = this, state = {};
  if (options2.signals) {
    var signals = state.signals = {};
    Object.keys(ctx.signals).forEach((key2) => {
      const op = ctx.signals[key2];
      if (options2.signals(key2, op)) {
        signals[key2] = op.value;
      }
    });
  }
  if (options2.data) {
    var data4 = state.data = {};
    Object.keys(ctx.data).forEach((key2) => {
      const dataset = ctx.data[key2];
      if (options2.data(key2, dataset)) {
        data4[key2] = dataset.input.value;
      }
    });
  }
  if (ctx.subcontext && options2.recurse !== false) {
    state.subcontext = ctx.subcontext.map((ctx2) => ctx2.getState(options2));
  }
  return state;
}
function setState(state) {
  var ctx = this, df = ctx.dataflow, data4 = state.data, signals = state.signals;
  Object.keys(signals || {}).forEach((key2) => {
    df.update(ctx.signals[key2], signals[key2], SKIP3);
  });
  Object.keys(data4 || {}).forEach((key2) => {
    df.pulse(ctx.data[key2].input, df.changeset().remove(truthy).insert(data4[key2]));
  });
  (state.subcontext || []).forEach((substate, i) => {
    const subctx = ctx.subcontext[i];
    if (subctx)
      subctx.setState(substate);
  });
}
function context2(df, transforms2, functions, expr2) {
  return new Context(df, transforms2, functions, expr2);
}
function Context(df, transforms2, functions, expr2) {
  this.dataflow = df;
  this.transforms = transforms2;
  this.events = df.events.bind(df);
  this.expr = expr2 || expressionCodegen, this.signals = {};
  this.scales = {};
  this.nodes = {};
  this.data = {};
  this.fn = {};
  if (functions) {
    this.functions = Object.create(functions);
    this.functions.context = this;
  }
}
function Subcontext(ctx) {
  this.dataflow = ctx.dataflow;
  this.transforms = ctx.transforms;
  this.events = ctx.events;
  this.expr = ctx.expr;
  this.signals = Object.create(ctx.signals);
  this.scales = Object.create(ctx.scales);
  this.nodes = Object.create(ctx.nodes);
  this.data = Object.create(ctx.data);
  this.fn = Object.create(ctx.fn);
  if (ctx.functions) {
    this.functions = Object.create(ctx.functions);
    this.functions.context = this;
  }
}
Context.prototype = Subcontext.prototype = {
  fork() {
    const ctx = new Subcontext(this);
    (this.subcontext || (this.subcontext = [])).push(ctx);
    return ctx;
  },
  detach(ctx) {
    this.subcontext = this.subcontext.filter((c2) => c2 !== ctx);
    const keys4 = Object.keys(ctx.nodes);
    for (const key2 of keys4)
      ctx.nodes[key2]._targets = null;
    for (const key2 of keys4)
      ctx.nodes[key2].detach();
    ctx.nodes = null;
  },
  get(id4) {
    return this.nodes[id4];
  },
  set(id4, node) {
    return this.nodes[id4] = node;
  },
  add(spec, op) {
    const ctx = this, df = ctx.dataflow, data4 = spec.value;
    ctx.set(spec.id, op);
    if (isCollect(spec.type) && data4) {
      if (data4.$ingest) {
        df.ingest(op, data4.$ingest, data4.$format);
      } else if (data4.$request) {
        df.preload(op, data4.$request, data4.$format);
      } else {
        df.pulse(op, df.changeset().insert(data4));
      }
    }
    if (spec.root) {
      ctx.root = op;
    }
    if (spec.parent) {
      let p = ctx.get(spec.parent.$ref);
      if (p) {
        df.connect(p, [op]);
        op.targets().add(p);
      } else {
        (ctx.unresolved = ctx.unresolved || []).push(() => {
          p = ctx.get(spec.parent.$ref);
          df.connect(p, [op]);
          op.targets().add(p);
        });
      }
    }
    if (spec.signal) {
      ctx.signals[spec.signal] = op;
    }
    if (spec.scale) {
      ctx.scales[spec.scale] = op;
    }
    if (spec.data) {
      for (const name4 in spec.data) {
        const data5 = ctx.data[name4] || (ctx.data[name4] = {});
        spec.data[name4].forEach((role) => data5[role] = op);
      }
    }
  },
  resolve() {
    (this.unresolved || []).forEach((fn) => fn());
    delete this.unresolved;
    return this;
  },
  operator(spec, update3) {
    this.add(spec, this.dataflow.add(spec.value, update3));
  },
  transform(spec, type2) {
    this.add(spec, this.dataflow.add(this.transforms[canonicalType(type2)]));
  },
  stream(spec, stream2) {
    this.set(spec.id, stream2);
  },
  update(spec, stream2, target, update3, params2) {
    this.dataflow.on(stream2, target, update3, params2, spec.options);
  },
  operatorExpression(expr2) {
    return this.expr.operator(this, expr2);
  },
  parameterExpression(expr2) {
    return this.expr.parameter(this, expr2);
  },
  eventExpression(expr2) {
    return this.expr.event(this, expr2);
  },
  handlerExpression(expr2) {
    return this.expr.handler(this, expr2);
  },
  encodeExpression(encode15) {
    return this.expr.encode(this, encode15);
  },
  parse: parse4,
  parseOperator,
  parseOperatorParameters,
  parseParameters,
  parseStream,
  parseUpdate,
  getState,
  setState
};

// node_modules/vega-view/build/vega-view.module.js
function initializeAria(view) {
  const el = view.container();
  if (el) {
    el.setAttribute("role", "graphics-document");
    el.setAttribute("aria-roleDescription", "visualization");
    ariaLabel(el, view.description());
  }
}
function ariaLabel(el, desc) {
  if (el)
    desc == null ? el.removeAttribute("aria-label") : el.setAttribute("aria-label", desc);
}
function background2(view) {
  view.add(null, (_) => {
    view._background = _.bg;
    view._resize = 1;
    return _.bg;
  }, {
    bg: view._signals.background
  });
}
var Default = "default";
function cursor(view) {
  const cursor3 = view._signals.cursor || (view._signals.cursor = view.add({
    user: Default,
    item: null
  }));
  view.on(view.events("view", "mousemove"), cursor3, (_, event2) => {
    const value3 = cursor3.value, user = value3 ? isString(value3) ? value3 : value3.user : Default, item = event2.item && event2.item.cursor || null;
    return value3 && user === value3.user && item == value3.item ? value3 : {
      user,
      item
    };
  });
  view.add(null, function(_) {
    let user = _.cursor, item = this.value;
    if (!isString(user)) {
      item = user.item;
      user = user.user;
    }
    setCursor(view, user && user !== Default ? user : item || user);
    return item;
  }, {
    cursor: cursor3
  });
}
function setCursor(view, cursor3) {
  const el = view.globalCursor() ? typeof document !== "undefined" && document.body : view.container();
  if (el) {
    return cursor3 == null ? el.style.removeProperty("cursor") : el.style.cursor = cursor3;
  }
}
function dataref(view, name4) {
  var data4 = view._runtime.data;
  if (!has(data4, name4)) {
    error("Unrecognized data set: " + name4);
  }
  return data4[name4];
}
function data2(name4, values4) {
  return arguments.length < 2 ? dataref(this, name4).values.value : change.call(this, name4, changeset().remove(truthy).insert(values4));
}
function change(name4, changes) {
  if (!isChangeSet(changes)) {
    error("Second argument to changes must be a changeset.");
  }
  const dataset = dataref(this, name4);
  dataset.modified = true;
  return this.pulse(dataset.input, changes);
}
function insert(name4, _) {
  return change.call(this, name4, changeset().insert(_));
}
function remove(name4, _) {
  return change.call(this, name4, changeset().remove(_));
}
function width(view) {
  var padding3 = view.padding();
  return Math.max(0, view._viewWidth + padding3.left + padding3.right);
}
function height(view) {
  var padding3 = view.padding();
  return Math.max(0, view._viewHeight + padding3.top + padding3.bottom);
}
function offset3(view) {
  var padding3 = view.padding(), origin = view._origin;
  return [padding3.left + origin[0], padding3.top + origin[1]];
}
function resizeRenderer(view) {
  var origin = offset3(view), w3 = width(view), h3 = height(view);
  view._renderer.background(view.background());
  view._renderer.resize(w3, h3, origin);
  view._handler.origin(origin);
  view._resizeListeners.forEach((handler) => {
    try {
      handler(w3, h3);
    } catch (error3) {
      view.error(error3);
    }
  });
}
function eventExtend(view, event2, item) {
  var r2 = view._renderer, el = r2 && r2.canvas(), p, e, translate4;
  if (el) {
    translate4 = offset3(view);
    e = event2.changedTouches ? event2.changedTouches[0] : event2;
    p = point6(e, el);
    p[0] -= translate4[0];
    p[1] -= translate4[1];
  }
  event2.dataflow = view;
  event2.item = item;
  event2.vega = extension(view, item, p);
  return event2;
}
function extension(view, item, point8) {
  const itemGroup = item ? item.mark.marktype === "group" ? item : item.mark.group : null;
  function group2(name4) {
    var g = itemGroup, i;
    if (name4)
      for (i = item; i; i = i.mark.group) {
        if (i.mark.name === name4) {
          g = i;
          break;
        }
      }
    return g && g.mark && g.mark.interactive ? g : {};
  }
  function xy(item2) {
    if (!item2)
      return point8;
    if (isString(item2))
      item2 = group2(item2);
    const p = point8.slice();
    while (item2) {
      p[0] -= item2.x || 0;
      p[1] -= item2.y || 0;
      item2 = item2.mark && item2.mark.group;
    }
    return p;
  }
  return {
    view: constant(view),
    item: constant(item || {}),
    group: group2,
    xy,
    x: (item2) => xy(item2)[0],
    y: (item2) => xy(item2)[1]
  };
}
var VIEW = "view";
var TIMER = "timer";
var WINDOW = "window";
var NO_TRAP = {
  trap: false
};
function initializeEventConfig(config) {
  const events4 = extend({
    defaults: {}
  }, config);
  const unpack = (obj, keys4) => {
    keys4.forEach((k) => {
      if (isArray(obj[k]))
        obj[k] = toSet(obj[k]);
    });
  };
  unpack(events4.defaults, ["prevent", "allow"]);
  unpack(events4, ["view", "window", "selector"]);
  return events4;
}
function prevent(view, type2) {
  var def2 = view._eventConfig.defaults, prevent2 = def2.prevent, allow = def2.allow;
  return prevent2 === false || allow === true ? false : prevent2 === true || allow === false ? true : prevent2 ? prevent2[type2] : allow ? !allow[type2] : view.preventDefault();
}
function permit(view, key2, type2) {
  const rule4 = view._eventConfig && view._eventConfig[key2];
  if (rule4 === false || isObject(rule4) && !rule4[type2]) {
    view.warn("Blocked ".concat(key2, " ").concat(type2, " event listener."));
    return false;
  }
  return true;
}
function events2(source4, type2, filter4) {
  var view = this, s = new EventStream(filter4), send = function(e, item) {
    view.runAsync(null, () => {
      if (source4 === VIEW && prevent(view, type2)) {
        e.preventDefault();
      }
      s.receive(eventExtend(view, e, item));
    });
  }, sources;
  if (source4 === TIMER) {
    if (permit(view, "timer", type2)) {
      view.timer(send, type2);
    }
  } else if (source4 === VIEW) {
    if (permit(view, "view", type2)) {
      view.addEventListener(type2, send, NO_TRAP);
    }
  } else {
    if (source4 === WINDOW) {
      if (permit(view, "window", type2) && typeof window !== "undefined") {
        sources = [window];
      }
    } else if (typeof document !== "undefined") {
      if (permit(view, "selector", type2)) {
        sources = document.querySelectorAll(source4);
      }
    }
    if (!sources) {
      view.warn("Can not resolve event source: " + source4);
    } else {
      for (var i = 0, n = sources.length; i < n; ++i) {
        sources[i].addEventListener(type2, send);
      }
      view._eventListeners.push({
        type: type2,
        sources,
        handler: send
      });
    }
  }
  return s;
}
function itemFilter(event2) {
  return event2.item;
}
function markTarget(event2) {
  return event2.item.mark.source;
}
function invoke(name4) {
  return function(_, event2) {
    return event2.vega.view().changeset().encode(event2.item, name4);
  };
}
function hover(hoverSet, leaveSet) {
  hoverSet = [hoverSet || "hover"];
  leaveSet = [leaveSet || "update", hoverSet[0]];
  this.on(this.events("view", "mouseover", itemFilter), markTarget, invoke(hoverSet));
  this.on(this.events("view", "mouseout", itemFilter), markTarget, invoke(leaveSet));
  return this;
}
function finalize() {
  var tooltip2 = this._tooltip, timers = this._timers, listeners = this._eventListeners, n, m2, e;
  n = timers.length;
  while (--n >= 0) {
    timers[n].stop();
  }
  n = listeners.length;
  while (--n >= 0) {
    e = listeners[n];
    m2 = e.sources.length;
    while (--m2 >= 0) {
      e.sources[m2].removeEventListener(e.type, e.handler);
    }
  }
  if (tooltip2) {
    tooltip2.call(this, this._handler, null, null, null);
  }
  return this;
}
function element2(tag, attr2, text4) {
  const el = document.createElement(tag);
  for (const key2 in attr2)
    el.setAttribute(key2, attr2[key2]);
  if (text4 != null)
    el.textContent = text4;
  return el;
}
var BindClass = "vega-bind";
var NameClass = "vega-bind-name";
var RadioClass = "vega-bind-radio";
function bind2(view, el, binding) {
  if (!el)
    return;
  const param2 = binding.param;
  let bind3 = binding.state;
  if (!bind3) {
    bind3 = binding.state = {
      elements: null,
      active: false,
      set: null,
      update: (value3) => {
        if (value3 !== view.signal(param2.signal)) {
          view.runAsync(null, () => {
            bind3.source = true;
            view.signal(param2.signal, value3);
          });
        }
      }
    };
    if (param2.debounce) {
      bind3.update = debounce(param2.debounce, bind3.update);
    }
  }
  generate2(bind3, el, param2, view.signal(param2.signal));
  if (!bind3.active) {
    view.on(view._signals[param2.signal], null, () => {
      bind3.source ? bind3.source = false : bind3.set(view.signal(param2.signal));
    });
    bind3.active = true;
  }
  return bind3;
}
function generate2(bind3, el, param2, value3) {
  const div = element2("div", {
    class: BindClass
  });
  const wrapper = param2.input === "radio" ? div : div.appendChild(element2("label"));
  wrapper.appendChild(element2("span", {
    class: NameClass
  }, param2.name || param2.signal));
  el.appendChild(div);
  let input = form;
  switch (param2.input) {
    case "checkbox":
      input = checkbox;
      break;
    case "select":
      input = select;
      break;
    case "radio":
      input = radio;
      break;
    case "range":
      input = range3;
      break;
  }
  input(bind3, wrapper, param2, value3);
}
function form(bind3, el, param2, value3) {
  const node = element2("input");
  for (const key2 in param2) {
    if (key2 !== "signal" && key2 !== "element") {
      node.setAttribute(key2 === "input" ? "type" : key2, param2[key2]);
    }
  }
  node.setAttribute("name", param2.signal);
  node.value = value3;
  el.appendChild(node);
  node.addEventListener("input", () => bind3.update(node.value));
  bind3.elements = [node];
  bind3.set = (value4) => node.value = value4;
}
function checkbox(bind3, el, param2, value3) {
  const attr2 = {
    type: "checkbox",
    name: param2.signal
  };
  if (value3)
    attr2.checked = true;
  const node = element2("input", attr2);
  el.appendChild(node);
  node.addEventListener("change", () => bind3.update(node.checked));
  bind3.elements = [node];
  bind3.set = (value4) => node.checked = !!value4 || null;
}
function select(bind3, el, param2, value3) {
  const node = element2("select", {
    name: param2.signal
  }), labels3 = param2.labels || [];
  param2.options.forEach((option, i) => {
    const attr2 = {
      value: option
    };
    if (valuesEqual(option, value3))
      attr2.selected = true;
    node.appendChild(element2("option", attr2, (labels3[i] || option) + ""));
  });
  el.appendChild(node);
  node.addEventListener("change", () => {
    bind3.update(param2.options[node.selectedIndex]);
  });
  bind3.elements = [node];
  bind3.set = (value4) => {
    for (let i = 0, n = param2.options.length; i < n; ++i) {
      if (valuesEqual(param2.options[i], value4)) {
        node.selectedIndex = i;
        return;
      }
    }
  };
}
function radio(bind3, el, param2, value3) {
  const group2 = element2("span", {
    class: RadioClass
  }), labels3 = param2.labels || [];
  el.appendChild(group2);
  bind3.elements = param2.options.map((option, i) => {
    const attr2 = {
      type: "radio",
      name: param2.signal,
      value: option
    };
    if (valuesEqual(option, value3))
      attr2.checked = true;
    const input = element2("input", attr2);
    input.addEventListener("change", () => bind3.update(option));
    const label = element2("label", {}, (labels3[i] || option) + "");
    label.prepend(input);
    group2.appendChild(label);
    return input;
  });
  bind3.set = (value4) => {
    const nodes = bind3.elements, n = nodes.length;
    for (let i = 0; i < n; ++i) {
      if (valuesEqual(nodes[i].value, value4))
        nodes[i].checked = true;
    }
  };
}
function range3(bind3, el, param2, value3) {
  value3 = value3 !== void 0 ? value3 : (+param2.max + +param2.min) / 2;
  const max4 = param2.max != null ? param2.max : Math.max(100, +value3) || 100, min4 = param2.min || Math.min(0, max4, +value3) || 0, step = param2.step || tickStep(min4, max4, 100);
  const node = element2("input", {
    type: "range",
    name: param2.signal,
    min: min4,
    max: max4,
    step
  });
  node.value = value3;
  const span2 = element2("span", {}, +value3);
  el.appendChild(node);
  el.appendChild(span2);
  const update3 = () => {
    span2.textContent = node.value;
    bind3.update(+node.value);
  };
  node.addEventListener("input", update3);
  node.addEventListener("change", update3);
  bind3.elements = [node];
  bind3.set = (value4) => {
    node.value = value4;
    span2.textContent = value4;
  };
}
function valuesEqual(a2, b2) {
  return a2 === b2 || a2 + "" === b2 + "";
}
function initializeRenderer(view, r2, el, constructor, scaleFactor, opt) {
  r2 = r2 || new constructor(view.loader());
  return r2.initialize(el, width(view), height(view), offset3(view), scaleFactor, opt).background(view.background());
}
function trap(view, fn) {
  return !fn ? null : function() {
    try {
      fn.apply(this, arguments);
    } catch (error3) {
      view.error(error3);
    }
  };
}
function initializeHandler(view, prevHandler, el, constructor) {
  const handler = new constructor(view.loader(), trap(view, view.tooltip())).scene(view.scenegraph().root).initialize(el, offset3(view), view);
  if (prevHandler) {
    prevHandler.handlers().forEach((h3) => {
      handler.on(h3.type, h3.handler);
    });
  }
  return handler;
}
function initialize2(el, elBind) {
  const view = this, type2 = view._renderType, config = view._eventConfig.bind, module4 = renderModule(type2);
  el = view._el = el ? lookup4(view, el) : null;
  initializeAria(view);
  if (!module4)
    view.error("Unrecognized renderer type: " + type2);
  const Handler3 = module4.handler || CanvasHandler, Renderer2 = el ? module4.renderer : module4.headless;
  view._renderer = !Renderer2 ? null : initializeRenderer(view, view._renderer, el, Renderer2);
  view._handler = initializeHandler(view, view._handler, el, Handler3);
  view._redraw = true;
  if (el && config !== "none") {
    elBind = elBind ? view._elBind = lookup4(view, elBind) : el.appendChild(element2("form", {
      class: "vega-bindings"
    }));
    view._bind.forEach((_) => {
      if (_.param.element && config !== "container") {
        _.element = lookup4(view, _.param.element);
      }
    });
    view._bind.forEach((_) => {
      bind2(view, _.element || elBind, _);
    });
  }
  return view;
}
function lookup4(view, el) {
  if (typeof el === "string") {
    if (typeof document !== "undefined") {
      el = document.querySelector(el);
      if (!el) {
        view.error("Signal bind element not found: " + el);
        return null;
      }
    } else {
      view.error("DOM document instance not found.");
      return null;
    }
  }
  if (el) {
    try {
      el.innerHTML = "";
    } catch (e) {
      el = null;
      view.error(e);
    }
  }
  return el;
}
var number5 = (_) => +_ || 0;
var paddingObject = (_) => ({
  top: _,
  bottom: _,
  left: _,
  right: _
});
function padding(_) {
  return isObject(_) ? {
    top: number5(_.top),
    bottom: number5(_.bottom),
    left: number5(_.left),
    right: number5(_.right)
  } : paddingObject(number5(_));
}
async function renderHeadless(view, type2, scaleFactor, opt) {
  const module4 = renderModule(type2), ctr = module4 && module4.headless;
  if (!ctr)
    error("Unrecognized renderer type: " + type2);
  await view.runAsync();
  return initializeRenderer(view, null, null, ctr, scaleFactor, opt).renderAsync(view._scenegraph.root);
}
async function renderToImageURL(type2, scaleFactor) {
  if (type2 !== RenderType.Canvas && type2 !== RenderType.SVG && type2 !== RenderType.PNG) {
    error("Unrecognized image type: " + type2);
  }
  const r2 = await renderHeadless(this, type2, scaleFactor);
  return type2 === RenderType.SVG ? toBlobURL(r2.svg(), "image/svg+xml") : r2.canvas().toDataURL("image/png");
}
function toBlobURL(data4, mime) {
  const blob = new Blob([data4], {
    type: mime
  });
  return window.URL.createObjectURL(blob);
}
async function renderToCanvas(scaleFactor, opt) {
  const r2 = await renderHeadless(this, RenderType.Canvas, scaleFactor, opt);
  return r2.canvas();
}
async function renderToSVG(scaleFactor) {
  const r2 = await renderHeadless(this, RenderType.SVG, scaleFactor);
  return r2.svg();
}
function runtime(view, spec, expr2) {
  return context2(view, transforms, functionContext, expr2).parse(spec);
}
function scale4(name4) {
  var scales2 = this._runtime.scales;
  if (!has(scales2, name4)) {
    error("Unrecognized scale or projection: " + name4);
  }
  return scales2[name4].value;
}
var Width = "width";
var Height = "height";
var Padding2 = "padding";
var Skip2 = {
  skip: true
};
function viewWidth(view, width2) {
  var a2 = view.autosize(), p = view.padding();
  return width2 - (a2 && a2.contains === Padding2 ? p.left + p.right : 0);
}
function viewHeight(view, height2) {
  var a2 = view.autosize(), p = view.padding();
  return height2 - (a2 && a2.contains === Padding2 ? p.top + p.bottom : 0);
}
function initializeResize(view) {
  var s = view._signals, w3 = s[Width], h3 = s[Height], p = s[Padding2];
  function resetSize() {
    view._autosize = view._resize = 1;
  }
  view._resizeWidth = view.add(null, (_) => {
    view._width = _.size;
    view._viewWidth = viewWidth(view, _.size);
    resetSize();
  }, {
    size: w3
  });
  view._resizeHeight = view.add(null, (_) => {
    view._height = _.size;
    view._viewHeight = viewHeight(view, _.size);
    resetSize();
  }, {
    size: h3
  });
  const resizePadding = view.add(null, resetSize, {
    pad: p
  });
  view._resizeWidth.rank = w3.rank + 1;
  view._resizeHeight.rank = h3.rank + 1;
  resizePadding.rank = p.rank + 1;
}
function resizeView(viewWidth2, viewHeight2, width2, height2, origin, auto) {
  this.runAfter((view) => {
    let rerun2 = 0;
    view._autosize = 0;
    if (view.width() !== width2) {
      rerun2 = 1;
      view.signal(Width, width2, Skip2);
      view._resizeWidth.skip(true);
    }
    if (view.height() !== height2) {
      rerun2 = 1;
      view.signal(Height, height2, Skip2);
      view._resizeHeight.skip(true);
    }
    if (view._viewWidth !== viewWidth2) {
      view._resize = 1;
      view._viewWidth = viewWidth2;
    }
    if (view._viewHeight !== viewHeight2) {
      view._resize = 1;
      view._viewHeight = viewHeight2;
    }
    if (view._origin[0] !== origin[0] || view._origin[1] !== origin[1]) {
      view._resize = 1;
      view._origin = origin;
    }
    if (rerun2)
      view.run("enter");
    if (auto)
      view.runAfter((v) => v.resize());
  }, false, 1);
}
function getState2(options2) {
  return this._runtime.getState(options2 || {
    data: dataTest,
    signals: signalTest,
    recurse: true
  });
}
function dataTest(name4, data4) {
  return data4.modified && isArray(data4.input.value) && name4.indexOf("_:vega:_");
}
function signalTest(name4, op) {
  return !(name4 === "parent" || op instanceof transforms.proxy);
}
function setState2(state) {
  this.runAsync(null, (v) => {
    v._trigger = false;
    v._runtime.setState(state);
  }, (v) => {
    v._trigger = true;
  });
  return this;
}
function timer2(callback, delay) {
  function tick2(elapsed) {
    callback({
      timestamp: Date.now(),
      elapsed
    });
  }
  this._timers.push(interval_default(tick2, delay));
}
function defaultTooltip2(handler, event2, item, value3) {
  const el = handler.element();
  if (el)
    el.setAttribute("title", formatTooltip(value3));
}
function formatTooltip(value3) {
  return value3 == null ? "" : isArray(value3) ? formatArray(value3) : isObject(value3) && !isDate(value3) ? formatObject(value3) : value3 + "";
}
function formatObject(obj) {
  return Object.keys(obj).map((key2) => {
    const v = obj[key2];
    return key2 + ": " + (isArray(v) ? formatArray(v) : formatValue2(v));
  }).join("\n");
}
function formatArray(value3) {
  return "[" + value3.map(formatValue2).join(", ") + "]";
}
function formatValue2(value3) {
  return isArray(value3) ? "[\u2026]" : isObject(value3) && !isDate(value3) ? "{\u2026}" : value3;
}
function View(spec, options2) {
  const view = this;
  options2 = options2 || {};
  Dataflow.call(view);
  if (options2.loader)
    view.loader(options2.loader);
  if (options2.logger)
    view.logger(options2.logger);
  if (options2.logLevel != null)
    view.logLevel(options2.logLevel);
  if (options2.locale || spec.locale) {
    const loc = extend({}, spec.locale, options2.locale);
    view.locale(locale3(loc.number, loc.time));
  }
  view._el = null;
  view._elBind = null;
  view._renderType = options2.renderer || RenderType.Canvas;
  view._scenegraph = new Scenegraph();
  const root2 = view._scenegraph.root;
  view._renderer = null;
  view._tooltip = options2.tooltip || defaultTooltip2, view._redraw = true;
  view._handler = new CanvasHandler().scene(root2);
  view._globalCursor = false;
  view._preventDefault = false;
  view._timers = [];
  view._eventListeners = [];
  view._resizeListeners = [];
  view._eventConfig = initializeEventConfig(spec.eventConfig);
  view.globalCursor(view._eventConfig.globalCursor);
  const ctx = runtime(view, spec, options2.expr);
  view._runtime = ctx;
  view._signals = ctx.signals;
  view._bind = (spec.bindings || []).map((_) => ({
    state: null,
    param: extend({}, _)
  }));
  if (ctx.root)
    ctx.root.set(root2);
  root2.source = ctx.data.root.input;
  view.pulse(ctx.data.root.input, view.changeset().insert(root2.items));
  view._width = view.width();
  view._height = view.height();
  view._viewWidth = viewWidth(view, view._width);
  view._viewHeight = viewHeight(view, view._height);
  view._origin = [0, 0];
  view._resize = 0;
  view._autosize = 1;
  initializeResize(view);
  background2(view);
  cursor(view);
  view.description(spec.description);
  if (options2.hover)
    view.hover();
  if (options2.container)
    view.initialize(options2.container, options2.bind);
}
function lookupSignal(view, name4) {
  return has(view._signals, name4) ? view._signals[name4] : error("Unrecognized signal name: " + $(name4));
}
function findOperatorHandler(op, handler) {
  const h3 = (op._targets || []).filter((op2) => op2._update && op2._update.handler === handler);
  return h3.length ? h3[0] : null;
}
function addOperatorListener(view, name4, op, handler) {
  let h3 = findOperatorHandler(op, handler);
  if (!h3) {
    h3 = trap(view, () => handler(name4, op.value));
    h3.handler = handler;
    view.on(op, null, h3);
  }
  return view;
}
function removeOperatorListener(view, op, handler) {
  const h3 = findOperatorHandler(op, handler);
  if (h3)
    op._targets.remove(h3);
  return view;
}
inherits(View, Dataflow, {
  async evaluate(encode15, prerun, postrun) {
    await Dataflow.prototype.evaluate.call(this, encode15, prerun);
    if (this._redraw || this._resize) {
      try {
        if (this._renderer) {
          if (this._resize) {
            this._resize = 0;
            resizeRenderer(this);
          }
          await this._renderer.renderAsync(this._scenegraph.root);
        }
        this._redraw = false;
      } catch (e) {
        this.error(e);
      }
    }
    if (postrun)
      asyncCallback(this, postrun);
    return this;
  },
  dirty(item) {
    this._redraw = true;
    this._renderer && this._renderer.dirty(item);
  },
  description(text4) {
    if (arguments.length) {
      const desc = text4 != null ? text4 + "" : null;
      if (desc !== this._desc)
        ariaLabel(this._el, this._desc = desc);
      return this;
    }
    return this._desc;
  },
  container() {
    return this._el;
  },
  scenegraph() {
    return this._scenegraph;
  },
  origin() {
    return this._origin.slice();
  },
  signal(name4, value3, options2) {
    const op = lookupSignal(this, name4);
    return arguments.length === 1 ? op.value : this.update(op, value3, options2);
  },
  width(_) {
    return arguments.length ? this.signal("width", _) : this.signal("width");
  },
  height(_) {
    return arguments.length ? this.signal("height", _) : this.signal("height");
  },
  padding(_) {
    return arguments.length ? this.signal("padding", padding(_)) : padding(this.signal("padding"));
  },
  autosize(_) {
    return arguments.length ? this.signal("autosize", _) : this.signal("autosize");
  },
  background(_) {
    return arguments.length ? this.signal("background", _) : this.signal("background");
  },
  renderer(type2) {
    if (!arguments.length)
      return this._renderType;
    if (!renderModule(type2))
      error("Unrecognized renderer type: " + type2);
    if (type2 !== this._renderType) {
      this._renderType = type2;
      this._resetRenderer();
    }
    return this;
  },
  tooltip(handler) {
    if (!arguments.length)
      return this._tooltip;
    if (handler !== this._tooltip) {
      this._tooltip = handler;
      this._resetRenderer();
    }
    return this;
  },
  loader(loader2) {
    if (!arguments.length)
      return this._loader;
    if (loader2 !== this._loader) {
      Dataflow.prototype.loader.call(this, loader2);
      this._resetRenderer();
    }
    return this;
  },
  resize() {
    this._autosize = 1;
    return this.touch(lookupSignal(this, "autosize"));
  },
  _resetRenderer() {
    if (this._renderer) {
      this._renderer = null;
      this.initialize(this._el, this._elBind);
    }
  },
  _resizeView: resizeView,
  addEventListener(type2, handler, options2) {
    let callback = handler;
    if (!(options2 && options2.trap === false)) {
      callback = trap(this, handler);
      callback.raw = handler;
    }
    this._handler.on(type2, callback);
    return this;
  },
  removeEventListener(type2, handler) {
    var handlers = this._handler.handlers(type2), i = handlers.length, h3, t;
    while (--i >= 0) {
      t = handlers[i].type;
      h3 = handlers[i].handler;
      if (type2 === t && (handler === h3 || handler === h3.raw)) {
        this._handler.off(t, h3);
        break;
      }
    }
    return this;
  },
  addResizeListener(handler) {
    const l = this._resizeListeners;
    if (l.indexOf(handler) < 0) {
      l.push(handler);
    }
    return this;
  },
  removeResizeListener(handler) {
    var l = this._resizeListeners, i = l.indexOf(handler);
    if (i >= 0) {
      l.splice(i, 1);
    }
    return this;
  },
  addSignalListener(name4, handler) {
    return addOperatorListener(this, name4, lookupSignal(this, name4), handler);
  },
  removeSignalListener(name4, handler) {
    return removeOperatorListener(this, lookupSignal(this, name4), handler);
  },
  addDataListener(name4, handler) {
    return addOperatorListener(this, name4, dataref(this, name4).values, handler);
  },
  removeDataListener(name4, handler) {
    return removeOperatorListener(this, dataref(this, name4).values, handler);
  },
  globalCursor(_) {
    if (arguments.length) {
      if (this._globalCursor !== !!_) {
        const prev = setCursor(this, null);
        this._globalCursor = !!_;
        if (prev)
          setCursor(this, prev);
      }
      return this;
    } else {
      return this._globalCursor;
    }
  },
  preventDefault(_) {
    if (arguments.length) {
      this._preventDefault = _;
      return this;
    } else {
      return this._preventDefault;
    }
  },
  timer: timer2,
  events: events2,
  finalize,
  hover,
  data: data2,
  change,
  insert,
  remove,
  scale: scale4,
  initialize: initialize2,
  toImageURL: renderToImageURL,
  toCanvas: renderToCanvas,
  toSVG: renderToSVG,
  getState: getState2,
  setState: setState2
});

// node_modules/vega/node_modules/vega-functions/build/vega-functions.module.js
function data3(name4) {
  const data4 = this.context.data[name4];
  return data4 ? data4.values.value : [];
}
function indata2(name4, field4, value3) {
  const index4 = this.context.data[name4]["index:" + field4], entry2 = index4 ? index4.value.get(value3) : void 0;
  return entry2 ? entry2.count : entry2;
}
function setdata2(name4, tuples) {
  const df = this.context.dataflow, data4 = this.context.data[name4], input = data4.input;
  df.pulse(input, df.changeset().remove(truthy).insert(tuples));
  return 1;
}
function encode2(item, name4, retval) {
  if (item) {
    const df = this.context.dataflow, target = item.mark.source;
    df.pulse(target, df.changeset().encode(item, name4));
  }
  return retval !== void 0 ? retval : item;
}
var wrap2 = (method2) => function(value3, spec) {
  const locale6 = this.context.dataflow.locale();
  return locale6[method2](spec)(value3);
};
var format6 = wrap2("format");
var timeFormat3 = wrap2("timeFormat");
var utcFormat3 = wrap2("utcFormat");
var timeParse3 = wrap2("timeParse");
var utcParse3 = wrap2("utcParse");
var dateObj2 = new Date(2e3, 0, 1);
function time3(month2, day2, specifier) {
  if (!Number.isInteger(month2) || !Number.isInteger(day2))
    return "";
  dateObj2.setYear(2e3);
  dateObj2.setMonth(month2);
  dateObj2.setDate(day2);
  return timeFormat3.call(this, dateObj2, specifier);
}
function monthFormat2(month2) {
  return time3.call(this, month2, 1, "%B");
}
function monthAbbrevFormat2(month2) {
  return time3.call(this, month2, 1, "%b");
}
function dayFormat2(day2) {
  return time3.call(this, 0, 2 + day2, "%A");
}
function dayAbbrevFormat2(day2) {
  return time3.call(this, 0, 2 + day2, "%a");
}
var DataPrefix3 = ":";
var IndexPrefix3 = "@";
var ScalePrefix2 = "%";
var SignalPrefix2 = "$";
function dataVisitor2(name4, args, scope, params2) {
  if (args[0].type !== Literal) {
    error("First argument to data functions must be a string literal.");
  }
  const data4 = args[0].value, dataName = DataPrefix3 + data4;
  if (!has(dataName, params2)) {
    try {
      params2[dataName] = scope.getData(data4).tuplesRef();
    } catch (err) {
    }
  }
}
function indataVisitor2(name4, args, scope, params2) {
  if (args[0].type !== Literal)
    error("First argument to indata must be a string literal.");
  if (args[1].type !== Literal)
    error("Second argument to indata must be a string literal.");
  const data4 = args[0].value, field4 = args[1].value, indexName = IndexPrefix3 + field4;
  if (!has(indexName, params2)) {
    params2[indexName] = scope.getData(data4).indataRef(scope, field4);
  }
}
function scaleVisitor2(name4, args, scope, params2) {
  if (args[0].type === Literal) {
    addScaleDependency2(scope, params2, args[0].value);
  } else {
    for (name4 in scope.scales) {
      addScaleDependency2(scope, params2, name4);
    }
  }
}
function addScaleDependency2(scope, params2, name4) {
  const scaleName = ScalePrefix2 + name4;
  if (!has(params2, scaleName)) {
    try {
      params2[scaleName] = scope.scaleRef(name4);
    } catch (err) {
    }
  }
}
function getScale2(name4, ctx) {
  let s;
  return isFunction(name4) ? name4 : isString(name4) ? (s = ctx.scales[name4]) && s.value : void 0;
}
function internalScaleFunctions2(codegen2, fnctx, visitors) {
  fnctx.__bandwidth = (s) => s && s.bandwidth ? s.bandwidth() : 0;
  visitors._bandwidth = scaleVisitor2;
  visitors._range = scaleVisitor2;
  visitors._scale = scaleVisitor2;
  const ref6 = (arg) => "_[" + (arg.type === Literal ? $(ScalePrefix2 + arg.value) : $(ScalePrefix2) + "+" + codegen2(arg)) + "]";
  return {
    _bandwidth: (args) => "this.__bandwidth(".concat(ref6(args[0]), ")"),
    _range: (args) => "".concat(ref6(args[0]), ".range()"),
    _scale: (args) => "".concat(ref6(args[0]), "(").concat(codegen2(args[1]), ")")
  };
}
function geoMethod2(methodName, globalMethod) {
  return function(projection3, geojson, group2) {
    if (projection3) {
      const p = getScale2(projection3, (group2 || this).context);
      return p && p.path[methodName](geojson);
    } else {
      return globalMethod(geojson);
    }
  };
}
var geoArea2 = geoMethod2("area", area_default2);
var geoBounds2 = geoMethod2("bounds", bounds_default);
var geoCentroid2 = geoMethod2("centroid", centroid_default);
function inScope2(item) {
  const group2 = this.context.group;
  let value3 = false;
  if (group2)
    while (item) {
      if (item === group2) {
        value3 = true;
        break;
      }
      item = item.mark.group;
    }
  return value3;
}
function log6(df, method2, args) {
  try {
    df[method2].apply(df, ["EXPRESSION"].concat([].slice.call(args)));
  } catch (err) {
    df.warn(err);
  }
  return args[args.length - 1];
}
function warn2() {
  return log6(this.context.dataflow, "warn", arguments);
}
function info2() {
  return log6(this.context.dataflow, "info", arguments);
}
function debug2() {
  return log6(this.context.dataflow, "debug", arguments);
}
function channel_luminance_value2(channelValue) {
  const val = channelValue / 255;
  if (val <= 0.03928) {
    return val / 12.92;
  }
  return Math.pow((val + 0.055) / 1.055, 2.4);
}
function luminance2(color5) {
  const c2 = rgb(color5), r2 = channel_luminance_value2(c2.r), g = channel_luminance_value2(c2.g), b2 = channel_luminance_value2(c2.b);
  return 0.2126 * r2 + 0.7152 * g + 0.0722 * b2;
}
function contrast2(color1, color22) {
  const lum1 = luminance2(color1), lum2 = luminance2(color22), lumL = Math.max(lum1, lum2), lumD = Math.min(lum1, lum2);
  return (lumL + 0.05) / (lumD + 0.05);
}
function merge5() {
  const args = [].slice.call(arguments);
  args.unshift({});
  return extend(...args);
}
function equal2(a2, b2) {
  return a2 === b2 || a2 !== a2 && b2 !== b2 ? true : isArray(a2) ? isArray(b2) && a2.length === b2.length ? equalArray2(a2, b2) : false : isObject(a2) && isObject(b2) ? equalObject2(a2, b2) : false;
}
function equalArray2(a2, b2) {
  for (let i = 0, n = a2.length; i < n; ++i) {
    if (!equal2(a2[i], b2[i]))
      return false;
  }
  return true;
}
function equalObject2(a2, b2) {
  for (const key2 in a2) {
    if (!equal2(a2[key2], b2[key2]))
      return false;
  }
  return true;
}
function removePredicate2(props) {
  return (_) => equalObject2(props, _);
}
function modify2(name4, insert2, remove3, toggle2, modify3, values4) {
  const df = this.context.dataflow, data4 = this.context.data[name4], input = data4.input, stamp = df.stamp();
  let changes = data4.changes, predicate, key2;
  if (df._trigger === false || !(input.value.length || insert2 || toggle2)) {
    return 0;
  }
  if (!changes || changes.stamp < stamp) {
    data4.changes = changes = df.changeset();
    changes.stamp = stamp;
    df.runAfter(() => {
      data4.modified = true;
      df.pulse(input, changes).run();
    }, true, 1);
  }
  if (remove3) {
    predicate = remove3 === true ? truthy : isArray(remove3) || isTuple(remove3) ? remove3 : removePredicate2(remove3);
    changes.remove(predicate);
  }
  if (insert2) {
    changes.insert(insert2);
  }
  if (toggle2) {
    predicate = removePredicate2(toggle2);
    if (input.value.some(predicate)) {
      changes.remove(predicate);
    } else {
      changes.insert(toggle2);
    }
  }
  if (modify3) {
    for (key2 in values4) {
      changes.modify(modify3, key2, values4[key2]);
    }
  }
  return 1;
}
function pinchDistance2(event2) {
  const t = event2.touches, dx = t[0].clientX - t[1].clientX, dy = t[0].clientY - t[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}
function pinchAngle2(event2) {
  const t = event2.touches;
  return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);
}
function array4(seq) {
  return isArray(seq) || ArrayBuffer.isView(seq) ? seq : null;
}
function sequence3(seq) {
  return array4(seq) || (isString(seq) ? seq : null);
}
function join3(seq, ...args) {
  return array4(seq).join(...args);
}
function indexof2(seq, ...args) {
  return sequence3(seq).indexOf(...args);
}
function lastindexof2(seq, ...args) {
  return sequence3(seq).lastIndexOf(...args);
}
function slice4(seq, ...args) {
  return sequence3(seq).slice(...args);
}
function replace3(str, pattern, repl) {
  if (isFunction(repl))
    error("Function argument passed to replace.");
  return String(str).replace(pattern, repl);
}
function reverse2(seq) {
  return array4(seq).slice().reverse();
}
function bandspace2(count2, paddingInner2, paddingOuter2) {
  return bandSpace(count2 || 0, paddingInner2 || 0, paddingOuter2 || 0);
}
function bandwidth2(name4, group2) {
  const s = getScale2(name4, (group2 || this).context);
  return s && s.bandwidth ? s.bandwidth() : 0;
}
function copy4(name4, group2) {
  const s = getScale2(name4, (group2 || this).context);
  return s ? s.copy() : void 0;
}
function domain2(name4, group2) {
  const s = getScale2(name4, (group2 || this).context);
  return s ? s.domain() : [];
}
function invert2(name4, range5, group2) {
  const s = getScale2(name4, (group2 || this).context);
  return !s ? void 0 : isArray(range5) ? (s.invertRange || s.invert)(range5) : (s.invert || s.invertExtent)(range5);
}
function range4(name4, group2) {
  const s = getScale2(name4, (group2 || this).context);
  return s && s.range ? s.range() : [];
}
function scale5(name4, value3, group2) {
  const s = getScale2(name4, (group2 || this).context);
  return s ? s(value3) : void 0;
}
function scaleGradient2(scale7, p02, p1, count2, group2) {
  scale7 = getScale2(scale7, (group2 || this).context);
  const gradient4 = Gradient(p02, p1);
  let stops = scale7.domain(), min4 = stops[0], max4 = peek(stops), fraction = identity;
  if (!(max4 - min4)) {
    scale7 = (scale7.interpolator ? scale("sequential")().interpolator(scale7.interpolator()) : scale("linear")().interpolate(scale7.interpolate()).range(scale7.range())).domain([min4 = 0, max4 = 1]);
  } else {
    fraction = scaleFraction(scale7, min4, max4);
  }
  if (scale7.ticks) {
    stops = scale7.ticks(+count2 || 15);
    if (min4 !== stops[0])
      stops.unshift(min4);
    if (max4 !== peek(stops))
      stops.push(max4);
  }
  stops.forEach((_) => gradient4.stop(fraction(_), scale7(_)));
  return gradient4;
}
function geoShape2(projection3, geojson, group2) {
  const p = getScale2(projection3, (group2 || this).context);
  return function(context3) {
    return p ? p.path.context(context3)(geojson) : "";
  };
}
function pathShape2(path3) {
  let p = null;
  return function(context3) {
    return context3 ? pathRender(context3, p = p || pathParse(path3)) : path3;
  };
}
var datum2 = (d) => d.data;
function treeNodes2(name4, context3) {
  const tree = data3.call(context3, name4);
  return tree.root && tree.root.lookup || {};
}
function treePath2(name4, source4, target) {
  const nodes = treeNodes2(name4, this), s = nodes[source4], t = nodes[target];
  return s && t ? s.path(t).map(datum2) : void 0;
}
function treeAncestors2(name4, node) {
  const n = treeNodes2(name4, this)[node];
  return n ? n.ancestors().map(datum2) : void 0;
}
var _window2 = () => typeof window !== "undefined" && window || null;
function screen2() {
  const w3 = _window2();
  return w3 ? w3.screen : {};
}
function windowSize2() {
  const w3 = _window2();
  return w3 ? [w3.innerWidth, w3.innerHeight] : [void 0, void 0];
}
function containerSize2() {
  const view = this.context.dataflow, el = view.container && view.container();
  return el ? [el.clientWidth, el.clientHeight] : [void 0, void 0];
}
function intersect5(b2, opt, group2) {
  if (!b2)
    return [];
  const [u, v] = b2, box = new Bounds().set(u[0], u[1], v[0], v[1]), scene = group2 || this.context.dataflow.scenegraph().root;
  return intersect2(scene, box, filter3(opt));
}
function filter3(opt) {
  let p = null;
  if (opt) {
    const types3 = array(opt.marktype), names = array(opt.markname);
    p = (_) => (!types3.length || types3.some((t) => _.marktype === t)) && (!names.length || names.some((s) => _.name === s));
  }
  return p;
}
var functionContext2 = {
  random() {
    return random();
  },
  cumulativeNormal,
  cumulativeLogNormal,
  cumulativeUniform,
  densityNormal,
  densityLogNormal,
  densityUniform,
  quantileNormal,
  quantileLogNormal,
  quantileUniform,
  sampleNormal,
  sampleLogNormal,
  sampleUniform,
  isArray,
  isBoolean,
  isDate,
  isDefined(_) {
    return _ !== void 0;
  },
  isNumber,
  isObject,
  isRegExp,
  isString,
  isTuple,
  isValid(_) {
    return _ != null && _ === _;
  },
  toBoolean,
  toDate,
  toNumber,
  toString,
  indexof: indexof2,
  join: join3,
  lastindexof: lastindexof2,
  replace: replace3,
  reverse: reverse2,
  slice: slice4,
  flush,
  lerp,
  merge: merge5,
  pad,
  peek,
  span,
  inrange,
  truncate,
  rgb,
  lab,
  hcl,
  hsl,
  luminance: luminance2,
  contrast: contrast2,
  sequence: range_default,
  format: format6,
  utcFormat: utcFormat3,
  utcParse: utcParse3,
  utcOffset,
  utcSequence,
  timeFormat: timeFormat3,
  timeParse: timeParse3,
  timeOffset,
  timeSequence,
  timeUnitSpecifier,
  monthFormat: monthFormat2,
  monthAbbrevFormat: monthAbbrevFormat2,
  dayFormat: dayFormat2,
  dayAbbrevFormat: dayAbbrevFormat2,
  quarter,
  utcquarter,
  week,
  utcweek,
  dayofyear,
  utcdayofyear,
  warn: warn2,
  info: info2,
  debug: debug2,
  extent,
  inScope: inScope2,
  intersect: intersect5,
  clampRange,
  pinchDistance: pinchDistance2,
  pinchAngle: pinchAngle2,
  screen: screen2,
  containerSize: containerSize2,
  windowSize: windowSize2,
  bandspace: bandspace2,
  setdata: setdata2,
  pathShape: pathShape2,
  panLinear,
  panLog,
  panPow,
  panSymlog,
  zoomLinear,
  zoomLog,
  zoomPow,
  zoomSymlog,
  encode: encode2,
  modify: modify2
};
var eventFunctions2 = ["view", "item", "group", "xy", "x", "y"];
var eventPrefix2 = "event.vega.";
var thisPrefix2 = "this.";
var astVisitors2 = {};
var codegenParams2 = {
  forbidden: ["_"],
  allowed: ["datum", "event", "item"],
  fieldvar: "datum",
  globalvar: (id4) => "_[".concat($(SignalPrefix2 + id4), "]"),
  functions: buildFunctions2,
  constants: Constants,
  visitors: astVisitors2
};
var codeGenerator2 = codegen(codegenParams2);
function buildFunctions2(codegen2) {
  const fn = Functions(codegen2);
  eventFunctions2.forEach((name4) => fn[name4] = eventPrefix2 + name4);
  for (const name4 in functionContext2) {
    fn[name4] = thisPrefix2 + name4;
  }
  extend(fn, internalScaleFunctions2(codegen2, functionContext2, astVisitors2));
  return fn;
}
function expressionFunction2(name4, fn, visitor) {
  if (arguments.length === 1) {
    return functionContext2[name4];
  }
  functionContext2[name4] = fn;
  if (visitor)
    astVisitors2[name4] = visitor;
  if (codeGenerator2)
    codeGenerator2.functions[name4] = thisPrefix2 + name4;
  return this;
}
expressionFunction2("bandwidth", bandwidth2, scaleVisitor2);
expressionFunction2("copy", copy4, scaleVisitor2);
expressionFunction2("domain", domain2, scaleVisitor2);
expressionFunction2("range", range4, scaleVisitor2);
expressionFunction2("invert", invert2, scaleVisitor2);
expressionFunction2("scale", scale5, scaleVisitor2);
expressionFunction2("gradient", scaleGradient2, scaleVisitor2);
expressionFunction2("geoArea", geoArea2, scaleVisitor2);
expressionFunction2("geoBounds", geoBounds2, scaleVisitor2);
expressionFunction2("geoCentroid", geoCentroid2, scaleVisitor2);
expressionFunction2("geoShape", geoShape2, scaleVisitor2);
expressionFunction2("indata", indata2, indataVisitor2);
expressionFunction2("data", data3, dataVisitor2);
expressionFunction2("treePath", treePath2, dataVisitor2);
expressionFunction2("treeAncestors", treeAncestors2, dataVisitor2);
expressionFunction2("vlSelectionTest", selectionTest, selectionVisitor);
expressionFunction2("vlSelectionResolve", selectionResolve, selectionVisitor);

// node_modules/vega-event-selector/build/vega-event-selector.module.js
var VIEW2 = "view";
var LBRACK = "[";
var RBRACK = "]";
var LBRACE = "{";
var RBRACE = "}";
var COLON = ":";
var COMMA = ",";
var NAME = "@";
var GT = ">";
var ILLEGAL2 = /[[\]{}]/;
var DEFAULT_MARKS = {
  "*": 1,
  arc: 1,
  area: 1,
  group: 1,
  image: 1,
  line: 1,
  path: 1,
  rect: 1,
  rule: 1,
  shape: 1,
  symbol: 1,
  text: 1,
  trail: 1
};
var DEFAULT_SOURCE;
var MARKS;
function eventSelector(selector, source4, marks) {
  DEFAULT_SOURCE = source4 || VIEW2;
  MARKS = marks || DEFAULT_MARKS;
  return parseMerge(selector.trim()).map(parseSelector);
}
function isMarkType(type2) {
  return MARKS[type2];
}
function find3(s, i, endChar, pushChar, popChar) {
  const n = s.length;
  let count2 = 0, c2;
  for (; i < n; ++i) {
    c2 = s[i];
    if (!count2 && c2 === endChar)
      return i;
    else if (popChar && popChar.indexOf(c2) >= 0)
      --count2;
    else if (pushChar && pushChar.indexOf(c2) >= 0)
      ++count2;
  }
  return i;
}
function parseMerge(s) {
  const output3 = [], n = s.length;
  let start = 0, i = 0;
  while (i < n) {
    i = find3(s, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);
    output3.push(s.substring(start, i).trim());
    start = ++i;
  }
  if (output3.length === 0) {
    throw "Empty event selector: " + s;
  }
  return output3;
}
function parseSelector(s) {
  return s[0] === "[" ? parseBetween(s) : parseStream2(s);
}
function parseBetween(s) {
  const n = s.length;
  let i = 1, b2;
  i = find3(s, i, RBRACK, LBRACK, RBRACK);
  if (i === n) {
    throw "Empty between selector: " + s;
  }
  b2 = parseMerge(s.substring(1, i));
  if (b2.length !== 2) {
    throw "Between selector must have two elements: " + s;
  }
  s = s.slice(i + 1).trim();
  if (s[0] !== GT) {
    throw "Expected '>' after between selector: " + s;
  }
  b2 = b2.map(parseSelector);
  const stream2 = parseSelector(s.slice(1).trim());
  if (stream2.between) {
    return {
      between: b2,
      stream: stream2
    };
  } else {
    stream2.between = b2;
  }
  return stream2;
}
function parseStream2(s) {
  const stream2 = {
    source: DEFAULT_SOURCE
  }, source4 = [];
  let throttle = [0, 0], markname = 0, start = 0, n = s.length, i = 0, j, filter4;
  if (s[n - 1] === RBRACE) {
    i = s.lastIndexOf(LBRACE);
    if (i >= 0) {
      try {
        throttle = parseThrottle(s.substring(i + 1, n - 1));
      } catch (e) {
        throw "Invalid throttle specification: " + s;
      }
      s = s.slice(0, i).trim();
      n = s.length;
    } else
      throw "Unmatched right brace: " + s;
    i = 0;
  }
  if (!n)
    throw s;
  if (s[0] === NAME)
    markname = ++i;
  j = find3(s, i, COLON);
  if (j < n) {
    source4.push(s.substring(start, j).trim());
    start = i = ++j;
  }
  i = find3(s, i, LBRACK);
  if (i === n) {
    source4.push(s.substring(start, n).trim());
  } else {
    source4.push(s.substring(start, i).trim());
    filter4 = [];
    start = ++i;
    if (start === n)
      throw "Unmatched left bracket: " + s;
  }
  while (i < n) {
    i = find3(s, i, RBRACK);
    if (i === n)
      throw "Unmatched left bracket: " + s;
    filter4.push(s.substring(start, i).trim());
    if (i < n - 1 && s[++i] !== LBRACK)
      throw "Expected left bracket: " + s;
    start = ++i;
  }
  if (!(n = source4.length) || ILLEGAL2.test(source4[n - 1])) {
    throw "Invalid event selector: " + s;
  }
  if (n > 1) {
    stream2.type = source4[1];
    if (markname) {
      stream2.markname = source4[0].slice(1);
    } else if (isMarkType(source4[0])) {
      stream2.marktype = source4[0];
    } else {
      stream2.source = source4[0];
    }
  } else {
    stream2.type = source4[0];
  }
  if (stream2.type.slice(-1) === "!") {
    stream2.consume = true;
    stream2.type = stream2.type.slice(0, -1);
  }
  if (filter4 != null)
    stream2.filter = filter4;
  if (throttle[0])
    stream2.throttle = throttle[0];
  if (throttle[1])
    stream2.debounce = throttle[1];
  return stream2;
}
function parseThrottle(s) {
  const a2 = s.split(COMMA);
  if (!s.length || a2.length > 2)
    throw s;
  return a2.map((_) => {
    const x5 = +_;
    if (x5 !== x5)
      throw s;
    return x5;
  });
}

// node_modules/vega-parser/build/vega-parser.module.js
function parseAutosize(spec) {
  return isObject(spec) ? spec : {
    type: spec || "pad"
  };
}
var number6 = (_) => +_ || 0;
var paddingObject2 = (_) => ({
  top: _,
  bottom: _,
  left: _,
  right: _
});
function parsePadding(spec) {
  return !isObject(spec) ? paddingObject2(number6(spec)) : spec.signal ? spec : {
    top: number6(spec.top),
    bottom: number6(spec.bottom),
    left: number6(spec.left),
    right: number6(spec.right)
  };
}
var encoder = (_) => isObject(_) && !isArray(_) ? extend({}, _) : {
  value: _
};
function addEncode(object2, name4, value3, set6) {
  if (value3 != null) {
    const isEncoder = isObject(value3) && !isArray(value3) || isArray(value3) && value3.length && isObject(value3[0]);
    if (isEncoder) {
      object2.update[name4] = value3;
    } else {
      object2[set6 || "enter"][name4] = {
        value: value3
      };
    }
    return 1;
  } else {
    return 0;
  }
}
function addEncoders(object2, enter, update3) {
  for (const name4 in enter) {
    addEncode(object2, name4, enter[name4]);
  }
  for (const name4 in update3) {
    addEncode(object2, name4, update3[name4], "update");
  }
}
function extendEncode(encode15, extra, skip) {
  for (const name4 in extra) {
    if (skip && has(skip, name4))
      continue;
    encode15[name4] = extend(encode15[name4] || {}, extra[name4]);
  }
  return encode15;
}
function has2(key2, encode15) {
  return encode15 && (encode15.enter && encode15.enter[key2] || encode15.update && encode15.update[key2]);
}
var MarkRole = "mark";
var FrameRole2 = "frame";
var ScopeRole2 = "scope";
var AxisRole2 = "axis";
var AxisDomainRole = "axis-domain";
var AxisGridRole = "axis-grid";
var AxisLabelRole = "axis-label";
var AxisTickRole = "axis-tick";
var AxisTitleRole = "axis-title";
var LegendRole2 = "legend";
var LegendBandRole = "legend-band";
var LegendEntryRole = "legend-entry";
var LegendGradientRole = "legend-gradient";
var LegendLabelRole = "legend-label";
var LegendSymbolRole = "legend-symbol";
var LegendTitleRole = "legend-title";
var TitleRole2 = "title";
var TitleTextRole = "title-text";
var TitleSubtitleRole = "title-subtitle";
function applyDefaults(encode15, type2, role, style2, config) {
  const defaults2 = {}, enter = {};
  let update3, key2, skip, props;
  key2 = "lineBreak";
  if (type2 === "text" && config[key2] != null && !has2(key2, encode15)) {
    applyDefault(defaults2, key2, config[key2]);
  }
  if (role == "legend" || String(role).startsWith("axis")) {
    role = null;
  }
  props = role === FrameRole2 ? config.group : role === MarkRole ? extend({}, config.mark, config[type2]) : null;
  for (key2 in props) {
    skip = has2(key2, encode15) || (key2 === "fill" || key2 === "stroke") && (has2("fill", encode15) || has2("stroke", encode15));
    if (!skip)
      applyDefault(defaults2, key2, props[key2]);
  }
  array(style2).forEach((name4) => {
    const props2 = config.style && config.style[name4];
    for (const key3 in props2) {
      if (!has2(key3, encode15)) {
        applyDefault(defaults2, key3, props2[key3]);
      }
    }
  });
  encode15 = extend({}, encode15);
  for (key2 in defaults2) {
    props = defaults2[key2];
    if (props.signal) {
      (update3 = update3 || {})[key2] = props;
    } else {
      enter[key2] = props;
    }
  }
  encode15.enter = extend(enter, encode15.enter);
  if (update3)
    encode15.update = extend(update3, encode15.update);
  return encode15;
}
function applyDefault(defaults2, key2, value3) {
  defaults2[key2] = value3 && value3.signal ? {
    signal: value3.signal
  } : {
    value: value3
  };
}
var scaleRef = (scale7) => isString(scale7) ? $(scale7) : scale7.signal ? "(".concat(scale7.signal, ")") : field2(scale7);
function entry(enc) {
  if (enc.gradient != null) {
    return gradient2(enc);
  }
  let value3 = enc.signal ? "(".concat(enc.signal, ")") : enc.color ? color3(enc.color) : enc.field != null ? field2(enc.field) : enc.value !== void 0 ? $(enc.value) : void 0;
  if (enc.scale != null) {
    value3 = scale6(enc, value3);
  }
  if (value3 === void 0) {
    value3 = null;
  }
  if (enc.exponent != null) {
    value3 = "pow(".concat(value3, ",").concat(property(enc.exponent), ")");
  }
  if (enc.mult != null) {
    value3 += "*".concat(property(enc.mult));
  }
  if (enc.offset != null) {
    value3 += "+".concat(property(enc.offset));
  }
  if (enc.round) {
    value3 = "round(".concat(value3, ")");
  }
  return value3;
}
var _color = (type2, x5, y5, z) => "(".concat(type2, "(").concat([x5, y5, z].map(entry).join(","), ")+'')");
function color3(enc) {
  return enc.c ? _color("hcl", enc.h, enc.c, enc.l) : enc.h || enc.s ? _color("hsl", enc.h, enc.s, enc.l) : enc.l || enc.a ? _color("lab", enc.l, enc.a, enc.b) : enc.r || enc.g || enc.b ? _color("rgb", enc.r, enc.g, enc.b) : null;
}
function gradient2(enc) {
  const args = [enc.start, enc.stop, enc.count].map((_) => _ == null ? null : $(_));
  while (args.length && peek(args) == null)
    args.pop();
  args.unshift(scaleRef(enc.gradient));
  return "gradient(".concat(args.join(","), ")");
}
function property(property2) {
  return isObject(property2) ? "(" + entry(property2) + ")" : property2;
}
function field2(ref6) {
  return resolveField(isObject(ref6) ? ref6 : {
    datum: ref6
  });
}
function resolveField(ref6) {
  let object2, level, field4;
  if (ref6.signal) {
    object2 = "datum";
    field4 = ref6.signal;
  } else if (ref6.group || ref6.parent) {
    level = Math.max(1, ref6.level || 1);
    object2 = "item";
    while (level-- > 0) {
      object2 += ".mark.group";
    }
    if (ref6.parent) {
      field4 = ref6.parent;
      object2 += ".datum";
    } else {
      field4 = ref6.group;
    }
  } else if (ref6.datum) {
    object2 = "datum";
    field4 = ref6.datum;
  } else {
    error("Invalid field reference: " + $(ref6));
  }
  if (!ref6.signal) {
    field4 = isString(field4) ? splitAccessPath(field4).map($).join("][") : resolveField(field4);
  }
  return object2 + "[" + field4 + "]";
}
function scale6(enc, value3) {
  const scale7 = scaleRef(enc.scale);
  if (enc.range != null) {
    value3 = "lerp(_range(".concat(scale7, "), ").concat(+enc.range, ")");
  } else {
    if (value3 !== void 0)
      value3 = "_scale(".concat(scale7, ", ").concat(value3, ")");
    if (enc.band) {
      value3 = (value3 ? value3 + "+" : "") + "_bandwidth(".concat(scale7, ")") + (+enc.band === 1 ? "" : "*" + property(enc.band));
      if (enc.extra) {
        value3 = "(datum.extra ? _scale(".concat(scale7, ", datum.extra.value) : ").concat(value3, ")");
      }
    }
    if (value3 == null)
      value3 = "0";
  }
  return value3;
}
function rule2(enc) {
  let code = "";
  enc.forEach((rule4) => {
    const value3 = entry(rule4);
    code += rule4.test ? "(".concat(rule4.test, ")?").concat(value3, ":") : value3;
  });
  if (peek(code) === ":") {
    code += "null";
  }
  return code;
}
function parseEncode(encode15, type2, role, style2, scope, params2) {
  const enc = {};
  params2 = params2 || {};
  params2.encoders = {
    $encode: enc
  };
  encode15 = applyDefaults(encode15, type2, role, style2, scope.config);
  for (const key2 in encode15) {
    enc[key2] = parseBlock(encode15[key2], type2, params2, scope);
  }
  return params2;
}
function parseBlock(block, marktype, params2, scope) {
  const channels = {}, fields = {};
  for (const name4 in block) {
    if (block[name4] != null) {
      channels[name4] = parse5(expr(block[name4]), scope, params2, fields);
    }
  }
  return {
    $expr: {
      marktype,
      channels
    },
    $fields: Object.keys(fields),
    $output: Object.keys(block)
  };
}
function expr(enc) {
  return isArray(enc) ? rule2(enc) : entry(enc);
}
function parse5(code, scope, params2, fields) {
  const expr2 = parser2(code, scope);
  expr2.$fields.forEach((name4) => fields[name4] = 1);
  extend(params2, expr2.$params);
  return expr2.$expr;
}
var OUTER = "outer";
var OUTER_INVALID = ["value", "update", "init", "react", "bind"];
function outerError(prefix, name4) {
  error(prefix + ' for "outer" push: ' + $(name4));
}
function parseSignal(signal, scope) {
  const name4 = signal.name;
  if (signal.push === OUTER) {
    if (!scope.signals[name4])
      outerError("No prior signal definition", name4);
    OUTER_INVALID.forEach((prop) => {
      if (signal[prop] !== void 0)
        outerError("Invalid property ", prop);
    });
  } else {
    const op = scope.addSignal(name4, signal.value);
    if (signal.react === false)
      op.react = false;
    if (signal.bind)
      scope.addBinding(name4, signal.bind);
  }
}
function Entry(type2, value3, params2, parent) {
  this.id = -1;
  this.type = type2;
  this.value = value3;
  this.params = params2;
  if (parent)
    this.parent = parent;
}
function entry$1(type2, value3, params2, parent) {
  return new Entry(type2, value3, params2, parent);
}
function operator(value3, params2) {
  return entry$1("operator", value3, params2);
}
function ref(op) {
  const ref6 = {
    $ref: op.id
  };
  if (op.id < 0)
    (op.refs = op.refs || []).push(ref6);
  return ref6;
}
function fieldRef(field4, name4) {
  return name4 ? {
    $field: field4,
    $name: name4
  } : {
    $field: field4
  };
}
var keyFieldRef = fieldRef("key");
function compareRef(fields, orders) {
  return {
    $compare: fields,
    $order: orders
  };
}
function keyRef(fields, flat) {
  const ref6 = {
    $key: fields
  };
  if (flat)
    ref6.$flat = true;
  return ref6;
}
var Ascending = "ascending";
var Descending = "descending";
function sortKey(sort2) {
  return !isObject(sort2) ? "" : (sort2.order === Descending ? "-" : "+") + aggrField(sort2.op, sort2.field);
}
function aggrField(op, field4) {
  return (op && op.signal ? "$" + op.signal : op || "") + (op && field4 ? "_" : "") + (field4 && field4.signal ? "$" + field4.signal : field4 || "");
}
var Scope = "scope";
var View2 = "view";
function isSignal(_) {
  return _ && _.signal;
}
function isExpr(_) {
  return _ && _.expr;
}
function hasSignal(_) {
  if (isSignal(_))
    return true;
  if (isObject(_))
    for (const key2 in _) {
      if (hasSignal(_[key2]))
        return true;
    }
  return false;
}
function value2(specValue, defaultValue) {
  return specValue != null ? specValue : defaultValue;
}
function deref(v) {
  return v && v.signal || v;
}
var Timer2 = "timer";
function parseStream3(stream2, scope) {
  const method2 = stream2.merge ? mergeStream : stream2.stream ? nestedStream : stream2.type ? eventStream : error("Invalid stream specification: " + $(stream2));
  return method2(stream2, scope);
}
function eventSource(source4) {
  return source4 === Scope ? View2 : source4 || View2;
}
function mergeStream(stream2, scope) {
  const list = stream2.merge.map((s) => parseStream3(s, scope)), entry2 = streamParameters({
    merge: list
  }, stream2, scope);
  return scope.addStream(entry2).id;
}
function nestedStream(stream2, scope) {
  const id4 = parseStream3(stream2.stream, scope), entry2 = streamParameters({
    stream: id4
  }, stream2, scope);
  return scope.addStream(entry2).id;
}
function eventStream(stream2, scope) {
  let id4;
  if (stream2.type === Timer2) {
    id4 = scope.event(Timer2, stream2.throttle);
    stream2 = {
      between: stream2.between,
      filter: stream2.filter
    };
  } else {
    id4 = scope.event(eventSource(stream2.source), stream2.type);
  }
  const entry2 = streamParameters({
    stream: id4
  }, stream2, scope);
  return Object.keys(entry2).length === 1 ? id4 : scope.addStream(entry2).id;
}
function streamParameters(entry2, stream2, scope) {
  let param2 = stream2.between;
  if (param2) {
    if (param2.length !== 2) {
      error('Stream "between" parameter must have 2 entries: ' + $(stream2));
    }
    entry2.between = [parseStream3(param2[0], scope), parseStream3(param2[1], scope)];
  }
  param2 = stream2.filter ? [].concat(stream2.filter) : [];
  if (stream2.marktype || stream2.markname || stream2.markrole) {
    param2.push(filterMark(stream2.marktype, stream2.markname, stream2.markrole));
  }
  if (stream2.source === Scope) {
    param2.push("inScope(event.item)");
  }
  if (param2.length) {
    entry2.filter = parser2("(" + param2.join(")&&(") + ")", scope).$expr;
  }
  if ((param2 = stream2.throttle) != null) {
    entry2.throttle = +param2;
  }
  if ((param2 = stream2.debounce) != null) {
    entry2.debounce = +param2;
  }
  if (stream2.consume) {
    entry2.consume = true;
  }
  return entry2;
}
function filterMark(type2, name4, role) {
  const item = "event.item";
  return item + (type2 && type2 !== "*" ? "&&" + item + ".mark.marktype==='" + type2 + "'" : "") + (role ? "&&" + item + ".mark.role==='" + role + "'" : "") + (name4 ? "&&" + item + ".mark.name==='" + name4 + "'" : "");
}
var OP_VALUE_EXPR = {
  code: "_.$value",
  ast: {
    type: "Identifier",
    value: "value"
  }
};
function parseUpdate2(spec, scope, target) {
  const encode15 = spec.encode, entry2 = {
    target
  };
  let events4 = spec.events, update3 = spec.update, sources = [];
  if (!events4) {
    error("Signal update missing events specification.");
  }
  if (isString(events4)) {
    events4 = eventSelector(events4, scope.isSubscope() ? Scope : View2);
  }
  events4 = array(events4).filter((s) => s.signal || s.scale ? (sources.push(s), 0) : 1);
  if (sources.length > 1) {
    sources = [mergeSources(sources)];
  }
  if (events4.length) {
    sources.push(events4.length > 1 ? {
      merge: events4
    } : events4[0]);
  }
  if (encode15 != null) {
    if (update3)
      error("Signal encode and update are mutually exclusive.");
    update3 = "encode(item()," + $(encode15) + ")";
  }
  entry2.update = isString(update3) ? parser2(update3, scope) : update3.expr != null ? parser2(update3.expr, scope) : update3.value != null ? update3.value : update3.signal != null ? {
    $expr: OP_VALUE_EXPR,
    $params: {
      $value: scope.signalRef(update3.signal)
    }
  } : error("Invalid signal update specification.");
  if (spec.force) {
    entry2.options = {
      force: true
    };
  }
  sources.forEach((source4) => scope.addUpdate(extend(streamSource(source4, scope), entry2)));
}
function streamSource(stream2, scope) {
  return {
    source: stream2.signal ? scope.signalRef(stream2.signal) : stream2.scale ? scope.scaleRef(stream2.scale) : parseStream3(stream2, scope)
  };
}
function mergeSources(sources) {
  return {
    signal: "[" + sources.map((s) => s.scale ? 'scale("' + s.scale + '")' : s.signal) + "]"
  };
}
function parseSignalUpdates(signal, scope) {
  const op = scope.getSignal(signal.name);
  let expr2 = signal.update;
  if (signal.init) {
    if (expr2) {
      error("Signals can not include both init and update expressions.");
    } else {
      expr2 = signal.init;
      op.initonly = true;
    }
  }
  if (expr2) {
    expr2 = parser2(expr2, scope);
    op.update = expr2.$expr;
    op.params = expr2.$params;
  }
  if (signal.on) {
    signal.on.forEach((_) => parseUpdate2(_, scope, op.id));
  }
}
var transform3 = (name4) => (params2, value3, parent) => entry$1(name4, value3, params2 || void 0, parent);
var Aggregate2 = transform3("aggregate");
var AxisTicks2 = transform3("axisticks");
var Bound2 = transform3("bound");
var Collect2 = transform3("collect");
var Compare2 = transform3("compare");
var DataJoin2 = transform3("datajoin");
var Encode2 = transform3("encode");
var Expression2 = transform3("expression");
var Facet2 = transform3("facet");
var Field2 = transform3("field");
var Key2 = transform3("key");
var LegendEntries2 = transform3("legendentries");
var Load2 = transform3("load");
var Mark2 = transform3("mark");
var MultiExtent2 = transform3("multiextent");
var MultiValues2 = transform3("multivalues");
var Overlap2 = transform3("overlap");
var Params3 = transform3("params");
var PreFacet2 = transform3("prefacet");
var Projection2 = transform3("projection");
var Proxy2 = transform3("proxy");
var Relay2 = transform3("relay");
var Render2 = transform3("render");
var Scale2 = transform3("scale");
var Sieve2 = transform3("sieve");
var SortItems2 = transform3("sortitems");
var ViewLayout2 = transform3("viewlayout");
var Values2 = transform3("values");
var FIELD_REF_ID = 0;
var MULTIDOMAIN_SORT_OPS = {
  min: "min",
  max: "max",
  count: "sum"
};
function initScale(spec, scope) {
  const type2 = spec.type || "linear";
  if (!isValidScaleType(type2)) {
    error("Unrecognized scale type: " + $(type2));
  }
  scope.addScale(spec.name, {
    type: type2,
    domain: void 0
  });
}
function parseScale(spec, scope) {
  const params2 = scope.getScale(spec.name).params;
  let key2;
  params2.domain = parseScaleDomain(spec.domain, spec, scope);
  if (spec.range != null) {
    params2.range = parseScaleRange(spec, scope, params2);
  }
  if (spec.interpolate != null) {
    parseScaleInterpolate(spec.interpolate, params2);
  }
  if (spec.nice != null) {
    params2.nice = parseScaleNice(spec.nice);
  }
  if (spec.bins != null) {
    params2.bins = parseScaleBins(spec.bins, scope);
  }
  for (key2 in spec) {
    if (has(params2, key2) || key2 === "name")
      continue;
    params2[key2] = parseLiteral(spec[key2], scope);
  }
}
function parseLiteral(v, scope) {
  return !isObject(v) ? v : v.signal ? scope.signalRef(v.signal) : error("Unsupported object: " + $(v));
}
function parseArray(v, scope) {
  return v.signal ? scope.signalRef(v.signal) : v.map((v2) => parseLiteral(v2, scope));
}
function dataLookupError(name4) {
  error("Can not find data set: " + $(name4));
}
function parseScaleDomain(domain4, spec, scope) {
  if (!domain4) {
    if (spec.domainMin != null || spec.domainMax != null) {
      error("No scale domain defined for domainMin/domainMax to override.");
    }
    return;
  }
  return domain4.signal ? scope.signalRef(domain4.signal) : (isArray(domain4) ? explicitDomain : domain4.fields ? multipleDomain : singularDomain)(domain4, spec, scope);
}
function explicitDomain(domain4, spec, scope) {
  return domain4.map((v) => parseLiteral(v, scope));
}
function singularDomain(domain4, spec, scope) {
  const data4 = scope.getData(domain4.data);
  if (!data4)
    dataLookupError(domain4.data);
  return isDiscrete(spec.type) ? data4.valuesRef(scope, domain4.field, parseSort(domain4.sort, false)) : isQuantile(spec.type) ? data4.domainRef(scope, domain4.field) : data4.extentRef(scope, domain4.field);
}
function multipleDomain(domain4, spec, scope) {
  const data4 = domain4.data, fields = domain4.fields.reduce((dom, d) => {
    d = isString(d) ? {
      data: data4,
      field: d
    } : isArray(d) || d.signal ? fieldRef$1(d, scope) : d;
    dom.push(d);
    return dom;
  }, []);
  return (isDiscrete(spec.type) ? ordinalMultipleDomain : isQuantile(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain4, scope, fields);
}
function fieldRef$1(data4, scope) {
  const name4 = "_:vega:_" + FIELD_REF_ID++, coll = Collect2({});
  if (isArray(data4)) {
    coll.value = {
      $ingest: data4
    };
  } else if (data4.signal) {
    const code = "setdata(" + $(name4) + "," + data4.signal + ")";
    coll.params.input = scope.signalRef(code);
  }
  scope.addDataPipeline(name4, [coll, Sieve2({})]);
  return {
    data: name4,
    field: "data"
  };
}
function ordinalMultipleDomain(domain4, scope, fields) {
  const sort2 = parseSort(domain4.sort, true);
  let a2, v;
  const counts = fields.map((f) => {
    const data4 = scope.getData(f.data);
    if (!data4)
      dataLookupError(f.data);
    return data4.countsRef(scope, f.field, sort2);
  });
  const p = {
    groupby: keyFieldRef,
    pulse: counts
  };
  if (sort2) {
    a2 = sort2.op || "count";
    v = sort2.field ? aggrField(a2, sort2.field) : "count";
    p.ops = [MULTIDOMAIN_SORT_OPS[a2]];
    p.fields = [scope.fieldRef(v)];
    p.as = [v];
  }
  a2 = scope.add(Aggregate2(p));
  const c2 = scope.add(Collect2({
    pulse: ref(a2)
  }));
  v = scope.add(Values2({
    field: keyFieldRef,
    sort: scope.sortRef(sort2),
    pulse: ref(c2)
  }));
  return ref(v);
}
function parseSort(sort2, multidomain) {
  if (sort2) {
    if (!sort2.field && !sort2.op) {
      if (isObject(sort2))
        sort2.field = "key";
      else
        sort2 = {
          field: "key"
        };
    } else if (!sort2.field && sort2.op !== "count") {
      error("No field provided for sort aggregate op: " + sort2.op);
    } else if (multidomain && sort2.field) {
      if (sort2.op && !MULTIDOMAIN_SORT_OPS[sort2.op]) {
        error("Multiple domain scales can not be sorted using " + sort2.op);
      }
    }
  }
  return sort2;
}
function quantileMultipleDomain(domain4, scope, fields) {
  const values4 = fields.map((f) => {
    const data4 = scope.getData(f.data);
    if (!data4)
      dataLookupError(f.data);
    return data4.domainRef(scope, f.field);
  });
  return ref(scope.add(MultiValues2({
    values: values4
  })));
}
function numericMultipleDomain(domain4, scope, fields) {
  const extents = fields.map((f) => {
    const data4 = scope.getData(f.data);
    if (!data4)
      dataLookupError(f.data);
    return data4.extentRef(scope, f.field);
  });
  return ref(scope.add(MultiExtent2({
    extents
  })));
}
function parseScaleBins(v, scope) {
  return v.signal || isArray(v) ? parseArray(v, scope) : scope.objectProperty(v);
}
function parseScaleNice(nice3) {
  return isObject(nice3) ? {
    interval: parseLiteral(nice3.interval),
    step: parseLiteral(nice3.step)
  } : parseLiteral(nice3);
}
function parseScaleInterpolate(interpolate3, params2) {
  params2.interpolate = parseLiteral(interpolate3.type || interpolate3);
  if (interpolate3.gamma != null) {
    params2.interpolateGamma = parseLiteral(interpolate3.gamma);
  }
}
function parseScaleRange(spec, scope, params2) {
  const config = scope.config.range;
  let range5 = spec.range;
  if (range5.signal) {
    return scope.signalRef(range5.signal);
  } else if (isString(range5)) {
    if (config && has(config, range5)) {
      spec = extend({}, spec, {
        range: config[range5]
      });
      return parseScaleRange(spec, scope, params2);
    } else if (range5 === "width") {
      range5 = [0, {
        signal: "width"
      }];
    } else if (range5 === "height") {
      range5 = isDiscrete(spec.type) ? [0, {
        signal: "height"
      }] : [{
        signal: "height"
      }, 0];
    } else {
      error("Unrecognized scale range value: " + $(range5));
    }
  } else if (range5.scheme) {
    params2.scheme = isArray(range5.scheme) ? parseArray(range5.scheme, scope) : parseLiteral(range5.scheme, scope);
    if (range5.extent)
      params2.schemeExtent = parseArray(range5.extent, scope);
    if (range5.count)
      params2.schemeCount = parseLiteral(range5.count, scope);
    return;
  } else if (range5.step) {
    params2.rangeStep = parseLiteral(range5.step, scope);
    return;
  } else if (isDiscrete(spec.type) && !isArray(range5)) {
    return parseScaleDomain(range5, spec, scope);
  } else if (!isArray(range5)) {
    error("Unsupported range type: " + $(range5));
  }
  return range5.map((v) => (isArray(v) ? parseArray : parseLiteral)(v, scope));
}
function parseProjection(proj, scope) {
  const config = scope.config.projection || {}, params2 = {};
  for (const name4 in proj) {
    if (name4 === "name")
      continue;
    params2[name4] = parseParameter2(proj[name4], name4, scope);
  }
  for (const name4 in config) {
    if (params2[name4] == null) {
      params2[name4] = parseParameter2(config[name4], name4, scope);
    }
  }
  scope.addProjection(proj.name, params2);
}
function parseParameter2(_, name4, scope) {
  return isArray(_) ? _.map((_2) => parseParameter2(_2, name4, scope)) : !isObject(_) ? _ : _.signal ? scope.signalRef(_.signal) : name4 === "fit" ? _ : error("Unsupported parameter object: " + $(_));
}
var Top2 = "top";
var Left2 = "left";
var Right2 = "right";
var Bottom2 = "bottom";
var Center2 = "center";
var Vertical = "vertical";
var Start2 = "start";
var Middle2 = "middle";
var End2 = "end";
var Index = "index";
var Label2 = "label";
var Offset = "offset";
var Perc = "perc";
var Perc2 = "perc2";
var Value = "value";
var GuideLabelStyle = "guide-label";
var GuideTitleStyle = "guide-title";
var GroupTitleStyle = "group-title";
var GroupSubtitleStyle = "group-subtitle";
var Symbols2 = "symbol";
var Gradient2 = "gradient";
var Discrete2 = "discrete";
var Size = "size";
var Shape = "shape";
var Fill = "fill";
var Stroke = "stroke";
var StrokeWidth = "strokeWidth";
var StrokeDash = "strokeDash";
var Opacity = "opacity";
var LegendScales = [Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity];
var Skip3 = {
  name: 1,
  style: 1,
  interactive: 1
};
var zero3 = {
  value: 0
};
var one3 = {
  value: 1
};
var GroupMark = "group";
var RectMark = "rect";
var RuleMark = "rule";
var SymbolMark = "symbol";
var TextMark = "text";
function guideGroup(mark2) {
  mark2.type = GroupMark;
  mark2.interactive = mark2.interactive || false;
  return mark2;
}
function lookup5(spec, config) {
  const _ = (name4, dflt) => value2(spec[name4], value2(config[name4], dflt));
  _.isVertical = (s) => Vertical === value2(spec.direction, config.direction || (s ? config.symbolDirection : config.gradientDirection));
  _.gradientLength = () => value2(spec.gradientLength, config.gradientLength || config.gradientWidth);
  _.gradientThickness = () => value2(spec.gradientThickness, config.gradientThickness || config.gradientHeight);
  _.entryColumns = () => value2(spec.columns, value2(config.columns, +_.isVertical(true)));
  return _;
}
function getEncoding(name4, encode15) {
  const v = encode15 && (encode15.update && encode15.update[name4] || encode15.enter && encode15.enter[name4]);
  return v && v.signal ? v : v ? v.value : null;
}
function getStyle(name4, scope, style2) {
  const s = scope.config.style[style2];
  return s && s[name4];
}
function anchorExpr(s, e, m2) {
  return "item.anchor === '".concat(Start2, "' ? ").concat(s, " : item.anchor === '").concat(End2, "' ? ").concat(e, " : ").concat(m2);
}
var alignExpr = anchorExpr($(Left2), $(Right2), $(Center2));
function tickBand(_) {
  const v = _("tickBand");
  let offset4 = _("tickOffset"), band2, extra;
  if (!v) {
    band2 = _("bandPosition");
    extra = _("tickExtra");
  } else if (v.signal) {
    band2 = {
      signal: "(".concat(v.signal, ") === 'extent' ? 1 : 0.5")
    };
    extra = {
      signal: "(".concat(v.signal, ") === 'extent'")
    };
    if (!isObject(offset4)) {
      offset4 = {
        signal: "(".concat(v.signal, ") === 'extent' ? 0 : ").concat(offset4)
      };
    }
  } else if (v === "extent") {
    band2 = 1;
    extra = true;
    offset4 = 0;
  } else {
    band2 = 0.5;
    extra = false;
  }
  return {
    extra,
    band: band2,
    offset: offset4
  };
}
function extendOffset(value3, offset4) {
  return !offset4 ? value3 : !value3 ? offset4 : !isObject(value3) ? {
    value: value3,
    offset: offset4
  } : Object.assign({}, value3, {
    offset: extendOffset(value3.offset, offset4)
  });
}
function guideMark(mark2, extras) {
  if (extras) {
    mark2.name = extras.name;
    mark2.style = extras.style || mark2.style;
    mark2.interactive = !!extras.interactive;
    mark2.encode = extendEncode(mark2.encode, extras, Skip3);
  } else {
    mark2.interactive = false;
  }
  return mark2;
}
function legendGradient(spec, scale7, config, userEncode) {
  const _ = lookup5(spec, config), vertical = _.isVertical(), thickness = _.gradientThickness(), length3 = _.gradientLength();
  let enter, start, stop2, width2, height2;
  if (vertical) {
    start = [0, 1];
    stop2 = [0, 0];
    width2 = thickness;
    height2 = length3;
  } else {
    start = [0, 0];
    stop2 = [1, 0];
    width2 = length3;
    height2 = thickness;
  }
  const encode15 = {
    enter: enter = {
      opacity: zero3,
      x: zero3,
      y: zero3,
      width: encoder(width2),
      height: encoder(height2)
    },
    update: extend({}, enter, {
      opacity: one3,
      fill: {
        gradient: scale7,
        start,
        stop: stop2
      }
    }),
    exit: {
      opacity: zero3
    }
  };
  addEncoders(encode15, {
    stroke: _("gradientStrokeColor"),
    strokeWidth: _("gradientStrokeWidth")
  }, {
    opacity: _("gradientOpacity")
  });
  return guideMark({
    type: RectMark,
    role: LegendGradientRole,
    encode: encode15
  }, userEncode);
}
function legendGradientDiscrete(spec, scale7, config, userEncode, dataRef) {
  const _ = lookup5(spec, config), vertical = _.isVertical(), thickness = _.gradientThickness(), length3 = _.gradientLength();
  let u, v, uu, vv, adjust = "";
  vertical ? (u = "y", uu = "y2", v = "x", vv = "width", adjust = "1-") : (u = "x", uu = "x2", v = "y", vv = "height");
  const enter = {
    opacity: zero3,
    fill: {
      scale: scale7,
      field: Value
    }
  };
  enter[u] = {
    signal: adjust + "datum." + Perc,
    mult: length3
  };
  enter[v] = zero3;
  enter[uu] = {
    signal: adjust + "datum." + Perc2,
    mult: length3
  };
  enter[vv] = encoder(thickness);
  const encode15 = {
    enter,
    update: extend({}, enter, {
      opacity: one3
    }),
    exit: {
      opacity: zero3
    }
  };
  addEncoders(encode15, {
    stroke: _("gradientStrokeColor"),
    strokeWidth: _("gradientStrokeWidth")
  }, {
    opacity: _("gradientOpacity")
  });
  return guideMark({
    type: RectMark,
    role: LegendBandRole,
    key: Value,
    from: dataRef,
    encode: encode15
  }, userEncode);
}
var alignExpr$1 = "datum.".concat(Perc, '<=0?"').concat(Left2, '":datum.').concat(Perc, '>=1?"').concat(Right2, '":"').concat(Center2, '"');
var baselineExpr = "datum.".concat(Perc, '<=0?"').concat(Bottom2, '":datum.').concat(Perc, '>=1?"').concat(Top2, '":"').concat(Middle2, '"');
function legendGradientLabels(spec, config, userEncode, dataRef) {
  const _ = lookup5(spec, config), vertical = _.isVertical(), thickness = encoder(_.gradientThickness()), length3 = _.gradientLength();
  let overlap = _("labelOverlap"), enter, update3, u, v, adjust = "";
  const encode15 = {
    enter: enter = {
      opacity: zero3
    },
    update: update3 = {
      opacity: one3,
      text: {
        field: Label2
      }
    },
    exit: {
      opacity: zero3
    }
  };
  addEncoders(encode15, {
    fill: _("labelColor"),
    fillOpacity: _("labelOpacity"),
    font: _("labelFont"),
    fontSize: _("labelFontSize"),
    fontStyle: _("labelFontStyle"),
    fontWeight: _("labelFontWeight"),
    limit: value2(spec.labelLimit, config.gradientLabelLimit)
  });
  if (vertical) {
    enter.align = {
      value: "left"
    };
    enter.baseline = update3.baseline = {
      signal: baselineExpr
    };
    u = "y";
    v = "x";
    adjust = "1-";
  } else {
    enter.align = update3.align = {
      signal: alignExpr$1
    };
    enter.baseline = {
      value: "top"
    };
    u = "x";
    v = "y";
  }
  enter[u] = update3[u] = {
    signal: adjust + "datum." + Perc,
    mult: length3
  };
  enter[v] = update3[v] = thickness;
  thickness.offset = value2(spec.labelOffset, config.gradientLabelOffset) || 0;
  overlap = overlap ? {
    separation: _("labelSeparation"),
    method: overlap,
    order: "datum." + Index
  } : void 0;
  return guideMark({
    type: TextMark,
    role: LegendLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: dataRef,
    encode: encode15,
    overlap
  }, userEncode);
}
function legendSymbolGroups(spec, config, userEncode, dataRef, columns) {
  const _ = lookup5(spec, config), entries3 = userEncode.entries, interactive2 = !!(entries3 && entries3.interactive), name4 = entries3 ? entries3.name : void 0, height2 = _("clipHeight"), symbolOffset = _("symbolOffset"), valueRef = {
    data: "value"
  }, xSignal = "(".concat(columns, ") ? datum.").concat(Offset, " : datum.").concat(Size), yEncode = height2 ? encoder(height2) : {
    field: Size
  }, index4 = "datum.".concat(Index), ncols = "max(1, ".concat(columns, ")");
  let encode15, enter, update3, nrows, sort2;
  yEncode.mult = 0.5;
  encode15 = {
    enter: enter = {
      opacity: zero3,
      x: {
        signal: xSignal,
        mult: 0.5,
        offset: symbolOffset
      },
      y: yEncode
    },
    update: update3 = {
      opacity: one3,
      x: enter.x,
      y: enter.y
    },
    exit: {
      opacity: zero3
    }
  };
  let baseFill = null, baseStroke = null;
  if (!spec.fill) {
    baseFill = config.symbolBaseFillColor;
    baseStroke = config.symbolBaseStrokeColor;
  }
  addEncoders(encode15, {
    fill: _("symbolFillColor", baseFill),
    shape: _("symbolType"),
    size: _("symbolSize"),
    stroke: _("symbolStrokeColor", baseStroke),
    strokeDash: _("symbolDash"),
    strokeDashOffset: _("symbolDashOffset"),
    strokeWidth: _("symbolStrokeWidth")
  }, {
    opacity: _("symbolOpacity")
  });
  LegendScales.forEach((scale7) => {
    if (spec[scale7]) {
      update3[scale7] = enter[scale7] = {
        scale: spec[scale7],
        field: Value
      };
    }
  });
  const symbols4 = guideMark({
    type: SymbolMark,
    role: LegendSymbolRole,
    key: Value,
    from: valueRef,
    clip: height2 ? true : void 0,
    encode: encode15
  }, userEncode.symbols);
  const labelOffset = encoder(symbolOffset);
  labelOffset.offset = _("labelOffset");
  encode15 = {
    enter: enter = {
      opacity: zero3,
      x: {
        signal: xSignal,
        offset: labelOffset
      },
      y: yEncode
    },
    update: update3 = {
      opacity: one3,
      text: {
        field: Label2
      },
      x: enter.x,
      y: enter.y
    },
    exit: {
      opacity: zero3
    }
  };
  addEncoders(encode15, {
    align: _("labelAlign"),
    baseline: _("labelBaseline"),
    fill: _("labelColor"),
    fillOpacity: _("labelOpacity"),
    font: _("labelFont"),
    fontSize: _("labelFontSize"),
    fontStyle: _("labelFontStyle"),
    fontWeight: _("labelFontWeight"),
    limit: _("labelLimit")
  });
  const labels3 = guideMark({
    type: TextMark,
    role: LegendLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: valueRef,
    encode: encode15
  }, userEncode.labels);
  encode15 = {
    enter: {
      noBound: {
        value: !height2
      },
      width: zero3,
      height: height2 ? encoder(height2) : zero3,
      opacity: zero3
    },
    exit: {
      opacity: zero3
    },
    update: update3 = {
      opacity: one3,
      row: {
        signal: null
      },
      column: {
        signal: null
      }
    }
  };
  if (_.isVertical(true)) {
    nrows = "ceil(item.mark.items.length / ".concat(ncols, ")");
    update3.row.signal = "".concat(index4, "%").concat(nrows);
    update3.column.signal = "floor(".concat(index4, " / ").concat(nrows, ")");
    sort2 = {
      field: ["row", index4]
    };
  } else {
    update3.row.signal = "floor(".concat(index4, " / ").concat(ncols, ")");
    update3.column.signal = "".concat(index4, " % ").concat(ncols);
    sort2 = {
      field: index4
    };
  }
  update3.column.signal = "(".concat(columns, ")?").concat(update3.column.signal, ":").concat(index4);
  dataRef = {
    facet: {
      data: dataRef,
      name: "value",
      groupby: Index
    }
  };
  return guideGroup({
    role: ScopeRole2,
    from: dataRef,
    encode: extendEncode(encode15, entries3, Skip3),
    marks: [symbols4, labels3],
    name: name4,
    interactive: interactive2,
    sort: sort2
  });
}
function legendSymbolLayout(spec, config) {
  const _ = lookup5(spec, config);
  return {
    align: _("gridAlign"),
    columns: _.entryColumns(),
    center: {
      row: true,
      column: false
    },
    padding: {
      row: _("rowPadding"),
      column: _("columnPadding")
    }
  };
}
var isL = 'item.orient === "left"';
var isR = 'item.orient === "right"';
var isLR = "(".concat(isL, " || ").concat(isR, ")");
var isVG = "datum.vgrad && ".concat(isLR);
var baseline = anchorExpr('"top"', '"bottom"', '"middle"');
var alignFlip = anchorExpr('"right"', '"left"', '"center"');
var exprAlign = "datum.vgrad && ".concat(isR, " ? (").concat(alignFlip, ") : (").concat(isLR, " && !(datum.vgrad && ").concat(isL, ')) ? "left" : ').concat(alignExpr);
var exprAnchor = "item._anchor || (".concat(isLR, ' ? "middle" : "start")');
var exprAngle = "".concat(isVG, " ? (").concat(isL, " ? -90 : 90) : 0");
var exprBaseline = "".concat(isLR, " ? (datum.vgrad ? (").concat(isR, ' ? "bottom" : "top") : ').concat(baseline, ') : "top"');
function legendTitle(spec, config, userEncode, dataRef) {
  const _ = lookup5(spec, config);
  const encode15 = {
    enter: {
      opacity: zero3
    },
    update: {
      opacity: one3,
      x: {
        field: {
          group: "padding"
        }
      },
      y: {
        field: {
          group: "padding"
        }
      }
    },
    exit: {
      opacity: zero3
    }
  };
  addEncoders(encode15, {
    orient: _("titleOrient"),
    _anchor: _("titleAnchor"),
    anchor: {
      signal: exprAnchor
    },
    angle: {
      signal: exprAngle
    },
    align: {
      signal: exprAlign
    },
    baseline: {
      signal: exprBaseline
    },
    text: spec.title,
    fill: _("titleColor"),
    fillOpacity: _("titleOpacity"),
    font: _("titleFont"),
    fontSize: _("titleFontSize"),
    fontStyle: _("titleFontStyle"),
    fontWeight: _("titleFontWeight"),
    limit: _("titleLimit"),
    lineHeight: _("titleLineHeight")
  }, {
    align: _("titleAlign"),
    baseline: _("titleBaseline")
  });
  return guideMark({
    type: TextMark,
    role: LegendTitleRole,
    style: GuideTitleStyle,
    from: dataRef,
    encode: encode15
  }, userEncode);
}
function clip2(clip3, scope) {
  let expr2;
  if (isObject(clip3)) {
    if (clip3.signal) {
      expr2 = clip3.signal;
    } else if (clip3.path) {
      expr2 = "pathShape(" + param(clip3.path) + ")";
    } else if (clip3.sphere) {
      expr2 = "geoShape(" + param(clip3.sphere) + ', {type: "Sphere"})';
    }
  }
  return expr2 ? scope.signalRef(expr2) : !!clip3;
}
function param(value3) {
  return isObject(value3) && value3.signal ? value3.signal : $(value3);
}
function getRole(spec) {
  const role = spec.role || "";
  return !role.indexOf("axis") || !role.indexOf("legend") || !role.indexOf("title") ? role : spec.type === GroupMark ? ScopeRole2 : role || MarkRole;
}
function definition2(spec) {
  return {
    marktype: spec.type,
    name: spec.name || void 0,
    role: spec.role || getRole(spec),
    zindex: +spec.zindex || void 0,
    aria: spec.aria,
    description: spec.description
  };
}
function interactive(spec, scope) {
  return spec && spec.signal ? scope.signalRef(spec.signal) : spec === false ? false : true;
}
function parseTransform(spec, scope) {
  const def2 = definition(spec.type);
  if (!def2)
    error("Unrecognized transform type: " + $(spec.type));
  const t = entry$1(def2.type.toLowerCase(), null, parseParameters2(def2, spec, scope));
  if (spec.signal)
    scope.addSignal(spec.signal, scope.proxy(t));
  t.metadata = def2.metadata || {};
  return t;
}
function parseParameters2(def2, spec, scope) {
  const params2 = {}, n = def2.params.length;
  for (let i = 0; i < n; ++i) {
    const pdef = def2.params[i];
    params2[pdef.name] = parseParameter$1(pdef, spec, scope);
  }
  return params2;
}
function parseParameter$1(def2, spec, scope) {
  const type2 = def2.type, value3 = spec[def2.name];
  if (type2 === "index") {
    return parseIndexParameter(def2, spec, scope);
  } else if (value3 === void 0) {
    if (def2.required) {
      error("Missing required " + $(spec.type) + " parameter: " + $(def2.name));
    }
    return;
  } else if (type2 === "param") {
    return parseSubParameters(def2, spec, scope);
  } else if (type2 === "projection") {
    return scope.projectionRef(spec[def2.name]);
  }
  return def2.array && !isSignal(value3) ? value3.map((v) => parameterValue(def2, v, scope)) : parameterValue(def2, value3, scope);
}
function parameterValue(def2, value3, scope) {
  const type2 = def2.type;
  if (isSignal(value3)) {
    return isExpr$1(type2) ? error("Expression references can not be signals.") : isField(type2) ? scope.fieldRef(value3) : isCompare(type2) ? scope.compareRef(value3) : scope.signalRef(value3.signal);
  } else {
    const expr2 = def2.expr || isField(type2);
    return expr2 && outerExpr(value3) ? scope.exprRef(value3.expr, value3.as) : expr2 && outerField(value3) ? fieldRef(value3.field, value3.as) : isExpr$1(type2) ? parser2(value3, scope) : isData(type2) ? ref(scope.getData(value3).values) : isField(type2) ? fieldRef(value3) : isCompare(type2) ? scope.compareRef(value3) : value3;
  }
}
function parseIndexParameter(def2, spec, scope) {
  if (!isString(spec.from)) {
    error('Lookup "from" parameter must be a string literal.');
  }
  return scope.getData(spec.from).lookupRef(scope, spec.key);
}
function parseSubParameters(def2, spec, scope) {
  const value3 = spec[def2.name];
  if (def2.array) {
    if (!isArray(value3)) {
      error("Expected an array of sub-parameters. Instead: " + $(value3));
    }
    return value3.map((v) => parseSubParameter(def2, v, scope));
  } else {
    return parseSubParameter(def2, value3, scope);
  }
}
function parseSubParameter(def2, value3, scope) {
  const n = def2.params.length;
  let pdef;
  for (let i = 0; i < n; ++i) {
    pdef = def2.params[i];
    for (const k in pdef.key) {
      if (pdef.key[k] !== value3[k]) {
        pdef = null;
        break;
      }
    }
    if (pdef)
      break;
  }
  if (!pdef)
    error("Unsupported parameter: " + $(value3));
  const params2 = extend(parseParameters2(pdef, value3, scope), pdef.key);
  return ref(scope.add(Params3(params2)));
}
var outerExpr = (_) => _ && _.expr;
var outerField = (_) => _ && _.field;
var isData = (_) => _ === "data";
var isExpr$1 = (_) => _ === "expr";
var isField = (_) => _ === "field";
var isCompare = (_) => _ === "compare";
function parseData(from, group2, scope) {
  let facet, key2, op, dataRef, parent;
  if (!from) {
    dataRef = ref(scope.add(Collect2(null, [{}])));
  } else if (facet = from.facet) {
    if (!group2)
      error("Only group marks can be faceted.");
    if (facet.field != null) {
      dataRef = parent = getDataRef(facet, scope);
    } else {
      if (!from.data) {
        op = parseTransform(extend({
          type: "aggregate",
          groupby: array(facet.groupby)
        }, facet.aggregate), scope);
        op.params.key = scope.keyRef(facet.groupby);
        op.params.pulse = getDataRef(facet, scope);
        dataRef = parent = ref(scope.add(op));
      } else {
        parent = ref(scope.getData(from.data).aggregate);
      }
      key2 = scope.keyRef(facet.groupby, true);
    }
  }
  if (!dataRef) {
    dataRef = getDataRef(from, scope);
  }
  return {
    key: key2,
    pulse: dataRef,
    parent
  };
}
function getDataRef(from, scope) {
  return from.$ref ? from : from.data && from.data.$ref ? from.data : ref(scope.getData(from.data).output);
}
function DataScope(scope, input, output3, values4, aggr) {
  this.scope = scope;
  this.input = input;
  this.output = output3;
  this.values = values4;
  this.aggregate = aggr;
  this.index = {};
}
DataScope.fromEntries = function(scope, entries3) {
  const n = entries3.length, values4 = entries3[n - 1], output3 = entries3[n - 2];
  let input = entries3[0], aggr = null, i = 1;
  if (input && input.type === "load") {
    input = entries3[1];
  }
  scope.add(entries3[0]);
  for (; i < n; ++i) {
    entries3[i].params.pulse = ref(entries3[i - 1]);
    scope.add(entries3[i]);
    if (entries3[i].type === "aggregate")
      aggr = entries3[i];
  }
  return new DataScope(scope, input, output3, values4, aggr);
};
function fieldKey(field4) {
  return isString(field4) ? field4 : null;
}
function addSortField(scope, p, sort2) {
  const as = aggrField(sort2.op, sort2.field);
  let s;
  if (p.ops) {
    for (let i = 0, n = p.as.length; i < n; ++i) {
      if (p.as[i] === as)
        return;
    }
  } else {
    p.ops = ["count"];
    p.fields = [null];
    p.as = ["count"];
  }
  if (sort2.op) {
    p.ops.push((s = sort2.op.signal) ? scope.signalRef(s) : sort2.op);
    p.fields.push(scope.fieldRef(sort2.field));
    p.as.push(as);
  }
}
function cache(scope, ds, name4, optype, field4, counts, index4) {
  const cache2 = ds[name4] || (ds[name4] = {}), sort2 = sortKey(counts);
  let k = fieldKey(field4), v, op;
  if (k != null) {
    scope = ds.scope;
    k = k + (sort2 ? "|" + sort2 : "");
    v = cache2[k];
  }
  if (!v) {
    const params2 = counts ? {
      field: keyFieldRef,
      pulse: ds.countsRef(scope, field4, counts)
    } : {
      field: scope.fieldRef(field4),
      pulse: ref(ds.output)
    };
    if (sort2)
      params2.sort = scope.sortRef(counts);
    op = scope.add(entry$1(optype, void 0, params2));
    if (index4)
      ds.index[field4] = op;
    v = ref(op);
    if (k != null)
      cache2[k] = v;
  }
  return v;
}
DataScope.prototype = {
  countsRef(scope, field4, sort2) {
    const ds = this, cache2 = ds.counts || (ds.counts = {}), k = fieldKey(field4);
    let v, a2, p;
    if (k != null) {
      scope = ds.scope;
      v = cache2[k];
    }
    if (!v) {
      p = {
        groupby: scope.fieldRef(field4, "key"),
        pulse: ref(ds.output)
      };
      if (sort2 && sort2.field)
        addSortField(scope, p, sort2);
      a2 = scope.add(Aggregate2(p));
      v = scope.add(Collect2({
        pulse: ref(a2)
      }));
      v = {
        agg: a2,
        ref: ref(v)
      };
      if (k != null)
        cache2[k] = v;
    } else if (sort2 && sort2.field) {
      addSortField(scope, v.agg.params, sort2);
    }
    return v.ref;
  },
  tuplesRef() {
    return ref(this.values);
  },
  extentRef(scope, field4) {
    return cache(scope, this, "extent", "extent", field4, false);
  },
  domainRef(scope, field4) {
    return cache(scope, this, "domain", "values", field4, false);
  },
  valuesRef(scope, field4, sort2) {
    return cache(scope, this, "vals", "values", field4, sort2 || true);
  },
  lookupRef(scope, field4) {
    return cache(scope, this, "lookup", "tupleindex", field4, false);
  },
  indataRef(scope, field4) {
    return cache(scope, this, "indata", "tupleindex", field4, true, true);
  }
};
function parseFacet(spec, scope, group2) {
  const facet = spec.from.facet, name4 = facet.name, data4 = getDataRef(facet, scope);
  let op;
  if (!facet.name) {
    error("Facet must have a name: " + $(facet));
  }
  if (!facet.data) {
    error("Facet must reference a data set: " + $(facet));
  }
  if (facet.field) {
    op = scope.add(PreFacet2({
      field: scope.fieldRef(facet.field),
      pulse: data4
    }));
  } else if (facet.groupby) {
    op = scope.add(Facet2({
      key: scope.keyRef(facet.groupby),
      group: ref(scope.proxy(group2.parent)),
      pulse: data4
    }));
  } else {
    error("Facet must specify groupby or field: " + $(facet));
  }
  const subscope = scope.fork(), source4 = subscope.add(Collect2()), values4 = subscope.add(Sieve2({
    pulse: ref(source4)
  }));
  subscope.addData(name4, new DataScope(subscope, source4, source4, values4));
  subscope.addSignal("parent", null);
  op.params.subflow = {
    $subflow: subscope.parse(spec).toRuntime()
  };
}
function parseSubflow(spec, scope, input) {
  const op = scope.add(PreFacet2({
    pulse: input.pulse
  })), subscope = scope.fork();
  subscope.add(Sieve2());
  subscope.addSignal("parent", null);
  op.params.subflow = {
    $subflow: subscope.parse(spec).toRuntime()
  };
}
function parseTrigger(spec, scope, name4) {
  const remove3 = spec.remove, insert2 = spec.insert, toggle2 = spec.toggle, modify3 = spec.modify, values4 = spec.values, op = scope.add(operator());
  const update3 = "if(" + spec.trigger + ',modify("' + name4 + '",' + [insert2, remove3, toggle2, modify3, values4].map((_) => _ == null ? "null" : _).join(",") + "),0)";
  const expr2 = parser2(update3, scope);
  op.update = expr2.$expr;
  op.params = expr2.$params;
}
function parseMark(spec, scope) {
  const role = getRole(spec), group2 = spec.type === GroupMark, facet = spec.from && spec.from.facet, overlap = spec.overlap;
  let layout = spec.layout || role === ScopeRole2 || role === FrameRole2, ops2, op, store, enc, name4, layoutRef, boundRef;
  const nested = role === MarkRole || layout || facet;
  const input = parseData(spec.from, group2, scope);
  op = scope.add(DataJoin2({
    key: input.key || (spec.key ? fieldRef(spec.key) : void 0),
    pulse: input.pulse,
    clean: !group2
  }));
  const joinRef = ref(op);
  op = store = scope.add(Collect2({
    pulse: joinRef
  }));
  op = scope.add(Mark2({
    markdef: definition2(spec),
    interactive: interactive(spec.interactive, scope),
    clip: clip2(spec.clip, scope),
    context: {
      $context: true
    },
    groups: scope.lookup(),
    parent: scope.signals.parent ? scope.signalRef("parent") : null,
    index: scope.markpath(),
    pulse: ref(op)
  }));
  const markRef = ref(op);
  op = enc = scope.add(Encode2(parseEncode(spec.encode, spec.type, role, spec.style, scope, {
    mod: false,
    pulse: markRef
  })));
  op.params.parent = scope.encode();
  if (spec.transform) {
    spec.transform.forEach((_) => {
      const tx = parseTransform(_, scope), md2 = tx.metadata;
      if (md2.generates || md2.changes) {
        error("Mark transforms should not generate new data.");
      }
      if (!md2.nomod)
        enc.params.mod = true;
      tx.params.pulse = ref(op);
      scope.add(op = tx);
    });
  }
  if (spec.sort) {
    op = scope.add(SortItems2({
      sort: scope.compareRef(spec.sort),
      pulse: ref(op)
    }));
  }
  const encodeRef = ref(op);
  if (facet || layout) {
    layout = scope.add(ViewLayout2({
      layout: scope.objectProperty(spec.layout),
      legends: scope.legends,
      mark: markRef,
      pulse: encodeRef
    }));
    layoutRef = ref(layout);
  }
  const bound2 = scope.add(Bound2({
    mark: markRef,
    pulse: layoutRef || encodeRef
  }));
  boundRef = ref(bound2);
  if (group2) {
    if (nested) {
      ops2 = scope.operators;
      ops2.pop();
      if (layout)
        ops2.pop();
    }
    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);
    facet ? parseFacet(spec, scope, input) : nested ? parseSubflow(spec, scope, input) : scope.parse(spec);
    scope.popState();
    if (nested) {
      if (layout)
        ops2.push(layout);
      ops2.push(bound2);
    }
  }
  if (overlap) {
    boundRef = parseOverlap(overlap, boundRef, scope);
  }
  const render4 = scope.add(Render2({
    pulse: boundRef
  })), sieve = scope.add(Sieve2({
    pulse: ref(render4)
  }, void 0, scope.parent()));
  if (spec.name != null) {
    name4 = spec.name;
    scope.addData(name4, new DataScope(scope, store, render4, sieve));
    if (spec.on)
      spec.on.forEach((on2) => {
        if (on2.insert || on2.remove || on2.toggle) {
          error("Marks only support modify triggers.");
        }
        parseTrigger(on2, scope, name4);
      });
  }
}
function parseOverlap(overlap, source4, scope) {
  const method2 = overlap.method, bound2 = overlap.bound, sep = overlap.separation;
  const params2 = {
    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,
    method: isSignal(method2) ? scope.signalRef(method2.signal) : method2,
    pulse: source4
  };
  if (overlap.order) {
    params2.sort = scope.compareRef({
      field: overlap.order
    });
  }
  if (bound2) {
    const tol = bound2.tolerance;
    params2.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;
    params2.boundScale = scope.scaleRef(bound2.scale);
    params2.boundOrient = bound2.orient;
  }
  return ref(scope.add(Overlap2(params2)));
}
function parseLegend(spec, scope) {
  const config = scope.config.legend, encode15 = spec.encode || {}, _ = lookup5(spec, config), legendEncode = encode15.legend || {}, name4 = legendEncode.name || void 0, interactive2 = legendEncode.interactive, style2 = legendEncode.style, scales2 = {};
  let scale7 = 0, entryLayout, params2, children4;
  LegendScales.forEach((s) => spec[s] ? (scales2[s] = spec[s], scale7 = scale7 || spec[s]) : 0);
  if (!scale7)
    error("Missing valid scale for legend.");
  const type2 = legendType(spec, scope.scaleType(scale7));
  const datum3 = {
    title: spec.title != null,
    scales: scales2,
    type: type2,
    vgrad: type2 !== "symbol" && _.isVertical()
  };
  const dataRef = ref(scope.add(Collect2(null, [datum3])));
  const entryEncode = {
    enter: {
      x: {
        value: 0
      },
      y: {
        value: 0
      }
    }
  };
  const entryRef = ref(scope.add(LegendEntries2(params2 = {
    type: type2,
    scale: scope.scaleRef(scale7),
    count: scope.objectProperty(_("tickCount")),
    limit: scope.property(_("symbolLimit")),
    values: scope.objectProperty(spec.values),
    minstep: scope.property(spec.tickMinStep),
    formatType: scope.property(spec.formatType),
    formatSpecifier: scope.property(spec.format)
  })));
  if (type2 === Gradient2) {
    children4 = [legendGradient(spec, scale7, config, encode15.gradient), legendGradientLabels(spec, config, encode15.labels, entryRef)];
    params2.count = params2.count || scope.signalRef("max(2,2*floor((".concat(deref(_.gradientLength()), ")/100))"));
  } else if (type2 === Discrete2) {
    children4 = [legendGradientDiscrete(spec, scale7, config, encode15.gradient, entryRef), legendGradientLabels(spec, config, encode15.labels, entryRef)];
  } else {
    entryLayout = legendSymbolLayout(spec, config);
    children4 = [legendSymbolGroups(spec, config, encode15, entryRef, deref(entryLayout.columns))];
    params2.size = sizeExpression(spec, scope, children4[0].marks);
  }
  children4 = [guideGroup({
    role: LegendEntryRole,
    from: dataRef,
    encode: entryEncode,
    marks: children4,
    layout: entryLayout,
    interactive: interactive2
  })];
  if (datum3.title) {
    children4.push(legendTitle(spec, config, encode15.title, dataRef));
  }
  return parseMark(guideGroup({
    role: LegendRole2,
    from: dataRef,
    encode: extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip3),
    marks: children4,
    aria: _("aria"),
    description: _("description"),
    zindex: _("zindex"),
    name: name4,
    interactive: interactive2,
    style: style2
  }), scope);
}
function legendType(spec, scaleType2) {
  let type2 = spec.type || Symbols2;
  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {
    type2 = isContinuous(scaleType2) ? Gradient2 : isDiscretizing(scaleType2) ? Discrete2 : Symbols2;
  }
  return type2 !== Gradient2 ? type2 : isDiscretizing(scaleType2) ? Discrete2 : Gradient2;
}
function scaleCount(spec) {
  return LegendScales.reduce((count2, type2) => count2 + (spec[type2] ? 1 : 0), 0);
}
function buildLegendEncode(_, spec, config) {
  const encode15 = {
    enter: {},
    update: {}
  };
  addEncoders(encode15, {
    orient: _("orient"),
    offset: _("offset"),
    padding: _("padding"),
    titlePadding: _("titlePadding"),
    cornerRadius: _("cornerRadius"),
    fill: _("fillColor"),
    stroke: _("strokeColor"),
    strokeWidth: config.strokeWidth,
    strokeDash: config.strokeDash,
    x: _("legendX"),
    y: _("legendY"),
    format: spec.format,
    formatType: spec.formatType
  });
  return encode15;
}
function sizeExpression(spec, scope, marks) {
  const size = deref(getChannel("size", spec, marks)), strokeWidth = deref(getChannel("strokeWidth", spec, marks)), fontSize2 = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));
  return parser2("max(ceil(sqrt(".concat(size, ")+").concat(strokeWidth, "),").concat(fontSize2, ")"), scope);
}
function getChannel(name4, spec, marks) {
  return spec[name4] ? 'scale("'.concat(spec[name4], '",datum)') : getEncoding(name4, marks[0].encode);
}
function getFontSize(encode15, scope, style2) {
  return getEncoding("fontSize", encode15) || getStyle("fontSize", scope, style2);
}
var angleExpr = 'item.orient==="'.concat(Left2, '"?-90:item.orient==="').concat(Right2, '"?90:0');
function parseTitle(spec, scope) {
  spec = isString(spec) ? {
    text: spec
  } : spec;
  const _ = lookup5(spec, scope.config.title), encode15 = spec.encode || {}, userEncode = encode15.group || {}, name4 = userEncode.name || void 0, interactive2 = userEncode.interactive, style2 = userEncode.style, children4 = [];
  const datum3 = {}, dataRef = ref(scope.add(Collect2(null, [datum3])));
  children4.push(buildTitle(spec, _, titleEncode(spec), dataRef));
  if (spec.subtitle) {
    children4.push(buildSubTitle(spec, _, encode15.subtitle, dataRef));
  }
  return parseMark(guideGroup({
    role: TitleRole2,
    from: dataRef,
    encode: groupEncode(_, userEncode),
    marks: children4,
    aria: _("aria"),
    description: _("description"),
    zindex: _("zindex"),
    name: name4,
    interactive: interactive2,
    style: style2
  }), scope);
}
function titleEncode(spec) {
  const encode15 = spec.encode;
  return encode15 && encode15.title || extend({
    name: spec.name,
    interactive: spec.interactive,
    style: spec.style
  }, encode15);
}
function groupEncode(_, userEncode) {
  const encode15 = {
    enter: {},
    update: {}
  };
  addEncoders(encode15, {
    orient: _("orient"),
    anchor: _("anchor"),
    align: {
      signal: alignExpr
    },
    angle: {
      signal: angleExpr
    },
    limit: _("limit"),
    frame: _("frame"),
    offset: _("offset") || 0,
    padding: _("subtitlePadding")
  });
  return extendEncode(encode15, userEncode, Skip3);
}
function buildTitle(spec, _, userEncode, dataRef) {
  const zero7 = {
    value: 0
  }, text4 = spec.text, encode15 = {
    enter: {
      opacity: zero7
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: zero7
    }
  };
  addEncoders(encode15, {
    text: text4,
    align: {
      signal: "item.mark.group.align"
    },
    angle: {
      signal: "item.mark.group.angle"
    },
    limit: {
      signal: "item.mark.group.limit"
    },
    baseline: "top",
    dx: _("dx"),
    dy: _("dy"),
    fill: _("color"),
    font: _("font"),
    fontSize: _("fontSize"),
    fontStyle: _("fontStyle"),
    fontWeight: _("fontWeight"),
    lineHeight: _("lineHeight")
  }, {
    align: _("align"),
    angle: _("angle"),
    baseline: _("baseline")
  });
  return guideMark({
    type: TextMark,
    role: TitleTextRole,
    style: GroupTitleStyle,
    from: dataRef,
    encode: encode15
  }, userEncode);
}
function buildSubTitle(spec, _, userEncode, dataRef) {
  const zero7 = {
    value: 0
  }, text4 = spec.subtitle, encode15 = {
    enter: {
      opacity: zero7
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: zero7
    }
  };
  addEncoders(encode15, {
    text: text4,
    align: {
      signal: "item.mark.group.align"
    },
    angle: {
      signal: "item.mark.group.angle"
    },
    limit: {
      signal: "item.mark.group.limit"
    },
    baseline: "top",
    dx: _("dx"),
    dy: _("dy"),
    fill: _("subtitleColor"),
    font: _("subtitleFont"),
    fontSize: _("subtitleFontSize"),
    fontStyle: _("subtitleFontStyle"),
    fontWeight: _("subtitleFontWeight"),
    lineHeight: _("subtitleLineHeight")
  }, {
    align: _("align"),
    angle: _("angle"),
    baseline: _("baseline")
  });
  return guideMark({
    type: TextMark,
    role: TitleSubtitleRole,
    style: GroupSubtitleStyle,
    from: dataRef,
    encode: encode15
  }, userEncode);
}
function parseData$1(data4, scope) {
  const transforms2 = [];
  if (data4.transform) {
    data4.transform.forEach((tx) => {
      transforms2.push(parseTransform(tx, scope));
    });
  }
  if (data4.on) {
    data4.on.forEach((on2) => {
      parseTrigger(on2, scope, data4.name);
    });
  }
  scope.addDataPipeline(data4.name, analyze(data4, scope, transforms2));
}
function analyze(data4, scope, ops2) {
  const output3 = [];
  let source4 = null, modify3 = false, generate3 = false, upstream, i, n, t, m2;
  if (data4.values) {
    if (isSignal(data4.values) || hasSignal(data4.format)) {
      output3.push(load2(scope, data4));
      output3.push(source4 = collect());
    } else {
      output3.push(source4 = collect({
        $ingest: data4.values,
        $format: data4.format
      }));
    }
  } else if (data4.url) {
    if (hasSignal(data4.url) || hasSignal(data4.format)) {
      output3.push(load2(scope, data4));
      output3.push(source4 = collect());
    } else {
      output3.push(source4 = collect({
        $request: data4.url,
        $format: data4.format
      }));
    }
  } else if (data4.source) {
    source4 = upstream = array(data4.source).map((d) => ref(scope.getData(d).output));
    output3.push(null);
  }
  for (i = 0, n = ops2.length; i < n; ++i) {
    t = ops2[i];
    m2 = t.metadata;
    if (!source4 && !m2.source) {
      output3.push(source4 = collect());
    }
    output3.push(t);
    if (m2.generates)
      generate3 = true;
    if (m2.modifies && !generate3)
      modify3 = true;
    if (m2.source)
      source4 = t;
    else if (m2.changes)
      source4 = null;
  }
  if (upstream) {
    n = upstream.length - 1;
    output3[0] = Relay2({
      derive: modify3,
      pulse: n ? upstream : upstream[0]
    });
    if (modify3 || n) {
      output3.splice(1, 0, collect());
    }
  }
  if (!source4)
    output3.push(collect());
  output3.push(Sieve2({}));
  return output3;
}
function collect(values4) {
  const s = Collect2({}, values4);
  s.metadata = {
    source: true
  };
  return s;
}
function load2(scope, data4) {
  return Load2({
    url: data4.url ? scope.property(data4.url) : void 0,
    async: data4.async ? scope.property(data4.async) : void 0,
    values: data4.values ? scope.property(data4.values) : void 0,
    format: scope.objectProperty(data4.format)
  });
}
var isX = (orient3) => orient3 === Bottom2 || orient3 === Top2;
var getSign = (orient3, a2, b2) => isSignal(orient3) ? ifLeftTopExpr(orient3.signal, a2, b2) : orient3 === Left2 || orient3 === Top2 ? a2 : b2;
var ifX = (orient3, a2, b2) => isSignal(orient3) ? ifXEnc(orient3.signal, a2, b2) : isX(orient3) ? a2 : b2;
var ifY = (orient3, a2, b2) => isSignal(orient3) ? ifYEnc(orient3.signal, a2, b2) : isX(orient3) ? b2 : a2;
var ifTop = (orient3, a2, b2) => isSignal(orient3) ? ifTopExpr(orient3.signal, a2, b2) : orient3 === Top2 ? {
  value: a2
} : {
  value: b2
};
var ifRight = (orient3, a2, b2) => isSignal(orient3) ? ifRightExpr(orient3.signal, a2, b2) : orient3 === Right2 ? {
  value: a2
} : {
  value: b2
};
var ifXEnc = ($orient, a2, b2) => ifEnc("".concat($orient, " === '").concat(Top2, "' || ").concat($orient, " === '").concat(Bottom2, "'"), a2, b2);
var ifYEnc = ($orient, a2, b2) => ifEnc("".concat($orient, " !== '").concat(Top2, "' && ").concat($orient, " !== '").concat(Bottom2, "'"), a2, b2);
var ifLeftTopExpr = ($orient, a2, b2) => ifExpr("".concat($orient, " === '").concat(Left2, "' || ").concat($orient, " === '").concat(Top2, "'"), a2, b2);
var ifTopExpr = ($orient, a2, b2) => ifExpr("".concat($orient, " === '").concat(Top2, "'"), a2, b2);
var ifRightExpr = ($orient, a2, b2) => ifExpr("".concat($orient, " === '").concat(Right2, "'"), a2, b2);
var ifEnc = (test2, a2, b2) => {
  a2 = a2 != null ? encoder(a2) : a2;
  b2 = b2 != null ? encoder(b2) : b2;
  if (isSimple(a2) && isSimple(b2)) {
    a2 = a2 ? a2.signal || $(a2.value) : null;
    b2 = b2 ? b2.signal || $(b2.value) : null;
    return {
      signal: "".concat(test2, " ? (").concat(a2, ") : (").concat(b2, ")")
    };
  } else {
    return [extend({
      test: test2
    }, a2)].concat(b2 || []);
  }
};
var isSimple = (enc) => enc == null || Object.keys(enc).length === 1;
var ifExpr = (test2, a2, b2) => ({
  signal: "".concat(test2, " ? (").concat(toExpr(a2), ") : (").concat(toExpr(b2), ")")
});
var ifOrient = ($orient, t, b2, l, r2) => ({
  signal: (l != null ? "".concat($orient, " === '").concat(Left2, "' ? (").concat(toExpr(l), ") : ") : "") + (b2 != null ? "".concat($orient, " === '").concat(Bottom2, "' ? (").concat(toExpr(b2), ") : ") : "") + (r2 != null ? "".concat($orient, " === '").concat(Right2, "' ? (").concat(toExpr(r2), ") : ") : "") + (t != null ? "".concat($orient, " === '").concat(Top2, "' ? (").concat(toExpr(t), ") : ") : "") + "(null)"
});
var toExpr = (v) => isSignal(v) ? v.signal : v == null ? null : $(v);
var mult = (sign3, value3) => value3 === 0 ? 0 : isSignal(sign3) ? {
  signal: "(".concat(sign3.signal, ") * ").concat(value3)
} : {
  value: sign3 * value3
};
var patch = (value3, base2) => {
  const s = value3.signal;
  return s && s.endsWith("(null)") ? {
    signal: s.slice(0, -6) + base2.signal
  } : value3;
};
function fallback(prop, config, axisConfig2, style2) {
  let styleProp;
  if (config && has(config, prop)) {
    return config[prop];
  } else if (has(axisConfig2, prop)) {
    return axisConfig2[prop];
  } else if (prop.startsWith("title")) {
    switch (prop) {
      case "titleColor":
        styleProp = "fill";
        break;
      case "titleFont":
      case "titleFontSize":
      case "titleFontWeight":
        styleProp = prop[5].toLowerCase() + prop.slice(6);
    }
    return style2[GuideTitleStyle][styleProp];
  } else if (prop.startsWith("label")) {
    switch (prop) {
      case "labelColor":
        styleProp = "fill";
        break;
      case "labelFont":
      case "labelFontSize":
        styleProp = prop[5].toLowerCase() + prop.slice(6);
    }
    return style2[GuideLabelStyle][styleProp];
  }
  return null;
}
function keys2(objects) {
  const map4 = {};
  for (const obj of objects) {
    if (!obj)
      continue;
    for (const key2 in obj)
      map4[key2] = 1;
  }
  return Object.keys(map4);
}
function axisConfig(spec, scope) {
  var config = scope.config, style2 = config.style, axis = config.axis, band2 = scope.scaleType(spec.scale) === "band" && config.axisBand, orient3 = spec.orient, xy, or2, key2;
  if (isSignal(orient3)) {
    const xyKeys = keys2([config.axisX, config.axisY]), orientKeys = keys2([config.axisTop, config.axisBottom, config.axisLeft, config.axisRight]);
    xy = {};
    for (key2 of xyKeys) {
      xy[key2] = ifX(orient3, fallback(key2, config.axisX, axis, style2), fallback(key2, config.axisY, axis, style2));
    }
    or2 = {};
    for (key2 of orientKeys) {
      or2[key2] = ifOrient(orient3.signal, fallback(key2, config.axisTop, axis, style2), fallback(key2, config.axisBottom, axis, style2), fallback(key2, config.axisLeft, axis, style2), fallback(key2, config.axisRight, axis, style2));
    }
  } else {
    xy = orient3 === Top2 || orient3 === Bottom2 ? config.axisX : config.axisY;
    or2 = config["axis" + orient3[0].toUpperCase() + orient3.slice(1)];
  }
  const result = xy || or2 || band2 ? extend({}, axis, xy, or2, band2) : axis;
  return result;
}
function axisDomain(spec, config, userEncode, dataRef) {
  const _ = lookup5(spec, config), orient3 = spec.orient;
  let enter, update3;
  const encode15 = {
    enter: enter = {
      opacity: zero3
    },
    update: update3 = {
      opacity: one3
    },
    exit: {
      opacity: zero3
    }
  };
  addEncoders(encode15, {
    stroke: _("domainColor"),
    strokeCap: _("domainCap"),
    strokeDash: _("domainDash"),
    strokeDashOffset: _("domainDashOffset"),
    strokeWidth: _("domainWidth"),
    strokeOpacity: _("domainOpacity")
  });
  const pos0 = position(spec, 0);
  const pos1 = position(spec, 1);
  enter.x = update3.x = ifX(orient3, pos0, zero3);
  enter.x2 = update3.x2 = ifX(orient3, pos1);
  enter.y = update3.y = ifY(orient3, pos0, zero3);
  enter.y2 = update3.y2 = ifY(orient3, pos1);
  return guideMark({
    type: RuleMark,
    role: AxisDomainRole,
    from: dataRef,
    encode: encode15
  }, userEncode);
}
function position(spec, pos) {
  return {
    scale: spec.scale,
    range: pos
  };
}
function axisGrid(spec, config, userEncode, dataRef, band2) {
  const _ = lookup5(spec, config), orient3 = spec.orient, vscale = spec.gridScale, sign3 = getSign(orient3, 1, -1), offset4 = offsetValue2(spec.offset, sign3);
  let enter, exit, update3;
  const encode15 = {
    enter: enter = {
      opacity: zero3
    },
    update: update3 = {
      opacity: one3
    },
    exit: exit = {
      opacity: zero3
    }
  };
  addEncoders(encode15, {
    stroke: _("gridColor"),
    strokeCap: _("gridCap"),
    strokeDash: _("gridDash"),
    strokeDashOffset: _("gridDashOffset"),
    strokeOpacity: _("gridOpacity"),
    strokeWidth: _("gridWidth")
  });
  const tickPos = {
    scale: spec.scale,
    field: Value,
    band: band2.band,
    extra: band2.extra,
    offset: band2.offset,
    round: _("tickRound")
  };
  const sz2 = ifX(orient3, {
    signal: "height"
  }, {
    signal: "width"
  });
  const gridStart = vscale ? {
    scale: vscale,
    range: 0,
    mult: sign3,
    offset: offset4
  } : {
    value: 0,
    offset: offset4
  };
  const gridEnd = vscale ? {
    scale: vscale,
    range: 1,
    mult: sign3,
    offset: offset4
  } : extend(sz2, {
    mult: sign3,
    offset: offset4
  });
  enter.x = update3.x = ifX(orient3, tickPos, gridStart);
  enter.y = update3.y = ifY(orient3, tickPos, gridStart);
  enter.x2 = update3.x2 = ifY(orient3, gridEnd);
  enter.y2 = update3.y2 = ifX(orient3, gridEnd);
  exit.x = ifX(orient3, tickPos);
  exit.y = ifY(orient3, tickPos);
  return guideMark({
    type: RuleMark,
    role: AxisGridRole,
    key: Value,
    from: dataRef,
    encode: encode15
  }, userEncode);
}
function offsetValue2(offset4, sign3) {
  if (sign3 === 1)
    ;
  else if (!isObject(offset4)) {
    offset4 = isSignal(sign3) ? {
      signal: "(".concat(sign3.signal, ") * (").concat(offset4 || 0, ")")
    } : sign3 * (offset4 || 0);
  } else {
    let entry2 = offset4 = extend({}, offset4);
    while (entry2.mult != null) {
      if (!isObject(entry2.mult)) {
        entry2.mult = isSignal(sign3) ? {
          signal: "(".concat(entry2.mult, ") * (").concat(sign3.signal, ")")
        } : entry2.mult * sign3;
        return offset4;
      } else {
        entry2 = entry2.mult = extend({}, entry2.mult);
      }
    }
    entry2.mult = sign3;
  }
  return offset4;
}
function axisTicks(spec, config, userEncode, dataRef, size, band2) {
  const _ = lookup5(spec, config), orient3 = spec.orient, sign3 = getSign(orient3, -1, 1);
  let enter, exit, update3;
  const encode15 = {
    enter: enter = {
      opacity: zero3
    },
    update: update3 = {
      opacity: one3
    },
    exit: exit = {
      opacity: zero3
    }
  };
  addEncoders(encode15, {
    stroke: _("tickColor"),
    strokeCap: _("tickCap"),
    strokeDash: _("tickDash"),
    strokeDashOffset: _("tickDashOffset"),
    strokeOpacity: _("tickOpacity"),
    strokeWidth: _("tickWidth")
  });
  const tickSize = encoder(size);
  tickSize.mult = sign3;
  const tickPos = {
    scale: spec.scale,
    field: Value,
    band: band2.band,
    extra: band2.extra,
    offset: band2.offset,
    round: _("tickRound")
  };
  update3.y = enter.y = ifX(orient3, zero3, tickPos);
  update3.y2 = enter.y2 = ifX(orient3, tickSize);
  exit.x = ifX(orient3, tickPos);
  update3.x = enter.x = ifY(orient3, zero3, tickPos);
  update3.x2 = enter.x2 = ifY(orient3, tickSize);
  exit.y = ifY(orient3, tickPos);
  return guideMark({
    type: RuleMark,
    role: AxisTickRole,
    key: Value,
    from: dataRef,
    encode: encode15
  }, userEncode);
}
function flushExpr(scale7, threshold2, a2, b2, c2) {
  return {
    signal: 'flush(range("' + scale7 + '"), scale("' + scale7 + '", datum.value), ' + threshold2 + "," + a2 + "," + b2 + "," + c2 + ")"
  };
}
function axisLabels(spec, config, userEncode, dataRef, size, band2) {
  const _ = lookup5(spec, config), orient3 = spec.orient, scale7 = spec.scale, sign3 = getSign(orient3, -1, 1), flush2 = deref(_("labelFlush")), flushOffset = deref(_("labelFlushOffset")), labelAlign = _("labelAlign"), labelBaseline = _("labelBaseline");
  let flushOn = flush2 === 0 || !!flush2, update3;
  const tickSize = encoder(size);
  tickSize.mult = sign3;
  tickSize.offset = encoder(_("labelPadding") || 0);
  tickSize.offset.mult = sign3;
  const tickPos = {
    scale: scale7,
    field: Value,
    band: 0.5,
    offset: extendOffset(band2.offset, _("labelOffset"))
  };
  const align2 = ifX(orient3, flushOn ? flushExpr(scale7, flush2, '"left"', '"right"', '"center"') : {
    value: "center"
  }, ifRight(orient3, "left", "right"));
  const baseline3 = ifX(orient3, ifTop(orient3, "bottom", "top"), flushOn ? flushExpr(scale7, flush2, '"top"', '"bottom"', '"middle"') : {
    value: "middle"
  });
  const offsetExpr = flushExpr(scale7, flush2, "-(".concat(flushOffset, ")"), flushOffset, 0);
  flushOn = flushOn && flushOffset;
  const enter = {
    opacity: zero3,
    x: ifX(orient3, tickPos, tickSize),
    y: ifY(orient3, tickPos, tickSize)
  };
  const encode15 = {
    enter,
    update: update3 = {
      opacity: one3,
      text: {
        field: Label2
      },
      x: enter.x,
      y: enter.y,
      align: align2,
      baseline: baseline3
    },
    exit: {
      opacity: zero3,
      x: enter.x,
      y: enter.y
    }
  };
  addEncoders(encode15, {
    dx: !labelAlign && flushOn ? ifX(orient3, offsetExpr) : null,
    dy: !labelBaseline && flushOn ? ifY(orient3, offsetExpr) : null
  });
  addEncoders(encode15, {
    angle: _("labelAngle"),
    fill: _("labelColor"),
    fillOpacity: _("labelOpacity"),
    font: _("labelFont"),
    fontSize: _("labelFontSize"),
    fontWeight: _("labelFontWeight"),
    fontStyle: _("labelFontStyle"),
    limit: _("labelLimit"),
    lineHeight: _("labelLineHeight")
  }, {
    align: labelAlign,
    baseline: labelBaseline
  });
  const bound2 = _("labelBound");
  let overlap = _("labelOverlap");
  overlap = overlap || bound2 ? {
    separation: _("labelSeparation"),
    method: overlap,
    order: "datum.index",
    bound: bound2 ? {
      scale: scale7,
      orient: orient3,
      tolerance: bound2
    } : null
  } : void 0;
  if (update3.align !== align2) {
    update3.align = patch(update3.align, align2);
  }
  if (update3.baseline !== baseline3) {
    update3.baseline = patch(update3.baseline, baseline3);
  }
  return guideMark({
    type: TextMark,
    role: AxisLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: dataRef,
    encode: encode15,
    overlap
  }, userEncode);
}
function axisTitle(spec, config, userEncode, dataRef) {
  const _ = lookup5(spec, config), orient3 = spec.orient, sign3 = getSign(orient3, -1, 1);
  let enter, update3;
  const encode15 = {
    enter: enter = {
      opacity: zero3,
      anchor: encoder(_("titleAnchor", null)),
      align: {
        signal: alignExpr
      }
    },
    update: update3 = extend({}, enter, {
      opacity: one3,
      text: encoder(spec.title)
    }),
    exit: {
      opacity: zero3
    }
  };
  const titlePos = {
    signal: 'lerp(range("'.concat(spec.scale, '"), ').concat(anchorExpr(0, 1, 0.5), ")")
  };
  update3.x = ifX(orient3, titlePos);
  update3.y = ifY(orient3, titlePos);
  enter.angle = ifX(orient3, zero3, mult(sign3, 90));
  enter.baseline = ifX(orient3, ifTop(orient3, Bottom2, Top2), {
    value: Bottom2
  });
  update3.angle = enter.angle;
  update3.baseline = enter.baseline;
  addEncoders(encode15, {
    fill: _("titleColor"),
    fillOpacity: _("titleOpacity"),
    font: _("titleFont"),
    fontSize: _("titleFontSize"),
    fontStyle: _("titleFontStyle"),
    fontWeight: _("titleFontWeight"),
    limit: _("titleLimit"),
    lineHeight: _("titleLineHeight")
  }, {
    align: _("titleAlign"),
    angle: _("titleAngle"),
    baseline: _("titleBaseline")
  });
  autoLayout(_, orient3, encode15, userEncode);
  encode15.update.align = patch(encode15.update.align, enter.align);
  encode15.update.angle = patch(encode15.update.angle, enter.angle);
  encode15.update.baseline = patch(encode15.update.baseline, enter.baseline);
  return guideMark({
    type: TextMark,
    role: AxisTitleRole,
    style: GuideTitleStyle,
    from: dataRef,
    encode: encode15
  }, userEncode);
}
function autoLayout(_, orient3, encode15, userEncode) {
  const auto = (value3, dim) => value3 != null ? (encode15.update[dim] = patch(encoder(value3), encode15.update[dim]), false) : !has2(dim, userEncode) ? true : false;
  const autoY = auto(_("titleX"), "x"), autoX = auto(_("titleY"), "y");
  encode15.enter.auto = autoX === autoY ? encoder(autoX) : ifX(orient3, encoder(autoX), encoder(autoY));
}
function parseAxis(spec, scope) {
  const config = axisConfig(spec, scope), encode15 = spec.encode || {}, axisEncode = encode15.axis || {}, name4 = axisEncode.name || void 0, interactive2 = axisEncode.interactive, style2 = axisEncode.style, _ = lookup5(spec, config), band2 = tickBand(_);
  const datum3 = {
    scale: spec.scale,
    ticks: !!_("ticks"),
    labels: !!_("labels"),
    grid: !!_("grid"),
    domain: !!_("domain"),
    title: spec.title != null
  };
  const dataRef = ref(scope.add(Collect2({}, [datum3])));
  const ticksRef = ref(scope.add(AxisTicks2({
    scale: scope.scaleRef(spec.scale),
    extra: scope.property(band2.extra),
    count: scope.objectProperty(spec.tickCount),
    values: scope.objectProperty(spec.values),
    minstep: scope.property(spec.tickMinStep),
    formatType: scope.property(spec.formatType),
    formatSpecifier: scope.property(spec.format)
  })));
  const children4 = [];
  let size;
  if (datum3.grid) {
    children4.push(axisGrid(spec, config, encode15.grid, ticksRef, band2));
  }
  if (datum3.ticks) {
    size = _("tickSize");
    children4.push(axisTicks(spec, config, encode15.ticks, ticksRef, size, band2));
  }
  if (datum3.labels) {
    size = datum3.ticks ? size : 0;
    children4.push(axisLabels(spec, config, encode15.labels, ticksRef, size, band2));
  }
  if (datum3.domain) {
    children4.push(axisDomain(spec, config, encode15.domain, dataRef));
  }
  if (datum3.title) {
    children4.push(axisTitle(spec, config, encode15.title, dataRef));
  }
  return parseMark(guideGroup({
    role: AxisRole2,
    from: dataRef,
    encode: extendEncode(buildAxisEncode(_, spec), axisEncode, Skip3),
    marks: children4,
    aria: _("aria"),
    description: _("description"),
    zindex: _("zindex"),
    name: name4,
    interactive: interactive2,
    style: style2
  }), scope);
}
function buildAxisEncode(_, spec) {
  const encode15 = {
    enter: {},
    update: {}
  };
  addEncoders(encode15, {
    orient: _("orient"),
    offset: _("offset") || 0,
    position: value2(spec.position, 0),
    titlePadding: _("titlePadding"),
    minExtent: _("minExtent"),
    maxExtent: _("maxExtent"),
    range: {
      signal: 'abs(span(range("'.concat(spec.scale, '")))')
    },
    translate: _("translate"),
    format: spec.format,
    formatType: spec.formatType
  });
  return encode15;
}
function parseScope(spec, scope, preprocessed) {
  const signals = array(spec.signals), scales2 = array(spec.scales);
  if (!preprocessed)
    signals.forEach((_) => parseSignal(_, scope));
  array(spec.projections).forEach((_) => parseProjection(_, scope));
  scales2.forEach((_) => initScale(_, scope));
  array(spec.data).forEach((_) => parseData$1(_, scope));
  scales2.forEach((_) => parseScale(_, scope));
  (preprocessed || signals).forEach((_) => parseSignalUpdates(_, scope));
  array(spec.axes).forEach((_) => parseAxis(_, scope));
  array(spec.marks).forEach((_) => parseMark(_, scope));
  array(spec.legends).forEach((_) => parseLegend(_, scope));
  if (spec.title)
    parseTitle(spec.title, scope);
  scope.parseLambdas();
  return scope;
}
var rootEncode = (spec) => extendEncode({
  enter: {
    x: {
      value: 0
    },
    y: {
      value: 0
    }
  },
  update: {
    width: {
      signal: "width"
    },
    height: {
      signal: "height"
    }
  }
}, spec);
function parseView(spec, scope) {
  const config = scope.config;
  const root2 = ref(scope.root = scope.add(operator()));
  const signals = collectSignals(spec, config);
  signals.forEach((_) => parseSignal(_, scope));
  scope.description = spec.description || config.description;
  scope.eventConfig = config.events;
  scope.legends = scope.objectProperty(config.legend && config.legend.layout);
  scope.locale = config.locale;
  const input = scope.add(Collect2());
  const encode15 = scope.add(Encode2(parseEncode(rootEncode(spec.encode), GroupMark, FrameRole2, spec.style, scope, {
    pulse: ref(input)
  })));
  const parent = scope.add(ViewLayout2({
    layout: scope.objectProperty(spec.layout),
    legends: scope.legends,
    autosize: scope.signalRef("autosize"),
    mark: root2,
    pulse: ref(encode15)
  }));
  scope.operators.pop();
  scope.pushState(ref(encode15), ref(parent), null);
  parseScope(spec, scope, signals);
  scope.operators.push(parent);
  let op = scope.add(Bound2({
    mark: root2,
    pulse: ref(parent)
  }));
  op = scope.add(Render2({
    pulse: ref(op)
  }));
  op = scope.add(Sieve2({
    pulse: ref(op)
  }));
  scope.addData("root", new DataScope(scope, input, input, op));
  return scope;
}
function signalObject(name4, value3) {
  return value3 && value3.signal ? {
    name: name4,
    update: value3.signal
  } : {
    name: name4,
    value: value3
  };
}
function collectSignals(spec, config) {
  const _ = (name4) => value2(spec[name4], config[name4]), signals = [signalObject("background", _("background")), signalObject("autosize", parseAutosize(_("autosize"))), signalObject("padding", parsePadding(_("padding"))), signalObject("width", _("width") || 0), signalObject("height", _("height") || 0)], pre = signals.reduce((p, s) => (p[s.name] = s, p), {}), map4 = {};
  array(spec.signals).forEach((s) => {
    if (has(pre, s.name)) {
      s = extend(pre[s.name], s);
    } else {
      signals.push(s);
    }
    map4[s.name] = s;
  });
  array(config.signals).forEach((s) => {
    if (!has(map4, s.name) && !has(pre, s.name)) {
      signals.push(s);
    }
  });
  return signals;
}
function Scope$1(config, options2) {
  this.config = config || {};
  this.options = options2 || {};
  this.bindings = [];
  this.field = {};
  this.signals = {};
  this.lambdas = {};
  this.scales = {};
  this.events = {};
  this.data = {};
  this.streams = [];
  this.updates = [];
  this.operators = [];
  this.eventConfig = null;
  this.locale = null;
  this._id = 0;
  this._subid = 0;
  this._nextsub = [0];
  this._parent = [];
  this._encode = [];
  this._lookup = [];
  this._markpath = [];
}
function Subscope(scope) {
  this.config = scope.config;
  this.options = scope.options;
  this.legends = scope.legends;
  this.field = Object.create(scope.field);
  this.signals = Object.create(scope.signals);
  this.lambdas = Object.create(scope.lambdas);
  this.scales = Object.create(scope.scales);
  this.events = Object.create(scope.events);
  this.data = Object.create(scope.data);
  this.streams = [];
  this.updates = [];
  this.operators = [];
  this._id = 0;
  this._subid = ++scope._nextsub[0];
  this._nextsub = scope._nextsub;
  this._parent = scope._parent.slice();
  this._encode = scope._encode.slice();
  this._lookup = scope._lookup.slice();
  this._markpath = scope._markpath;
}
Scope$1.prototype = Subscope.prototype = {
  parse(spec) {
    return parseScope(spec, this);
  },
  fork() {
    return new Subscope(this);
  },
  isSubscope() {
    return this._subid > 0;
  },
  toRuntime() {
    this.finish();
    return {
      description: this.description,
      operators: this.operators,
      streams: this.streams,
      updates: this.updates,
      bindings: this.bindings,
      eventConfig: this.eventConfig,
      locale: this.locale
    };
  },
  id() {
    return (this._subid ? this._subid + ":" : 0) + this._id++;
  },
  add(op) {
    this.operators.push(op);
    op.id = this.id();
    if (op.refs) {
      op.refs.forEach((ref6) => {
        ref6.$ref = op.id;
      });
      op.refs = null;
    }
    return op;
  },
  proxy(op) {
    const vref = op instanceof Entry ? ref(op) : op;
    return this.add(Proxy2({
      value: vref
    }));
  },
  addStream(stream2) {
    this.streams.push(stream2);
    stream2.id = this.id();
    return stream2;
  },
  addUpdate(update3) {
    this.updates.push(update3);
    return update3;
  },
  finish() {
    let name4, ds;
    if (this.root)
      this.root.root = true;
    for (name4 in this.signals) {
      this.signals[name4].signal = name4;
    }
    for (name4 in this.scales) {
      this.scales[name4].scale = name4;
    }
    function annotate(op, name5, type2) {
      let data4, list;
      if (op) {
        data4 = op.data || (op.data = {});
        list = data4[name5] || (data4[name5] = []);
        list.push(type2);
      }
    }
    for (name4 in this.data) {
      ds = this.data[name4];
      annotate(ds.input, name4, "input");
      annotate(ds.output, name4, "output");
      annotate(ds.values, name4, "values");
      for (const field4 in ds.index) {
        annotate(ds.index[field4], name4, "index:" + field4);
      }
    }
    return this;
  },
  pushState(encode15, parent, lookup6) {
    this._encode.push(ref(this.add(Sieve2({
      pulse: encode15
    }))));
    this._parent.push(parent);
    this._lookup.push(lookup6 ? ref(this.proxy(lookup6)) : null);
    this._markpath.push(-1);
  },
  popState() {
    this._encode.pop();
    this._parent.pop();
    this._lookup.pop();
    this._markpath.pop();
  },
  parent() {
    return peek(this._parent);
  },
  encode() {
    return peek(this._encode);
  },
  lookup() {
    return peek(this._lookup);
  },
  markpath() {
    const p = this._markpath;
    return ++p[p.length - 1];
  },
  fieldRef(field4, name4) {
    if (isString(field4))
      return fieldRef(field4, name4);
    if (!field4.signal) {
      error("Unsupported field reference: " + $(field4));
    }
    const s = field4.signal;
    let f = this.field[s];
    if (!f) {
      const params2 = {
        name: this.signalRef(s)
      };
      if (name4)
        params2.as = name4;
      this.field[s] = f = ref(this.add(Field2(params2)));
    }
    return f;
  },
  compareRef(cmp) {
    let signal = false;
    const check = (_) => isSignal(_) ? (signal = true, this.signalRef(_.signal)) : isExpr(_) ? (signal = true, this.exprRef(_.expr)) : _;
    const fields = array(cmp.field).map(check), orders = array(cmp.order).map(check);
    return signal ? ref(this.add(Compare2({
      fields,
      orders
    }))) : compareRef(fields, orders);
  },
  keyRef(fields, flat) {
    let signal = false;
    const check = (_) => isSignal(_) ? (signal = true, ref(sig[_.signal])) : _;
    const sig = this.signals;
    fields = array(fields).map(check);
    return signal ? ref(this.add(Key2({
      fields,
      flat
    }))) : keyRef(fields, flat);
  },
  sortRef(sort2) {
    if (!sort2)
      return sort2;
    const a2 = aggrField(sort2.op, sort2.field), o = sort2.order || Ascending;
    return o.signal ? ref(this.add(Compare2({
      fields: a2,
      orders: this.signalRef(o.signal)
    }))) : compareRef(a2, o);
  },
  event(source4, type2) {
    const key2 = source4 + ":" + type2;
    if (!this.events[key2]) {
      const id4 = this.id();
      this.streams.push({
        id: id4,
        source: source4,
        type: type2
      });
      this.events[key2] = id4;
    }
    return this.events[key2];
  },
  hasOwnSignal(name4) {
    return has(this.signals, name4);
  },
  addSignal(name4, value3) {
    if (this.hasOwnSignal(name4)) {
      error("Duplicate signal name: " + $(name4));
    }
    const op = value3 instanceof Entry ? value3 : this.add(operator(value3));
    return this.signals[name4] = op;
  },
  getSignal(name4) {
    if (!this.signals[name4]) {
      error("Unrecognized signal name: " + $(name4));
    }
    return this.signals[name4];
  },
  signalRef(s) {
    if (this.signals[s]) {
      return ref(this.signals[s]);
    } else if (!has(this.lambdas, s)) {
      this.lambdas[s] = this.add(operator(null));
    }
    return ref(this.lambdas[s]);
  },
  parseLambdas() {
    const code = Object.keys(this.lambdas);
    for (let i = 0, n = code.length; i < n; ++i) {
      const s = code[i], e = parser2(s, this), op = this.lambdas[s];
      op.params = e.$params;
      op.update = e.$expr;
    }
  },
  property(spec) {
    return spec && spec.signal ? this.signalRef(spec.signal) : spec;
  },
  objectProperty(spec) {
    return !spec || !isObject(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));
  },
  exprRef(code, name4) {
    const params2 = {
      expr: parser2(code, this)
    };
    if (name4)
      params2.expr.$name = name4;
    return ref(this.add(Expression2(params2)));
  },
  addBinding(name4, bind3) {
    if (!this.bindings) {
      error("Nested signals do not support binding: " + $(name4));
    }
    this.bindings.push(extend({
      signal: name4
    }, bind3));
  },
  addScaleProj(name4, transform4) {
    if (has(this.scales, name4)) {
      error("Duplicate scale or projection name: " + $(name4));
    }
    this.scales[name4] = this.add(transform4);
  },
  addScale(name4, params2) {
    this.addScaleProj(name4, Scale2(params2));
  },
  addProjection(name4, params2) {
    this.addScaleProj(name4, Projection2(params2));
  },
  getScale(name4) {
    if (!this.scales[name4]) {
      error("Unrecognized scale name: " + $(name4));
    }
    return this.scales[name4];
  },
  scaleRef(name4) {
    return ref(this.getScale(name4));
  },
  scaleType(name4) {
    return this.getScale(name4).params.type;
  },
  projectionRef(name4) {
    return this.scaleRef(name4);
  },
  projectionType(name4) {
    return this.scaleType(name4);
  },
  addData(name4, dataScope) {
    if (has(this.data, name4)) {
      error("Duplicate data set name: " + $(name4));
    }
    return this.data[name4] = dataScope;
  },
  getData(name4) {
    if (!this.data[name4]) {
      error("Undefined data set name: " + $(name4));
    }
    return this.data[name4];
  },
  addDataPipeline(name4, entries3) {
    if (has(this.data, name4)) {
      error("Duplicate data set name: " + $(name4));
    }
    return this.addData(name4, DataScope.fromEntries(this, entries3));
  }
};
function propertyLambda(spec) {
  return (isArray(spec) ? arrayLambda : objectLambda)(spec);
}
function arrayLambda(array5) {
  const n = array5.length;
  let code = "[";
  for (let i = 0; i < n; ++i) {
    const value3 = array5[i];
    code += (i > 0 ? "," : "") + (isObject(value3) ? value3.signal || propertyLambda(value3) : $(value3));
  }
  return code + "]";
}
function objectLambda(obj) {
  let code = "{", i = 0, key2, value3;
  for (key2 in obj) {
    value3 = obj[key2];
    code += (++i > 1 ? "," : "") + $(key2) + ":" + (isObject(value3) ? value3.signal || propertyLambda(value3) : $(value3));
  }
  return code + "}";
}
function defaults() {
  const defaultFont2 = "sans-serif", defaultSymbolSize = 30, defaultStrokeWidth = 2, defaultColor = "#4c78a8", black = "#000", gray = "#888", lightGray = "#ddd";
  return {
    description: "Vega visualization",
    padding: 0,
    autosize: "pad",
    background: null,
    events: {
      defaults: {
        allow: ["wheel"]
      }
    },
    group: null,
    mark: null,
    arc: {
      fill: defaultColor
    },
    area: {
      fill: defaultColor
    },
    image: null,
    line: {
      stroke: defaultColor,
      strokeWidth: defaultStrokeWidth
    },
    path: {
      stroke: defaultColor
    },
    rect: {
      fill: defaultColor
    },
    rule: {
      stroke: black
    },
    shape: {
      stroke: defaultColor
    },
    symbol: {
      fill: defaultColor,
      size: 64
    },
    text: {
      fill: black,
      font: defaultFont2,
      fontSize: 11
    },
    trail: {
      fill: defaultColor,
      size: defaultStrokeWidth
    },
    style: {
      "guide-label": {
        fill: black,
        font: defaultFont2,
        fontSize: 10
      },
      "guide-title": {
        fill: black,
        font: defaultFont2,
        fontSize: 11,
        fontWeight: "bold"
      },
      "group-title": {
        fill: black,
        font: defaultFont2,
        fontSize: 13,
        fontWeight: "bold"
      },
      "group-subtitle": {
        fill: black,
        font: defaultFont2,
        fontSize: 12
      },
      point: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth,
        shape: "circle"
      },
      circle: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth
      },
      square: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth,
        shape: "square"
      },
      cell: {
        fill: "transparent",
        stroke: lightGray
      }
    },
    title: {
      orient: "top",
      anchor: "middle",
      offset: 4,
      subtitlePadding: 3
    },
    axis: {
      minExtent: 0,
      maxExtent: 200,
      bandPosition: 0.5,
      domain: true,
      domainWidth: 1,
      domainColor: gray,
      grid: false,
      gridWidth: 1,
      gridColor: lightGray,
      labels: true,
      labelAngle: 0,
      labelLimit: 180,
      labelOffset: 0,
      labelPadding: 2,
      ticks: true,
      tickColor: gray,
      tickOffset: 0,
      tickRound: true,
      tickSize: 5,
      tickWidth: 1,
      titlePadding: 4
    },
    axisBand: {
      tickOffset: -0.5
    },
    projection: {
      type: "mercator"
    },
    legend: {
      orient: "right",
      padding: 0,
      gridAlign: "each",
      columnPadding: 10,
      rowPadding: 2,
      symbolDirection: "vertical",
      gradientDirection: "vertical",
      gradientLength: 200,
      gradientThickness: 16,
      gradientStrokeColor: lightGray,
      gradientStrokeWidth: 0,
      gradientLabelOffset: 2,
      labelAlign: "left",
      labelBaseline: "middle",
      labelLimit: 160,
      labelOffset: 4,
      labelOverlap: true,
      symbolLimit: 30,
      symbolType: "circle",
      symbolSize: 100,
      symbolOffset: 0,
      symbolStrokeWidth: 1.5,
      symbolBaseFillColor: "transparent",
      symbolBaseStrokeColor: gray,
      titleLimit: 180,
      titleOrient: "top",
      titlePadding: 5,
      layout: {
        offset: 18,
        direction: "horizontal",
        left: {
          direction: "vertical"
        },
        right: {
          direction: "vertical"
        }
      }
    },
    range: {
      category: {
        scheme: "tableau10"
      },
      ordinal: {
        scheme: "blues"
      },
      heatmap: {
        scheme: "yellowgreenblue"
      },
      ramp: {
        scheme: "blues"
      },
      diverging: {
        scheme: "blueorange",
        extent: [1, 0]
      },
      symbol: ["circle", "square", "triangle-up", "cross", "diamond", "triangle-right", "triangle-down", "triangle-left"]
    }
  };
}
function parse$1(spec, config, options2) {
  if (!isObject(spec)) {
    error("Input Vega specification must be an object.");
  }
  config = mergeConfig(defaults(), config, spec.config);
  return parseView(spec, new Scope$1(config, options2)).toRuntime();
}

// node_modules/vega/build/vega.module.js
var version = "5.17.3";
extend(transforms, vega_transforms_module_exports, vega_view_transforms_module_exports, vega_encode_module_exports, vega_geo_module_exports, vega_force_module_exports, vega_label_module_exports, vega_hierarchy_module_exports, vega_regression_module_exports, vega_voronoi_module_exports, vega_wordcloud_module_exports, vega_crossfilter_module_exports);

// node_modules/vega-lite/build/src/index.js
var src_exports2 = {};
__export(src_exports2, {
  compile: () => compile,
  extractTransforms: () => extractTransforms,
  normalize: () => normalize2,
  version: () => version3
});

// node_modules/vega-lite/build/package.json
var name = "vega-lite";
var author = 'Dominik Moritz, Kanit "Ham" Wongsuphasawat, Arvind Satyanarayan, Jeffrey Heer';
var version2 = "4.13.1";
var collaborators = [
  "Kanit Wongsuphasawat (http://kanitw.yellowpigz.com)",
  "Dominik Moritz (https://www.domoritz.de)",
  "Arvind Satyanarayan (https://arvindsatya.com)",
  "Jeffrey Heer (https://jheer.org)"
];
var homepage = "https://vega.github.io/vega-lite/";
var description = "Vega-Lite is a concise high-level language for interactive visualization.";
var main = "build/vega-lite.js";
var unpkg = "build/vega-lite.min.js";
var jsdelivr = "build/vega-lite.min.js";
var module = "build/src/index";
var types = "build/src/index.d.ts";
var bin3 = {
  vl2png: "./bin/vl2png",
  vl2svg: "./bin/vl2svg",
  vl2pdf: "./bin/vl2pdf",
  vl2vg: "./bin/vl2vg"
};
var directories = {
  test: "test"
};
var scripts = {
  changelog: "conventional-changelog -p angular -r 2",
  build: "yarn build:only",
  "build:only": "yarn tsc:src && rollup -c",
  postbuild: "terser build/vega-lite.js -cm --source-map content=build/vega-lite.js.map,filename=build/vega-lite.min.js.map -o build/vega-lite.min.js && yarn schema && babel build/vega-lite.js --out-dir build-es5 --config-file ./babel.config.js",
  "prebuild:examples": "yarn build:only",
  "build:examples": "yarn data && TZ=America/Los_Angeles scripts/build-examples.sh",
  "prebuild:examples-full": "yarn build:only",
  "build:examples-full": "TZ=America/Los_Angeles scripts/build-examples.sh 1",
  "build:example": "TZ=America/Los_Angeles scripts/build-example.sh",
  "build:toc": "yarn build:jekyll && scripts/generate-toc",
  "build:site": "yarn tsc:site && rollup -c site/rollup.config.js",
  "build:jekyll": "pushd site && bundle exec jekyll build -q && popd",
  "build:versions": "scripts/update-version.sh",
  clean: "find build ! -name 'vega-lite-schema.json' -type f -delete && rm -rf site/data/* && rm -f examples/compiled/*.png && find site/examples ! -name 'index.md' ! -name 'data' -type f -delete",
  "predeploy:site": "yarn presite",
  "deploy:site": "gh-pages -d site",
  data: "rsync -r node_modules/vega-datasets/data/* site/data",
  schema: "mkdir -p build && ts-json-schema-generator -f tsconfig.json -p src/index.ts -t TopLevelSpec --no-type-check --no-ref-encode > build/vega-lite-schema.json && yarn renameschema && cp build/vega-lite-schema.json site/_data/",
  renameschema: "scripts/rename-schema.sh",
  presite: "yarn data && yarn schema && yarn build:site && yarn build:versions && scripts/create-example-pages.sh",
  site: "pushd site && bundle exec jekyll serve -I -l && popd",
  "tsc:src": "tsc -b src/tsconfig.src.json",
  "tsc:site": "tsc -b site/tsconfig.site.json",
  prettierbase: "prettier '**/*.{md,css,yml}'",
  eslintbase: "eslint .",
  format: "yarn eslintbase --fix && yarn prettierbase --write",
  lint: "yarn eslintbase && yarn prettierbase --check",
  test: "jest test/ && yarn lint && yarn schema && jest examples/ && yarn test:runtime",
  "test:inspect": "node --inspect-brk ./node_modules/.bin/jest --runInBand test",
  "test:runtime": "TZ=America/Los_Angeles jest test-runtime/",
  "test:runtime:generate": "yarn build:only && rm -Rf test-runtime/resources && VL_GENERATE_TESTS=true yarn test:runtime",
  "watch:build": "yarn build:only && concurrently --kill-others -n Typescript,Rollup 'yarn tsc:src -w' 'rollup -c -w'",
  "watch:site": "concurrently --kill-others -n Typescript,Rollup 'yarn tsc:site -w' 'rollup -c site/rollup.config.js -w'",
  "watch:test": "jest --watch"
};
var repository = {
  type: "git",
  url: "https://github.com/vega/vega-lite.git"
};
var license = "BSD-3-Clause";
var bugs = {
  url: "https://github.com/vega/vega-lite/issues"
};
var devDependencies = {
  "@babel/cli": "^7.10.1",
  "@babel/core": "^7.10.1",
  "@babel/preset-env": "^7.10.1",
  "@rollup/plugin-commonjs": "12.0.0",
  "@rollup/plugin-json": "^4.0.3",
  "@rollup/plugin-node-resolve": "^8.0.0",
  "@types/chai": "^4.2.11",
  "@types/d3": "^5.7.2",
  "@types/jest": "^25.2.3",
  "@types/mkdirp": "^1.0.0",
  "@types/puppeteer": "^3.0.0",
  "@typescript-eslint/eslint-plugin": "^3.0.2",
  "@typescript-eslint/parser": "^3.0.2",
  ajv: "^6.12.2",
  chai: "^4.2.0",
  cheerio: "^1.0.0-rc.3",
  codecov: "^3.7.0",
  concurrently: "^5.2.0",
  "conventional-changelog-cli": "^2.0.34",
  d3: "^5.16.0",
  eslint: "^7.1.0",
  "eslint-config-prettier": "^6.11.0",
  "eslint-plugin-jest": "^23.13.2",
  "eslint-plugin-prettier": "^3.1.3",
  "gh-pages": "^2.2.0",
  "highlight.js": "^10.0.3",
  "http-server": "^0.12.3",
  jest: "^26.0.1",
  "jest-puppeteer": "^4.4.0",
  mkdirp: "^1.0.4",
  prettier: "^2.0.5",
  puppeteer: "^3.1.0",
  rollup: "^2.11.0",
  "rollup-plugin-sourcemaps": "^0.6.2",
  "rollup-plugin-terser": "^6.1.0",
  "svg2png-many": "^0.0.7",
  terser: "^4.7.0",
  "ts-jest": "^26.0.0",
  "ts-json-schema-generator": "^0.68.1",
  typescript: "~3.9.3",
  "vega-cli": "^5.12.1",
  "vega-datasets": "^1.30.2",
  "vega-embed": "^6.8.0",
  "vega-tooltip": "^0.23.0",
  "vega-typings": "^0.17.0",
  "yaml-front-matter": "^4.1.0"
};
var dependencies = {
  "@types/clone": "~0.1.30",
  "@types/fast-json-stable-stringify": "^2.0.0",
  "array-flat-polyfill": "^1.0.1",
  clone: "~2.1.2",
  "fast-deep-equal": "~3.1.1",
  "fast-json-stable-stringify": "~2.1.0",
  "json-stringify-pretty-compact": "~2.0.0",
  tslib: "~2.0.0",
  "vega-event-selector": "~2.0.3",
  "vega-expression": "~2.6.5",
  "vega-util": "~1.14.0",
  yargs: "~15.3.1"
};
var peerDependencies = {
  vega: "^5.12.1"
};
var jest = {
  preset: "jest-puppeteer",
  transform: {
    "^.+\\.tsx?$": "ts-jest"
  },
  testRegex: "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
  moduleFileExtensions: [
    "ts",
    "tsx",
    "js",
    "jsx",
    "json",
    "node"
  ],
  testPathIgnorePatterns: [
    "<rootDir>/node_modules",
    "<rootDir>/build",
    "<rootDir>/_site",
    "<rootDir>/src"
  ],
  coverageDirectory: "./coverage/",
  collectCoverage: false
};
var package_default = {
  name,
  author,
  version: version2,
  collaborators,
  homepage,
  description,
  main,
  unpkg,
  jsdelivr,
  module,
  types,
  bin: bin3,
  directories,
  scripts,
  repository,
  license,
  bugs,
  devDependencies,
  dependencies,
  peerDependencies,
  jest
};

// node_modules/vega-lite/node_modules/vega-util/src/accessor.js
function accessor_default(fn, fields, name4) {
  fn.fields = fields || [];
  fn.fname = name4;
  return fn;
}

// node_modules/vega-lite/node_modules/vega-util/src/getter.js
function getter_default(path3) {
  return path3.length === 1 ? get12(path3[0]) : getN2(path3);
}
var get12 = (field4) => function(obj) {
  return obj[field4];
};
var getN2 = (path3) => {
  const len = path3.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path3[i]];
    }
    return obj;
  };
};

// node_modules/vega-lite/node_modules/vega-util/src/error.js
function error_default(message) {
  throw Error(message);
}

// node_modules/vega-lite/node_modules/vega-util/src/splitAccessPath.js
function splitAccessPath_default(p) {
  var path3 = [], q = null, b2 = 0, n = p.length, s = "", i, j, c2;
  p = p + "";
  function push() {
    path3.push(s + p.substring(i, j));
    s = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c2 = p[j];
    if (c2 === "\\") {
      s += p.substring(i, j);
      s += p.substring(++j, ++j);
      i = j;
    } else if (c2 === q) {
      push();
      q = null;
      b2 = -1;
    } else if (q) {
      continue;
    } else if (i === b2 && c2 === '"') {
      i = j + 1;
      q = c2;
    } else if (i === b2 && c2 === "'") {
      i = j + 1;
      q = c2;
    } else if (c2 === "." && !b2) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c2 === "[") {
      if (j > i)
        push();
      b2 = i = j + 1;
    } else if (c2 === "]") {
      if (!b2)
        error_default("Access path missing open bracket: " + p);
      if (b2 > 0)
        push();
      b2 = 0;
      i = j + 1;
    }
  }
  if (b2)
    error_default("Access path missing closing bracket: " + p);
  if (q)
    error_default("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path3;
}

// node_modules/vega-lite/node_modules/vega-util/src/field.js
function field_default(field4, name4, opt) {
  const path3 = splitAccessPath_default(field4);
  field4 = path3.length === 1 ? path3[0] : field4;
  return accessor_default((opt && opt.get || getter_default)(path3), [field4], name4 || field4);
}

// node_modules/vega-lite/node_modules/vega-util/src/accessors.js
var empty = [];
var id2 = field_default("id");
var identity5 = accessor_default(function(_) {
  return _;
}, empty, "identity");
var zero4 = accessor_default(function() {
  return 0;
}, empty, "zero");
var one4 = accessor_default(function() {
  return 1;
}, empty, "one");
var truthy2 = accessor_default(function() {
  return true;
}, empty, "true");
var falsy2 = accessor_default(function() {
  return false;
}, empty, "false");

// node_modules/vega-lite/node_modules/vega-util/src/logger.js
function log7(method2, level, input) {
  var args = [level].concat([].slice.call(input));
  console[method2].apply(console, args);
}
var None4 = 0;
var Error2 = 1;
var Warn2 = 2;
var Info2 = 3;
var Debug2 = 4;
function logger_default(_, method2) {
  var level = _ || None4;
  return {
    level: function(_2) {
      if (arguments.length) {
        level = +_2;
        return this;
      } else {
        return level;
      }
    },
    error: function() {
      if (level >= Error2)
        log7(method2 || "error", "ERROR", arguments);
      return this;
    },
    warn: function() {
      if (level >= Warn2)
        log7(method2 || "warn", "WARN", arguments);
      return this;
    },
    info: function() {
      if (level >= Info2)
        log7(method2 || "log", "INFO", arguments);
      return this;
    },
    debug: function() {
      if (level >= Debug2)
        log7(method2 || "log", "DEBUG", arguments);
      return this;
    }
  };
}

// node_modules/vega-lite/node_modules/vega-util/src/isArray.js
var isArray_default = Array.isArray;

// node_modules/vega-lite/node_modules/vega-util/src/isObject.js
function isObject_default(_) {
  return _ === Object(_);
}

// node_modules/vega-lite/node_modules/vega-util/src/mergeConfig.js
var isLegalKey2 = (key2) => key2 !== "__proto__";
function mergeConfig2(...configs) {
  return configs.reduce((out, source4) => {
    for (var key2 in source4) {
      if (key2 === "signals") {
        out.signals = mergeNamed2(out.signals, source4.signals);
      } else {
        var r2 = key2 === "legend" ? {layout: 1} : key2 === "style" ? true : null;
        writeConfig2(out, key2, source4[key2], r2);
      }
    }
    return out;
  }, {});
}
function writeConfig2(output3, key2, value3, recurse2) {
  if (!isLegalKey2(key2))
    return;
  var k, o;
  if (isObject_default(value3) && !isArray_default(value3)) {
    o = isObject_default(output3[key2]) ? output3[key2] : output3[key2] = {};
    for (k in value3) {
      if (recurse2 && (recurse2 === true || recurse2[k])) {
        writeConfig2(o, k, value3[k]);
      } else if (isLegalKey2(k)) {
        o[k] = value3[k];
      }
    }
  } else {
    output3[key2] = value3;
  }
}
function mergeNamed2(a2, b2) {
  if (a2 == null)
    return b2;
  const map4 = {}, out = [];
  function add6(_) {
    if (!map4[_.name]) {
      map4[_.name] = 1;
      out.push(_);
    }
  }
  b2.forEach(add6);
  a2.forEach(add6);
  return out;
}

// node_modules/vega-lite/node_modules/vega-util/src/array.js
function array_default4(_) {
  return _ != null ? isArray_default(_) ? _ : [_] : [];
}

// node_modules/vega-lite/node_modules/vega-util/src/isFunction.js
function isFunction_default(_) {
  return typeof _ === "function";
}

// node_modules/vega-lite/node_modules/vega-util/src/hasOwnProperty.js
var hop2 = Object.prototype.hasOwnProperty;
function hasOwnProperty_default(object2, property2) {
  return hop2.call(object2, property2);
}

// node_modules/vega-lite/node_modules/vega-util/src/isBoolean.js
function isBoolean_default(_) {
  return typeof _ === "boolean";
}

// node_modules/vega-lite/node_modules/vega-util/src/isNumber.js
function isNumber_default(_) {
  return typeof _ === "number";
}

// node_modules/vega-lite/node_modules/vega-util/src/isString.js
function isString_default(_) {
  return typeof _ === "string";
}

// node_modules/vega-lite/node_modules/vega-util/src/stringValue.js
function $2(x5) {
  return isArray_default(x5) ? "[" + x5.map($2) + "]" : isObject_default(x5) || isString_default(x5) ? JSON.stringify(x5).replace("\u2028", "\\u2028").replace("\u2029", "\\u2029") : x5;
}

// node_modules/vega-lite/node_modules/vega-util/src/toSet.js
function toSet_default(_) {
  for (var s = {}, i = 0, n = _.length; i < n; ++i)
    s[_[i]] = true;
  return s;
}

// node_modules/vega-lite/node_modules/tslib/tslib.es6.js
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}

// node_modules/array-flat-polyfill/index.mjs
Array.prototype.flat || Object.defineProperty(Array.prototype, "flat", {configurable: true, value: function r() {
  var t = isNaN(arguments[0]) ? 1 : Number(arguments[0]);
  return t ? Array.prototype.reduce.call(this, function(a2, e) {
    return Array.isArray(e) ? a2.push.apply(a2, r.call(e, t - 1)) : a2.push(e), a2;
  }, []) : Array.prototype.slice.call(this);
}, writable: true}), Array.prototype.flatMap || Object.defineProperty(Array.prototype, "flatMap", {configurable: true, value: function(r2) {
  return Array.prototype.map.apply(this, arguments).flat();
}, writable: true});

// node_modules/vega-lite/build/src/util.js
var import_clone = __toModule(require_clone());
var import_fast_deep_equal = __toModule(require_fast_deep_equal());
var import_fast_json_stable_stringify = __toModule(require_fast_json_stable_stringify());

// node_modules/vega-lite/build/src/logical.js
function isLogicalOr(op) {
  return !!op.or;
}
function isLogicalAnd(op) {
  return !!op.and;
}
function isLogicalNot(op) {
  return !!op.not;
}
function forEachLeaf(op, fn) {
  if (isLogicalNot(op)) {
    forEachLeaf(op.not, fn);
  } else if (isLogicalAnd(op)) {
    for (const subop of op.and) {
      forEachLeaf(subop, fn);
    }
  } else if (isLogicalOr(op)) {
    for (const subop of op.or) {
      forEachLeaf(subop, fn);
    }
  } else {
    fn(op);
  }
}
function normalizeLogicalComposition(op, normalizer2) {
  if (isLogicalNot(op)) {
    return {not: normalizeLogicalComposition(op.not, normalizer2)};
  } else if (isLogicalAnd(op)) {
    return {and: op.and.map((o) => normalizeLogicalComposition(o, normalizer2))};
  } else if (isLogicalOr(op)) {
    return {or: op.or.map((o) => normalizeLogicalComposition(o, normalizer2))};
  } else {
    return normalizer2(op);
  }
}

// node_modules/vega-lite/build/src/util.js
var deepEqual = import_fast_deep_equal.default;
var duplicate = import_clone.default;
function pick2(obj, props) {
  const copy5 = {};
  for (const prop of props) {
    if (hasOwnProperty_default(obj, prop)) {
      copy5[prop] = obj[prop];
    }
  }
  return copy5;
}
function omit(obj, props) {
  const copy5 = Object.assign({}, obj);
  for (const prop of props) {
    delete copy5[prop];
  }
  return copy5;
}
Set.prototype["toJSON"] = function() {
  return `Set(${[...this].map((x5) => import_fast_json_stable_stringify.default(x5)).join(",")})`;
};
var stringify = import_fast_json_stable_stringify.default;
function hash(a2) {
  if (isNumber_default(a2)) {
    return a2;
  }
  const str = isString_default(a2) ? a2 : import_fast_json_stable_stringify.default(a2);
  if (str.length < 250) {
    return str;
  }
  let h3 = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    h3 = (h3 << 5) - h3 + char;
    h3 = h3 & h3;
  }
  return h3;
}
function isNullOrFalse(x5) {
  return x5 === false || x5 === null;
}
function contains2(array5, item) {
  return array5.indexOf(item) > -1;
}
function some(arr, f) {
  let i = 0;
  for (const [k, a2] of arr.entries()) {
    if (f(a2, k, i++)) {
      return true;
    }
  }
  return false;
}
function every(arr, f) {
  let i = 0;
  for (const [k, a2] of arr.entries()) {
    if (!f(a2, k, i++)) {
      return false;
    }
  }
  return true;
}
function mergeDeep(dest, ...src) {
  for (const s of src) {
    deepMerge_(dest, s !== null && s !== void 0 ? s : {});
  }
  return dest;
}
function deepMerge_(dest, src) {
  for (const property2 of keys3(src)) {
    writeConfig2(dest, property2, src[property2], true);
  }
}
function unique(values4, f) {
  const results = [];
  const u = {};
  let v;
  for (const val of values4) {
    v = f(val);
    if (v in u) {
      continue;
    }
    u[v] = 1;
    results.push(val);
  }
  return results;
}
function setEqual(a2, b2) {
  if (a2.size !== b2.size) {
    return false;
  }
  for (const e of a2) {
    if (!b2.has(e)) {
      return false;
    }
  }
  return true;
}
function hasIntersection(a2, b2) {
  for (const key2 of a2) {
    if (b2.has(key2)) {
      return true;
    }
  }
  return false;
}
function prefixGenerator(a2) {
  const prefixes4 = new Set();
  for (const x5 of a2) {
    const splitField = splitAccessPath_default(x5);
    const wrappedWithAccessors = splitField.map((y5, i) => i === 0 ? y5 : `[${y5}]`);
    const computedPrefixes = wrappedWithAccessors.map((_, i) => wrappedWithAccessors.slice(0, i + 1).join(""));
    for (const y5 of computedPrefixes) {
      prefixes4.add(y5);
    }
  }
  return prefixes4;
}
function fieldIntersection(a2, b2) {
  if (a2 === void 0 || b2 === void 0) {
    return true;
  }
  return hasIntersection(prefixGenerator(a2), prefixGenerator(b2));
}
function isEmpty(obj) {
  return keys3(obj).length === 0;
}
var keys3 = Object.keys;
var vals = Object.values;
function entries(x5) {
  const _entries = [];
  for (const k in x5) {
    if (hasOwnProperty_default(x5, k)) {
      _entries.push({
        key: k,
        value: x5[k]
      });
    }
  }
  return _entries;
}
function isBoolean3(b2) {
  return b2 === true || b2 === false;
}
function varName(s) {
  const alphanumericS = s.replace(/\W/g, "_");
  return (s.match(/^\d+/) ? "_" : "") + alphanumericS;
}
function logicalExpr(op, cb) {
  if (isLogicalNot(op)) {
    return "!(" + logicalExpr(op.not, cb) + ")";
  } else if (isLogicalAnd(op)) {
    return "(" + op.and.map((and) => logicalExpr(and, cb)).join(") && (") + ")";
  } else if (isLogicalOr(op)) {
    return "(" + op.or.map((or2) => logicalExpr(or2, cb)).join(") || (") + ")";
  } else {
    return cb(op);
  }
}
function deleteNestedProperty(obj, orderedProps) {
  if (orderedProps.length === 0) {
    return true;
  }
  const prop = orderedProps.shift();
  if (prop in obj && deleteNestedProperty(obj[prop], orderedProps)) {
    delete obj[prop];
  }
  return isEmpty(obj);
}
function titleCase(s) {
  return s.charAt(0).toUpperCase() + s.substr(1);
}
function accessPathWithDatum(path3, datum3 = "datum") {
  const pieces = splitAccessPath_default(path3);
  const prefixes4 = [];
  for (let i = 1; i <= pieces.length; i++) {
    const prefix = `[${pieces.slice(0, i).map($2).join("][")}]`;
    prefixes4.push(`${datum3}${prefix}`);
  }
  return prefixes4.join(" && ");
}
function flatAccessWithDatum(path3, datum3 = "datum") {
  return `${datum3}[${$2(splitAccessPath_default(path3).join("."))}]`;
}
function escapePathAccess(string) {
  return string.replace(/(\[|\]|\.|'|")/g, "\\$1");
}
function replacePathInField(path3) {
  return `${splitAccessPath_default(path3).map(escapePathAccess).join("\\.")}`;
}
function replaceAll(string, find4, replacement) {
  return string.replace(new RegExp(find4.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), replacement);
}
function removePathFromField(path3) {
  return `${splitAccessPath_default(path3).join(".")}`;
}
function accessPathDepth(path3) {
  if (!path3) {
    return 0;
  }
  return splitAccessPath_default(path3).length;
}
function getFirstDefined(...args) {
  for (const arg of args) {
    if (arg !== void 0) {
      return arg;
    }
  }
  return void 0;
}
var idCounter = 42;
function uniqueId(prefix) {
  const id4 = ++idCounter;
  return prefix ? String(prefix) + id4 : id4;
}
function internalField(name4) {
  return isInternalField(name4) ? name4 : `__${name4}`;
}
function isInternalField(name4) {
  return name4.indexOf("__") === 0;
}
function normalizeAngle(angle2) {
  if (angle2 === void 0) {
    return void 0;
  }
  return (angle2 % 360 + 360) % 360;
}
function isNumeric(value3) {
  if (isNumber_default(value3)) {
    return true;
  }
  return !isNaN(value3) && !isNaN(parseFloat(value3));
}

// node_modules/vega-lite/build/src/axis.js
var CONDITIONAL_AXIS_PROP_INDEX = {
  domainColor: {
    part: "domain",
    vgProp: "stroke"
  },
  labelAlign: {
    part: "labels",
    vgProp: "align"
  },
  labelBaseline: {
    part: "labels",
    vgProp: "baseline"
  },
  labelColor: {
    part: "labels",
    vgProp: "fill"
  },
  labelFont: {
    part: "labels",
    vgProp: "font"
  },
  labelFontSize: {
    part: "labels",
    vgProp: "fontSize"
  },
  labelFontStyle: {
    part: "labels",
    vgProp: "fontStyle"
  },
  labelFontWeight: {
    part: "labels",
    vgProp: "fontWeight"
  },
  labelOpacity: {
    part: "labels",
    vgProp: "opacity"
  },
  labelOffset: null,
  labelPadding: null,
  gridColor: {
    part: "grid",
    vgProp: "stroke"
  },
  gridDash: {
    part: "grid",
    vgProp: "strokeDash"
  },
  gridDashOffset: {
    part: "grid",
    vgProp: "strokeDash"
  },
  gridOpacity: {
    part: "grid",
    vgProp: "opacity"
  },
  gridWidth: {
    part: "grid",
    vgProp: "strokeWidth"
  },
  tickColor: {
    part: "ticks",
    vgProp: "stroke"
  },
  tickDash: {
    part: "ticks",
    vgProp: "strokeDash"
  },
  tickDashOffset: {
    part: "ticks",
    vgProp: "strokeDash"
  },
  tickOpacity: {
    part: "ticks",
    vgProp: "opacity"
  },
  tickSize: null,
  tickWidth: {
    part: "ticks",
    vgProp: "strokeWidth"
  },
  titleColor: {
    part: "title",
    vgProp: "fill"
  },
  title: null
};
function isConditionalAxisValue(v) {
  return v && v["condition"];
}
var AXIS_PARTS = ["domain", "grid", "labels", "ticks", "title"];
var AXIS_PROPERTY_TYPE = {
  grid: "grid",
  gridCap: "grid",
  gridColor: "grid",
  gridDash: "grid",
  gridDashOffset: "grid",
  gridOpacity: "grid",
  gridScale: "grid",
  gridWidth: "grid",
  orient: "main",
  bandPosition: "both",
  aria: "main",
  description: "main",
  domain: "main",
  domainCap: "main",
  domainColor: "main",
  domainDash: "main",
  domainDashOffset: "main",
  domainOpacity: "main",
  domainWidth: "main",
  format: "main",
  formatType: "main",
  labelAlign: "main",
  labelAngle: "main",
  labelBaseline: "main",
  labelBound: "main",
  labelColor: "main",
  labelFlush: "main",
  labelFlushOffset: "main",
  labelFont: "main",
  labelFontSize: "main",
  labelFontStyle: "main",
  labelFontWeight: "main",
  labelLimit: "main",
  labelLineHeight: "main",
  labelOffset: "main",
  labelOpacity: "main",
  labelOverlap: "main",
  labelPadding: "main",
  labels: "main",
  labelSeparation: "main",
  maxExtent: "main",
  minExtent: "main",
  offset: "both",
  position: "main",
  tickCap: "main",
  tickColor: "main",
  tickDash: "main",
  tickDashOffset: "main",
  tickMinStep: "main",
  tickOffset: "both",
  tickOpacity: "main",
  tickRound: "both",
  ticks: "main",
  tickSize: "main",
  tickWidth: "both",
  title: "main",
  titleAlign: "main",
  titleAnchor: "main",
  titleAngle: "main",
  titleBaseline: "main",
  titleColor: "main",
  titleFont: "main",
  titleFontSize: "main",
  titleFontStyle: "main",
  titleFontWeight: "main",
  titleLimit: "main",
  titleLineHeight: "main",
  titleOpacity: "main",
  titlePadding: "main",
  titleX: "main",
  titleY: "main",
  encode: "both",
  scale: "both",
  tickBand: "both",
  tickCount: "both",
  tickExtra: "both",
  translate: "both",
  values: "both",
  zindex: "both"
};
var COMMON_AXIS_PROPERTIES_INDEX = {
  orient: 1,
  aria: 1,
  bandPosition: 1,
  description: 1,
  domain: 1,
  domainCap: 1,
  domainColor: 1,
  domainDash: 1,
  domainDashOffset: 1,
  domainOpacity: 1,
  domainWidth: 1,
  format: 1,
  formatType: 1,
  grid: 1,
  gridCap: 1,
  gridColor: 1,
  gridDash: 1,
  gridDashOffset: 1,
  gridOpacity: 1,
  gridWidth: 1,
  labelAlign: 1,
  labelAngle: 1,
  labelBaseline: 1,
  labelBound: 1,
  labelColor: 1,
  labelFlush: 1,
  labelFlushOffset: 1,
  labelFont: 1,
  labelFontSize: 1,
  labelFontStyle: 1,
  labelFontWeight: 1,
  labelLimit: 1,
  labelLineHeight: 1,
  labelOffset: 1,
  labelOpacity: 1,
  labelOverlap: 1,
  labelPadding: 1,
  labels: 1,
  labelSeparation: 1,
  maxExtent: 1,
  minExtent: 1,
  offset: 1,
  position: 1,
  tickBand: 1,
  tickCap: 1,
  tickColor: 1,
  tickCount: 1,
  tickDash: 1,
  tickDashOffset: 1,
  tickExtra: 1,
  tickMinStep: 1,
  tickOffset: 1,
  tickOpacity: 1,
  tickRound: 1,
  ticks: 1,
  tickSize: 1,
  tickWidth: 1,
  title: 1,
  titleAlign: 1,
  titleAnchor: 1,
  titleAngle: 1,
  titleBaseline: 1,
  titleColor: 1,
  titleFont: 1,
  titleFontSize: 1,
  titleFontStyle: 1,
  titleFontWeight: 1,
  titleLimit: 1,
  titleLineHeight: 1,
  titleOpacity: 1,
  titlePadding: 1,
  titleX: 1,
  titleY: 1,
  translate: 1,
  values: 1,
  zindex: 1
};
var AXIS_PROPERTIES_INDEX = Object.assign(Object.assign({}, COMMON_AXIS_PROPERTIES_INDEX), {style: 1, labelExpr: 1, encoding: 1});
function isAxisProperty(prop) {
  return !!AXIS_PROPERTIES_INDEX[prop];
}
var AXIS_PROPERTIES = keys3(AXIS_PROPERTIES_INDEX);

// node_modules/vega-lite/build/src/mark.js
var Mark3 = {
  arc: "arc",
  area: "area",
  bar: "bar",
  image: "image",
  line: "line",
  point: "point",
  rect: "rect",
  rule: "rule",
  text: "text",
  tick: "tick",
  trail: "trail",
  circle: "circle",
  square: "square",
  geoshape: "geoshape"
};
var ARC = Mark3.arc;
var AREA = Mark3.area;
var BAR = Mark3.bar;
var IMAGE = Mark3.image;
var LINE = Mark3.line;
var POINT = Mark3.point;
var RECT = Mark3.rect;
var RULE = Mark3.rule;
var TEXT = Mark3.text;
var TICK = Mark3.tick;
var TRAIL = Mark3.trail;
var CIRCLE = Mark3.circle;
var SQUARE = Mark3.square;
var GEOSHAPE = Mark3.geoshape;
function isPathMark(m2) {
  return contains2(["line", "area", "trail"], m2);
}
function isRectBasedMark(m2) {
  return contains2(["rect", "bar", "image", "arc"], m2);
}
var PRIMITIVE_MARKS = keys3(Mark3);
function isMarkDef(mark2) {
  return mark2["type"];
}
var PRIMITIVE_MARK_INDEX = toSet_default(PRIMITIVE_MARKS);
var STROKE_CONFIG = [
  "stroke",
  "strokeWidth",
  "strokeDash",
  "strokeDashOffset",
  "strokeOpacity",
  "strokeJoin",
  "strokeMiterLimit"
];
var FILL_CONFIG = ["fill", "fillOpacity"];
var FILL_STROKE_CONFIG = [...STROKE_CONFIG, ...FILL_CONFIG];
var VL_ONLY_MARK_CONFIG_INDEX = {
  color: 1,
  filled: 1,
  invalid: 1,
  order: 1,
  radius2: 1,
  theta2: 1,
  timeUnitBand: 1,
  timeUnitBandPosition: 1
};
var VL_ONLY_MARK_CONFIG_PROPERTIES = keys3(VL_ONLY_MARK_CONFIG_INDEX);
var VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX = {
  area: ["line", "point"],
  bar: ["binSpacing", "continuousBandSize", "discreteBandSize"],
  rect: ["binSpacing", "continuousBandSize", "discreteBandSize"],
  line: ["point"],
  tick: ["bandSize", "thickness"]
};
var defaultMarkConfig = {
  color: "#4c78a8",
  invalid: "filter",
  timeUnitBand: 1
};
var BAR_CORNER_RADIUS_INDEX = {
  horizontal: ["cornerRadiusTopRight", "cornerRadiusBottomRight"],
  vertical: ["cornerRadiusTopLeft", "cornerRadiusTopRight"]
};
var DEFAULT_RECT_BAND_SIZE = 5;
var defaultBarConfig = {
  binSpacing: 1,
  continuousBandSize: DEFAULT_RECT_BAND_SIZE,
  timeUnitBandPosition: 0.5
};
var defaultRectConfig = {
  binSpacing: 0,
  continuousBandSize: DEFAULT_RECT_BAND_SIZE,
  timeUnitBandPosition: 0.5
};
var defaultTickConfig = {
  thickness: 1
};
function getMarkType(m2) {
  return isMarkDef(m2) ? m2.type : m2;
}

// node_modules/vega-lite/build/src/spec/unit.js
function isUnitSpec(spec) {
  return "mark" in spec;
}

// node_modules/vega-lite/build/src/compositemark/base.js
var CompositeMarkNormalizer = class {
  constructor(name4, run2) {
    this.name = name4;
    this.run = run2;
  }
  hasMatchingType(spec) {
    if (isUnitSpec(spec)) {
      return getMarkType(spec.mark) === this.name;
    }
    return false;
  }
};

// node_modules/vega-lite/build/src/aggregate.js
var AGGREGATE_OP_INDEX = {
  argmax: 1,
  argmin: 1,
  average: 1,
  count: 1,
  distinct: 1,
  product: 1,
  max: 1,
  mean: 1,
  median: 1,
  min: 1,
  missing: 1,
  q1: 1,
  q3: 1,
  ci0: 1,
  ci1: 1,
  stderr: 1,
  stdev: 1,
  stdevp: 1,
  sum: 1,
  valid: 1,
  values: 1,
  variance: 1,
  variancep: 1
};
var MULTIDOMAIN_SORT_OP_INDEX = {
  count: 1,
  min: 1,
  max: 1
};
function isArgminDef(a2) {
  return !!a2 && !!a2["argmin"];
}
function isArgmaxDef(a2) {
  return !!a2 && !!a2["argmax"];
}
var AGGREGATE_OPS = keys3(AGGREGATE_OP_INDEX);
function isAggregateOp(a2) {
  return isString_default(a2) && !!AGGREGATE_OP_INDEX[a2];
}
var COUNTING_OPS = ["count", "valid", "missing", "distinct"];
function isCountingAggregateOp(aggregate) {
  return isString_default(aggregate) && contains2(COUNTING_OPS, aggregate);
}
function isMinMaxOp(aggregate) {
  return isString_default(aggregate) && contains2(["min", "max"], aggregate);
}
var SUM_OPS = ["count", "sum", "distinct", "valid", "missing"];
var SHARED_DOMAIN_OPS = ["mean", "average", "median", "q1", "q3", "min", "max"];
var SHARED_DOMAIN_OP_INDEX = toSet_default(SHARED_DOMAIN_OPS);

// node_modules/vega-lite/build/src/channel.js
var ROW = "row";
var COLUMN = "column";
var FACET = "facet";
var X3 = "x";
var Y3 = "y";
var X23 = "x2";
var Y23 = "y2";
var RADIUS = "radius";
var RADIUS2 = "radius2";
var THETA = "theta";
var THETA2 = "theta2";
var LATITUDE = "latitude";
var LONGITUDE = "longitude";
var LATITUDE2 = "latitude2";
var LONGITUDE2 = "longitude2";
var COLOR = "color";
var FILL = "fill";
var STROKE = "stroke";
var SHAPE = "shape";
var SIZE2 = "size";
var ANGLE = "angle";
var OPACITY = "opacity";
var FILLOPACITY = "fillOpacity";
var STROKEOPACITY = "strokeOpacity";
var STROKEWIDTH = "strokeWidth";
var STROKEDASH = "strokeDash";
var TEXT2 = "text";
var ORDER = "order";
var DETAIL = "detail";
var KEY = "key";
var TOOLTIP = "tooltip";
var HREF = "href";
var URL2 = "url";
var DESCRIPTION = "description";
var POSITION_CHANNEL_INDEX = {
  x: 1,
  y: 1,
  x2: 1,
  y2: 1
};
var POLAR_POSITION_CHANNEL_INDEX = {
  theta: 1,
  theta2: 1,
  radius: 1,
  radius2: 1
};
function isPolarPositionChannel(c2) {
  return c2 in POLAR_POSITION_CHANNEL_INDEX;
}
var GEO_POSIITON_CHANNEL_INDEX = {
  longitude: 1,
  longitude2: 1,
  latitude: 1,
  latitude2: 1
};
function getPositionChannelFromLatLong(channel) {
  switch (channel) {
    case LATITUDE:
      return "y";
    case LATITUDE2:
      return "y2";
    case LONGITUDE:
      return "x";
    case LONGITUDE2:
      return "x2";
  }
}
function isGeoPositionChannel(c2) {
  return c2 in GEO_POSIITON_CHANNEL_INDEX;
}
var GEOPOSITION_CHANNELS = keys3(GEO_POSIITON_CHANNEL_INDEX);
var UNIT_CHANNEL_INDEX = Object.assign(Object.assign(Object.assign(Object.assign({}, POSITION_CHANNEL_INDEX), POLAR_POSITION_CHANNEL_INDEX), GEO_POSIITON_CHANNEL_INDEX), {
  color: 1,
  fill: 1,
  stroke: 1,
  opacity: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  strokeWidth: 1,
  strokeDash: 1,
  size: 1,
  angle: 1,
  shape: 1,
  order: 1,
  text: 1,
  detail: 1,
  key: 1,
  tooltip: 1,
  href: 1,
  url: 1,
  description: 1
});
function isColorChannel(channel) {
  return channel === COLOR || channel === FILL || channel === STROKE;
}
var FACET_CHANNEL_INDEX = {
  row: 1,
  column: 1,
  facet: 1
};
var FACET_CHANNELS = keys3(FACET_CHANNEL_INDEX);
var CHANNEL_INDEX = Object.assign(Object.assign({}, UNIT_CHANNEL_INDEX), FACET_CHANNEL_INDEX);
var CHANNELS = keys3(CHANNEL_INDEX);
var SINGLE_DEF_CHANNEL_INDEX = __rest(CHANNEL_INDEX, ["order", "detail", "tooltip"]);
var SINGLE_DEF_UNIT_CHANNEL_INDEX = __rest(SINGLE_DEF_CHANNEL_INDEX, ["row", "column", "facet"]);
var SINGLE_DEF_CHANNELS = keys3(SINGLE_DEF_CHANNEL_INDEX);
var SINGLE_DEF_UNIT_CHANNELS = keys3(SINGLE_DEF_UNIT_CHANNEL_INDEX);
function isSingleDefUnitChannel(str) {
  return !!SINGLE_DEF_UNIT_CHANNEL_INDEX[str];
}
function isChannel(str) {
  return !!CHANNEL_INDEX[str];
}
var SECONDARY_RANGE_CHANNEL = [X23, Y23, LATITUDE2, LONGITUDE2, THETA2, RADIUS2];
function isSecondaryRangeChannel(c2) {
  const main5 = getMainRangeChannel(c2);
  return main5 !== c2;
}
function getMainRangeChannel(channel) {
  switch (channel) {
    case X23:
      return X3;
    case Y23:
      return Y3;
    case LATITUDE2:
      return LATITUDE;
    case LONGITUDE2:
      return LONGITUDE;
    case THETA2:
      return THETA;
    case RADIUS2:
      return RADIUS;
  }
  return channel;
}
function getVgPositionChannel(channel) {
  if (isPolarPositionChannel(channel)) {
    switch (channel) {
      case THETA:
        return "startAngle";
      case THETA2:
        return "endAngle";
      case RADIUS:
        return "outerRadius";
      case RADIUS2:
        return "innerRadius";
    }
  }
  return channel;
}
function getSecondaryRangeChannel(channel) {
  switch (channel) {
    case X3:
      return X23;
    case Y3:
      return Y23;
    case LATITUDE:
      return LATITUDE2;
    case LONGITUDE:
      return LONGITUDE2;
    case THETA:
      return THETA2;
    case RADIUS:
      return RADIUS2;
  }
  return void 0;
}
function getSizeChannel(channel) {
  switch (channel) {
    case X3:
    case X23:
      return "width";
    case Y3:
    case Y23:
      return "height";
  }
  return void 0;
}
function getOffsetChannel(channel) {
  switch (channel) {
    case X3:
      return "xOffset";
    case Y3:
      return "yOffset";
    case X23:
      return "x2Offset";
    case Y23:
      return "y2Offset";
    case THETA:
      return "thetaOffset";
    case RADIUS:
      return "radiusOffset";
    case THETA2:
      return "theta2Offset";
    case RADIUS2:
      return "radius2Offset";
  }
  return void 0;
}
var UNIT_CHANNELS = keys3(UNIT_CHANNEL_INDEX);
var NONPOSITION_CHANNEL_INDEX = __rest(UNIT_CHANNEL_INDEX, ["x", "y", "x2", "y2", "latitude", "longitude", "latitude2", "longitude2", "theta", "theta2", "radius", "radius2"]);
var NONPOSITION_CHANNELS = keys3(NONPOSITION_CHANNEL_INDEX);
var POSITION_SCALE_CHANNEL_INDEX = {
  x: 1,
  y: 1
};
var POSITION_SCALE_CHANNELS = keys3(POSITION_SCALE_CHANNEL_INDEX);
function isXorY(channel) {
  return channel in POSITION_SCALE_CHANNEL_INDEX;
}
var POLAR_POSITION_SCALE_CHANNEL_INDEX = {
  theta: 1,
  radius: 1
};
var POLAR_POSITION_SCALE_CHANNELS = keys3(POLAR_POSITION_SCALE_CHANNEL_INDEX);
function getPositionScaleChannel(sizeType) {
  return sizeType === "width" ? X3 : Y3;
}
var NONPOSITION_SCALE_CHANNEL_INDEX = __rest(NONPOSITION_CHANNEL_INDEX, ["text", "tooltip", "href", "url", "description", "detail", "key", "order"]);
var NONPOSITION_SCALE_CHANNELS = keys3(NONPOSITION_SCALE_CHANNEL_INDEX);
function isNonPositionScaleChannel(channel) {
  return !!NONPOSITION_CHANNEL_INDEX[channel];
}
function supportLegend(channel) {
  switch (channel) {
    case COLOR:
    case FILL:
    case STROKE:
    case SIZE2:
    case SHAPE:
    case OPACITY:
    case STROKEWIDTH:
    case STROKEDASH:
      return true;
    case FILLOPACITY:
    case STROKEOPACITY:
    case ANGLE:
      return false;
  }
}
var SCALE_CHANNEL_INDEX = Object.assign(Object.assign(Object.assign({}, POSITION_SCALE_CHANNEL_INDEX), POLAR_POSITION_SCALE_CHANNEL_INDEX), NONPOSITION_SCALE_CHANNEL_INDEX);
var SCALE_CHANNELS = keys3(SCALE_CHANNEL_INDEX);
function isScaleChannel(channel) {
  return !!SCALE_CHANNEL_INDEX[channel];
}
function supportMark(channel, mark2) {
  return getSupportedMark(channel)[mark2];
}
var ALL_MARKS = {
  arc: "always",
  area: "always",
  bar: "always",
  circle: "always",
  geoshape: "always",
  image: "always",
  line: "always",
  rule: "always",
  point: "always",
  rect: "always",
  square: "always",
  trail: "always",
  text: "always",
  tick: "always"
};
var ALL_MARKS_EXCEPT_GEOSHAPE = __rest(ALL_MARKS, ["geoshape"]);
function getSupportedMark(channel) {
  switch (channel) {
    case COLOR:
    case FILL:
    case STROKE:
    case DESCRIPTION:
    case DETAIL:
    case KEY:
    case TOOLTIP:
    case HREF:
    case ORDER:
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case STROKEWIDTH:
    case FACET:
    case ROW:
    case COLUMN:
      return ALL_MARKS;
    case X3:
    case Y3:
    case LATITUDE:
    case LONGITUDE:
      return ALL_MARKS_EXCEPT_GEOSHAPE;
    case X23:
    case Y23:
    case LATITUDE2:
    case LONGITUDE2:
      return {
        area: "always",
        bar: "always",
        image: "always",
        rect: "always",
        rule: "always",
        circle: "binned",
        point: "binned",
        square: "binned",
        tick: "binned",
        line: "binned",
        trail: "binned"
      };
    case SIZE2:
      return {
        point: "always",
        tick: "always",
        rule: "always",
        circle: "always",
        square: "always",
        bar: "always",
        text: "always",
        line: "always",
        trail: "always"
      };
    case STROKEDASH:
      return {
        line: "always",
        point: "always",
        tick: "always",
        rule: "always",
        circle: "always",
        square: "always",
        bar: "always",
        geoshape: "always"
      };
    case SHAPE:
      return {point: "always", geoshape: "always"};
    case TEXT2:
      return {text: "always"};
    case ANGLE:
      return {point: "always", square: "always", text: "always"};
    case URL2:
      return {image: "always"};
    case THETA:
      return {text: "always", arc: "always"};
    case RADIUS:
      return {text: "always", arc: "always"};
    case THETA2:
    case RADIUS2:
      return {arc: "always"};
  }
}
function rangeType(channel) {
  switch (channel) {
    case X3:
    case Y3:
    case THETA:
    case RADIUS:
    case SIZE2:
    case ANGLE:
    case STROKEWIDTH:
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case X23:
    case Y23:
    case THETA2:
    case RADIUS2:
      return void 0;
    case FACET:
    case ROW:
    case COLUMN:
    case SHAPE:
    case STROKEDASH:
    case TEXT2:
    case TOOLTIP:
    case HREF:
    case URL2:
    case DESCRIPTION:
      return "discrete";
    case COLOR:
    case FILL:
    case STROKE:
      return "flexible";
    case LATITUDE:
    case LONGITUDE:
    case LATITUDE2:
    case LONGITUDE2:
    case DETAIL:
    case KEY:
    case ORDER:
      return void 0;
  }
}

// node_modules/vega-lite/build/src/bin.js
function binToString(bin4) {
  if (isBoolean_default(bin4)) {
    bin4 = normalizeBin(bin4, void 0);
  }
  return "bin" + keys3(bin4).map((p) => isSelectionExtent(bin4[p]) ? varName(`_${p}_${Object.entries(bin4[p])}`) : varName(`_${p}_${bin4[p]}`)).join("");
}
function isBinning(bin4) {
  return bin4 === true || isBinParams(bin4) && !bin4.binned;
}
function isBinned(bin4) {
  return bin4 === "binned" || isBinParams(bin4) && bin4.binned === true;
}
function isBinParams(bin4) {
  return isObject_default(bin4);
}
function isSelectionExtent(extent2) {
  return extent2 === null || extent2 === void 0 ? void 0 : extent2["selection"];
}
function autoMaxBins(channel) {
  switch (channel) {
    case ROW:
    case COLUMN:
    case SIZE2:
    case COLOR:
    case FILL:
    case STROKE:
    case STROKEWIDTH:
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case SHAPE:
      return 6;
    case STROKEDASH:
      return 4;
    default:
      return 10;
  }
}

// node_modules/vega-lite/build/src/timeunit.js
var import_fast_json_stable_stringify2 = __toModule(require_fast_json_stable_stringify());

// node_modules/vega-lite/build/src/log/message.js
var message_exports = {};
__export(message_exports, {
  CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN: () => CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN,
  CONCAT_CANNOT_SHARE_AXIS: () => CONCAT_CANNOT_SHARE_AXIS,
  FACETED_INDEPENDENT_DIFFERENT_SOURCES: () => FACETED_INDEPENDENT_DIFFERENT_SOURCES,
  FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES: () => FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES,
  FACETED_INDEPENDENT_SAME_SOURCE: () => FACETED_INDEPENDENT_SAME_SOURCE,
  FIT_NON_SINGLE: () => FIT_NON_SINGLE,
  INVALID_CHANNEL_FOR_AXIS: () => INVALID_CHANNEL_FOR_AXIS,
  LEGEND_BINDINGS_PROJECT_LENGTH: () => LEGEND_BINDINGS_PROJECT_LENGTH,
  LINE_WITH_VARYING_SIZE: () => LINE_WITH_VARYING_SIZE,
  MORE_THAN_ONE_SORT: () => MORE_THAN_ONE_SORT,
  NO_FIELDS_NEEDS_AS: () => NO_FIELDS_NEEDS_AS,
  RANGE_STEP_DEPRECATED: () => RANGE_STEP_DEPRECATED,
  REPLACE_ANGLE_WITH_THETA: () => REPLACE_ANGLE_WITH_THETA,
  SCALE_BINDINGS_CONTINUOUS: () => SCALE_BINDINGS_CONTINUOUS,
  cannotApplySizeToNonOrientedMark: () => cannotApplySizeToNonOrientedMark,
  cannotProjectAggregate: () => cannotProjectAggregate,
  cannotProjectOnChannelWithoutField: () => cannotProjectOnChannelWithoutField,
  cannotStackNonLinearScale: () => cannotStackNonLinearScale,
  cannotStackRangedMark: () => cannotStackRangedMark,
  cannotUseScalePropertyWithNonColor: () => cannotUseScalePropertyWithNonColor,
  channelRequiredForBinned: () => channelRequiredForBinned,
  columnsNotSupportByRowCol: () => columnsNotSupportByRowCol,
  containerSizeNonSingle: () => containerSizeNonSingle,
  containerSizeNotCompatibleWithAutosize: () => containerSizeNotCompatibleWithAutosize,
  customFormatTypeNotAllowed: () => customFormatTypeNotAllowed,
  differentParse: () => differentParse,
  discreteChannelCannotEncode: () => discreteChannelCannotEncode,
  domainRequiredForThresholdScale: () => domainRequiredForThresholdScale,
  domainSortDropped: () => domainSortDropped,
  droppedDay: () => droppedDay,
  droppingColor: () => droppingColor,
  droppingFit: () => droppingFit,
  emptyFieldDef: () => emptyFieldDef,
  encodingOverridden: () => encodingOverridden,
  errorBand1DNotSupport: () => errorBand1DNotSupport,
  errorBarCenterAndExtentAreNotNeeded: () => errorBarCenterAndExtentAreNotNeeded,
  errorBarCenterIsNotNeeded: () => errorBarCenterIsNotNeeded,
  errorBarCenterIsUsedWithWrongExtent: () => errorBarCenterIsUsedWithWrongExtent,
  errorBarContinuousAxisHasCustomizedAggregate: () => errorBarContinuousAxisHasCustomizedAggregate,
  facetChannelDropped: () => facetChannelDropped,
  facetChannelShouldBeDiscrete: () => facetChannelShouldBeDiscrete,
  incompatibleChannel: () => incompatibleChannel,
  independentScaleMeansIndependentGuide: () => independentScaleMeansIndependentGuide,
  invalidAggregate: () => invalidAggregate,
  invalidEncodingChannel: () => invalidEncodingChannel,
  invalidFieldType: () => invalidFieldType,
  invalidFieldTypeForCountAggregate: () => invalidFieldTypeForCountAggregate,
  invalidSpec: () => invalidSpec,
  invalidTimeUnit: () => invalidTimeUnit,
  invalidTransformIgnored: () => invalidTransformIgnored,
  latLongDeprecated: () => latLongDeprecated,
  lineWithRange: () => lineWithRange,
  mergeConflictingDomainProperty: () => mergeConflictingDomainProperty,
  mergeConflictingProperty: () => mergeConflictingProperty,
  missingFieldType: () => missingFieldType,
  nearestNotSupportForContinuous: () => nearestNotSupportForContinuous,
  noSameUnitLookup: () => noSameUnitLookup,
  noSuchRepeatedValue: () => noSuchRepeatedValue,
  orientOverridden: () => orientOverridden,
  primitiveChannelDef: () => primitiveChannelDef,
  projectionOverridden: () => projectionOverridden,
  scalePropertyNotWorkWithScaleType: () => scalePropertyNotWorkWithScaleType,
  scaleTypeNotWorkWithChannel: () => scaleTypeNotWorkWithChannel,
  scaleTypeNotWorkWithFieldDef: () => scaleTypeNotWorkWithFieldDef,
  scaleTypeNotWorkWithMark: () => scaleTypeNotWorkWithMark,
  selectionNotFound: () => selectionNotFound,
  selectionNotSupported: () => selectionNotSupported,
  stackNonSummativeAggregate: () => stackNonSummativeAggregate,
  stepDropped: () => stepDropped,
  unaggregateDomainHasNoEffectForRawField: () => unaggregateDomainHasNoEffectForRawField,
  unaggregateDomainWithNonSharedDomainOp: () => unaggregateDomainWithNonSharedDomainOp,
  unaggregatedDomainWithLogScale: () => unaggregatedDomainWithLogScale,
  unrecognizedParse: () => unrecognizedParse
});
function invalidSpec(spec) {
  return `Invalid specification ${JSON.stringify(spec)}. Make sure the specification includes at least one of the following properties: "mark", "layer", "facet", "hconcat", "vconcat", "concat", or "repeat".`;
}
var FIT_NON_SINGLE = 'Autosize "fit" only works for single views and layered views.';
function containerSizeNonSingle(name4) {
  const uName = name4 == "width" ? "Width" : "Height";
  return `${uName} "container" only works for single views and layered views.`;
}
function containerSizeNotCompatibleWithAutosize(name4) {
  const uName = name4 == "width" ? "Width" : "Height";
  const fitDirection = name4 == "width" ? "x" : "y";
  return `${uName} "container" only works well with autosize "fit" or "fit-${fitDirection}".`;
}
function droppingFit(channel) {
  return channel ? `Dropping "fit-${channel}" because spec has discrete ${getSizeChannel(channel)}.` : `Dropping "fit" because spec has discrete size.`;
}
function cannotProjectOnChannelWithoutField(channel) {
  return `Cannot project a selection on encoding channel "${channel}", which has no field.`;
}
function cannotProjectAggregate(channel, aggregate) {
  return `Cannot project a selection on encoding channel "${channel}" as it uses an aggregate function ("${aggregate}").`;
}
function nearestNotSupportForContinuous(mark2) {
  return `The "nearest" transform is not supported for ${mark2} marks.`;
}
function selectionNotSupported(mark2) {
  return `Selection not supported for ${mark2} yet.`;
}
function selectionNotFound(name4) {
  return `Cannot find a selection named "${name4}".`;
}
var SCALE_BINDINGS_CONTINUOUS = "Scale bindings are currently only supported for scales with unbinned, continuous domains.";
var LEGEND_BINDINGS_PROJECT_LENGTH = "Legend bindings are only supported for selections over an individual field or encoding channel.";
function noSameUnitLookup(name4) {
  return `Cannot define and lookup the "${name4}" selection in the same view. Try moving the lookup into a second, layered view?`;
}
function noSuchRepeatedValue(field4) {
  return `Unknown repeated value "${field4}".`;
}
function columnsNotSupportByRowCol(type2) {
  return `The "columns" property cannot be used when "${type2}" has nested row/column.`;
}
var CONCAT_CANNOT_SHARE_AXIS = "Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).";
function unrecognizedParse(p) {
  return `Unrecognized parse "${p}".`;
}
function differentParse(field4, local2, ancestor) {
  return `An ancestor parsed field "${field4}" as ${ancestor} but a child wants to parse the field as ${local2}.`;
}
function invalidTransformIgnored(transform4) {
  return `Ignoring an invalid transform: ${stringify(transform4)}.`;
}
var NO_FIELDS_NEEDS_AS = 'If "from.fields" is not specified, "as" has to be a string that specifies the key to be used for the data from the secondary source.';
function customFormatTypeNotAllowed(channel) {
  return `Config.customFormatTypes is not true, thus custom format type and format for channel ${channel} are dropped.`;
}
function encodingOverridden(channels) {
  return `Layer's shared ${channels.join(",")} channel ${channels.length === 1 ? "is" : "are"} overriden.`;
}
function projectionOverridden(opt) {
  const {parentProjection, projection: projection3} = opt;
  return `Layer's shared projection ${stringify(parentProjection)} is overridden by a child projection ${stringify(projection3)}.`;
}
var REPLACE_ANGLE_WITH_THETA = "Arc marks uses theta channel rather than angle, replacing angle with theta.";
function primitiveChannelDef(channel, type2, value3) {
  return `Channel ${channel} is a ${type2}. Converted to {value: ${stringify(value3)}}.`;
}
function invalidFieldType(type2) {
  return `Invalid field type "${type2}".`;
}
function invalidFieldTypeForCountAggregate(type2, aggregate) {
  return `Invalid field type "${type2}" for aggregate: "${aggregate}", using "quantitative" instead.`;
}
function invalidAggregate(aggregate) {
  return `Invalid aggregation operator "${aggregate}".`;
}
function missingFieldType(channel, newType) {
  return `Missing type for channel "${channel}", using "${newType}" instead.`;
}
function droppingColor(type2, opt) {
  const {fill: fill2, stroke: stroke2} = opt;
  return `Dropping color ${type2} as the plot also has ${fill2 && stroke2 ? "fill and stroke" : fill2 ? "fill" : "stroke"}.`;
}
function emptyFieldDef(fieldDef, channel) {
  return `Dropping ${stringify(fieldDef)} from channel "${channel}" since it does not contain any data field, datum, value, or signal.`;
}
function latLongDeprecated(channel, type2, newChannel) {
  return `${channel}-encoding with type ${type2} is deprecated. Replacing with ${newChannel}-encoding.`;
}
var LINE_WITH_VARYING_SIZE = "Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.";
function incompatibleChannel(channel, markOrFacet, when) {
  return `${channel} dropped as it is incompatible with "${markOrFacet}"${when ? ` when ${when}` : ""}.`;
}
function invalidEncodingChannel(channel) {
  return `${channel}-encoding is dropped as ${channel} is not a valid encoding channel.`;
}
function facetChannelShouldBeDiscrete(channel) {
  return `${channel} encoding should be discrete (ordinal / nominal / binned).`;
}
function facetChannelDropped(channels) {
  return `Facet encoding dropped as ${channels.join(" and ")} ${channels.length > 1 ? "are" : "is"} also specified.`;
}
function discreteChannelCannotEncode(channel, type2) {
  return `Using discrete channel "${channel}" to encode "${type2}" field can be misleading as it does not encode ${type2 === "ordinal" ? "order" : "magnitude"}.`;
}
function lineWithRange(hasX2, hasY2) {
  const channels = hasX2 && hasY2 ? "x2 and y2" : hasX2 ? "x2" : "y2";
  return `Line mark is for continuous lines and thus cannot be used with ${channels}. We will use the rule mark (line segments) instead.`;
}
function orientOverridden(original, actual) {
  return `Specified orient "${original}" overridden with "${actual}".`;
}
var CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN = "Custom domain scale cannot be unioned with default field-based domain.";
var RANGE_STEP_DEPRECATED = `Scale's "rangeStep" is deprecated and will be removed in Vega-Lite 5.0. Please use "width"/"height": {"step": ...} instead. See https://vega.github.io/vega-lite/docs/size.html.`;
function cannotUseScalePropertyWithNonColor(prop) {
  return `Cannot use the scale property "${prop}" with non-color channel.`;
}
function unaggregateDomainHasNoEffectForRawField(fieldDef) {
  return `Using unaggregated domain with raw field has no effect (${stringify(fieldDef)}).`;
}
function unaggregateDomainWithNonSharedDomainOp(aggregate) {
  return `Unaggregated domain not applicable for "${aggregate}" since it produces values outside the origin domain of the source data.`;
}
function unaggregatedDomainWithLogScale(fieldDef) {
  return `Unaggregated domain is currently unsupported for log scale (${stringify(fieldDef)}).`;
}
function cannotApplySizeToNonOrientedMark(mark2) {
  return `Cannot apply size to non-oriented mark "${mark2}".`;
}
function scaleTypeNotWorkWithChannel(channel, scaleType2, defaultScaleType) {
  return `Channel "${channel}" does not work with "${scaleType2}" scale. We are using "${defaultScaleType}" scale instead.`;
}
function scaleTypeNotWorkWithFieldDef(scaleType2, defaultScaleType) {
  return `FieldDef does not work with "${scaleType2}" scale. We are using "${defaultScaleType}" scale instead.`;
}
function scalePropertyNotWorkWithScaleType(scaleType2, propName, channel) {
  return `${channel}-scale's "${propName}" is dropped as it does not work with ${scaleType2} scale.`;
}
function scaleTypeNotWorkWithMark(mark2, scaleType2) {
  return `Scale type "${scaleType2}" does not work with mark "${mark2}".`;
}
function stepDropped(channel) {
  return `The step for "${channel}" is dropped because the ${channel === "width" ? "x" : "y"} is continuous.`;
}
function mergeConflictingProperty(property2, propertyOf, v1, v2) {
  return `Conflicting ${propertyOf.toString()} property "${property2.toString()}" (${stringify(v1)} and ${stringify(v2)}). Using ${stringify(v1)}.`;
}
function mergeConflictingDomainProperty(property2, propertyOf, v1, v2) {
  return `Conflicting ${propertyOf.toString()} property "${property2.toString()}" (${stringify(v1)} and ${stringify(v2)}). Using the union of the two domains.`;
}
function independentScaleMeansIndependentGuide(channel) {
  return `Setting the scale to be independent for "${channel}" means we also have to set the guide (axis or legend) to be independent.`;
}
function domainSortDropped(sort2) {
  return `Dropping sort property ${stringify(sort2)} as unioned domains only support boolean or op "count", "min", and "max".`;
}
var MORE_THAN_ONE_SORT = "Domains that should be unioned has conflicting sort properties. Sort will be set to true.";
var FACETED_INDEPENDENT_DIFFERENT_SOURCES = "Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.";
var FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES = "Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.";
var FACETED_INDEPENDENT_SAME_SOURCE = "Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.";
var INVALID_CHANNEL_FOR_AXIS = "Invalid channel for axis.";
function cannotStackRangedMark(channel) {
  return `Cannot stack "${channel}" if there is already "${channel}2".`;
}
function cannotStackNonLinearScale(scaleType2) {
  return `Cannot stack non-linear scale (${scaleType2}).`;
}
function stackNonSummativeAggregate(aggregate) {
  return `Stacking is applied even though the aggregate function is non-summative ("${aggregate}").`;
}
function invalidTimeUnit(unitName2, value3) {
  return `Invalid ${unitName2}: ${stringify(value3)}.`;
}
function droppedDay(d) {
  return `Dropping day from datetime ${stringify(d)} as day cannot be combined with other units.`;
}
function errorBarCenterAndExtentAreNotNeeded(center, extent2) {
  return `${extent2 ? "extent " : ""}${extent2 && center ? "and " : ""}${center ? "center " : ""}${extent2 && center ? "are " : "is "}not needed when data are aggregated.`;
}
function errorBarCenterIsUsedWithWrongExtent(center, extent2, mark2) {
  return `${center} is not usually used with ${extent2} for ${mark2}.`;
}
function errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark) {
  return `Continuous axis should not have customized aggregation function ${aggregate}; ${compositeMark} already agregates the axis.`;
}
function errorBarCenterIsNotNeeded(extent2, mark2) {
  return `Center is not needed to be specified in ${mark2} when extent is ${extent2}.`;
}
function errorBand1DNotSupport(property2) {
  return `1D error band does not support ${property2}.`;
}
function channelRequiredForBinned(channel) {
  return `Channel ${channel} is required for "binned" bin.`;
}
function domainRequiredForThresholdScale(channel) {
  return `Domain for ${channel} is required for threshold scale.`;
}

// node_modules/vega-lite/build/src/log/index.js
var main2 = logger_default(Warn2);
var current = main2;
function set5(newLogger) {
  current = newLogger;
  return current;
}
function reset2() {
  current = main2;
  return current;
}
function warn3(...args) {
  current.warn(...args);
}
function debug3(...args) {
  current.debug(...args);
}

// node_modules/vega-lite/build/src/datetime.js
function isDateTime(o) {
  if (o && isObject_default(o)) {
    for (const part of TIMEUNIT_PARTS) {
      if (part in o) {
        return true;
      }
    }
  }
  return false;
}
var MONTHS = [
  "january",
  "february",
  "march",
  "april",
  "may",
  "june",
  "july",
  "august",
  "september",
  "october",
  "november",
  "december"
];
var SHORT_MONTHS = MONTHS.map((m2) => m2.substr(0, 3));
var DAYS = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
var SHORT_DAYS = DAYS.map((d) => d.substr(0, 3));
function normalizeQuarter(q) {
  if (isNumeric(q)) {
    q = +q;
  }
  if (isNumber_default(q)) {
    if (q > 4) {
      warn3(message_exports.invalidTimeUnit("quarter", q));
    }
    return q - 1;
  } else {
    throw new Error(message_exports.invalidTimeUnit("quarter", q));
  }
}
function normalizeMonth(m2) {
  if (isNumeric(m2)) {
    m2 = +m2;
  }
  if (isNumber_default(m2)) {
    return m2 - 1;
  } else {
    const lowerM = m2.toLowerCase();
    const monthIndex = MONTHS.indexOf(lowerM);
    if (monthIndex !== -1) {
      return monthIndex;
    }
    const shortM = lowerM.substr(0, 3);
    const shortMonthIndex = SHORT_MONTHS.indexOf(shortM);
    if (shortMonthIndex !== -1) {
      return shortMonthIndex;
    }
    throw new Error(message_exports.invalidTimeUnit("month", m2));
  }
}
function normalizeDay(d) {
  if (isNumeric(d)) {
    d = +d;
  }
  if (isNumber_default(d)) {
    return d % 7;
  } else {
    const lowerD = d.toLowerCase();
    const dayIndex = DAYS.indexOf(lowerD);
    if (dayIndex !== -1) {
      return dayIndex;
    }
    const shortD = lowerD.substr(0, 3);
    const shortDayIndex = SHORT_DAYS.indexOf(shortD);
    if (shortDayIndex !== -1) {
      return shortDayIndex;
    }
    throw new Error(message_exports.invalidTimeUnit("day", d));
  }
}
function dateTimeParts(d, normalize3) {
  const parts = [];
  if (normalize3 && d.day !== void 0) {
    if (keys3(d).length > 1) {
      warn3(message_exports.droppedDay(d));
      d = duplicate(d);
      delete d.day;
    }
  }
  if (d.year !== void 0) {
    parts.push(d.year);
  } else {
    parts.push(2012);
  }
  if (d.month !== void 0) {
    const month2 = normalize3 ? normalizeMonth(d.month) : d.month;
    parts.push(month2);
  } else if (d.quarter !== void 0) {
    const quarter3 = normalize3 ? normalizeQuarter(d.quarter) : d.quarter;
    parts.push(isNumber_default(quarter3) ? quarter3 * 3 : quarter3 + "*3");
  } else {
    parts.push(0);
  }
  if (d.date !== void 0) {
    parts.push(d.date);
  } else if (d.day !== void 0) {
    const day2 = normalize3 ? normalizeDay(d.day) : d.day;
    parts.push(isNumber_default(day2) ? day2 + 1 : day2 + "+1");
  } else {
    parts.push(1);
  }
  for (const timeUnit of ["hours", "minutes", "seconds", "milliseconds"]) {
    const unit2 = d[timeUnit];
    parts.push(typeof unit2 === "undefined" ? 0 : unit2);
  }
  return parts;
}
function dateTimeToExpr(d) {
  const parts = dateTimeParts(d, true);
  const string = parts.join(", ");
  if (d.utc) {
    return `utc(${string})`;
  } else {
    return `datetime(${string})`;
  }
}
function dateTimeExprToExpr(d) {
  const parts = dateTimeParts(d, false);
  const string = parts.join(", ");
  if (d.utc) {
    return `utc(${string})`;
  } else {
    return `datetime(${string})`;
  }
}
function dateTimeToTimestamp(d) {
  const parts = dateTimeParts(d, true);
  if (d.utc) {
    return +new Date(Date.UTC(...parts));
  } else {
    return +new Date(...parts);
  }
}

// node_modules/vega-lite/build/src/timeunit.js
var LOCAL_SINGLE_TIMEUNIT_INDEX = {
  year: 1,
  quarter: 1,
  month: 1,
  week: 1,
  day: 1,
  dayofyear: 1,
  date: 1,
  hours: 1,
  minutes: 1,
  seconds: 1,
  milliseconds: 1
};
var TIMEUNIT_PARTS = keys3(LOCAL_SINGLE_TIMEUNIT_INDEX);
function isLocalSingleTimeUnit(timeUnit) {
  return !!LOCAL_SINGLE_TIMEUNIT_INDEX[timeUnit];
}
function isUTCTimeUnit(t) {
  return t.startsWith("utc");
}
function getLocalTimeUnit(t) {
  return t.substr(3);
}
var VEGALITE_TIMEFORMAT = {
  "year-month": "%b %Y ",
  "year-month-date": "%b %d, %Y "
};
function getTimeUnitParts(timeUnit) {
  const parts = [];
  for (const part of TIMEUNIT_PARTS) {
    if (containsTimeUnit(timeUnit, part)) {
      parts.push(part);
    }
  }
  return parts;
}
function containsTimeUnit(fullTimeUnit, timeUnit) {
  const index4 = fullTimeUnit.indexOf(timeUnit);
  if (index4 < 0) {
    return false;
  }
  if (index4 > 0 && timeUnit === "seconds" && fullTimeUnit.charAt(index4 - 1) === "i") {
    return false;
  }
  if (fullTimeUnit.length > index4 + 3 && timeUnit === "day" && fullTimeUnit.charAt(index4 + 3) === "o") {
    return false;
  }
  if (index4 > 0 && timeUnit === "year" && fullTimeUnit.charAt(index4 - 1) === "f") {
    return false;
  }
  return true;
}
function fieldExpr(fullTimeUnit, field4, {end} = {end: false}) {
  const fieldRef2 = accessPathWithDatum(field4);
  const utc = isUTCTimeUnit(fullTimeUnit) ? "utc" : "";
  function func(timeUnit) {
    if (timeUnit === "quarter") {
      return `(${utc}quarter(${fieldRef2})-1)`;
    } else {
      return `${utc}${timeUnit}(${fieldRef2})`;
    }
  }
  let lastTimeUnit;
  const dateExpr = {};
  for (const part of TIMEUNIT_PARTS) {
    if (containsTimeUnit(fullTimeUnit, part)) {
      dateExpr[part] = func(part);
      lastTimeUnit = part;
    }
  }
  if (end) {
    dateExpr[lastTimeUnit] += "+1";
  }
  return dateTimeExprToExpr(dateExpr);
}
function timeUnitSpecifierExpression(timeUnit) {
  if (!timeUnit) {
    return void 0;
  }
  const timeUnitParts = getTimeUnitParts(timeUnit);
  return `timeUnitSpecifier(${import_fast_json_stable_stringify2.default(timeUnitParts)}, ${import_fast_json_stable_stringify2.default(VEGALITE_TIMEFORMAT)})`;
}
function formatExpression(timeUnit, field4, isUTCScale) {
  if (!timeUnit) {
    return void 0;
  }
  const expr2 = timeUnitSpecifierExpression(timeUnit);
  const utc = isUTCScale || isUTCTimeUnit(timeUnit);
  return `${utc ? "utc" : "time"}Format(${field4}, ${expr2})`;
}
function normalizeTimeUnit(timeUnit) {
  if (!timeUnit) {
    return void 0;
  }
  let params2;
  if (isString_default(timeUnit)) {
    params2 = {
      unit: timeUnit
    };
  } else if (isObject_default(timeUnit)) {
    params2 = Object.assign(Object.assign({}, timeUnit), timeUnit.unit ? {unit: timeUnit.unit} : {});
  }
  if (isUTCTimeUnit(params2.unit)) {
    params2.utc = true;
    params2.unit = getLocalTimeUnit(params2.unit);
  }
  return params2;
}
function timeUnitToString(tu) {
  const _a2 = normalizeTimeUnit(tu), {utc} = _a2, rest = __rest(_a2, ["utc"]);
  if (rest.unit) {
    return (utc ? "utc" : "") + keys3(rest).map((p) => varName(`${p === "unit" ? "" : `_${p}_`}${rest[p]}`)).join("");
  } else {
    return (utc ? "utc" : "") + "timeunit" + keys3(rest).map((p) => varName(`_${p}_${rest[p]}`)).join("");
  }
}

// node_modules/vega-lite/build/src/vega.schema.js
function isSignalRef(o) {
  return o && !!o["signal"];
}
function isVgRangeStep(range5) {
  return !!range5["step"];
}
function isDataRefUnionedDomain(domain4) {
  if (!isArray_default(domain4)) {
    return "fields" in domain4 && !("data" in domain4);
  }
  return false;
}
function isFieldRefUnionDomain(domain4) {
  if (!isArray_default(domain4)) {
    return "fields" in domain4 && "data" in domain4;
  }
  return false;
}
function isDataRefDomain(domain4) {
  if (!isArray_default(domain4)) {
    return "field" in domain4 && "data" in domain4;
  }
  return false;
}
var VG_MARK_CONFIG_INDEX = {
  aria: 1,
  description: 1,
  ariaRole: 1,
  ariaRoleDescription: 1,
  blend: 1,
  opacity: 1,
  fill: 1,
  fillOpacity: 1,
  stroke: 1,
  strokeCap: 1,
  strokeWidth: 1,
  strokeOpacity: 1,
  strokeDash: 1,
  strokeDashOffset: 1,
  strokeJoin: 1,
  strokeOffset: 1,
  strokeMiterLimit: 1,
  startAngle: 1,
  endAngle: 1,
  padAngle: 1,
  innerRadius: 1,
  outerRadius: 1,
  size: 1,
  shape: 1,
  interpolate: 1,
  tension: 1,
  orient: 1,
  align: 1,
  baseline: 1,
  text: 1,
  dir: 1,
  dx: 1,
  dy: 1,
  ellipsis: 1,
  limit: 1,
  radius: 1,
  theta: 1,
  angle: 1,
  font: 1,
  fontSize: 1,
  fontWeight: 1,
  fontStyle: 1,
  lineBreak: 1,
  lineHeight: 1,
  cursor: 1,
  href: 1,
  tooltip: 1,
  cornerRadius: 1,
  cornerRadiusTopLeft: 1,
  cornerRadiusTopRight: 1,
  cornerRadiusBottomLeft: 1,
  cornerRadiusBottomRight: 1,
  aspect: 1,
  width: 1,
  height: 1
};
var VG_MARK_CONFIGS = keys3(VG_MARK_CONFIG_INDEX);
var VG_MARK_INDEX = {
  arc: 1,
  area: 1,
  group: 1,
  image: 1,
  line: 1,
  path: 1,
  rect: 1,
  rule: 1,
  shape: 1,
  symbol: 1,
  text: 1,
  trail: 1
};
var VG_CORNERRADIUS_CHANNELS = [
  "cornerRadius",
  "cornerRadiusTopLeft",
  "cornerRadiusTopRight",
  "cornerRadiusBottomLeft",
  "cornerRadiusBottomRight"
];

// node_modules/vega-lite/build/src/predicate.js
function isSelectionPredicate(predicate) {
  return predicate === null || predicate === void 0 ? void 0 : predicate["selection"];
}
function isFieldEqualPredicate(predicate) {
  return predicate && !!predicate.field && predicate.equal !== void 0;
}
function isFieldLTPredicate(predicate) {
  return predicate && !!predicate.field && predicate.lt !== void 0;
}
function isFieldLTEPredicate(predicate) {
  return predicate && !!predicate.field && predicate.lte !== void 0;
}
function isFieldGTPredicate(predicate) {
  return predicate && !!predicate.field && predicate.gt !== void 0;
}
function isFieldGTEPredicate(predicate) {
  return predicate && !!predicate.field && predicate.gte !== void 0;
}
function isFieldRangePredicate(predicate) {
  if (predicate && predicate.field) {
    if (isArray_default(predicate.range) && predicate.range.length === 2) {
      return true;
    } else if (isSignalRef(predicate.range)) {
      return true;
    }
  }
  return false;
}
function isFieldOneOfPredicate(predicate) {
  return predicate && !!predicate.field && (isArray_default(predicate.oneOf) || isArray_default(predicate.in));
}
function isFieldValidPredicate(predicate) {
  return predicate && !!predicate.field && predicate.valid !== void 0;
}
function isFieldPredicate(predicate) {
  return isFieldOneOfPredicate(predicate) || isFieldEqualPredicate(predicate) || isFieldRangePredicate(predicate) || isFieldLTPredicate(predicate) || isFieldGTPredicate(predicate) || isFieldLTEPredicate(predicate) || isFieldGTEPredicate(predicate);
}
function predicateValueExpr(v, timeUnit) {
  return valueExpr(v, {timeUnit, wrapTime: true});
}
function predicateValuesExpr(vals2, timeUnit) {
  return vals2.map((v) => predicateValueExpr(v, timeUnit));
}
function fieldFilterExpression(predicate, useInRange = true) {
  var _a2;
  const {field: field4} = predicate;
  const timeUnit = (_a2 = normalizeTimeUnit(predicate.timeUnit)) === null || _a2 === void 0 ? void 0 : _a2.unit;
  const fieldExpr2 = timeUnit ? "time(" + fieldExpr(timeUnit, field4) + ")" : vgField(predicate, {expr: "datum"});
  if (isFieldEqualPredicate(predicate)) {
    return fieldExpr2 + "===" + predicateValueExpr(predicate.equal, timeUnit);
  } else if (isFieldLTPredicate(predicate)) {
    const upper = predicate.lt;
    return `${fieldExpr2}<${predicateValueExpr(upper, timeUnit)}`;
  } else if (isFieldGTPredicate(predicate)) {
    const lower2 = predicate.gt;
    return `${fieldExpr2}>${predicateValueExpr(lower2, timeUnit)}`;
  } else if (isFieldLTEPredicate(predicate)) {
    const upper = predicate.lte;
    return `${fieldExpr2}<=${predicateValueExpr(upper, timeUnit)}`;
  } else if (isFieldGTEPredicate(predicate)) {
    const lower2 = predicate.gte;
    return `${fieldExpr2}>=${predicateValueExpr(lower2, timeUnit)}`;
  } else if (isFieldOneOfPredicate(predicate)) {
    return `indexof([${predicateValuesExpr(predicate.oneOf, timeUnit).join(",")}], ${fieldExpr2}) !== -1`;
  } else if (isFieldValidPredicate(predicate)) {
    return fieldValidPredicate(fieldExpr2, predicate.valid);
  } else if (isFieldRangePredicate(predicate)) {
    const {range: range5} = predicate;
    const lower2 = isSignalRef(range5) ? {signal: `${range5.signal}[0]`} : range5[0];
    const upper = isSignalRef(range5) ? {signal: `${range5.signal}[1]`} : range5[1];
    if (lower2 !== null && upper !== null && useInRange) {
      return "inrange(" + fieldExpr2 + ", [" + predicateValueExpr(lower2, timeUnit) + ", " + predicateValueExpr(upper, timeUnit) + "])";
    }
    const exprs = [];
    if (lower2 !== null) {
      exprs.push(`${fieldExpr2} >= ${predicateValueExpr(lower2, timeUnit)}`);
    }
    if (upper !== null) {
      exprs.push(`${fieldExpr2} <= ${predicateValueExpr(upper, timeUnit)}`);
    }
    return exprs.length > 0 ? exprs.join(" && ") : "true";
  }
  throw new Error(`Invalid field predicate: ${JSON.stringify(predicate)}`);
}
function fieldValidPredicate(fieldExpr2, valid = true) {
  if (valid) {
    return `isValid(${fieldExpr2}) && isFinite(+${fieldExpr2})`;
  } else {
    return `!isValid(${fieldExpr2}) || !isFinite(+${fieldExpr2})`;
  }
}
function normalizePredicate(f) {
  var _a2;
  if (isFieldPredicate(f) && f.timeUnit) {
    return Object.assign(Object.assign({}, f), {timeUnit: (_a2 = normalizeTimeUnit(f.timeUnit)) === null || _a2 === void 0 ? void 0 : _a2.unit});
  }
  return f;
}

// node_modules/vega-lite/build/src/type.js
var Type = {
  quantitative: "quantitative",
  ordinal: "ordinal",
  temporal: "temporal",
  nominal: "nominal",
  geojson: "geojson"
};
var QUANTITATIVE = Type.quantitative;
var ORDINAL = Type.ordinal;
var TEMPORAL = Type.temporal;
var NOMINAL = Type.nominal;
var GEOJSON = Type.geojson;
var TYPES = keys3(Type);
function getFullName(type2) {
  if (type2) {
    type2 = type2.toLowerCase();
    switch (type2) {
      case "q":
      case QUANTITATIVE:
        return "quantitative";
      case "t":
      case TEMPORAL:
        return "temporal";
      case "o":
      case ORDINAL:
        return "ordinal";
      case "n":
      case NOMINAL:
        return "nominal";
      case GEOJSON:
        return "geojson";
    }
  }
  return void 0;
}

// node_modules/vega-lite/build/src/scale.js
var ScaleType = {
  LINEAR: "linear",
  LOG: "log",
  POW: "pow",
  SQRT: "sqrt",
  SYMLOG: "symlog",
  IDENTITY: "identity",
  SEQUENTIAL: "sequential",
  TIME: "time",
  UTC: "utc",
  QUANTILE: "quantile",
  QUANTIZE: "quantize",
  THRESHOLD: "threshold",
  BIN_ORDINAL: "bin-ordinal",
  ORDINAL: "ordinal",
  POINT: "point",
  BAND: "band"
};
var SCALE_CATEGORY_INDEX = {
  linear: "numeric",
  log: "numeric",
  pow: "numeric",
  sqrt: "numeric",
  symlog: "numeric",
  identity: "numeric",
  sequential: "numeric",
  time: "time",
  utc: "time",
  ordinal: "ordinal",
  "bin-ordinal": "bin-ordinal",
  point: "ordinal-position",
  band: "ordinal-position",
  quantile: "discretizing",
  quantize: "discretizing",
  threshold: "discretizing"
};
var SCALE_TYPES = keys3(SCALE_CATEGORY_INDEX);
function scaleCompatible(scaleType1, scaleType2) {
  const scaleCategory1 = SCALE_CATEGORY_INDEX[scaleType1];
  const scaleCategory2 = SCALE_CATEGORY_INDEX[scaleType2];
  return scaleCategory1 === scaleCategory2 || scaleCategory1 === "ordinal-position" && scaleCategory2 === "time" || scaleCategory2 === "ordinal-position" && scaleCategory1 === "time";
}
var SCALE_PRECEDENCE_INDEX = {
  linear: 0,
  log: 1,
  pow: 1,
  sqrt: 1,
  symlog: 1,
  identity: 1,
  sequential: 1,
  time: 0,
  utc: 0,
  point: 10,
  band: 11,
  ordinal: 0,
  "bin-ordinal": 0,
  quantile: 0,
  quantize: 0,
  threshold: 0
};
function scaleTypePrecedence(scaleType2) {
  return SCALE_PRECEDENCE_INDEX[scaleType2];
}
var CONTINUOUS_TO_CONTINUOUS_SCALES = ["linear", "log", "pow", "sqrt", "symlog", "time", "utc"];
var CONTINUOUS_TO_CONTINUOUS_INDEX = toSet_default(CONTINUOUS_TO_CONTINUOUS_SCALES);
var QUANTITATIVE_SCALES = ["linear", "log", "pow", "sqrt", "symlog"];
var QUANTITATIVE_SCALES_INDEX = toSet_default(QUANTITATIVE_SCALES);
function isQuantitative(type2) {
  return type2 in QUANTITATIVE_SCALES_INDEX;
}
var CONTINUOUS_TO_DISCRETE_SCALES = ["quantile", "quantize", "threshold"];
var CONTINUOUS_TO_DISCRETE_INDEX = toSet_default(CONTINUOUS_TO_DISCRETE_SCALES);
var CONTINUOUS_DOMAIN_SCALES = CONTINUOUS_TO_CONTINUOUS_SCALES.concat([
  "quantile",
  "quantize",
  "threshold",
  "sequential",
  "identity"
]);
var CONTINUOUS_DOMAIN_INDEX = toSet_default(CONTINUOUS_DOMAIN_SCALES);
var DISCRETE_DOMAIN_SCALES = ["ordinal", "bin-ordinal", "point", "band"];
var DISCRETE_DOMAIN_INDEX = toSet_default(DISCRETE_DOMAIN_SCALES);
function hasDiscreteDomain(type2) {
  return type2 in DISCRETE_DOMAIN_INDEX;
}
function hasContinuousDomain(type2) {
  return type2 in CONTINUOUS_DOMAIN_INDEX;
}
function isContinuousToContinuous(type2) {
  return type2 in CONTINUOUS_TO_CONTINUOUS_INDEX;
}
function isContinuousToDiscrete(type2) {
  return type2 in CONTINUOUS_TO_DISCRETE_INDEX;
}
var defaultScaleConfig = {
  pointPadding: 0.5,
  barBandPaddingInner: 0.1,
  rectBandPaddingInner: 0,
  minBandSize: 2,
  minFontSize: 8,
  maxFontSize: 40,
  minOpacity: 0.3,
  maxOpacity: 0.8,
  minSize: 9,
  minStrokeWidth: 1,
  maxStrokeWidth: 4,
  quantileCount: 4,
  quantizeCount: 4
};
function isExtendedScheme(scheme2) {
  return !isString_default(scheme2) && !!scheme2["name"];
}
function isSelectionDomain(domain4) {
  return domain4 === null || domain4 === void 0 ? void 0 : domain4["selection"];
}
function isDomainUnionWith(domain4) {
  return domain4 && domain4["unionWith"];
}
var SCALE_PROPERTY_INDEX = {
  type: 1,
  domain: 1,
  domainMid: 1,
  align: 1,
  range: 1,
  scheme: 1,
  bins: 1,
  reverse: 1,
  round: 1,
  clamp: 1,
  nice: 1,
  base: 1,
  exponent: 1,
  constant: 1,
  interpolate: 1,
  zero: 1,
  padding: 1,
  paddingInner: 1,
  paddingOuter: 1
};
var SCALE_PROPERTIES = keys3(SCALE_PROPERTY_INDEX);
var NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX = __rest(SCALE_PROPERTY_INDEX, ["type", "domain", "range", "scheme"]);
var NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES = keys3(NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX);
var SCALE_TYPE_INDEX = generateScaleTypeIndex();
function scaleTypeSupportProperty(scaleType2, propName) {
  switch (propName) {
    case "type":
    case "domain":
    case "reverse":
    case "range":
      return true;
    case "scheme":
    case "interpolate":
      return !contains2(["point", "band", "identity"], scaleType2);
    case "bins":
      return !contains2(["point", "band", "identity", "ordinal"], scaleType2);
    case "round":
      return isContinuousToContinuous(scaleType2) || scaleType2 === "band" || scaleType2 === "point";
    case "padding":
      return isContinuousToContinuous(scaleType2) || contains2(["point", "band"], scaleType2);
    case "paddingOuter":
    case "align":
      return contains2(["point", "band"], scaleType2);
    case "paddingInner":
      return scaleType2 === "band";
    case "domainMid":
    case "clamp":
      return isContinuousToContinuous(scaleType2);
    case "nice":
      return isContinuousToContinuous(scaleType2) || scaleType2 === "quantize" || scaleType2 === "threshold";
    case "exponent":
      return scaleType2 === "pow";
    case "base":
      return scaleType2 === "log";
    case "constant":
      return scaleType2 === "symlog";
    case "zero":
      return hasContinuousDomain(scaleType2) && !contains2([
        "log",
        "time",
        "utc",
        "threshold",
        "quantile"
      ], scaleType2);
  }
}
function channelScalePropertyIncompatability(channel, propName) {
  switch (propName) {
    case "interpolate":
    case "scheme":
    case "domainMid":
      if (!isColorChannel(channel)) {
        return message_exports.cannotUseScalePropertyWithNonColor(channel);
      }
      return void 0;
    case "align":
    case "type":
    case "bins":
    case "domain":
    case "range":
    case "base":
    case "exponent":
    case "constant":
    case "nice":
    case "padding":
    case "paddingInner":
    case "paddingOuter":
    case "reverse":
    case "round":
    case "clamp":
    case "zero":
      return void 0;
  }
}
function scaleTypeSupportDataType(specifiedType, fieldDefType) {
  if (contains2([ORDINAL, NOMINAL], fieldDefType)) {
    return specifiedType === void 0 || hasDiscreteDomain(specifiedType);
  } else if (fieldDefType === TEMPORAL) {
    return contains2([ScaleType.TIME, ScaleType.UTC, void 0], specifiedType);
  } else if (fieldDefType === QUANTITATIVE) {
    return contains2([
      ScaleType.LOG,
      ScaleType.POW,
      ScaleType.SQRT,
      ScaleType.SYMLOG,
      ScaleType.QUANTILE,
      ScaleType.QUANTIZE,
      ScaleType.THRESHOLD,
      ScaleType.LINEAR,
      void 0
    ], specifiedType);
  }
  return true;
}
function channelSupportScaleType(channel, scaleType2) {
  if (!isScaleChannel(channel)) {
    return false;
  }
  switch (channel) {
    case X3:
    case Y3:
    case THETA:
    case RADIUS:
      return isContinuousToContinuous(scaleType2) || contains2(["band", "point"], scaleType2);
    case SIZE2:
    case STROKEWIDTH:
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case ANGLE:
      return isContinuousToContinuous(scaleType2) || isContinuousToDiscrete(scaleType2) || contains2(["band", "point", "ordinal"], scaleType2);
    case COLOR:
    case FILL:
    case STROKE:
      return scaleType2 !== "band";
    case STROKEDASH:
      return scaleType2 === "ordinal" || isContinuousToDiscrete(scaleType2);
    case SHAPE:
      return scaleType2 === "ordinal";
  }
}
function generateScaleTypeIndex() {
  var _a2;
  const index4 = {};
  for (const channel of CHANNELS) {
    for (const fieldDefType of TYPES) {
      for (const scaleType2 of SCALE_TYPES) {
        const key2 = generateScaleTypeIndexKey(channel, fieldDefType);
        if (channelSupportScaleType(channel, scaleType2) && scaleTypeSupportDataType(scaleType2, fieldDefType)) {
          index4[key2] = (_a2 = index4[key2]) !== null && _a2 !== void 0 ? _a2 : [];
          index4[key2].push(scaleType2);
        }
      }
    }
  }
  return index4;
}
function generateScaleTypeIndexKey(channel, fieldDefType) {
  return channel + "_" + fieldDefType;
}

// node_modules/vega-lite/build/src/compile/mark/encode/valueref.js
function midPointRefWithPositionInvalidTest(params2) {
  const {channel, channelDef, markDef, scale: scale7, config} = params2;
  const ref6 = midPoint(params2);
  if (isFieldDef(channelDef) && !isCountingAggregateOp(channelDef.aggregate) && scale7 && isContinuousToContinuous(scale7.get("type")) && scale7.get("zero") === false) {
    return wrapPositionInvalidTest({
      fieldDef: channelDef,
      channel,
      markDef,
      ref: ref6,
      config
    });
  }
  return ref6;
}
function wrapPositionInvalidTest({fieldDef, channel, markDef, ref: ref6, config}) {
  if (isPathMark(markDef.type)) {
    return ref6;
  }
  const invalid = getMarkPropOrConfig("invalid", markDef, config);
  if (invalid === null) {
    return ref6;
  }
  return [fieldInvalidTestValueRef(fieldDef, channel), ref6];
}
function fieldInvalidTestValueRef(fieldDef, channel) {
  const test2 = fieldInvalidPredicate(fieldDef, true);
  const mainChannel = getMainRangeChannel(channel);
  const zeroValueRef = mainChannel === "y" ? {field: {group: "height"}} : {value: 0};
  return Object.assign({test: test2}, zeroValueRef);
}
function fieldInvalidPredicate(field4, invalid = true) {
  return fieldValidPredicate(isString_default(field4) ? field4 : vgField(field4, {expr: "datum"}), !invalid);
}
function datumDefToExpr(datumDef) {
  const {datum: datum3} = datumDef;
  if (isDateTime(datum3)) {
    return dateTimeToExpr(datum3);
  }
  return `${JSON.stringify(datum3)}`;
}
function valueRefForFieldOrDatumDef(fieldDef, scaleName, opt, encode15) {
  const ref6 = {};
  if (scaleName) {
    ref6.scale = scaleName;
  }
  if (isDatumDef(fieldDef)) {
    const {datum: datum3} = fieldDef;
    if (isDateTime(datum3)) {
      ref6.signal = dateTimeToExpr(datum3);
    } else if (isSignalRef(datum3)) {
      ref6.signal = datum3.signal;
    } else {
      ref6.value = datum3;
    }
  } else {
    ref6.field = vgField(fieldDef, opt);
  }
  if (encode15) {
    const {offset: offset4, band: band2} = encode15;
    if (offset4) {
      ref6.offset = offset4;
    }
    if (band2) {
      ref6.band = band2;
    }
  }
  return ref6;
}
function interpolatedSignalRef({scaleName, fieldOrDatumDef, fieldOrDatumDef2, offset: offset4, startSuffix, band: band2 = 0.5}) {
  const expr2 = 0 < band2 && band2 < 1 ? "datum" : void 0;
  const start = vgField(fieldOrDatumDef, {expr: expr2, suffix: startSuffix});
  const end = fieldOrDatumDef2 !== void 0 ? vgField(fieldOrDatumDef2, {expr: expr2}) : vgField(fieldOrDatumDef, {suffix: "end", expr: expr2});
  const ref6 = {};
  if (band2 === 0 || band2 === 1) {
    ref6.scale = scaleName;
    const val = band2 === 0 ? start : end;
    ref6.field = val;
  } else {
    const datum3 = `${band2} * ${start} + ${1 - band2} * ${end}`;
    ref6.signal = `scale("${scaleName}", ${datum3})`;
  }
  if (offset4) {
    ref6.offset = offset4;
  }
  return ref6;
}
function midPoint({channel, channelDef, channel2Def, markDef, config, scaleName, scale: scale7, stack: stack3, offset: offset4, defaultRef, band: band2}) {
  var _a2;
  if (channelDef) {
    if (isFieldOrDatumDef(channelDef)) {
      if (isTypedFieldDef(channelDef)) {
        band2 = band2 !== null && band2 !== void 0 ? band2 : getBand({
          channel,
          fieldDef: channelDef,
          fieldDef2: channel2Def,
          markDef,
          stack: stack3,
          config,
          isMidPoint: true
        });
        const {bin: bin4, timeUnit, type: type2} = channelDef;
        if (isBinning(bin4) || band2 && timeUnit && type2 === TEMPORAL) {
          if (stack3 && stack3.impute) {
            return valueRefForFieldOrDatumDef(channelDef, scaleName, {binSuffix: "mid"}, {offset: offset4});
          }
          if (band2) {
            return interpolatedSignalRef({scaleName, fieldOrDatumDef: channelDef, band: band2, offset: offset4});
          }
          return valueRefForFieldOrDatumDef(channelDef, scaleName, binRequiresRange(channelDef, channel) ? {binSuffix: "range"} : {}, {
            offset: offset4
          });
        } else if (isBinned(bin4)) {
          if (isFieldDef(channel2Def)) {
            return interpolatedSignalRef({
              scaleName,
              fieldOrDatumDef: channelDef,
              fieldOrDatumDef2: channel2Def,
              band: band2,
              offset: offset4
            });
          } else {
            const channel2 = channel === X3 ? X23 : Y23;
            warn3(message_exports.channelRequiredForBinned(channel2));
          }
        }
      }
      const scaleType2 = scale7 === null || scale7 === void 0 ? void 0 : scale7.get("type");
      return valueRefForFieldOrDatumDef(channelDef, scaleName, hasDiscreteDomain(scaleType2) ? {binSuffix: "range"} : {}, {
        offset: offset4,
        band: scaleType2 === "band" ? (_a2 = band2 !== null && band2 !== void 0 ? band2 : channelDef.band) !== null && _a2 !== void 0 ? _a2 : 0.5 : void 0
      });
    } else if (isValueDef(channelDef)) {
      const value3 = channelDef.value;
      const offsetMixins = offset4 ? {offset: offset4} : {};
      return Object.assign(Object.assign({}, widthHeightValueOrSignalRef(channel, value3)), offsetMixins);
    }
  }
  if (isFunction_default(defaultRef)) {
    defaultRef = defaultRef();
  }
  if (defaultRef) {
    return Object.assign(Object.assign({}, defaultRef), offset4 ? {offset: offset4} : {});
  }
  return defaultRef;
}
function widthHeightValueOrSignalRef(channel, value3) {
  if (contains2(["x", "x2"], channel) && value3 === "width") {
    return {field: {group: "width"}};
  } else if (contains2(["y", "y2"], channel) && value3 === "height") {
    return {field: {group: "height"}};
  }
  return signalOrValueRef(value3);
}

// node_modules/vega-lite/build/src/compile/format.js
function isCustomFormatType(formatType) {
  return formatType && formatType !== "number" && formatType !== "time";
}
function customFormatExpr(formatType, field4, format8) {
  return `${formatType}(${field4}${format8 ? `, ${JSON.stringify(format8)}` : ""})`;
}
var BIN_RANGE_DELIMITER = " \u2013 ";
function formatSignalRef({fieldOrDatumDef, format: format8, formatType, expr: expr2, normalizeStack, config}) {
  var _a2, _b;
  if (isCustomFormatType(formatType)) {
    return formatCustomType({
      fieldOrDatumDef,
      format: format8,
      formatType,
      expr: expr2,
      config
    });
  }
  const field4 = fieldToFormat(fieldOrDatumDef, expr2, normalizeStack);
  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {
    const signal = timeFormatExpression(field4, isFieldDef(fieldOrDatumDef) ? (_a2 = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a2 === void 0 ? void 0 : _a2.unit : void 0, format8, config.timeFormat, isScaleFieldDef(fieldOrDatumDef) && ((_b = fieldOrDatumDef.scale) === null || _b === void 0 ? void 0 : _b.type) === ScaleType.UTC);
    return signal ? {signal} : void 0;
  }
  format8 = numberFormat(channelDefType(fieldOrDatumDef), format8, config);
  if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {
    const endField = vgField(fieldOrDatumDef, {expr: expr2, binSuffix: "end"});
    return {
      signal: binFormatExpression(field4, endField, format8, formatType, config)
    };
  } else if (format8 || channelDefType(fieldOrDatumDef) === "quantitative") {
    return {
      signal: `${formatExpr(field4, format8)}`
    };
  } else {
    return {signal: `isValid(${field4}) ? ${field4} : ""+${field4}`};
  }
}
function fieldToFormat(fieldOrDatumDef, expr2, normalizeStack) {
  if (isFieldDef(fieldOrDatumDef)) {
    if (normalizeStack) {
      return `${vgField(fieldOrDatumDef, {expr: expr2, suffix: "end"})}-${vgField(fieldOrDatumDef, {
        expr: expr2,
        suffix: "start"
      })}`;
    } else {
      return vgField(fieldOrDatumDef, {expr: expr2});
    }
  } else {
    return datumDefToExpr(fieldOrDatumDef);
  }
}
function formatCustomType({fieldOrDatumDef, format: format8, formatType, expr: expr2, normalizeStack, config, field: field4}) {
  field4 = field4 !== null && field4 !== void 0 ? field4 : fieldToFormat(fieldOrDatumDef, expr2, normalizeStack);
  if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {
    const endField = vgField(fieldOrDatumDef, {expr: expr2, binSuffix: "end"});
    return {
      signal: binFormatExpression(field4, endField, format8, formatType, config)
    };
  }
  return {signal: customFormatExpr(formatType, field4, format8)};
}
function guideFormat(fieldOrDatumDef, type2, format8, formatType, config, omitTimeFormatConfig) {
  var _a2;
  if (isCustomFormatType(formatType)) {
    return void 0;
  }
  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {
    const timeUnit = isFieldDef(fieldOrDatumDef) ? (_a2 = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a2 === void 0 ? void 0 : _a2.unit : void 0;
    return timeFormat4(format8, timeUnit, config, omitTimeFormatConfig);
  }
  return numberFormat(type2, format8, config);
}
function guideFormatType(formatType, fieldOrDatumDef, scaleType2) {
  if (formatType && (isSignalRef(formatType) || formatType === "number" || formatType === "time")) {
    return formatType;
  }
  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) && scaleType2 !== "time" && scaleType2 !== "utc") {
    return "time";
  }
  return void 0;
}
function numberFormat(type2, specifiedFormat, config) {
  if (isString_default(specifiedFormat)) {
    return specifiedFormat;
  }
  if (type2 === QUANTITATIVE) {
    return config.numberFormat;
  }
  return void 0;
}
function timeFormat4(specifiedFormat, timeUnit, config, omitTimeFormatConfig) {
  if (specifiedFormat) {
    return specifiedFormat;
  }
  if (timeUnit) {
    return {
      signal: timeUnitSpecifierExpression(timeUnit)
    };
  }
  return omitTimeFormatConfig ? void 0 : config.timeFormat;
}
function formatExpr(field4, format8) {
  return `format(${field4}, "${format8 || ""}")`;
}
function binNumberFormatExpr(field4, format8, formatType, config) {
  var _a2;
  if (isCustomFormatType(formatType)) {
    return customFormatExpr(formatType, field4, format8);
  }
  return formatExpr(field4, (_a2 = isString_default(format8) ? format8 : void 0) !== null && _a2 !== void 0 ? _a2 : config.numberFormat);
}
function binFormatExpression(startField, endField, format8, formatType, config) {
  const start = binNumberFormatExpr(startField, format8, formatType, config);
  const end = binNumberFormatExpr(endField, format8, formatType, config);
  return `${fieldValidPredicate(startField, false)} ? "null" : ${start} + "${BIN_RANGE_DELIMITER}" + ${end}`;
}
function timeFormatExpression(field4, timeUnit, format8, rawTimeFormat, isUTCScale) {
  if (!timeUnit || format8) {
    format8 = isString_default(format8) ? format8 : rawTimeFormat;
    return `${isUTCScale ? "utc" : "time"}Format(${field4}, '${format8}')`;
  } else {
    return formatExpression(timeUnit, field4, isUTCScale);
  }
}

// node_modules/vega-lite/build/src/sort.js
var DEFAULT_SORT_OP = "min";
var SORT_BY_CHANNEL_INDEX = {
  x: 1,
  y: 1,
  color: 1,
  fill: 1,
  stroke: 1,
  strokeWidth: 1,
  size: 1,
  shape: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  opacity: 1,
  text: 1
};
function isSortByChannel(c2) {
  return c2 in SORT_BY_CHANNEL_INDEX;
}
function isSortByEncoding(sort2) {
  return !!sort2 && !!sort2["encoding"];
}
function isSortField(sort2) {
  return !!sort2 && (sort2["op"] === "count" || !!sort2["field"]);
}
function isSortArray(sort2) {
  return !!sort2 && isArray_default(sort2);
}

// node_modules/vega-lite/build/src/spec/facet.js
function isFacetMapping(f) {
  return "row" in f || "column" in f;
}
function isFacetFieldDef(channelDef) {
  return !!channelDef && "header" in channelDef;
}
function isFacetSpec(spec) {
  return "facet" in spec;
}

// node_modules/vega-lite/build/src/channeldef.js
function isConditionalSelection(c2) {
  return c2["selection"];
}
function isRepeatRef(field4) {
  return field4 && !isString_default(field4) && "repeat" in field4;
}
function toFieldDefBase(fieldDef) {
  const {field: field4, timeUnit, bin: bin4, aggregate} = fieldDef;
  return Object.assign(Object.assign(Object.assign(Object.assign({}, timeUnit ? {timeUnit} : {}), bin4 ? {bin: bin4} : {}), aggregate ? {aggregate} : {}), {field: field4});
}
function isSortableFieldDef(fieldDef) {
  return isTypedFieldDef(fieldDef) && "sort" in fieldDef;
}
function getBand({channel, fieldDef, fieldDef2, markDef: mark2, stack: stack3, config, isMidPoint}) {
  if (isFieldOrDatumDef(fieldDef) && fieldDef.band !== void 0) {
    return fieldDef.band;
  }
  if (isFieldDef(fieldDef)) {
    const {timeUnit, bin: bin4} = fieldDef;
    if (timeUnit && !fieldDef2) {
      if (isMidPoint) {
        return getMarkConfig("timeUnitBandPosition", mark2, config);
      } else {
        return isRectBasedMark(mark2.type) ? getMarkConfig("timeUnitBand", mark2, config) : 0;
      }
    } else if (isBinning(bin4)) {
      return isRectBasedMark(mark2.type) && !isMidPoint ? 1 : 0.5;
    }
  }
  if ((stack3 === null || stack3 === void 0 ? void 0 : stack3.fieldChannel) === channel && isMidPoint) {
    return 0.5;
  }
  return void 0;
}
function hasBand(channel, fieldDef, fieldDef2, stack3, markDef, config) {
  if (isBinning(fieldDef.bin) || fieldDef.timeUnit && isTypedFieldDef(fieldDef) && fieldDef.type === "temporal") {
    return !!getBand({channel, fieldDef, fieldDef2, stack: stack3, markDef, config});
  }
  return false;
}
function isConditionalDef(channelDef) {
  return !!channelDef && "condition" in channelDef;
}
function hasConditionalFieldDef(channelDef) {
  const condition = channelDef && channelDef["condition"];
  return !!condition && !isArray_default(condition) && isFieldDef(condition);
}
function hasConditionalFieldOrDatumDef(channelDef) {
  const condition = channelDef && channelDef["condition"];
  return !!condition && !isArray_default(condition) && isFieldOrDatumDef(condition);
}
function hasConditionalValueDef(channelDef) {
  const condition = channelDef && channelDef["condition"];
  return !!condition && (isArray_default(condition) || isValueDef(condition));
}
function isFieldDef(channelDef) {
  return !!channelDef && (!!channelDef["field"] || channelDef["aggregate"] === "count");
}
function channelDefType(channelDef) {
  return channelDef && channelDef["type"];
}
function isDatumDef(channelDef) {
  return !!channelDef && "datum" in channelDef;
}
function isContinuousFieldOrDatumDef(cd) {
  return isTypedFieldDef(cd) && isContinuous2(cd) || isNumericDataDef(cd);
}
function isNumericDataDef(cd) {
  return isDatumDef(cd) && isNumber_default(cd.datum);
}
function isFieldOrDatumDef(channelDef) {
  return isFieldDef(channelDef) || isDatumDef(channelDef);
}
function isTypedFieldDef(channelDef) {
  return !!channelDef && ("field" in channelDef && "type" in channelDef || channelDef["aggregate"] === "count");
}
function isValueDef(channelDef) {
  return channelDef && "value" in channelDef && "value" in channelDef;
}
function isScaleFieldDef(channelDef) {
  return !!channelDef && ("scale" in channelDef || "sort" in channelDef);
}
function isPositionFieldOrDatumDef(channelDef) {
  return channelDef && ("axis" in channelDef || "stack" in channelDef || "impute" in channelDef);
}
function isMarkPropFieldOrDatumDef(channelDef) {
  return !!channelDef && "legend" in channelDef;
}
function isTextFieldOrDatumDef(channelDef) {
  return !!channelDef && ("format" in channelDef || "formatType" in channelDef);
}
function isOpFieldDef(fieldDef) {
  return "op" in fieldDef;
}
function vgField(fieldDef, opt = {}) {
  var _a2, _b, _c;
  let field4 = fieldDef.field;
  const prefix = opt.prefix;
  let suffix = opt.suffix;
  let argAccessor = "";
  if (isCount(fieldDef)) {
    field4 = internalField("count");
  } else {
    let fn;
    if (!opt.nofn) {
      if (isOpFieldDef(fieldDef)) {
        fn = fieldDef.op;
      } else {
        const {bin: bin4, aggregate, timeUnit} = fieldDef;
        if (isBinning(bin4)) {
          fn = binToString(bin4);
          suffix = ((_a2 = opt.binSuffix) !== null && _a2 !== void 0 ? _a2 : "") + ((_b = opt.suffix) !== null && _b !== void 0 ? _b : "");
        } else if (aggregate) {
          if (isArgmaxDef(aggregate)) {
            argAccessor = `["${field4}"]`;
            field4 = `argmax_${aggregate.argmax}`;
          } else if (isArgminDef(aggregate)) {
            argAccessor = `["${field4}"]`;
            field4 = `argmin_${aggregate.argmin}`;
          } else {
            fn = String(aggregate);
          }
        } else if (timeUnit) {
          fn = timeUnitToString(timeUnit);
          suffix = (!contains2(["range", "mid"], opt.binSuffix) && opt.binSuffix || "") + ((_c = opt.suffix) !== null && _c !== void 0 ? _c : "");
        }
      }
    }
    if (fn) {
      field4 = field4 ? `${fn}_${field4}` : fn;
    }
  }
  if (suffix) {
    field4 = `${field4}_${suffix}`;
  }
  if (prefix) {
    field4 = `${prefix}_${field4}`;
  }
  if (opt.forAs) {
    return removePathFromField(field4);
  } else if (opt.expr) {
    return flatAccessWithDatum(field4, opt.expr) + argAccessor;
  } else {
    return replacePathInField(field4) + argAccessor;
  }
}
function isDiscrete2(def2) {
  switch (def2.type) {
    case "nominal":
    case "ordinal":
    case "geojson":
      return true;
    case "quantitative":
      return isFieldDef(def2) && !!def2.bin;
    case "temporal":
      return false;
  }
  throw new Error(message_exports.invalidFieldType(def2.type));
}
function isContinuous2(fieldDef) {
  return !isDiscrete2(fieldDef);
}
function isCount(fieldDef) {
  return fieldDef.aggregate === "count";
}
function verbalTitleFormatter(fieldDef, config) {
  var _a2;
  const {field: field4, bin: bin4, timeUnit, aggregate} = fieldDef;
  if (aggregate === "count") {
    return config.countTitle;
  } else if (isBinning(bin4)) {
    return `${field4} (binned)`;
  } else if (timeUnit) {
    const unit2 = (_a2 = normalizeTimeUnit(timeUnit)) === null || _a2 === void 0 ? void 0 : _a2.unit;
    if (unit2) {
      return `${field4} (${getTimeUnitParts(unit2).join("-")})`;
    }
  } else if (aggregate) {
    if (isArgmaxDef(aggregate)) {
      return `${field4} for max ${aggregate.argmax}`;
    } else if (isArgminDef(aggregate)) {
      return `${field4} for min ${aggregate.argmin}`;
    } else {
      return `${titleCase(aggregate)} of ${field4}`;
    }
  }
  return field4;
}
function functionalTitleFormatter(fieldDef) {
  const {aggregate, bin: bin4, timeUnit, field: field4} = fieldDef;
  if (isArgmaxDef(aggregate)) {
    return `${field4} for argmax(${aggregate.argmax})`;
  } else if (isArgminDef(aggregate)) {
    return `${field4} for argmin(${aggregate.argmin})`;
  }
  const timeUnitParams = normalizeTimeUnit(timeUnit);
  const fn = aggregate || (timeUnitParams === null || timeUnitParams === void 0 ? void 0 : timeUnitParams.unit) || (timeUnitParams === null || timeUnitParams === void 0 ? void 0 : timeUnitParams.maxbins) && "timeunit" || isBinning(bin4) && "bin";
  if (fn) {
    return fn.toUpperCase() + "(" + field4 + ")";
  } else {
    return field4;
  }
}
var defaultTitleFormatter = (fieldDef, config) => {
  switch (config.fieldTitle) {
    case "plain":
      return fieldDef.field;
    case "functional":
      return functionalTitleFormatter(fieldDef);
    default:
      return verbalTitleFormatter(fieldDef, config);
  }
};
var titleFormatter = defaultTitleFormatter;
function setTitleFormatter(formatter) {
  titleFormatter = formatter;
}
function resetTitleFormatter() {
  setTitleFormatter(defaultTitleFormatter);
}
function title(fieldOrDatumDef, config, {allowDisabling, includeDefault = true}) {
  var _a2, _b;
  const guide = (_a2 = getGuide(fieldOrDatumDef)) !== null && _a2 !== void 0 ? _a2 : {};
  const guideTitle = guide.title;
  if (!isFieldDef(fieldOrDatumDef)) {
    return guideTitle;
  }
  const fieldDef = fieldOrDatumDef;
  const def2 = includeDefault ? defaultTitle(fieldDef, config) : void 0;
  if (allowDisabling) {
    return getFirstDefined(guideTitle, fieldDef.title, def2);
  } else {
    return (_b = guideTitle !== null && guideTitle !== void 0 ? guideTitle : fieldDef.title) !== null && _b !== void 0 ? _b : def2;
  }
}
function getGuide(fieldDef) {
  if (isPositionFieldOrDatumDef(fieldDef) && fieldDef.axis) {
    return fieldDef.axis;
  } else if (isMarkPropFieldOrDatumDef(fieldDef) && fieldDef.legend) {
    return fieldDef.legend;
  } else if (isFacetFieldDef(fieldDef) && fieldDef.header) {
    return fieldDef.header;
  }
  return void 0;
}
function defaultTitle(fieldDef, config) {
  return titleFormatter(fieldDef, config);
}
function getFormatMixins(fieldDef) {
  var _a2;
  if (isTextFieldOrDatumDef(fieldDef)) {
    const {format: format8, formatType} = fieldDef;
    return {format: format8, formatType};
  } else {
    const guide = (_a2 = getGuide(fieldDef)) !== null && _a2 !== void 0 ? _a2 : {};
    const {format: format8, formatType} = guide;
    return {format: format8, formatType};
  }
}
function defaultType(fieldDef, channel) {
  if (fieldDef.timeUnit) {
    return "temporal";
  }
  if (isBinning(fieldDef.bin)) {
    return "quantitative";
  }
  switch (rangeType(channel)) {
    case "continuous":
      return "quantitative";
    case "discrete":
      return "nominal";
    case "flexible":
      return "nominal";
    default:
      return "quantitative";
  }
}
function getFieldDef(channelDef) {
  if (isFieldDef(channelDef)) {
    return channelDef;
  } else if (hasConditionalFieldDef(channelDef)) {
    return channelDef.condition;
  }
  return void 0;
}
function getFieldOrDatumDef(channelDef) {
  if (isFieldOrDatumDef(channelDef)) {
    return channelDef;
  } else if (hasConditionalFieldOrDatumDef(channelDef)) {
    return channelDef.condition;
  }
  return void 0;
}
function initChannelDef(channelDef, channel, config) {
  if (isString_default(channelDef) || isNumber_default(channelDef) || isBoolean_default(channelDef)) {
    const primitiveType = isString_default(channelDef) ? "string" : isNumber_default(channelDef) ? "number" : "boolean";
    warn3(message_exports.primitiveChannelDef(channel, primitiveType, channelDef));
    return {value: channelDef};
  }
  if (isFieldOrDatumDef(channelDef)) {
    return initFieldOrDatumDef(channelDef, channel, config);
  } else if (hasConditionalFieldOrDatumDef(channelDef)) {
    return Object.assign(Object.assign({}, channelDef), {
      condition: initFieldOrDatumDef(channelDef.condition, channel, config)
    });
  }
  return channelDef;
}
function initFieldOrDatumDef(fd, channel, config) {
  if (isTextFieldOrDatumDef(fd)) {
    const {format: format8, formatType} = fd, rest = __rest(fd, ["format", "formatType"]);
    if (isCustomFormatType(formatType) && !config.customFormatTypes) {
      warn3(message_exports.customFormatTypeNotAllowed(channel));
      return initFieldOrDatumDef(rest, channel, config);
    }
  } else {
    const guideType = isPositionFieldOrDatumDef(fd) ? "axis" : isMarkPropFieldOrDatumDef(fd) ? "legend" : isFacetFieldDef(fd) ? "header" : null;
    if (guideType && fd[guideType]) {
      const _a2 = fd[guideType], {format: format8, formatType} = _a2, newGuide = __rest(_a2, ["format", "formatType"]);
      if (isCustomFormatType(formatType) && !config.customFormatTypes) {
        warn3(message_exports.customFormatTypeNotAllowed(channel));
        return initFieldOrDatumDef(Object.assign(Object.assign({}, fd), {[guideType]: newGuide}), channel, config);
      }
    }
  }
  if (isFieldDef(fd)) {
    return initFieldDef(fd, channel);
  }
  return initDatumDef(fd);
}
function initDatumDef(datumDef) {
  let type2 = datumDef["type"];
  if (type2) {
    return datumDef;
  }
  const {datum: datum3} = datumDef;
  type2 = isNumber_default(datum3) ? "quantitative" : isString_default(datum3) ? "nominal" : isDateTime(datum3) ? "temporal" : void 0;
  return Object.assign(Object.assign({}, datumDef), {type: type2});
}
function initFieldDef(fd, channel) {
  const {aggregate, timeUnit, bin: bin4, field: field4} = fd;
  const fieldDef = Object.assign({}, fd);
  if (aggregate && !isAggregateOp(aggregate) && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {
    warn3(message_exports.invalidAggregate(aggregate));
    delete fieldDef.aggregate;
  }
  if (timeUnit) {
    fieldDef.timeUnit = normalizeTimeUnit(timeUnit);
  }
  if (field4) {
    fieldDef.field = `${field4}`;
  }
  if (isBinning(bin4)) {
    fieldDef.bin = normalizeBin(bin4, channel);
  }
  if (isBinned(bin4) && !isXorY(channel)) {
    warn3(`Channel ${channel} should not be used with "binned" bin.`);
  }
  if (isTypedFieldDef(fieldDef)) {
    const {type: type2} = fieldDef;
    const fullType = getFullName(type2);
    if (type2 !== fullType) {
      fieldDef.type = fullType;
    }
    if (type2 !== "quantitative") {
      if (isCountingAggregateOp(aggregate)) {
        warn3(message_exports.invalidFieldTypeForCountAggregate(type2, aggregate));
        fieldDef.type = "quantitative";
      }
    }
  } else if (!isSecondaryRangeChannel(channel)) {
    const newType = defaultType(fieldDef, channel);
    warn3(message_exports.missingFieldType(channel, newType));
    fieldDef["type"] = newType;
  }
  if (isTypedFieldDef(fieldDef)) {
    const {compatible, warning} = channelCompatibility(fieldDef, channel);
    if (!compatible) {
      warn3(warning);
    }
  }
  if (isSortableFieldDef(fieldDef) && isString_default(fieldDef.sort)) {
    const {sort: sort2} = fieldDef;
    if (isSortByChannel(sort2)) {
      return Object.assign(Object.assign({}, fieldDef), {sort: {encoding: sort2}});
    }
    const sub = sort2.substr(1);
    if (sort2.charAt(0) === "-" && isSortByChannel(sub)) {
      return Object.assign(Object.assign({}, fieldDef), {sort: {encoding: sub, order: "descending"}});
    }
  }
  if (isFacetFieldDef(fieldDef)) {
    const {header} = fieldDef;
    const {orient: orient3} = header, rest = __rest(header, ["orient"]);
    if (orient3) {
      return Object.assign(Object.assign({}, fieldDef), {header: Object.assign(Object.assign({}, rest), {labelOrient: header.labelOrient || orient3, titleOrient: header.titleOrient || orient3})});
    }
  }
  return fieldDef;
}
function normalizeBin(bin4, channel) {
  if (isBoolean_default(bin4)) {
    return {maxbins: autoMaxBins(channel)};
  } else if (bin4 === "binned") {
    return {
      binned: true
    };
  } else if (!bin4.maxbins && !bin4.step) {
    return Object.assign(Object.assign({}, bin4), {maxbins: autoMaxBins(channel)});
  } else {
    return bin4;
  }
}
var COMPATIBLE = {compatible: true};
function channelCompatibility(fieldDef, channel) {
  const type2 = fieldDef.type;
  if (type2 === "geojson" && channel !== "shape") {
    return {
      compatible: false,
      warning: `Channel ${channel} should not be used with a geojson data.`
    };
  }
  switch (channel) {
    case ROW:
    case COLUMN:
    case FACET:
      if (isContinuous2(fieldDef)) {
        return {
          compatible: false,
          warning: message_exports.facetChannelShouldBeDiscrete(channel)
        };
      }
      return COMPATIBLE;
    case X3:
    case Y3:
    case COLOR:
    case FILL:
    case STROKE:
    case TEXT2:
    case DETAIL:
    case KEY:
    case TOOLTIP:
    case HREF:
    case URL2:
    case ANGLE:
    case THETA:
    case RADIUS:
    case DESCRIPTION:
      return COMPATIBLE;
    case LONGITUDE:
    case LONGITUDE2:
    case LATITUDE:
    case LATITUDE2:
      if (type2 !== QUANTITATIVE) {
        return {
          compatible: false,
          warning: `Channel ${channel} should be used with a quantitative field only, not ${fieldDef.type} field.`
        };
      }
      return COMPATIBLE;
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case STROKEWIDTH:
    case SIZE2:
    case THETA2:
    case RADIUS2:
    case X23:
    case Y23:
      if (type2 === "nominal" && !fieldDef["sort"]) {
        return {
          compatible: false,
          warning: `Channel ${channel} should not be used with an unsorted discrete field.`
        };
      }
      return COMPATIBLE;
    case STROKEDASH:
      if (!contains2(["ordinal", "nominal"], fieldDef.type)) {
        return {
          compatible: false,
          warning: "StrokeDash channel should be used with only discrete data."
        };
      }
      return COMPATIBLE;
    case SHAPE:
      if (!contains2(["ordinal", "nominal", "geojson"], fieldDef.type)) {
        return {
          compatible: false,
          warning: "Shape channel should be used with only either discrete or geojson data."
        };
      }
      return COMPATIBLE;
    case ORDER:
      if (fieldDef.type === "nominal" && !("sort" in fieldDef)) {
        return {
          compatible: false,
          warning: `Channel order is inappropriate for nominal field, which has no inherent order.`
        };
      }
      return COMPATIBLE;
  }
}
function isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) {
  const {formatType} = getFormatMixins(fieldOrDatumDef);
  return formatType === "time" || !formatType && isTimeFieldDef(fieldOrDatumDef);
}
function isTimeFieldDef(def2) {
  return def2 && (def2["type"] === "temporal" || isFieldDef(def2) && !!def2.timeUnit);
}
function valueExpr(v, {timeUnit, type: type2, wrapTime, undefinedIfExprNotRequired}) {
  var _a2;
  const unit2 = timeUnit && ((_a2 = normalizeTimeUnit(timeUnit)) === null || _a2 === void 0 ? void 0 : _a2.unit);
  let isTime = unit2 || type2 === "temporal";
  let expr2;
  if (isSignalRef(v)) {
    expr2 = v.signal;
  } else if (isDateTime(v)) {
    isTime = true;
    expr2 = dateTimeToExpr(v);
  } else if (isString_default(v) || isNumber_default(v)) {
    if (isTime) {
      expr2 = `datetime(${JSON.stringify(v)})`;
      if (isLocalSingleTimeUnit(unit2)) {
        if (isNumber_default(v) && v < 1e4 || isString_default(v) && isNaN(Date.parse(v))) {
          expr2 = dateTimeToExpr({[unit2]: v});
        }
      }
    }
  }
  if (expr2) {
    return wrapTime && isTime ? `time(${expr2})` : expr2;
  }
  return undefinedIfExprNotRequired ? void 0 : JSON.stringify(v);
}
function valueArray(fieldOrDatumDef, values4) {
  const {type: type2} = fieldOrDatumDef;
  return values4.map((v) => {
    const expr2 = valueExpr(v, {
      timeUnit: isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.timeUnit : void 0,
      type: type2,
      undefinedIfExprNotRequired: true
    });
    if (expr2 !== void 0) {
      return {signal: expr2};
    }
    return v;
  });
}
function binRequiresRange(fieldDef, channel) {
  if (!isBinning(fieldDef.bin)) {
    console.warn("Only call this method for binned field defs.");
    return false;
  }
  return isScaleChannel(channel) && contains2(["ordinal", "nominal"], fieldDef.type);
}

// node_modules/vega-lite/build/src/title.js
function extractTitleConfig(titleConfig) {
  const {
    anchor,
    frame: frame2,
    offset: offset4,
    orient: orient3,
    color: color5,
    subtitleColor,
    subtitleFont,
    subtitleFontSize,
    subtitleFontStyle,
    subtitleFontWeight,
    subtitleLineHeight,
    subtitlePadding
  } = titleConfig, rest = __rest(titleConfig, ["anchor", "frame", "offset", "orient", "color", "subtitleColor", "subtitleFont", "subtitleFontSize", "subtitleFontStyle", "subtitleFontWeight", "subtitleLineHeight", "subtitlePadding"]);
  const titleMarkConfig = Object.assign(Object.assign({}, rest), color5 ? {fill: color5} : {});
  const nonMark = Object.assign(Object.assign(Object.assign(Object.assign({}, anchor ? {anchor} : {}), frame2 ? {frame: frame2} : {}), offset4 ? {offset: offset4} : {}), orient3 ? {orient: orient3} : {});
  const subtitle = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, subtitleColor ? {subtitleColor} : {}), subtitleFont ? {subtitleFont} : {}), subtitleFontSize ? {subtitleFontSize} : {}), subtitleFontStyle ? {subtitleFontStyle} : {}), subtitleFontWeight ? {subtitleFontWeight} : {}), subtitleLineHeight ? {subtitleLineHeight} : {}), subtitlePadding ? {subtitlePadding} : {});
  const subtitleMarkConfig = pick2(titleMarkConfig, ["align", "baseline", "dx", "dy", "limit"]);
  return {titleMarkConfig, subtitleMarkConfig, nonMark, subtitle};
}
function isText(v) {
  return isString_default(v) || isArray_default(v) && isString_default(v[0]);
}

// node_modules/vega-lite/build/src/compile/common.js
function signalOrValueRef(value3) {
  if (isSignalRef(value3)) {
    return value3;
  }
  return value3 !== void 0 ? {value: value3} : void 0;
}
function exprFromValueOrSignalRef(ref6) {
  if (isSignalRef(ref6)) {
    return ref6.signal;
  }
  return $2(ref6.value);
}
function signalOrStringValue(v) {
  if (isSignalRef(v)) {
    return v.signal;
  }
  return v == null ? null : $2(v);
}
function applyMarkConfig(e, model, propsList) {
  for (const property2 of propsList) {
    const value3 = getMarkConfig(property2, model.markDef, model.config);
    if (value3 !== void 0) {
      e[property2] = signalOrValueRef(value3);
    }
  }
  return e;
}
function getStyles(mark2) {
  var _a2;
  return [].concat(mark2.type, (_a2 = mark2.style) !== null && _a2 !== void 0 ? _a2 : []);
}
function getMarkPropOrConfig(channel, mark2, config, opt = {}) {
  const {vgChannel, ignoreVgConfig} = opt;
  if (vgChannel && mark2[vgChannel] !== void 0) {
    return mark2[vgChannel];
  } else if (mark2[channel] !== void 0) {
    return mark2[channel];
  } else if (ignoreVgConfig && (!vgChannel || vgChannel === channel)) {
    return void 0;
  }
  return getMarkConfig(channel, mark2, config, opt);
}
function getMarkConfig(channel, mark2, config, {vgChannel} = {}) {
  return getFirstDefined(vgChannel ? getMarkStyleConfig(channel, mark2, config.style) : void 0, getMarkStyleConfig(channel, mark2, config.style), vgChannel ? config[mark2.type][vgChannel] : void 0, config[mark2.type][channel], vgChannel ? config.mark[vgChannel] : config.mark[channel]);
}
function getMarkStyleConfig(prop, mark2, styleConfigIndex) {
  return getStyleConfig(prop, getStyles(mark2), styleConfigIndex);
}
function getStyleConfig(p, styles2, styleConfigIndex) {
  styles2 = array_default4(styles2);
  let value3;
  for (const style2 of styles2) {
    const styleConfig = styleConfigIndex[style2];
    if (styleConfig && styleConfig[p] !== void 0) {
      value3 = styleConfig[p];
    }
  }
  return value3;
}
function sortParams(orderDef, fieldRefOption) {
  return array_default4(orderDef).reduce((s, orderChannelDef) => {
    var _a2;
    s.field.push(vgField(orderChannelDef, fieldRefOption));
    s.order.push((_a2 = orderChannelDef.sort) !== null && _a2 !== void 0 ? _a2 : "ascending");
    return s;
  }, {field: [], order: []});
}
function mergeTitleFieldDefs(f1, f2) {
  const merged = [...f1];
  f2.forEach((fdToMerge) => {
    for (const fieldDef1 of merged) {
      if (deepEqual(fieldDef1, fdToMerge)) {
        return;
      }
    }
    merged.push(fdToMerge);
  });
  return merged;
}
function mergeTitle(title1, title2) {
  if (deepEqual(title1, title2) || !title2) {
    return title1;
  } else if (!title1) {
    return title2;
  } else {
    return [...array_default4(title1), ...array_default4(title2)].join(", ");
  }
}
function mergeTitleComponent(v1, v2) {
  const v1Val = v1.value;
  const v2Val = v2.value;
  if (v1Val == null || v2Val === null) {
    return {
      explicit: v1.explicit,
      value: null
    };
  } else if ((isText(v1Val) || isSignalRef(v1Val)) && (isText(v2Val) || isSignalRef(v2Val))) {
    return {
      explicit: v1.explicit,
      value: mergeTitle(v1Val, v2Val)
    };
  } else if (isText(v1Val) || isSignalRef(v1Val)) {
    return {
      explicit: v1.explicit,
      value: v1Val
    };
  } else if (isText(v2Val) || isSignalRef(v2Val)) {
    return {
      explicit: v1.explicit,
      value: v2Val
    };
  } else if (!isText(v1Val) && !isSignalRef(v1Val) && !isText(v2Val) && !isSignalRef(v2Val)) {
    return {
      explicit: v1.explicit,
      value: mergeTitleFieldDefs(v1Val, v2Val)
    };
  }
  throw new Error("It should never reach here");
}

// node_modules/vega-lite/build/src/encoding.js
function channelHasField(encoding, channel) {
  const channelDef = encoding && encoding[channel];
  if (channelDef) {
    if (isArray_default(channelDef)) {
      return some(channelDef, (fieldDef) => !!fieldDef.field);
    } else {
      return isFieldDef(channelDef) || hasConditionalFieldDef(channelDef);
    }
  }
  return false;
}
function isAggregate(encoding) {
  return some(CHANNELS, (channel) => {
    if (channelHasField(encoding, channel)) {
      const channelDef = encoding[channel];
      if (isArray_default(channelDef)) {
        return some(channelDef, (fieldDef) => !!fieldDef.aggregate);
      } else {
        const fieldDef = getFieldDef(channelDef);
        return fieldDef && !!fieldDef.aggregate;
      }
    }
    return false;
  });
}
function extractTransformsFromEncoding(oldEncoding, config) {
  const groupby = [];
  const bins2 = [];
  const timeUnits2 = [];
  const aggregate = [];
  const encoding = {};
  forEach(oldEncoding, (channelDef, channel) => {
    if (isFieldDef(channelDef)) {
      const {field: field4, aggregate: aggOp, bin: bin4, timeUnit} = channelDef, remaining = __rest(channelDef, ["field", "aggregate", "bin", "timeUnit"]);
      if (aggOp || timeUnit || bin4) {
        const guide = getGuide(channelDef);
        const isTitleDefined = guide && guide.title;
        let newField = vgField(channelDef, {forAs: true});
        const newFieldDef = Object.assign(Object.assign(Object.assign({}, isTitleDefined ? [] : {title: title(channelDef, config, {allowDisabling: true})}), remaining), {
          field: newField
        });
        if (aggOp) {
          let op;
          if (isArgmaxDef(aggOp)) {
            op = "argmax";
            newField = vgField({op: "argmax", field: aggOp.argmax}, {forAs: true});
            newFieldDef.field = `${newField}.${field4}`;
          } else if (isArgminDef(aggOp)) {
            op = "argmin";
            newField = vgField({op: "argmin", field: aggOp.argmin}, {forAs: true});
            newFieldDef.field = `${newField}.${field4}`;
          } else if (aggOp !== "boxplot" && aggOp !== "errorbar" && aggOp !== "errorband") {
            op = aggOp;
          }
          if (op) {
            const aggregateEntry = {
              op,
              as: newField
            };
            if (field4) {
              aggregateEntry.field = field4;
            }
            aggregate.push(aggregateEntry);
          }
        } else {
          groupby.push(newField);
          if (isTypedFieldDef(channelDef) && isBinning(bin4)) {
            bins2.push({bin: bin4, field: field4, as: newField});
            groupby.push(vgField(channelDef, {binSuffix: "end"}));
            if (binRequiresRange(channelDef, channel)) {
              groupby.push(vgField(channelDef, {binSuffix: "range"}));
            }
            if (isXorY(channel)) {
              const secondaryChannel = {
                field: newField + "_end"
              };
              encoding[channel + "2"] = secondaryChannel;
            }
            newFieldDef.bin = "binned";
            if (!isSecondaryRangeChannel(channel)) {
              newFieldDef["type"] = QUANTITATIVE;
            }
          } else if (timeUnit) {
            timeUnits2.push({
              timeUnit,
              field: field4,
              as: newField
            });
            const formatType = isTypedFieldDef(channelDef) && channelDef.type !== TEMPORAL && "time";
            if (formatType) {
              if (channel === TEXT2 || channel === TOOLTIP) {
                newFieldDef["formatType"] = formatType;
              } else if (isNonPositionScaleChannel(channel)) {
                newFieldDef["legend"] = Object.assign({formatType}, newFieldDef["legend"]);
              } else if (isXorY(channel)) {
                newFieldDef["axis"] = Object.assign({formatType}, newFieldDef["axis"]);
              }
            }
          }
        }
        encoding[channel] = newFieldDef;
      } else {
        groupby.push(field4);
        encoding[channel] = oldEncoding[channel];
      }
    } else {
      encoding[channel] = oldEncoding[channel];
    }
  });
  return {
    bins: bins2,
    timeUnits: timeUnits2,
    aggregate,
    groupby,
    encoding
  };
}
function markChannelCompatible(encoding, channel, mark2) {
  const markSupported = supportMark(channel, mark2);
  if (!markSupported) {
    return false;
  } else if (markSupported === "binned") {
    const primaryFieldDef = encoding[channel === X23 ? X3 : Y3];
    if (isFieldDef(primaryFieldDef) && isFieldDef(encoding[channel]) && isBinned(primaryFieldDef.bin)) {
      return true;
    } else {
      return false;
    }
  }
  return true;
}
function initEncoding(encoding, markDef, config) {
  const mark2 = markDef.type;
  return keys3(encoding).reduce((normalizedEncoding, channel) => {
    if (!isChannel(channel)) {
      warn3(message_exports.invalidEncodingChannel(channel));
      return normalizedEncoding;
    }
    const channelDef = encoding[channel];
    if (channel === "angle" && mark2 === "arc" && !encoding.theta) {
      warn3(message_exports.REPLACE_ANGLE_WITH_THETA);
      channel = THETA;
    }
    if (!markChannelCompatible(encoding, channel, mark2)) {
      warn3(message_exports.incompatibleChannel(channel, mark2));
      return normalizedEncoding;
    }
    if (channel === SIZE2 && mark2 === "line") {
      const fieldDef = getFieldDef(encoding[channel]);
      if (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.aggregate) {
        warn3(message_exports.LINE_WITH_VARYING_SIZE);
        return normalizedEncoding;
      }
    }
    if (channel === COLOR && (markDef.filled ? "fill" in encoding : "stroke" in encoding)) {
      warn3(message_exports.droppingColor("encoding", {fill: "fill" in encoding, stroke: "stroke" in encoding}));
      return normalizedEncoding;
    }
    if (channel === DETAIL || channel === ORDER && !isArray_default(channelDef) && !isValueDef(channelDef) || channel === TOOLTIP && isArray_default(channelDef)) {
      if (channelDef) {
        normalizedEncoding[channel] = array_default4(channelDef).reduce((defs, fieldDef) => {
          if (!isFieldDef(fieldDef)) {
            warn3(message_exports.emptyFieldDef(fieldDef, channel));
          } else {
            defs.push(initFieldDef(fieldDef, channel));
          }
          return defs;
        }, []);
      }
    } else {
      if (channel === TOOLTIP && channelDef === null) {
        normalizedEncoding[channel] = null;
      } else if (!isFieldDef(channelDef) && !isDatumDef(channelDef) && !isValueDef(channelDef) && !isConditionalDef(channelDef) && !isSignalRef(channelDef)) {
        warn3(message_exports.emptyFieldDef(channelDef, channel));
        return normalizedEncoding;
      }
      normalizedEncoding[channel] = initChannelDef(channelDef, channel, config);
    }
    return normalizedEncoding;
  }, {});
}
function fieldDefs(encoding) {
  const arr = [];
  for (const channel of keys3(encoding)) {
    if (channelHasField(encoding, channel)) {
      const channelDef = encoding[channel];
      const channelDefArray = array_default4(channelDef);
      for (const def2 of channelDefArray) {
        if (isFieldDef(def2)) {
          arr.push(def2);
        } else if (hasConditionalFieldDef(def2)) {
          arr.push(def2.condition);
        }
      }
    }
  }
  return arr;
}
function forEach(mapping, f, thisArg) {
  if (!mapping) {
    return;
  }
  for (const channel of keys3(mapping)) {
    const el = mapping[channel];
    if (isArray_default(el)) {
      for (const channelDef of el) {
        f.call(thisArg, channelDef, channel);
      }
    } else {
      f.call(thisArg, el, channel);
    }
  }
}
function reduce(mapping, f, init2, thisArg) {
  if (!mapping) {
    return init2;
  }
  return keys3(mapping).reduce((r2, channel) => {
    const map4 = mapping[channel];
    if (isArray_default(map4)) {
      return map4.reduce((r1, channelDef) => {
        return f.call(thisArg, r1, channelDef, channel);
      }, r2);
    } else {
      return f.call(thisArg, r2, map4, channel);
    }
  }, init2);
}
function pathGroupingFields(mark2, encoding) {
  return keys3(encoding).reduce((details, channel) => {
    switch (channel) {
      case X3:
      case Y3:
      case HREF:
      case DESCRIPTION:
      case URL2:
      case X23:
      case Y23:
      case THETA:
      case THETA2:
      case RADIUS:
      case RADIUS2:
      case LATITUDE:
      case LONGITUDE:
      case LATITUDE2:
      case LONGITUDE2:
      case TEXT2:
      case SHAPE:
      case ANGLE:
      case TOOLTIP:
        return details;
      case ORDER:
        if (mark2 === "line" || mark2 === "trail") {
          return details;
        }
      case DETAIL:
      case KEY: {
        const channelDef = encoding[channel];
        if (isArray_default(channelDef) || isFieldDef(channelDef)) {
          for (const fieldDef of array_default4(channelDef)) {
            if (!fieldDef.aggregate) {
              details.push(vgField(fieldDef, {}));
            }
          }
        }
        return details;
      }
      case SIZE2:
        if (mark2 === "trail") {
          return details;
        }
      case COLOR:
      case FILL:
      case STROKE:
      case OPACITY:
      case FILLOPACITY:
      case STROKEOPACITY:
      case STROKEDASH:
      case STROKEWIDTH: {
        const fieldDef = getFieldDef(encoding[channel]);
        if (fieldDef && !fieldDef.aggregate) {
          details.push(vgField(fieldDef, {}));
        }
        return details;
      }
    }
  }, []);
}

// node_modules/vega-lite/build/src/compositemark/common.js
function filterTooltipWithAggregatedField(oldEncoding) {
  const {tooltip: tooltip2} = oldEncoding, filteredEncoding = __rest(oldEncoding, ["tooltip"]);
  if (!tooltip2) {
    return {filteredEncoding: oldEncoding};
  }
  let customTooltipWithAggregatedField;
  let customTooltipWithoutAggregatedField;
  if (isArray_default(tooltip2)) {
    for (const t of tooltip2) {
      if (t.aggregate) {
        if (!customTooltipWithAggregatedField) {
          customTooltipWithAggregatedField = [];
        }
        customTooltipWithAggregatedField.push(t);
      } else {
        if (!customTooltipWithoutAggregatedField) {
          customTooltipWithoutAggregatedField = [];
        }
        customTooltipWithoutAggregatedField.push(t);
      }
    }
    if (customTooltipWithAggregatedField) {
      filteredEncoding.tooltip = customTooltipWithAggregatedField;
    }
  } else {
    if (tooltip2["aggregate"]) {
      filteredEncoding.tooltip = tooltip2;
    } else {
      customTooltipWithoutAggregatedField = tooltip2;
    }
  }
  if (isArray_default(customTooltipWithoutAggregatedField) && customTooltipWithoutAggregatedField.length === 1) {
    customTooltipWithoutAggregatedField = customTooltipWithoutAggregatedField[0];
  }
  return {customTooltipWithoutAggregatedField, filteredEncoding};
}
function getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, withFieldName = true) {
  if ("tooltip" in encodingWithoutContinuousAxis) {
    return {tooltip: encodingWithoutContinuousAxis.tooltip};
  }
  const fiveSummaryTooltip = tooltipSummary.map(({fieldPrefix, titlePrefix}) => {
    const mainTitle = withFieldName ? ` of ${continuousAxisChannelDef.field}` : "";
    return {
      field: fieldPrefix + continuousAxisChannelDef.field,
      type: continuousAxisChannelDef.type,
      title: isSignalRef(titlePrefix) ? {signal: titlePrefix + `"${escape(mainTitle)}"`} : titlePrefix + mainTitle
    };
  });
  return {
    tooltip: [
      ...fiveSummaryTooltip,
      ...fieldDefs(encodingWithoutContinuousAxis)
    ]
  };
}
function getTitle(continuousAxisChannelDef) {
  const {axis, title: title2, field: field4} = continuousAxisChannelDef;
  return axis && axis.title !== void 0 ? void 0 : getFirstDefined(title2, field4);
}
function makeCompositeAggregatePartFactory(compositeMarkDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, compositeMarkConfig) {
  const {scale: scale7, axis} = continuousAxisChannelDef;
  return ({partName, mark: mark2, positionPrefix, endPositionPrefix = void 0, aria: aria2, extraEncoding = {}}) => {
    const title2 = getTitle(continuousAxisChannelDef);
    return partLayerMixins(compositeMarkDef, partName, compositeMarkConfig, aria2, {
      mark: mark2,
      encoding: Object.assign(Object.assign(Object.assign({[continuousAxis]: Object.assign(Object.assign(Object.assign({field: positionPrefix + "_" + continuousAxisChannelDef.field, type: continuousAxisChannelDef.type}, title2 !== void 0 ? {title: title2} : {}), scale7 !== void 0 ? {scale: scale7} : {}), axis !== void 0 ? {axis} : {})}, isString_default(endPositionPrefix) ? {
        [continuousAxis + "2"]: {
          field: endPositionPrefix + "_" + continuousAxisChannelDef.field
        }
      } : {}), sharedEncoding), extraEncoding)
    });
  };
}
function partLayerMixins(markDef, part, compositeMarkConfig, aria2, partBaseSpec) {
  const {clip: clip3, color: color5, opacity: opacity2} = markDef;
  const mark2 = markDef.type;
  if (markDef[part] || markDef[part] === void 0 && compositeMarkConfig[part]) {
    return [
      Object.assign(Object.assign({}, partBaseSpec), {mark: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, compositeMarkConfig[part]), clip3 ? {clip: clip3} : {}), color5 ? {color: color5} : {}), opacity2 ? {opacity: opacity2} : {}), isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : {type: partBaseSpec.mark}), {style: `${mark2}-${part}`}), isBoolean_default(markDef[part]) ? {} : markDef[part]), aria2 === false ? {aria: aria2} : {})})
    ];
  }
  return [];
}
function compositeMarkContinuousAxis(spec, orient3, compositeMark) {
  const {encoding} = spec;
  const continuousAxis = orient3 === "vertical" ? "y" : "x";
  const continuousAxisChannelDef = encoding[continuousAxis];
  const continuousAxisChannelDef2 = encoding[continuousAxis + "2"];
  const continuousAxisChannelDefError = encoding[continuousAxis + "Error"];
  const continuousAxisChannelDefError2 = encoding[continuousAxis + "Error2"];
  return {
    continuousAxisChannelDef: filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark),
    continuousAxisChannelDef2: filterAggregateFromChannelDef(continuousAxisChannelDef2, compositeMark),
    continuousAxisChannelDefError: filterAggregateFromChannelDef(continuousAxisChannelDefError, compositeMark),
    continuousAxisChannelDefError2: filterAggregateFromChannelDef(continuousAxisChannelDefError2, compositeMark),
    continuousAxis
  };
}
function filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark) {
  if (continuousAxisChannelDef && continuousAxisChannelDef.aggregate) {
    const {aggregate} = continuousAxisChannelDef, continuousAxisWithoutAggregate = __rest(continuousAxisChannelDef, ["aggregate"]);
    if (aggregate !== compositeMark) {
      warn3(message_exports.errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));
    }
    return continuousAxisWithoutAggregate;
  } else {
    return continuousAxisChannelDef;
  }
}
function compositeMarkOrient(spec, compositeMark) {
  const {mark: mark2, encoding} = spec;
  const {x: x5, y: y5} = encoding;
  if (isContinuousFieldOrDatumDef(x5)) {
    if (isContinuousFieldOrDatumDef(y5)) {
      const xAggregate = isFieldDef(x5) && x5.aggregate;
      const yAggregate = isFieldDef(y5) && y5.aggregate;
      if (!xAggregate && yAggregate === compositeMark) {
        return "vertical";
      } else if (!yAggregate && xAggregate === compositeMark) {
        return "horizontal";
      } else if (xAggregate === compositeMark && yAggregate === compositeMark) {
        throw new Error("Both x and y cannot have aggregate");
      } else {
        if (isMarkDef(mark2) && mark2.orient) {
          return mark2.orient;
        }
        return "vertical";
      }
    }
    return "horizontal";
  } else if (isContinuousFieldOrDatumDef(y5)) {
    return "vertical";
  } else {
    throw new Error("Need a valid continuous axis for " + compositeMark + "s");
  }
}

// node_modules/vega-lite/build/src/compositemark/boxplot.js
var BOXPLOT = "boxplot";
var BOXPLOT_PARTS = ["box", "median", "outliers", "rule", "ticks"];
var boxPlotNormalizer = new CompositeMarkNormalizer(BOXPLOT, normalizeBoxPlot);
function getBoxPlotType(extent2) {
  if (isNumber_default(extent2)) {
    return "tukey";
  }
  return extent2;
}
function normalizeBoxPlot(spec, {config}) {
  var _a2, _b;
  const {mark: mark2, encoding: _encoding, selection: selection2, projection: _p} = spec, outerSpec = __rest(spec, ["mark", "encoding", "selection", "projection"]);
  const markDef = isMarkDef(mark2) ? mark2 : {type: mark2};
  if (selection2) {
    warn3(message_exports.selectionNotSupported("boxplot"));
  }
  const extent2 = (_a2 = markDef.extent) !== null && _a2 !== void 0 ? _a2 : config.boxplot.extent;
  const sizeValue = getMarkPropOrConfig("size", markDef, config);
  const boxPlotType = getBoxPlotType(extent2);
  const {transform: transform4, continuousAxisChannelDef, continuousAxis, groupby, aggregate, encodingWithoutContinuousAxis, ticksOrient, boxOrient, customTooltipWithoutAggregatedField} = boxParams(spec, extent2, config);
  const {color: color5, size} = encodingWithoutContinuousAxis, encodingWithoutSizeColorAndContinuousAxis = __rest(encodingWithoutContinuousAxis, ["color", "size"]);
  const makeBoxPlotPart = (sharedEncoding) => {
    return makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, config.boxplot);
  };
  const makeBoxPlotExtent = makeBoxPlotPart(encodingWithoutSizeColorAndContinuousAxis);
  const makeBoxPlotBox = makeBoxPlotPart(encodingWithoutContinuousAxis);
  const makeBoxPlotMidTick = makeBoxPlotPart(Object.assign(Object.assign({}, encodingWithoutSizeColorAndContinuousAxis), size ? {size} : {}));
  const fiveSummaryTooltipEncoding = getCompositeMarkTooltip([
    {fieldPrefix: boxPlotType === "min-max" ? "upper_whisker_" : "max_", titlePrefix: "Max"},
    {fieldPrefix: "upper_box_", titlePrefix: "Q3"},
    {fieldPrefix: "mid_box_", titlePrefix: "Median"},
    {fieldPrefix: "lower_box_", titlePrefix: "Q1"},
    {fieldPrefix: boxPlotType === "min-max" ? "lower_whisker_" : "min_", titlePrefix: "Min"}
  ], continuousAxisChannelDef, encodingWithoutContinuousAxis);
  const endTick = {type: "tick", color: "black", opacity: 1, orient: ticksOrient, invalid: null};
  const whiskerTooltipEncoding = boxPlotType === "min-max" ? fiveSummaryTooltipEncoding : getCompositeMarkTooltip([
    {fieldPrefix: "upper_whisker_", titlePrefix: "Upper Whisker"},
    {fieldPrefix: "lower_whisker_", titlePrefix: "Lower Whisker"}
  ], continuousAxisChannelDef, encodingWithoutContinuousAxis);
  const whiskerLayers = [
    ...makeBoxPlotExtent({
      partName: "rule",
      mark: {type: "rule", invalid: null},
      positionPrefix: "lower_whisker",
      endPositionPrefix: "lower_box",
      aria: false,
      extraEncoding: whiskerTooltipEncoding
    }),
    ...makeBoxPlotExtent({
      partName: "rule",
      mark: {type: "rule", invalid: null},
      positionPrefix: "upper_box",
      endPositionPrefix: "upper_whisker",
      aria: false,
      extraEncoding: whiskerTooltipEncoding
    }),
    ...makeBoxPlotExtent({
      partName: "ticks",
      mark: endTick,
      positionPrefix: "lower_whisker",
      aria: false,
      extraEncoding: whiskerTooltipEncoding
    }),
    ...makeBoxPlotExtent({
      partName: "ticks",
      mark: endTick,
      positionPrefix: "upper_whisker",
      aria: false,
      extraEncoding: whiskerTooltipEncoding
    })
  ];
  const boxLayers = [
    ...boxPlotType !== "tukey" ? whiskerLayers : [],
    ...makeBoxPlotBox({
      partName: "box",
      mark: Object.assign(Object.assign({type: "bar"}, sizeValue ? {size: sizeValue} : {}), {orient: boxOrient, invalid: null}),
      positionPrefix: "lower_box",
      endPositionPrefix: "upper_box",
      aria: false,
      extraEncoding: fiveSummaryTooltipEncoding
    }),
    ...makeBoxPlotMidTick({
      partName: "median",
      mark: Object.assign(Object.assign(Object.assign({type: "tick", invalid: null}, isObject_default(config.boxplot.median) && config.boxplot.median.color ? {color: config.boxplot.median.color} : {}), sizeValue ? {size: sizeValue} : {}), {orient: ticksOrient, ariaRoleDescription: "box"}),
      positionPrefix: "mid_box",
      extraEncoding: fiveSummaryTooltipEncoding
    })
  ];
  let filteredLayersMixins;
  if (boxPlotType !== "min-max") {
    const lowerBoxExpr = `datum["lower_box_${continuousAxisChannelDef.field}"]`;
    const upperBoxExpr = `datum["upper_box_${continuousAxisChannelDef.field}"]`;
    const iqrExpr = `(${upperBoxExpr} - ${lowerBoxExpr})`;
    const lowerWhiskerExpr = `${lowerBoxExpr} - ${extent2} * ${iqrExpr}`;
    const upperWhiskerExpr = `${upperBoxExpr} + ${extent2} * ${iqrExpr}`;
    const fieldExpr2 = `datum["${continuousAxisChannelDef.field}"]`;
    const joinaggregateTransform = {
      joinaggregate: boxParamsQuartiles(continuousAxisChannelDef.field),
      groupby
    };
    let filteredWhiskerSpec = void 0;
    if (boxPlotType === "tukey") {
      filteredWhiskerSpec = {
        transform: [
          {
            filter: `(${lowerWhiskerExpr} <= ${fieldExpr2}) && (${fieldExpr2} <= ${upperWhiskerExpr})`
          },
          {
            aggregate: [
              {
                op: "min",
                field: continuousAxisChannelDef.field,
                as: "lower_whisker_" + continuousAxisChannelDef.field
              },
              {
                op: "max",
                field: continuousAxisChannelDef.field,
                as: "upper_whisker_" + continuousAxisChannelDef.field
              },
              {
                op: "min",
                field: "lower_box_" + continuousAxisChannelDef.field,
                as: "lower_box_" + continuousAxisChannelDef.field
              },
              {
                op: "max",
                field: "upper_box_" + continuousAxisChannelDef.field,
                as: "upper_box_" + continuousAxisChannelDef.field
              },
              ...aggregate
            ],
            groupby
          }
        ],
        layer: whiskerLayers
      };
    }
    const {tooltip: tooltip2} = encodingWithoutSizeColorAndContinuousAxis, encodingWithoutSizeColorContinuousAxisAndTooltip = __rest(encodingWithoutSizeColorAndContinuousAxis, ["tooltip"]);
    const {scale: scale7, axis} = continuousAxisChannelDef;
    const title2 = getTitle(continuousAxisChannelDef);
    const outlierLayersMixins = partLayerMixins(markDef, "outliers", config.boxplot, true, {
      transform: [{filter: `(${fieldExpr2} < ${lowerWhiskerExpr}) || (${fieldExpr2} > ${upperWhiskerExpr})`}],
      mark: "point",
      encoding: Object.assign(Object.assign({[continuousAxis]: Object.assign(Object.assign(Object.assign({field: continuousAxisChannelDef.field, type: continuousAxisChannelDef.type}, title2 !== void 0 ? {title: title2} : {}), scale7 !== void 0 ? {scale: scale7} : {}), axis !== void 0 ? {axis} : {})}, encodingWithoutSizeColorContinuousAxisAndTooltip), customTooltipWithoutAggregatedField ? {tooltip: customTooltipWithoutAggregatedField} : {})
    })[0];
    if (outlierLayersMixins && filteredWhiskerSpec) {
      filteredLayersMixins = {
        transform: [joinaggregateTransform],
        layer: [outlierLayersMixins, filteredWhiskerSpec]
      };
    } else if (outlierLayersMixins) {
      filteredLayersMixins = outlierLayersMixins;
      filteredLayersMixins.transform.unshift(joinaggregateTransform);
    } else if (filteredWhiskerSpec) {
      filteredLayersMixins = filteredWhiskerSpec;
      filteredLayersMixins.transform.unshift(joinaggregateTransform);
    }
  }
  if (filteredLayersMixins) {
    return Object.assign(Object.assign({}, outerSpec), {layer: [
      filteredLayersMixins,
      {
        transform: transform4,
        layer: boxLayers
      }
    ]});
  }
  return Object.assign(Object.assign({}, outerSpec), {transform: ((_b = outerSpec.transform) !== null && _b !== void 0 ? _b : []).concat(transform4), layer: boxLayers});
}
function boxParamsQuartiles(continousAxisField) {
  return [
    {
      op: "q1",
      field: continousAxisField,
      as: "lower_box_" + continousAxisField
    },
    {
      op: "q3",
      field: continousAxisField,
      as: "upper_box_" + continousAxisField
    }
  ];
}
function boxParams(spec, extent2, config) {
  const orient3 = compositeMarkOrient(spec, BOXPLOT);
  const {continuousAxisChannelDef, continuousAxis} = compositeMarkContinuousAxis(spec, orient3, BOXPLOT);
  const continuousFieldName = continuousAxisChannelDef.field;
  const boxPlotType = getBoxPlotType(extent2);
  const boxplotSpecificAggregate = [
    ...boxParamsQuartiles(continuousFieldName),
    {
      op: "median",
      field: continuousFieldName,
      as: "mid_box_" + continuousFieldName
    },
    {
      op: "min",
      field: continuousFieldName,
      as: (boxPlotType === "min-max" ? "lower_whisker_" : "min_") + continuousFieldName
    },
    {
      op: "max",
      field: continuousFieldName,
      as: (boxPlotType === "min-max" ? "upper_whisker_" : "max_") + continuousFieldName
    }
  ];
  const postAggregateCalculates = boxPlotType === "min-max" || boxPlotType === "tukey" ? [] : [
    {
      calculate: `datum["upper_box_${continuousFieldName}"] - datum["lower_box_${continuousFieldName}"]`,
      as: "iqr_" + continuousFieldName
    },
    {
      calculate: `min(datum["upper_box_${continuousFieldName}"] + datum["iqr_${continuousFieldName}"] * ${extent2}, datum["max_${continuousFieldName}"])`,
      as: "upper_whisker_" + continuousFieldName
    },
    {
      calculate: `max(datum["lower_box_${continuousFieldName}"] - datum["iqr_${continuousFieldName}"] * ${extent2}, datum["min_${continuousFieldName}"])`,
      as: "lower_whisker_" + continuousFieldName
    }
  ];
  const _a2 = spec.encoding, _b = continuousAxis, oldContinuousAxisChannelDef = _a2[_b], oldEncodingWithoutContinuousAxis = __rest(_a2, [typeof _b === "symbol" ? _b : _b + ""]);
  const {customTooltipWithoutAggregatedField, filteredEncoding} = filterTooltipWithAggregatedField(oldEncodingWithoutContinuousAxis);
  const {bins: bins2, timeUnits: timeUnits2, aggregate, groupby, encoding: encodingWithoutContinuousAxis} = extractTransformsFromEncoding(filteredEncoding, config);
  const ticksOrient = orient3 === "vertical" ? "horizontal" : "vertical";
  const boxOrient = orient3;
  const transform4 = [
    ...bins2,
    ...timeUnits2,
    {
      aggregate: [...aggregate, ...boxplotSpecificAggregate],
      groupby
    },
    ...postAggregateCalculates
  ];
  return {
    transform: transform4,
    groupby,
    aggregate,
    continuousAxisChannelDef,
    continuousAxis,
    encodingWithoutContinuousAxis,
    ticksOrient,
    boxOrient,
    customTooltipWithoutAggregatedField
  };
}

// node_modules/vega-lite/build/src/compositemark/errorbar.js
var ERRORBAR = "errorbar";
var ERRORBAR_PARTS = ["ticks", "rule"];
var errorBarNormalizer = new CompositeMarkNormalizer(ERRORBAR, normalizeErrorBar);
function normalizeErrorBar(spec, {config}) {
  const {transform: transform4, continuousAxisChannelDef, continuousAxis, encodingWithoutContinuousAxis, ticksOrient, markDef, outerSpec, tooltipEncoding} = errorBarParams(spec, ERRORBAR, config);
  const makeErrorBarPart = makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorbar);
  const tick2 = {type: "tick", orient: ticksOrient};
  const layer2 = [
    ...makeErrorBarPart({
      partName: "ticks",
      mark: tick2,
      positionPrefix: "lower",
      aria: false,
      extraEncoding: tooltipEncoding
    }),
    ...makeErrorBarPart({
      partName: "ticks",
      mark: tick2,
      positionPrefix: "upper",
      aria: false,
      extraEncoding: tooltipEncoding
    }),
    ...makeErrorBarPart({
      partName: "rule",
      mark: {
        type: "rule",
        ariaRoleDescription: "errorbar"
      },
      positionPrefix: "lower",
      endPositionPrefix: "upper",
      extraEncoding: tooltipEncoding
    })
  ];
  return Object.assign(Object.assign(Object.assign({}, outerSpec), {transform: transform4}), layer2.length > 1 ? {layer: layer2} : Object.assign({}, layer2[0]));
}
function errorBarOrientAndInputType(spec, compositeMark) {
  const {encoding} = spec;
  if (errorBarIsInputTypeRaw(encoding)) {
    return {
      orient: compositeMarkOrient(spec, compositeMark),
      inputType: "raw"
    };
  }
  const isTypeAggregatedUpperLower = errorBarIsInputTypeAggregatedUpperLower(encoding);
  const isTypeAggregatedError = errorBarIsInputTypeAggregatedError(encoding);
  const x5 = encoding.x;
  const y5 = encoding.y;
  if (isTypeAggregatedUpperLower) {
    if (isTypeAggregatedError) {
      throw new Error(`${compositeMark} cannot be both type aggregated-upper-lower and aggregated-error`);
    }
    const x22 = encoding.x2;
    const y22 = encoding.y2;
    if (isFieldOrDatumDef(x22) && isFieldOrDatumDef(y22)) {
      throw new Error(`${compositeMark} cannot have both x2 and y2`);
    } else if (isFieldOrDatumDef(x22)) {
      if (isContinuousFieldOrDatumDef(x5)) {
        return {orient: "horizontal", inputType: "aggregated-upper-lower"};
      } else {
        throw new Error(`Both x and x2 have to be quantitative in ${compositeMark}`);
      }
    } else if (isFieldOrDatumDef(y22)) {
      if (isContinuousFieldOrDatumDef(y5)) {
        return {orient: "vertical", inputType: "aggregated-upper-lower"};
      } else {
        throw new Error(`Both y and y2 have to be quantitative in ${compositeMark}`);
      }
    }
    throw new Error("No ranged axis");
  } else {
    const xError = encoding.xError;
    const xError2 = encoding.xError2;
    const yError = encoding.yError;
    const yError2 = encoding.yError2;
    if (isFieldOrDatumDef(xError2) && !isFieldOrDatumDef(xError)) {
      throw new Error(`${compositeMark} cannot have xError2 without xError`);
    }
    if (isFieldOrDatumDef(yError2) && !isFieldOrDatumDef(yError)) {
      throw new Error(`${compositeMark} cannot have yError2 without yError`);
    }
    if (isFieldOrDatumDef(xError) && isFieldOrDatumDef(yError)) {
      throw new Error(`${compositeMark} cannot have both xError and yError with both are quantiative`);
    } else if (isFieldOrDatumDef(xError)) {
      if (isContinuousFieldOrDatumDef(x5)) {
        return {orient: "horizontal", inputType: "aggregated-error"};
      } else {
        throw new Error("All x, xError, and xError2 (if exist) have to be quantitative");
      }
    } else if (isFieldOrDatumDef(yError)) {
      if (isContinuousFieldOrDatumDef(y5)) {
        return {orient: "vertical", inputType: "aggregated-error"};
      } else {
        throw new Error("All y, yError, and yError2 (if exist) have to be quantitative");
      }
    }
    throw new Error("No ranged axis");
  }
}
function errorBarIsInputTypeRaw(encoding) {
  return (isFieldOrDatumDef(encoding.x) || isFieldOrDatumDef(encoding.y)) && !isFieldOrDatumDef(encoding.x2) && !isFieldOrDatumDef(encoding.y2) && !isFieldOrDatumDef(encoding.xError) && !isFieldOrDatumDef(encoding.xError2) && !isFieldOrDatumDef(encoding.yError) && !isFieldOrDatumDef(encoding.yError2);
}
function errorBarIsInputTypeAggregatedUpperLower(encoding) {
  return isFieldOrDatumDef(encoding.x2) || isFieldOrDatumDef(encoding.y2);
}
function errorBarIsInputTypeAggregatedError(encoding) {
  return isFieldOrDatumDef(encoding.xError) || isFieldOrDatumDef(encoding.xError2) || isFieldOrDatumDef(encoding.yError) || isFieldOrDatumDef(encoding.yError2);
}
function errorBarParams(spec, compositeMark, config) {
  var _a2;
  const {mark: mark2, encoding, selection: selection2, projection: _p} = spec, outerSpec = __rest(spec, ["mark", "encoding", "selection", "projection"]);
  const markDef = isMarkDef(mark2) ? mark2 : {type: mark2};
  if (selection2) {
    warn3(message_exports.selectionNotSupported(compositeMark));
  }
  const {orient: orient3, inputType} = errorBarOrientAndInputType(spec, compositeMark);
  const {continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, continuousAxis} = compositeMarkContinuousAxis(spec, orient3, compositeMark);
  const {errorBarSpecificAggregate, postAggregateCalculates, tooltipSummary, tooltipTitleWithFieldName} = errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config);
  const _b = encoding, _c = continuousAxis, oldContinuousAxisChannelDef = _b[_c], _d = continuousAxis === "x" ? "x2" : "y2", oldContinuousAxisChannelDef2 = _b[_d], _e = continuousAxis === "x" ? "xError" : "yError", oldContinuousAxisChannelDefError = _b[_e], _f = continuousAxis === "x" ? "xError2" : "yError2", oldContinuousAxisChannelDefError2 = _b[_f], oldEncodingWithoutContinuousAxis = __rest(_b, [typeof _c === "symbol" ? _c : _c + "", typeof _d === "symbol" ? _d : _d + "", typeof _e === "symbol" ? _e : _e + "", typeof _f === "symbol" ? _f : _f + ""]);
  const {bins: bins2, timeUnits: timeUnits2, aggregate: oldAggregate, groupby: oldGroupBy, encoding: encodingWithoutContinuousAxis} = extractTransformsFromEncoding(oldEncodingWithoutContinuousAxis, config);
  const aggregate = [...oldAggregate, ...errorBarSpecificAggregate];
  const groupby = inputType !== "raw" ? [] : oldGroupBy;
  const tooltipEncoding = getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, tooltipTitleWithFieldName);
  return {
    transform: [
      ...(_a2 = outerSpec.transform) !== null && _a2 !== void 0 ? _a2 : [],
      ...bins2,
      ...timeUnits2,
      ...aggregate.length === 0 ? [] : [{aggregate, groupby}],
      ...postAggregateCalculates
    ],
    groupby,
    continuousAxisChannelDef,
    continuousAxis,
    encodingWithoutContinuousAxis,
    ticksOrient: orient3 === "vertical" ? "horizontal" : "vertical",
    markDef,
    outerSpec,
    tooltipEncoding
  };
}
function errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config) {
  let errorBarSpecificAggregate = [];
  let postAggregateCalculates = [];
  const continuousFieldName = continuousAxisChannelDef.field;
  let tooltipSummary;
  let tooltipTitleWithFieldName = false;
  if (inputType === "raw") {
    const center = markDef.center ? markDef.center : markDef.extent ? markDef.extent === "iqr" ? "median" : "mean" : config.errorbar.center;
    const extent2 = markDef.extent ? markDef.extent : center === "mean" ? "stderr" : "iqr";
    if (center === "median" !== (extent2 === "iqr")) {
      warn3(message_exports.errorBarCenterIsUsedWithWrongExtent(center, extent2, compositeMark));
    }
    if (extent2 === "stderr" || extent2 === "stdev") {
      errorBarSpecificAggregate = [
        {op: extent2, field: continuousFieldName, as: "extent_" + continuousFieldName},
        {op: center, field: continuousFieldName, as: "center_" + continuousFieldName}
      ];
      postAggregateCalculates = [
        {
          calculate: `datum["center_${continuousFieldName}"] + datum["extent_${continuousFieldName}"]`,
          as: "upper_" + continuousFieldName
        },
        {
          calculate: `datum["center_${continuousFieldName}"] - datum["extent_${continuousFieldName}"]`,
          as: "lower_" + continuousFieldName
        }
      ];
      tooltipSummary = [
        {fieldPrefix: "center_", titlePrefix: titleCase(center)},
        {fieldPrefix: "upper_", titlePrefix: getTitlePrefix(center, extent2, "+")},
        {fieldPrefix: "lower_", titlePrefix: getTitlePrefix(center, extent2, "-")}
      ];
      tooltipTitleWithFieldName = true;
    } else {
      if (markDef.center && markDef.extent) {
        warn3(message_exports.errorBarCenterIsNotNeeded(markDef.extent, compositeMark));
      }
      let centerOp;
      let lowerExtentOp;
      let upperExtentOp;
      if (extent2 === "ci") {
        centerOp = "mean";
        lowerExtentOp = "ci0";
        upperExtentOp = "ci1";
      } else {
        centerOp = "median";
        lowerExtentOp = "q1";
        upperExtentOp = "q3";
      }
      errorBarSpecificAggregate = [
        {op: lowerExtentOp, field: continuousFieldName, as: "lower_" + continuousFieldName},
        {op: upperExtentOp, field: continuousFieldName, as: "upper_" + continuousFieldName},
        {op: centerOp, field: continuousFieldName, as: "center_" + continuousFieldName}
      ];
      tooltipSummary = [
        {
          fieldPrefix: "upper_",
          titlePrefix: title({field: continuousFieldName, aggregate: upperExtentOp, type: "quantitative"}, config, {
            allowDisabling: false
          })
        },
        {
          fieldPrefix: "lower_",
          titlePrefix: title({field: continuousFieldName, aggregate: lowerExtentOp, type: "quantitative"}, config, {
            allowDisabling: false
          })
        },
        {
          fieldPrefix: "center_",
          titlePrefix: title({field: continuousFieldName, aggregate: centerOp, type: "quantitative"}, config, {
            allowDisabling: false
          })
        }
      ];
    }
  } else {
    if (markDef.center || markDef.extent) {
      warn3(message_exports.errorBarCenterAndExtentAreNotNeeded(markDef.center, markDef.extent));
    }
    if (inputType === "aggregated-upper-lower") {
      tooltipSummary = [];
      postAggregateCalculates = [
        {calculate: `datum["${continuousAxisChannelDef2.field}"]`, as: "upper_" + continuousFieldName},
        {calculate: `datum["${continuousFieldName}"]`, as: "lower_" + continuousFieldName}
      ];
    } else if (inputType === "aggregated-error") {
      tooltipSummary = [{fieldPrefix: "", titlePrefix: continuousFieldName}];
      postAggregateCalculates = [
        {
          calculate: `datum["${continuousFieldName}"] + datum["${continuousAxisChannelDefError.field}"]`,
          as: "upper_" + continuousFieldName
        }
      ];
      if (continuousAxisChannelDefError2) {
        postAggregateCalculates.push({
          calculate: `datum["${continuousFieldName}"] + datum["${continuousAxisChannelDefError2.field}"]`,
          as: "lower_" + continuousFieldName
        });
      } else {
        postAggregateCalculates.push({
          calculate: `datum["${continuousFieldName}"] - datum["${continuousAxisChannelDefError.field}"]`,
          as: "lower_" + continuousFieldName
        });
      }
    }
    for (const postAggregateCalculate of postAggregateCalculates) {
      tooltipSummary.push({
        fieldPrefix: postAggregateCalculate.as.substring(0, 6),
        titlePrefix: replaceAll(replaceAll(postAggregateCalculate.calculate, 'datum["', ""), '"]', "")
      });
    }
  }
  return {postAggregateCalculates, errorBarSpecificAggregate, tooltipSummary, tooltipTitleWithFieldName};
}
function getTitlePrefix(center, extent2, operation) {
  return titleCase(center) + " " + operation + " " + extent2;
}

// node_modules/vega-lite/build/src/compositemark/errorband.js
var ERRORBAND = "errorband";
var ERRORBAND_PARTS = ["band", "borders"];
var errorBandNormalizer = new CompositeMarkNormalizer(ERRORBAND, normalizeErrorBand);
function normalizeErrorBand(spec, {config}) {
  const {transform: transform4, continuousAxisChannelDef, continuousAxis, encodingWithoutContinuousAxis, markDef, outerSpec, tooltipEncoding} = errorBarParams(spec, ERRORBAND, config);
  const errorBandDef = markDef;
  const makeErrorBandPart = makeCompositeAggregatePartFactory(errorBandDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorband);
  const is2D = spec.encoding.x !== void 0 && spec.encoding.y !== void 0;
  let bandMark = {type: is2D ? "area" : "rect"};
  let bordersMark = {type: is2D ? "line" : "rule"};
  const interpolate3 = Object.assign(Object.assign({}, errorBandDef.interpolate ? {interpolate: errorBandDef.interpolate} : {}), errorBandDef.tension && errorBandDef.interpolate ? {tension: errorBandDef.tension} : {});
  if (is2D) {
    bandMark = Object.assign(Object.assign(Object.assign({}, bandMark), interpolate3), {ariaRoleDescription: "errorband"});
    bordersMark = Object.assign(Object.assign({}, bordersMark), interpolate3);
  } else if (errorBandDef.interpolate) {
    warn3(message_exports.errorBand1DNotSupport("interpolate"));
  } else if (errorBandDef.tension) {
    warn3(message_exports.errorBand1DNotSupport("tension"));
  }
  return Object.assign(Object.assign({}, outerSpec), {transform: transform4, layer: [
    ...makeErrorBandPart({
      partName: "band",
      mark: bandMark,
      positionPrefix: "lower",
      endPositionPrefix: "upper",
      extraEncoding: tooltipEncoding
    }),
    ...makeErrorBandPart({
      partName: "borders",
      mark: bordersMark,
      positionPrefix: "lower",
      aria: false,
      extraEncoding: tooltipEncoding
    }),
    ...makeErrorBandPart({
      partName: "borders",
      mark: bordersMark,
      positionPrefix: "upper",
      aria: false,
      extraEncoding: tooltipEncoding
    })
  ]});
}

// node_modules/vega-lite/build/src/compositemark/index.js
var compositeMarkRegistry = {};
function add5(mark2, run2, parts) {
  const normalizer2 = new CompositeMarkNormalizer(mark2, run2);
  compositeMarkRegistry[mark2] = {normalizer: normalizer2, parts};
}
function getAllCompositeMarks() {
  return keys3(compositeMarkRegistry);
}
add5(BOXPLOT, normalizeBoxPlot, BOXPLOT_PARTS);
add5(ERRORBAR, normalizeErrorBar, ERRORBAR_PARTS);
add5(ERRORBAND, normalizeErrorBand, ERRORBAND_PARTS);

// node_modules/vega-lite/build/src/guide.js
var VL_ONLY_LEGEND_CONFIG = [
  "gradientHorizontalMaxLength",
  "gradientHorizontalMinLength",
  "gradientVerticalMaxLength",
  "gradientVerticalMinLength",
  "unselectedOpacity"
];

// node_modules/vega-lite/build/src/legend.js
var LEGEND_SCALE_CHANNELS = [
  "size",
  "shape",
  "fill",
  "stroke",
  "strokeDash",
  "strokeWidth",
  "opacity"
];
var SIGNAL_LEGEND_PROP_INDEX = {
  fillColor: {
    part: "legend",
    vgProp: "fill"
  },
  gradientStrokeColor: {
    part: "gradient",
    vgProp: "stroke"
  },
  labelColor: {
    part: "labels",
    vgProp: "fill"
  },
  strokeColor: {
    part: "legend",
    vgProp: "stroke"
  },
  symbolFillColor: {
    part: "symbols",
    vgProp: "fill"
  },
  symbolStrokeColor: {
    part: "symbols",
    vgProp: "stroke"
  },
  titleColor: {
    part: "title",
    vgProp: "fill"
  }
};
var defaultLegendConfig = {
  gradientHorizontalMaxLength: 200,
  gradientHorizontalMinLength: 100,
  gradientVerticalMaxLength: 200,
  gradientVerticalMinLength: 64,
  unselectedOpacity: 0.35
};
var COMMON_LEGEND_PROPERTY_INDEX = {
  aria: 1,
  clipHeight: 1,
  columnPadding: 1,
  columns: 1,
  cornerRadius: 1,
  description: 1,
  direction: 1,
  fillColor: 1,
  format: 1,
  formatType: 1,
  gradientLength: 1,
  gradientOpacity: 1,
  gradientStrokeColor: 1,
  gradientStrokeWidth: 1,
  gradientThickness: 1,
  gridAlign: 1,
  labelAlign: 1,
  labelBaseline: 1,
  labelColor: 1,
  labelFont: 1,
  labelFontSize: 1,
  labelFontStyle: 1,
  labelFontWeight: 1,
  labelLimit: 1,
  labelOffset: 1,
  labelOpacity: 1,
  labelOverlap: 1,
  labelPadding: 1,
  labelSeparation: 1,
  legendX: 1,
  legendY: 1,
  offset: 1,
  orient: 1,
  padding: 1,
  rowPadding: 1,
  strokeColor: 1,
  symbolDash: 1,
  symbolDashOffset: 1,
  symbolFillColor: 1,
  symbolLimit: 1,
  symbolOffset: 1,
  symbolOpacity: 1,
  symbolSize: 1,
  symbolStrokeColor: 1,
  symbolStrokeWidth: 1,
  symbolType: 1,
  tickCount: 1,
  tickMinStep: 1,
  title: 1,
  titleAlign: 1,
  titleAnchor: 1,
  titleBaseline: 1,
  titleColor: 1,
  titleFont: 1,
  titleFontSize: 1,
  titleFontStyle: 1,
  titleFontWeight: 1,
  titleLimit: 1,
  titleLineHeight: 1,
  titleOpacity: 1,
  titleOrient: 1,
  titlePadding: 1,
  type: 1,
  values: 1,
  zindex: 1
};
var LEGEND_PROPERTIES = keys3(COMMON_LEGEND_PROPERTY_INDEX);

// node_modules/vega-lite/build/src/selection.js
var SELECTION_ID2 = "_vgsid_";
var defaultConfig = {
  single: {
    on: "click",
    fields: [SELECTION_ID2],
    resolve: "global",
    empty: "all",
    clear: "dblclick"
  },
  multi: {
    on: "click",
    fields: [SELECTION_ID2],
    toggle: "event.shiftKey",
    resolve: "global",
    empty: "all",
    clear: "dblclick"
  },
  interval: {
    on: "[mousedown, window:mouseup] > window:mousemove!",
    encodings: ["x", "y"],
    translate: "[mousedown, window:mouseup] > window:mousemove!",
    zoom: "wheel!",
    mark: {fill: "#333", fillOpacity: 0.125, stroke: "white"},
    resolve: "global",
    clear: "dblclick"
  }
};
function isLegendBinding(bind3) {
  return !!bind3 && (bind3 === "legend" || !!bind3.legend);
}
function isLegendStreamBinding(bind3) {
  return isLegendBinding(bind3) && isObject_default(bind3);
}

// node_modules/vega-lite/build/src/spec/concat.js
function isAnyConcatSpec(spec) {
  return isVConcatSpec(spec) || isHConcatSpec(spec) || isConcatSpec(spec);
}
function isConcatSpec(spec) {
  return "concat" in spec;
}
function isVConcatSpec(spec) {
  return "vconcat" in spec;
}
function isHConcatSpec(spec) {
  return "hconcat" in spec;
}

// node_modules/vega-lite/build/src/spec/base.js
function isStep(size) {
  return isObject_default(size) && size["step"] !== void 0;
}
function isFrameMixins(o) {
  return o["view"] || o["width"] || o["height"];
}
var DEFAULT_SPACING = 20;
var COMPOSITION_LAYOUT_INDEX = {
  align: 1,
  bounds: 1,
  center: 1,
  columns: 1,
  spacing: 1
};
var COMPOSITION_LAYOUT_PROPERTIES = keys3(COMPOSITION_LAYOUT_INDEX);
function extractCompositionLayout(spec, specType, config) {
  var _a2, _b;
  const compositionConfig = config[specType];
  const layout = {};
  const {spacing: spacingConfig, columns} = compositionConfig;
  if (spacingConfig !== void 0) {
    layout.spacing = spacingConfig;
  }
  if (columns !== void 0) {
    if (isFacetSpec(spec) && !isFacetMapping(spec.facet) || isConcatSpec(spec)) {
      layout.columns = columns;
    }
  }
  if (isVConcatSpec(spec)) {
    layout.columns = 1;
  }
  for (const prop of COMPOSITION_LAYOUT_PROPERTIES) {
    if (spec[prop] !== void 0) {
      if (prop === "spacing") {
        const spacing = spec[prop];
        layout[prop] = isNumber_default(spacing) ? spacing : {
          row: (_a2 = spacing.row) !== null && _a2 !== void 0 ? _a2 : spacingConfig,
          column: (_b = spacing.column) !== null && _b !== void 0 ? _b : spacingConfig
        };
      } else {
        layout[prop] = spec[prop];
      }
    }
  }
  return layout;
}

// node_modules/vega-lite/build/src/config.js
function getViewConfigContinuousSize(viewConfig, channel) {
  var _a2;
  return (_a2 = viewConfig[channel]) !== null && _a2 !== void 0 ? _a2 : viewConfig[channel === "width" ? "continuousWidth" : "continuousHeight"];
}
function getViewConfigDiscreteStep(viewConfig, channel) {
  const size = getViewConfigDiscreteSize(viewConfig, channel);
  return isStep(size) ? size.step : DEFAULT_STEP;
}
function getViewConfigDiscreteSize(viewConfig, channel) {
  var _a2;
  const size = (_a2 = viewConfig[channel]) !== null && _a2 !== void 0 ? _a2 : viewConfig[channel === "width" ? "discreteWidth" : "discreteHeight"];
  return getFirstDefined(size, {step: viewConfig.step});
}
var DEFAULT_STEP = 20;
var defaultViewConfig = {
  continuousWidth: 200,
  continuousHeight: 200,
  step: DEFAULT_STEP
};
var defaultConfig2 = {
  background: "white",
  padding: 5,
  timeFormat: "%b %d, %Y",
  countTitle: "Count of Records",
  view: defaultViewConfig,
  mark: defaultMarkConfig,
  arc: {},
  area: {},
  bar: defaultBarConfig,
  circle: {},
  geoshape: {},
  image: {},
  line: {},
  point: {},
  rect: defaultRectConfig,
  rule: {color: "black"},
  square: {},
  text: {color: "black"},
  tick: defaultTickConfig,
  trail: {},
  boxplot: {
    size: 14,
    extent: 1.5,
    box: {},
    median: {color: "white"},
    outliers: {},
    rule: {},
    ticks: null
  },
  errorbar: {
    center: "mean",
    rule: true,
    ticks: false
  },
  errorband: {
    band: {
      opacity: 0.3
    },
    borders: false
  },
  scale: defaultScaleConfig,
  projection: {},
  legend: defaultLegendConfig,
  header: {titlePadding: 10, labelPadding: 10},
  headerColumn: {},
  headerRow: {},
  headerFacet: {},
  selection: defaultConfig,
  style: {},
  title: {},
  facet: {spacing: DEFAULT_SPACING},
  concat: {spacing: DEFAULT_SPACING}
};
var tab10 = [
  "#4c78a8",
  "#f58518",
  "#e45756",
  "#72b7b2",
  "#54a24b",
  "#eeca3b",
  "#b279a2",
  "#ff9da6",
  "#9d755d",
  "#bab0ac"
];
var DEFAULT_FONT_SIZE = {
  text: 11,
  guideLabel: 10,
  guideTitle: 11,
  groupTitle: 13,
  groupSubtitle: 12
};
var DEFAULT_COLOR = {
  blue: tab10[0],
  orange: tab10[1],
  red: tab10[2],
  teal: tab10[3],
  green: tab10[4],
  yellow: tab10[5],
  purple: tab10[6],
  pink: tab10[7],
  brown: tab10[8],
  gray0: "#000",
  gray1: "#111",
  gray2: "#222",
  gray3: "#333",
  gray4: "#444",
  gray5: "#555",
  gray6: "#666",
  gray7: "#777",
  gray8: "#888",
  gray9: "#999",
  gray10: "#aaa",
  gray11: "#bbb",
  gray12: "#ccc",
  gray13: "#ddd",
  gray14: "#eee",
  gray15: "#fff"
};
function colorSignalConfig(color5 = {}) {
  return {
    signals: [
      {
        name: "color",
        value: isObject_default(color5) ? Object.assign(Object.assign({}, DEFAULT_COLOR), color5) : DEFAULT_COLOR
      }
    ],
    mark: {color: {signal: "color.blue"}},
    rule: {color: {signal: "color.gray0"}},
    text: {
      color: {signal: "color.gray0"}
    },
    style: {
      "guide-label": {
        fill: {signal: "color.gray0"}
      },
      "guide-title": {
        fill: {signal: "color.gray0"}
      },
      "group-title": {
        fill: {signal: "color.gray0"}
      },
      "group-subtitle": {
        fill: {signal: "color.gray0"}
      },
      cell: {
        stroke: {signal: "color.gray8"}
      }
    },
    axis: {
      domainColor: {signal: "color.gray13"},
      gridColor: {signal: "color.gray8"},
      tickColor: {signal: "color.gray13"}
    },
    range: {
      category: [
        {signal: "color.blue"},
        {signal: "color.orange"},
        {signal: "color.red"},
        {signal: "color.teal"},
        {signal: "color.green"},
        {signal: "color.yellow"},
        {signal: "color.purple"},
        {signal: "color.pink"},
        {signal: "color.brown"},
        {signal: "color.grey8"}
      ]
    }
  };
}
function fontSizeSignalConfig(fontSize2) {
  return {
    signals: [
      {
        name: "fontSize",
        value: isObject_default(fontSize2) ? Object.assign(Object.assign({}, DEFAULT_FONT_SIZE), fontSize2) : DEFAULT_FONT_SIZE
      }
    ],
    text: {
      fontSize: {signal: "fontSize.text"}
    },
    style: {
      "guide-label": {
        fontSize: {signal: "fontSize.guideLabel"}
      },
      "guide-title": {
        fontSize: {signal: "fontSize.guideTitle"}
      },
      "group-title": {
        fontSize: {signal: "fontSize.groupTitle"}
      },
      "group-subtitle": {
        fontSize: {signal: "fontSize.groupSubtitle"}
      }
    }
  };
}
function fontConfig(font3) {
  return {
    text: {font: font3},
    style: {
      "guide-label": {font: font3},
      "guide-title": {font: font3},
      "group-title": {font: font3},
      "group-subtitle": {font: font3}
    }
  };
}
function initConfig(config = {}) {
  const {color: color5, font: font3, fontSize: fontSize2} = config, restConfig = __rest(config, ["color", "font", "fontSize"]);
  return mergeConfig2({}, defaultConfig2, font3 ? fontConfig(font3) : {}, color5 ? colorSignalConfig(color5) : {}, fontSize2 ? fontSizeSignalConfig(fontSize2) : {}, restConfig || {});
}
var MARK_STYLES = ["view", ...PRIMITIVE_MARKS];
var VL_ONLY_CONFIG_PROPERTIES = [
  "color",
  "fontSize",
  "background",
  "padding",
  "facet",
  "concat",
  "numberFormat",
  "timeFormat",
  "countTitle",
  "header",
  "axisQuantitative",
  "axisTemporal",
  "axisDiscrete",
  "axisPoint",
  "axisXBand",
  "axisXPoint",
  "axisXDiscrete",
  "axisXQuantitative",
  "axisXTemporal",
  "axisYBand",
  "axisYPoint",
  "axisYDiscrete",
  "axisYQuantitative",
  "axisYTemporal",
  "scale",
  "selection",
  "overlay"
];
var VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX = Object.assign({view: ["continuousWidth", "continuousHeight", "discreteWidth", "discreteHeight", "step"]}, VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX);
function stripAndRedirectConfig(config) {
  config = duplicate(config);
  for (const prop of VL_ONLY_CONFIG_PROPERTIES) {
    delete config[prop];
  }
  if (config.axis) {
    for (const prop in config.axis) {
      if (isConditionalAxisValue(config.axis[prop])) {
        delete config.axis[prop];
      }
    }
  }
  if (config.legend) {
    for (const prop of VL_ONLY_LEGEND_CONFIG) {
      delete config.legend[prop];
    }
  }
  if (config.mark) {
    for (const prop of VL_ONLY_MARK_CONFIG_PROPERTIES) {
      delete config.mark[prop];
    }
    if (config.mark.tooltip && isObject_default(config.mark.tooltip)) {
      delete config.mark.tooltip;
    }
  }
  for (const markType2 of MARK_STYLES) {
    for (const prop of VL_ONLY_MARK_CONFIG_PROPERTIES) {
      delete config[markType2][prop];
    }
    const vlOnlyMarkSpecificConfigs = VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX[markType2];
    if (vlOnlyMarkSpecificConfigs) {
      for (const prop of vlOnlyMarkSpecificConfigs) {
        delete config[markType2][prop];
      }
    }
    redirectConfigToStyleConfig(config, markType2);
  }
  for (const m2 of getAllCompositeMarks()) {
    delete config[m2];
  }
  redirectTitleConfig(config);
  for (const prop in config) {
    if (isObject_default(config[prop]) && isEmpty(config[prop])) {
      delete config[prop];
    }
  }
  return isEmpty(config) ? void 0 : config;
}
function redirectTitleConfig(config) {
  const {titleMarkConfig, subtitleMarkConfig, subtitle} = extractTitleConfig(config.title);
  if (!isEmpty(titleMarkConfig)) {
    config.style["group-title"] = Object.assign(Object.assign({}, config.style["group-title"]), titleMarkConfig);
  }
  if (!isEmpty(subtitleMarkConfig)) {
    config.style["group-subtitle"] = Object.assign(Object.assign({}, config.style["group-subtitle"]), subtitleMarkConfig);
  }
  if (!isEmpty(subtitle)) {
    config.title = subtitle;
  } else {
    delete config.title;
  }
}
function redirectConfigToStyleConfig(config, prop, toProp, compositeMarkPart) {
  const propConfig = compositeMarkPart ? config[prop][compositeMarkPart] : config[prop];
  if (prop === "view") {
    toProp = "cell";
  }
  const style2 = Object.assign(Object.assign({}, propConfig), config.style[toProp !== null && toProp !== void 0 ? toProp : prop]);
  if (!isEmpty(style2)) {
    config.style[toProp !== null && toProp !== void 0 ? toProp : prop] = style2;
  }
  if (!compositeMarkPart) {
    delete config[prop];
  }
}

// node_modules/vega-lite/build/src/spec/layer.js
function isLayerSpec(spec) {
  return "layer" in spec;
}

// node_modules/vega-lite/build/src/spec/repeat.js
function isRepeatSpec(spec) {
  return "repeat" in spec;
}
function isLayerRepeatSpec(spec) {
  return !isArray_default(spec.repeat) && spec.repeat["layer"];
}

// node_modules/vega-lite/build/src/spec/map.js
var SpecMapper = class {
  map(spec, params2) {
    if (isFacetSpec(spec)) {
      return this.mapFacet(spec, params2);
    } else if (isRepeatSpec(spec)) {
      return this.mapRepeat(spec, params2);
    } else if (isHConcatSpec(spec)) {
      return this.mapHConcat(spec, params2);
    } else if (isVConcatSpec(spec)) {
      return this.mapVConcat(spec, params2);
    } else if (isConcatSpec(spec)) {
      return this.mapConcat(spec, params2);
    } else {
      return this.mapLayerOrUnit(spec, params2);
    }
  }
  mapLayerOrUnit(spec, params2) {
    if (isLayerSpec(spec)) {
      return this.mapLayer(spec, params2);
    } else if (isUnitSpec(spec)) {
      return this.mapUnit(spec, params2);
    }
    throw new Error(message_exports.invalidSpec(spec));
  }
  mapLayer(spec, params2) {
    return Object.assign(Object.assign({}, spec), {layer: spec.layer.map((subspec) => this.mapLayerOrUnit(subspec, params2))});
  }
  mapHConcat(spec, params2) {
    return Object.assign(Object.assign({}, spec), {hconcat: spec.hconcat.map((subspec) => this.map(subspec, params2))});
  }
  mapVConcat(spec, params2) {
    return Object.assign(Object.assign({}, spec), {vconcat: spec.vconcat.map((subspec) => this.map(subspec, params2))});
  }
  mapConcat(spec, params2) {
    const {concat} = spec, rest = __rest(spec, ["concat"]);
    return Object.assign(Object.assign({}, rest), {concat: concat.map((subspec) => this.map(subspec, params2))});
  }
  mapFacet(spec, params2) {
    return Object.assign(Object.assign({}, spec), {
      spec: this.map(spec.spec, params2)
    });
  }
  mapRepeat(spec, params2) {
    return Object.assign(Object.assign({}, spec), {
      spec: this.map(spec.spec, params2)
    });
  }
};

// node_modules/vega-lite/build/src/stack.js
var STACK_OFFSET_INDEX = {
  zero: 1,
  center: 1,
  normalize: 1
};
function isStackOffset(s) {
  return s in STACK_OFFSET_INDEX;
}
var STACKABLE_MARKS = new Set([ARC, BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT, TICK]);
var STACK_BY_DEFAULT_MARKS = new Set([BAR, AREA, ARC]);
function potentialStackedChannel(encoding, x5) {
  var _a2, _b;
  const y5 = x5 === "x" ? "y" : "radius";
  const xDef = encoding[x5];
  const yDef = encoding[y5];
  if (isFieldDef(xDef) && isFieldDef(yDef)) {
    if (channelDefType(xDef) === "quantitative" && channelDefType(yDef) === "quantitative") {
      if (xDef.stack) {
        return x5;
      } else if (yDef.stack) {
        return y5;
      }
      const xAggregate = isFieldDef(xDef) && !!xDef.aggregate;
      const yAggregate = isFieldDef(yDef) && !!yDef.aggregate;
      if (xAggregate !== yAggregate) {
        return xAggregate ? x5 : y5;
      } else {
        const xScale = (_a2 = xDef.scale) === null || _a2 === void 0 ? void 0 : _a2.type;
        const yScale = (_b = yDef.scale) === null || _b === void 0 ? void 0 : _b.type;
        if (xScale && xScale !== "linear") {
          return y5;
        } else if (yScale && yScale !== "linear") {
          return x5;
        }
      }
    } else if (channelDefType(xDef) === "quantitative") {
      return x5;
    } else if (channelDefType(yDef) === "quantitative") {
      return y5;
    }
  } else if (channelDefType(xDef) === "quantitative") {
    return x5;
  } else if (channelDefType(yDef) === "quantitative") {
    return y5;
  }
  return void 0;
}
function getDimensionChannel(channel) {
  switch (channel) {
    case "x":
      return "y";
    case "y":
      return "x";
    case "theta":
      return "radius";
    case "radius":
      return "theta";
  }
}
function stack(m2, encoding, opt = {}) {
  const mark2 = isMarkDef(m2) ? m2.type : m2;
  if (!STACKABLE_MARKS.has(mark2)) {
    return null;
  }
  const fieldChannel = potentialStackedChannel(encoding, "x") || potentialStackedChannel(encoding, "theta");
  if (!fieldChannel) {
    return null;
  }
  const stackedFieldDef = encoding[fieldChannel];
  const stackedField = isFieldDef(stackedFieldDef) ? vgField(stackedFieldDef, {}) : void 0;
  let dimensionChannel = getDimensionChannel(fieldChannel);
  let dimensionDef = encoding[dimensionChannel];
  let dimensionField = isFieldDef(dimensionDef) ? vgField(dimensionDef, {}) : void 0;
  if (dimensionField === stackedField) {
    dimensionField = void 0;
    dimensionDef = void 0;
    dimensionChannel = void 0;
  }
  const stackBy = NONPOSITION_CHANNELS.reduce((sc, channel) => {
    if (channel !== "tooltip" && channelHasField(encoding, channel)) {
      const channelDef = encoding[channel];
      for (const cDef of array_default4(channelDef)) {
        const fieldDef = getFieldDef(cDef);
        if (fieldDef.aggregate) {
          continue;
        }
        const f = vgField(fieldDef, {});
        if (!f || f !== dimensionField) {
          sc.push({channel, fieldDef});
        }
      }
    }
    return sc;
  }, []);
  let offset4;
  if (stackedFieldDef.stack !== void 0) {
    if (isBoolean_default(stackedFieldDef.stack)) {
      offset4 = stackedFieldDef.stack ? "zero" : null;
    } else {
      offset4 = stackedFieldDef.stack;
    }
  } else if (stackBy.length > 0 && STACK_BY_DEFAULT_MARKS.has(mark2)) {
    offset4 = "zero";
  }
  if (!offset4 || !isStackOffset(offset4)) {
    return null;
  }
  if (isAggregate(encoding) && stackBy.length === 0) {
    return null;
  }
  if (stackedFieldDef.scale && stackedFieldDef.scale.type && stackedFieldDef.scale.type !== ScaleType.LINEAR) {
    if (opt.disallowNonLinearStack) {
      return null;
    } else {
      warn3(message_exports.cannotStackNonLinearScale(stackedFieldDef.scale.type));
    }
  }
  if (isFieldOrDatumDef(encoding[getSecondaryRangeChannel(fieldChannel)])) {
    if (stackedFieldDef.stack !== void 0) {
      warn3(message_exports.cannotStackRangedMark(fieldChannel));
    }
    return null;
  }
  if (isFieldDef(stackedFieldDef) && stackedFieldDef.aggregate && !contains2(SUM_OPS, stackedFieldDef.aggregate)) {
    warn3(message_exports.stackNonSummativeAggregate(stackedFieldDef.aggregate));
  }
  return {
    groupbyChannel: dimensionDef ? dimensionChannel : void 0,
    groupbyField: dimensionField,
    fieldChannel,
    impute: stackedFieldDef.impute === null ? false : isPathMark(mark2),
    stackBy,
    offset: offset4
  };
}

// node_modules/vega-lite/build/src/normalize/pathoverlay.js
function dropLineAndPoint(markDef) {
  const {point: _point, line: _line} = markDef, mark2 = __rest(markDef, ["point", "line"]);
  return keys3(mark2).length > 1 ? mark2 : mark2.type;
}
function dropLineAndPointFromConfig(config) {
  for (const mark2 of ["line", "area", "rule", "trail"]) {
    if (config[mark2]) {
      config = Object.assign(Object.assign({}, config), {
        [mark2]: omit(config[mark2], ["point", "line"])
      });
    }
  }
  return config;
}
function getPointOverlay(markDef, markConfig = {}, encoding) {
  if (markDef.point === "transparent") {
    return {opacity: 0};
  } else if (markDef.point) {
    return isObject_default(markDef.point) ? markDef.point : {};
  } else if (markDef.point !== void 0) {
    return null;
  } else {
    if (markConfig.point || encoding.shape) {
      return isObject_default(markConfig.point) ? markConfig.point : {};
    }
    return void 0;
  }
}
function getLineOverlay(markDef, markConfig = {}) {
  if (markDef.line) {
    return markDef.line === true ? {} : markDef.line;
  } else if (markDef.line !== void 0) {
    return null;
  } else {
    if (markConfig.line) {
      return markConfig.line === true ? {} : markConfig.line;
    }
    return void 0;
  }
}
var PathOverlayNormalizer = class {
  constructor() {
    this.name = "path-overlay";
  }
  hasMatchingType(spec, config) {
    if (isUnitSpec(spec)) {
      const {mark: mark2, encoding} = spec;
      const markDef = isMarkDef(mark2) ? mark2 : {type: mark2};
      switch (markDef.type) {
        case "line":
        case "rule":
        case "trail":
          return !!getPointOverlay(markDef, config[markDef.type], encoding);
        case "area":
          return !!getPointOverlay(markDef, config[markDef.type], encoding) || !!getLineOverlay(markDef, config[markDef.type]);
      }
    }
    return false;
  }
  run(spec, params2, normalize3) {
    const {config} = params2;
    const {selection: selection2, projection: projection3, encoding, mark: mark2} = spec, outerSpec = __rest(spec, ["selection", "projection", "encoding", "mark"]);
    const markDef = isMarkDef(mark2) ? mark2 : {type: mark2};
    const pointOverlay = getPointOverlay(markDef, config[markDef.type], encoding);
    const lineOverlay = markDef.type === "area" && getLineOverlay(markDef, config[markDef.type]);
    const layer2 = [
      Object.assign(Object.assign({}, selection2 ? {selection: selection2} : {}), {
        mark: dropLineAndPoint(Object.assign(Object.assign({}, markDef.type === "area" && markDef.opacity === void 0 && markDef.fillOpacity === void 0 ? {opacity: 0.7} : {}), markDef)),
        encoding: omit(encoding, ["shape"])
      })
    ];
    const stackProps = stack(markDef, encoding);
    let overlayEncoding = encoding;
    if (stackProps) {
      const {fieldChannel: stackFieldChannel, offset: offset4} = stackProps;
      overlayEncoding = Object.assign(Object.assign({}, encoding), {[stackFieldChannel]: Object.assign(Object.assign({}, encoding[stackFieldChannel]), offset4 ? {stack: offset4} : {})});
    }
    if (lineOverlay) {
      layer2.push(Object.assign(Object.assign({}, projection3 ? {projection: projection3} : {}), {mark: Object.assign(Object.assign({type: "line"}, pick2(markDef, ["clip", "interpolate", "tension", "tooltip"])), lineOverlay), encoding: overlayEncoding}));
    }
    if (pointOverlay) {
      layer2.push(Object.assign(Object.assign({}, projection3 ? {projection: projection3} : {}), {mark: Object.assign(Object.assign({type: "point", opacity: 1, filled: true}, pick2(markDef, ["clip", "tooltip"])), pointOverlay), encoding: overlayEncoding}));
    }
    return normalize3(Object.assign(Object.assign({}, outerSpec), {layer: layer2}), Object.assign(Object.assign({}, params2), {config: dropLineAndPointFromConfig(config)}));
  }
};

// node_modules/vega-lite/build/src/normalize/rangestep.js
var RangeStepNormalizer = class {
  constructor() {
    this.name = "RangeStep";
  }
  hasMatchingType(spec) {
    var _a2;
    if (isUnitSpec(spec) && spec.encoding) {
      for (const channel of POSITION_SCALE_CHANNELS) {
        const def2 = spec.encoding[channel];
        if (def2 && isFieldOrDatumDef(def2)) {
          if ((_a2 = def2 === null || def2 === void 0 ? void 0 : def2.scale) === null || _a2 === void 0 ? void 0 : _a2["rangeStep"]) {
            return true;
          }
        }
      }
    }
    return false;
  }
  run(spec) {
    var _a2;
    const sizeMixins = {};
    let encoding = Object.assign({}, spec.encoding);
    for (const channel of POSITION_SCALE_CHANNELS) {
      const sizeType = getSizeChannel(channel);
      const def2 = encoding[channel];
      if (def2 && isFieldOrDatumDef(def2)) {
        if ((_a2 = def2 === null || def2 === void 0 ? void 0 : def2.scale) === null || _a2 === void 0 ? void 0 : _a2["rangeStep"]) {
          const {scale: scale7} = def2, defWithoutScale = __rest(def2, ["scale"]);
          const _b = scale7, {rangeStep} = _b, scaleWithoutRangeStep = __rest(_b, ["rangeStep"]);
          sizeMixins[sizeType] = {step: scale7["rangeStep"]};
          warn3(message_exports.RANGE_STEP_DEPRECATED);
          encoding = Object.assign(Object.assign({}, encoding), {[channel]: Object.assign(Object.assign({}, defWithoutScale), isEmpty(scaleWithoutRangeStep) ? {} : {scale: scaleWithoutRangeStep})});
        }
      }
    }
    return Object.assign(Object.assign(Object.assign({}, sizeMixins), spec), {encoding});
  }
};

// node_modules/vega-lite/build/src/normalize/repeater.js
function replaceRepeaterInFacet(facet, repeater) {
  if (!repeater) {
    return facet;
  }
  if (isFacetMapping(facet)) {
    return replaceRepeaterInMapping(facet, repeater);
  }
  return replaceRepeaterInFieldDef(facet, repeater);
}
function replaceRepeaterInEncoding(encoding, repeater) {
  if (!repeater) {
    return encoding;
  }
  return replaceRepeaterInMapping(encoding, repeater);
}
function replaceRepeatInProp(prop, o, repeater) {
  const val = o[prop];
  if (isRepeatRef(val)) {
    if (val.repeat in repeater) {
      return Object.assign(Object.assign({}, o), {[prop]: repeater[val.repeat]});
    } else {
      warn3(message_exports.noSuchRepeatedValue(val.repeat));
      return void 0;
    }
  }
  return o;
}
function replaceRepeaterInFieldDef(fieldDef, repeater) {
  fieldDef = replaceRepeatInProp("field", fieldDef, repeater);
  if (fieldDef === void 0) {
    return void 0;
  } else if (fieldDef === null) {
    return null;
  }
  if (isSortableFieldDef(fieldDef) && isSortField(fieldDef.sort)) {
    const sort2 = replaceRepeatInProp("field", fieldDef.sort, repeater);
    fieldDef = Object.assign(Object.assign({}, fieldDef), sort2 ? {sort: sort2} : {});
  }
  return fieldDef;
}
function replaceRepeaterInFieldOrDatumDef(def2, repeater) {
  if (isFieldDef(def2)) {
    return replaceRepeaterInFieldDef(def2, repeater);
  } else {
    const datumDef = replaceRepeatInProp("datum", def2, repeater);
    if (datumDef !== def2 && !datumDef.type) {
      datumDef.type = "nominal";
    }
    return datumDef;
  }
}
function replaceRepeaterInChannelDef(channelDef, repeater) {
  if (isFieldOrDatumDef(channelDef)) {
    const fd = replaceRepeaterInFieldOrDatumDef(channelDef, repeater);
    if (fd) {
      return fd;
    } else if (isConditionalDef(channelDef)) {
      return {condition: channelDef.condition};
    }
  } else {
    if (hasConditionalFieldOrDatumDef(channelDef)) {
      const fd = replaceRepeaterInFieldOrDatumDef(channelDef.condition, repeater);
      if (fd) {
        return Object.assign(Object.assign({}, channelDef), {condition: fd});
      } else {
        const {condition} = channelDef, channelDefWithoutCondition = __rest(channelDef, ["condition"]);
        return channelDefWithoutCondition;
      }
    }
    return channelDef;
  }
  return void 0;
}
function replaceRepeaterInMapping(mapping, repeater) {
  const out = {};
  for (const channel in mapping) {
    if (hasOwnProperty_default(mapping, channel)) {
      const channelDef = mapping[channel];
      if (isArray_default(channelDef)) {
        out[channel] = channelDef.map((cd) => replaceRepeaterInChannelDef(cd, repeater)).filter((cd) => cd);
      } else {
        const cd = replaceRepeaterInChannelDef(channelDef, repeater);
        if (cd !== void 0) {
          out[channel] = cd;
        }
      }
    }
  }
  return out;
}

// node_modules/vega-lite/build/src/normalize/ruleforrangedline.js
var RuleForRangedLineNormalizer = class {
  constructor() {
    this.name = "RuleForRangedLine";
  }
  hasMatchingType(spec) {
    if (isUnitSpec(spec)) {
      const {encoding, mark: mark2} = spec;
      if (mark2 === "line") {
        for (const channel of SECONDARY_RANGE_CHANNEL) {
          const mainChannel = getMainRangeChannel(channel);
          const mainChannelDef = encoding[mainChannel];
          if (encoding[channel]) {
            if (isFieldDef(mainChannelDef) && !isBinned(mainChannelDef.bin) || isDatumDef(mainChannelDef)) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }
  run(spec, params2, normalize3) {
    const {encoding} = spec;
    warn3(message_exports.lineWithRange(!!encoding.x2, !!encoding.y2));
    return normalize3(Object.assign(Object.assign({}, spec), {mark: "rule"}), params2);
  }
};

// node_modules/vega-lite/build/src/normalize/core.js
var CoreNormalizer = class extends SpecMapper {
  constructor() {
    super(...arguments);
    this.nonFacetUnitNormalizers = [
      boxPlotNormalizer,
      errorBarNormalizer,
      errorBandNormalizer,
      new PathOverlayNormalizer(),
      new RuleForRangedLineNormalizer(),
      new RangeStepNormalizer()
    ];
  }
  map(spec, params2) {
    if (isUnitSpec(spec)) {
      const hasRow = channelHasField(spec.encoding, ROW);
      const hasColumn = channelHasField(spec.encoding, COLUMN);
      const hasFacet = channelHasField(spec.encoding, FACET);
      if (hasRow || hasColumn || hasFacet) {
        return this.mapFacetedUnit(spec, params2);
      }
    }
    return super.map(spec, params2);
  }
  mapUnit(spec, params2) {
    const {parentEncoding, parentProjection} = params2;
    const specWithReplacedEncoding = Object.assign(Object.assign({}, spec), {encoding: replaceRepeaterInEncoding(spec.encoding, params2.repeater)});
    if (parentEncoding || parentProjection) {
      return this.mapUnitWithParentEncodingOrProjection(specWithReplacedEncoding, params2);
    }
    const normalizeLayerOrUnit = this.mapLayerOrUnit.bind(this);
    for (const unitNormalizer of this.nonFacetUnitNormalizers) {
      if (unitNormalizer.hasMatchingType(specWithReplacedEncoding, params2.config)) {
        return unitNormalizer.run(specWithReplacedEncoding, params2, normalizeLayerOrUnit);
      }
    }
    return specWithReplacedEncoding;
  }
  mapRepeat(spec, params2) {
    if (isLayerRepeatSpec(spec)) {
      return this.mapLayerRepeat(spec, params2);
    } else {
      return this.mapNonLayerRepeat(spec, params2);
    }
  }
  mapLayerRepeat(spec, params2) {
    const {repeat: repeat2, spec: childSpec} = spec, rest = __rest(spec, ["repeat", "spec"]);
    const {row, column, layer: layer2} = repeat2;
    const {repeater = {}, repeaterPrefix = ""} = params2;
    if (row || column) {
      return this.mapRepeat(Object.assign(Object.assign({}, spec), {repeat: Object.assign(Object.assign({}, row ? {row} : {}), column ? {column} : {}), spec: {
        repeat: {layer: layer2},
        spec: childSpec
      }}), params2);
    } else {
      return Object.assign(Object.assign({}, rest), {layer: layer2.map((layerValue) => {
        const childRepeater = Object.assign(Object.assign({}, repeater), {layer: layerValue});
        const childName = (childSpec.name || "") + repeaterPrefix + `child__layer_${varName(layerValue)}`;
        const child = this.mapLayerOrUnit(childSpec, Object.assign(Object.assign({}, params2), {repeater: childRepeater, repeaterPrefix: childName}));
        child.name = childName;
        return child;
      })});
    }
  }
  mapNonLayerRepeat(spec, params2) {
    var _a2;
    const {repeat: repeat2, spec: childSpec, data: data4} = spec, remainingProperties = __rest(spec, ["repeat", "spec", "data"]);
    if (!isArray_default(repeat2) && spec.columns) {
      spec = omit(spec, ["columns"]);
      warn3(message_exports.columnsNotSupportByRowCol("repeat"));
    }
    const concat = [];
    const {repeater = {}, repeaterPrefix = ""} = params2;
    const row = !isArray_default(repeat2) && repeat2.row || [repeater ? repeater.row : null];
    const column = !isArray_default(repeat2) && repeat2.column || [repeater ? repeater.column : null];
    const repeatValues = isArray_default(repeat2) && repeat2 || [repeater ? repeater.repeat : null];
    for (const repeatValue of repeatValues) {
      for (const rowValue of row) {
        for (const columnValue of column) {
          const childRepeater = {
            repeat: repeatValue,
            row: rowValue,
            column: columnValue,
            layer: repeater.layer
          };
          const childName = (childSpec.name || "") + repeaterPrefix + "child__" + (isArray_default(repeat2) ? `${varName(repeatValue)}` : (repeat2.row ? `row_${varName(rowValue)}` : "") + (repeat2.column ? `column_${varName(columnValue)}` : ""));
          const child = this.map(childSpec, Object.assign(Object.assign({}, params2), {repeater: childRepeater, repeaterPrefix: childName}));
          child.name = childName;
          concat.push(omit(child, ["data"]));
        }
      }
    }
    const columns = isArray_default(repeat2) ? spec.columns : repeat2.column ? repeat2.column.length : 1;
    return Object.assign(Object.assign({data: (_a2 = childSpec.data) !== null && _a2 !== void 0 ? _a2 : data4, align: "all"}, remainingProperties), {
      columns,
      concat
    });
  }
  mapFacet(spec, params2) {
    const {facet} = spec;
    if (isFacetMapping(facet) && spec.columns) {
      spec = omit(spec, ["columns"]);
      warn3(message_exports.columnsNotSupportByRowCol("facet"));
    }
    return super.mapFacet(spec, params2);
  }
  mapUnitWithParentEncodingOrProjection(spec, params2) {
    const {encoding, projection: projection3} = spec;
    const {parentEncoding, parentProjection, config} = params2;
    const mergedProjection = mergeProjection({parentProjection, projection: projection3});
    const mergedEncoding = mergeEncoding({
      parentEncoding,
      encoding: replaceRepeaterInEncoding(encoding, params2.repeater)
    });
    return this.mapUnit(Object.assign(Object.assign(Object.assign({}, spec), mergedProjection ? {projection: mergedProjection} : {}), mergedEncoding ? {encoding: mergedEncoding} : {}), {config});
  }
  mapFacetedUnit(spec, params2) {
    const _a2 = spec.encoding, {row, column, facet} = _a2, encoding = __rest(_a2, ["row", "column", "facet"]);
    const {mark: mark2, width: width2, projection: projection3, height: height2, view, selection: selection2, encoding: _} = spec, outerSpec = __rest(spec, ["mark", "width", "projection", "height", "view", "selection", "encoding"]);
    const {facetMapping, layout} = this.getFacetMappingAndLayout({row, column, facet}, params2);
    const newEncoding = replaceRepeaterInEncoding(encoding, params2.repeater);
    return this.mapFacet(Object.assign(Object.assign(Object.assign({}, outerSpec), layout), {
      facet: facetMapping,
      spec: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, width2 ? {width: width2} : {}), height2 ? {height: height2} : {}), view ? {view} : {}), projection3 ? {projection: projection3} : {}), {mark: mark2, encoding: newEncoding}), selection2 ? {selection: selection2} : {})
    }), params2);
  }
  getFacetMappingAndLayout(facets, params2) {
    var _a2;
    const {row, column, facet} = facets;
    if (row || column) {
      if (facet) {
        warn3(message_exports.facetChannelDropped([...row ? [ROW] : [], ...column ? [COLUMN] : []]));
      }
      const facetMapping = {};
      const layout = {};
      for (const channel of [ROW, COLUMN]) {
        const def2 = facets[channel];
        if (def2) {
          const {align: align2, center, spacing, columns} = def2, defWithoutLayout = __rest(def2, ["align", "center", "spacing", "columns"]);
          facetMapping[channel] = defWithoutLayout;
          for (const prop of ["align", "center", "spacing"]) {
            if (def2[prop] !== void 0) {
              layout[prop] = (_a2 = layout[prop]) !== null && _a2 !== void 0 ? _a2 : {};
              layout[prop][channel] = def2[prop];
            }
          }
        }
      }
      return {facetMapping, layout};
    } else {
      const {align: align2, center, spacing, columns} = facet, facetMapping = __rest(facet, ["align", "center", "spacing", "columns"]);
      return {
        facetMapping: replaceRepeaterInFacet(facetMapping, params2.repeater),
        layout: Object.assign(Object.assign(Object.assign(Object.assign({}, align2 ? {align: align2} : {}), center ? {center} : {}), spacing ? {spacing} : {}), columns ? {columns} : {})
      };
    }
  }
  mapLayer(spec, _a2) {
    var {parentEncoding, parentProjection} = _a2, otherParams = __rest(_a2, ["parentEncoding", "parentProjection"]);
    const {encoding, projection: projection3} = spec, rest = __rest(spec, ["encoding", "projection"]);
    const params2 = Object.assign(Object.assign({}, otherParams), {parentEncoding: mergeEncoding({parentEncoding, encoding}), parentProjection: mergeProjection({parentProjection, projection: projection3})});
    return super.mapLayer(rest, params2);
  }
};
function mergeEncoding(opt) {
  const {parentEncoding, encoding} = opt;
  if (parentEncoding && encoding) {
    const overriden = keys3(parentEncoding).reduce((o, key2) => {
      if (encoding[key2]) {
        o.push(key2);
      }
      return o;
    }, []);
    if (overriden.length > 0) {
      warn3(message_exports.encodingOverridden(overriden));
    }
  }
  const merged = Object.assign(Object.assign({}, parentEncoding !== null && parentEncoding !== void 0 ? parentEncoding : {}), encoding !== null && encoding !== void 0 ? encoding : {});
  return isEmpty(merged) ? void 0 : merged;
}
function mergeProjection(opt) {
  const {parentProjection, projection: projection3} = opt;
  if (parentProjection && projection3) {
    warn3(message_exports.projectionOverridden({parentProjection, projection: projection3}));
  }
  return projection3 !== null && projection3 !== void 0 ? projection3 : parentProjection;
}

// node_modules/vega-lite/build/src/normalize/index.js
function normalize2(spec, config) {
  if (config === void 0) {
    config = initConfig(spec.config);
  }
  const normalizedSpec = normalizeGenericSpec(spec, config);
  const {width: width2, height: height2} = spec;
  const autosize = normalizeAutoSize(normalizedSpec, {width: width2, height: height2, autosize: spec.autosize}, config);
  return Object.assign(Object.assign({}, normalizedSpec), autosize ? {autosize} : {});
}
var normalizer = new CoreNormalizer();
function normalizeGenericSpec(spec, config = {}) {
  return normalizer.map(spec, {config});
}
function _normalizeAutoSize(autosize) {
  return isString_default(autosize) ? {type: autosize} : autosize !== null && autosize !== void 0 ? autosize : {};
}
function normalizeAutoSize(spec, sizeInfo, config) {
  let {width: width2, height: height2} = sizeInfo;
  const isFitCompatible = isUnitSpec(spec) || isLayerSpec(spec);
  const autosizeDefault = {};
  if (!isFitCompatible) {
    if (width2 == "container") {
      warn3(message_exports.containerSizeNonSingle("width"));
      width2 = void 0;
    }
    if (height2 == "container") {
      warn3(message_exports.containerSizeNonSingle("height"));
      height2 = void 0;
    }
  } else {
    if (width2 == "container" && height2 == "container") {
      autosizeDefault.type = "fit";
      autosizeDefault.contains = "padding";
    } else if (width2 == "container") {
      autosizeDefault.type = "fit-x";
      autosizeDefault.contains = "padding";
    } else if (height2 == "container") {
      autosizeDefault.type = "fit-y";
      autosizeDefault.contains = "padding";
    }
  }
  const autosize = Object.assign(Object.assign(Object.assign({type: "pad"}, autosizeDefault), config ? _normalizeAutoSize(config.autosize) : {}), _normalizeAutoSize(spec.autosize));
  if (autosize.type === "fit" && !isFitCompatible) {
    warn3(message_exports.FIT_NON_SINGLE);
    autosize.type = "pad";
  }
  if (width2 == "container" && !(autosize.type == "fit" || autosize.type == "fit-x")) {
    warn3(message_exports.containerSizeNotCompatibleWithAutosize("width"));
  }
  if (height2 == "container" && !(autosize.type == "fit" || autosize.type == "fit-y")) {
    warn3(message_exports.containerSizeNotCompatibleWithAutosize("height"));
  }
  if (deepEqual(autosize, {type: "pad"})) {
    return void 0;
  }
  return autosize;
}

// node_modules/vega-lite/build/src/spec/toplevel.js
function isFitType(autoSizeType) {
  return autoSizeType === "fit" || autoSizeType === "fit-x" || autoSizeType === "fit-y";
}
function getFitType(sizeType) {
  return sizeType ? `fit-${getPositionScaleChannel(sizeType)}` : "fit";
}
var TOP_LEVEL_PROPERTIES = [
  "background",
  "padding"
];
function extractTopLevelProperties(t) {
  return TOP_LEVEL_PROPERTIES.reduce((o, p) => {
    if (t && t[p] !== void 0) {
      o[p] = t[p];
    }
    return o;
  }, {});
}

// node_modules/vega-lite/build/src/compile/split.js
var Split = class {
  constructor(explicit = {}, implicit2 = {}) {
    this.explicit = explicit;
    this.implicit = implicit2;
  }
  clone() {
    return new Split(duplicate(this.explicit), duplicate(this.implicit));
  }
  combine() {
    return Object.assign(Object.assign({}, this.explicit), this.implicit);
  }
  get(key2) {
    return getFirstDefined(this.explicit[key2], this.implicit[key2]);
  }
  getWithExplicit(key2) {
    if (this.explicit[key2] !== void 0) {
      return {explicit: true, value: this.explicit[key2]};
    } else if (this.implicit[key2] !== void 0) {
      return {explicit: false, value: this.implicit[key2]};
    }
    return {explicit: false, value: void 0};
  }
  setWithExplicit(key2, value3) {
    if (value3.value !== void 0) {
      this.set(key2, value3.value, value3.explicit);
    }
  }
  set(key2, value3, explicit) {
    delete this[explicit ? "implicit" : "explicit"][key2];
    this[explicit ? "explicit" : "implicit"][key2] = value3;
    return this;
  }
  copyKeyFromSplit(key2, s) {
    if (s.explicit[key2] !== void 0) {
      this.set(key2, s.explicit[key2], true);
    } else if (s.implicit[key2] !== void 0) {
      this.set(key2, s.implicit[key2], false);
    }
  }
  copyKeyFromObject(key2, s) {
    if (s[key2] !== void 0) {
      this.set(key2, s[key2], true);
    }
  }
  copyAll(other) {
    for (const key2 of keys3(other.combine())) {
      const val = other.getWithExplicit(key2);
      this.setWithExplicit(key2, val);
    }
  }
};
function makeExplicit(value3) {
  return {
    explicit: true,
    value: value3
  };
}
function makeImplicit(value3) {
  return {
    explicit: false,
    value: value3
  };
}
function tieBreakByComparing(compare4) {
  return (v1, v2, property2, propertyOf) => {
    const diff2 = compare4(v1.value, v2.value);
    if (diff2 > 0) {
      return v1;
    } else if (diff2 < 0) {
      return v2;
    }
    return defaultTieBreaker(v1, v2, property2, propertyOf);
  };
}
function defaultTieBreaker(v1, v2, property2, propertyOf) {
  if (v1.explicit && v2.explicit) {
    warn3(message_exports.mergeConflictingProperty(property2, propertyOf, v1.value, v2.value));
  }
  return v1;
}
function mergeValuesWithExplicit(v1, v2, property2, propertyOf, tieBreaker = defaultTieBreaker) {
  if (v1 === void 0 || v1.value === void 0) {
    return v2;
  }
  if (v1.explicit && !v2.explicit) {
    return v1;
  } else if (v2.explicit && !v1.explicit) {
    return v2;
  } else if (deepEqual(v1.value, v2.value)) {
    return v1;
  } else {
    return tieBreaker(v1, v2, property2, propertyOf);
  }
}

// node_modules/vega-lite/build/src/compile/data/index.js
var AncestorParse = class extends Split {
  constructor(explicit = {}, implicit2 = {}, parseNothing = false) {
    super(explicit, implicit2);
    this.explicit = explicit;
    this.implicit = implicit2;
    this.parseNothing = parseNothing;
  }
  clone() {
    const clone = super.clone();
    clone.parseNothing = this.parseNothing;
    return clone;
  }
};

// node_modules/vega-lite/build/src/data.js
function isUrlData(data4) {
  return "url" in data4;
}
function isInlineData(data4) {
  return "values" in data4;
}
function isNamedData(data4) {
  return "name" in data4 && !isUrlData(data4) && !isInlineData(data4) && !isGenerator(data4);
}
function isGenerator(data4) {
  return data4 && (isSequenceGenerator(data4) || isSphereGenerator(data4) || isGraticuleGenerator(data4));
}
function isSequenceGenerator(data4) {
  return "sequence" in data4;
}
function isSphereGenerator(data4) {
  return "sphere" in data4;
}
function isGraticuleGenerator(data4) {
  return "graticule" in data4;
}
var MAIN = "main";
var RAW = "raw";

// node_modules/vega-lite/build/src/transform.js
function isFilter(t) {
  return "filter" in t;
}
function isImputeSequence(t) {
  return (t === null || t === void 0 ? void 0 : t["stop"]) !== void 0;
}
function isLookup(t) {
  return "lookup" in t;
}
function isLookupData(from) {
  return "data" in from;
}
function isLookupSelection(from) {
  return "selection" in from;
}
function isPivot(t) {
  return "pivot" in t;
}
function isDensity(t) {
  return "density" in t;
}
function isQuantile2(t) {
  return "quantile" in t;
}
function isRegression(t) {
  return "regression" in t;
}
function isLoess(t) {
  return "loess" in t;
}
function isSample(t) {
  return "sample" in t;
}
function isWindow(t) {
  return "window" in t;
}
function isJoinAggregate(t) {
  return "joinaggregate" in t;
}
function isFlatten(t) {
  return "flatten" in t;
}
function isCalculate(t) {
  return "calculate" in t;
}
function isBin(t) {
  return "bin" in t;
}
function isImpute(t) {
  return "impute" in t;
}
function isTimeUnit(t) {
  return "timeUnit" in t;
}
function isAggregate2(t) {
  return "aggregate" in t;
}
function isStack(t) {
  return "stack" in t;
}
function isFold(t) {
  return "fold" in t;
}
function normalizeTransform(transform4) {
  return transform4.map((t) => {
    if (isFilter(t)) {
      return {
        filter: normalizeLogicalComposition(t.filter, normalizePredicate)
      };
    }
    return t;
  });
}

// node_modules/vega-lite/build/src/compile/mark/encode/conditional.js
function wrapCondition(model, channelDef, vgChannel, refFn) {
  const condition = isConditionalDef(channelDef) && channelDef.condition;
  const valueRef = refFn(channelDef);
  if (condition) {
    const conditions = array_default4(condition);
    const vgConditions = conditions.map((c2) => {
      const conditionValueRef = refFn(c2);
      const test2 = isConditionalSelection(c2) ? parseSelectionPredicate(model, c2.selection) : expression2(model, c2.test);
      return Object.assign({test: test2}, conditionValueRef);
    });
    return {
      [vgChannel]: [...vgConditions, ...valueRef !== void 0 ? [valueRef] : []]
    };
  } else {
    return valueRef !== void 0 ? {[vgChannel]: valueRef} : {};
  }
}

// node_modules/vega-lite/build/src/compile/mark/encode/text.js
function text2(model, channel = "text") {
  const channelDef = model.encoding[channel];
  return wrapCondition(model, channelDef, channel, (cDef) => textRef(cDef, model.config));
}
function textRef(channelDef, config, expr2 = "datum") {
  if (channelDef) {
    if (isValueDef(channelDef)) {
      return signalOrValueRef(channelDef.value);
    }
    if (isFieldOrDatumDef(channelDef)) {
      const {format: format8, formatType} = getFormatMixins(channelDef);
      return formatSignalRef({fieldOrDatumDef: channelDef, format: format8, formatType, expr: expr2, config});
    }
  }
  return void 0;
}

// node_modules/vega-lite/build/src/compile/mark/encode/tooltip.js
function tooltip(model, opt = {}) {
  const {encoding, markDef, config, stack: stack3} = model;
  const channelDef = encoding.tooltip;
  if (isArray_default(channelDef)) {
    return {tooltip: tooltipRefForEncoding({tooltip: channelDef}, stack3, config, opt)};
  } else {
    const datum3 = opt.reactiveGeom ? "datum.datum" : "datum";
    return wrapCondition(model, channelDef, "tooltip", (cDef) => {
      const tooltipRefFromChannelDef = textRef(cDef, config, datum3);
      if (tooltipRefFromChannelDef) {
        return tooltipRefFromChannelDef;
      }
      if (cDef === null) {
        return void 0;
      }
      let markTooltip = getMarkPropOrConfig("tooltip", markDef, config);
      if (markTooltip === true) {
        markTooltip = {content: "encoding"};
      }
      if (isString_default(markTooltip)) {
        return {value: markTooltip};
      } else if (isObject_default(markTooltip)) {
        if (markTooltip.content === "encoding") {
          return tooltipRefForEncoding(encoding, stack3, config, opt);
        } else {
          return {signal: datum3};
        }
      }
      return void 0;
    });
  }
}
function tooltipData(encoding, stack3, config, {reactiveGeom} = {}) {
  const toSkip = {};
  const expr2 = reactiveGeom ? "datum.datum" : "datum";
  const tuples = [];
  function add6(fDef, channel) {
    const mainChannel = getMainRangeChannel(channel);
    const fieldDef = isTypedFieldDef(fDef) ? fDef : Object.assign(Object.assign({}, fDef), {
      type: encoding[mainChannel].type
    });
    const key2 = array_default4(title(fieldDef, config, {allowDisabling: false})).join(", ");
    let value3;
    if (isXorY(channel)) {
      const channel2 = channel === "x" ? "x2" : "y2";
      const fieldDef2 = getFieldDef(encoding[channel2]);
      if (isBinned(fieldDef.bin) && fieldDef2) {
        const startField = vgField(fieldDef, {expr: expr2});
        const endField = vgField(fieldDef2, {expr: expr2});
        const {format: format8, formatType} = getFormatMixins(fieldDef);
        value3 = binFormatExpression(startField, endField, format8, formatType, config);
        toSkip[channel2] = true;
      } else if (stack3 && stack3.fieldChannel === channel && stack3.offset === "normalize") {
        const {format: format8, formatType} = getFormatMixins(fieldDef);
        value3 = formatSignalRef({fieldOrDatumDef: fieldDef, format: format8, formatType, expr: expr2, config, normalizeStack: true}).signal;
      }
    }
    value3 = value3 !== null && value3 !== void 0 ? value3 : textRef(fieldDef, config, expr2).signal;
    tuples.push({channel, key: key2, value: value3});
  }
  forEach(encoding, (channelDef, channel) => {
    if (isFieldDef(channelDef)) {
      add6(channelDef, channel);
    } else if (hasConditionalFieldDef(channelDef)) {
      add6(channelDef.condition, channel);
    }
  });
  const out = {};
  for (const {channel, key: key2, value: value3} of tuples) {
    if (!toSkip[channel] && !out[key2]) {
      out[$2(key2)] = value3;
    }
  }
  return out;
}
function tooltipRefForEncoding(encoding, stack3, config, {reactiveGeom} = {}) {
  const data4 = tooltipData(encoding, stack3, config, {reactiveGeom});
  const keyValues = entries(data4).map(({key: key2, value: value3}) => `${key2}: ${value3}`);
  return keyValues.length > 0 ? {signal: `{${keyValues.join(", ")}}`} : void 0;
}

// node_modules/vega-lite/build/src/compile/mark/encode/aria.js
function aria(model) {
  const {markDef, config} = model;
  const enableAria = getMarkPropOrConfig("aria", markDef, config);
  if (enableAria === false) {
    return {};
  }
  return Object.assign(Object.assign(Object.assign({}, enableAria ? {aria: enableAria} : {}), ariaRoleDescription(model)), description2(model));
}
function ariaRoleDescription(model) {
  const {mark: mark2, markDef, config} = model;
  if (config.aria === false) {
    return {};
  }
  const ariaRoleDesc = getMarkPropOrConfig("ariaRoleDescription", markDef, config);
  if (ariaRoleDesc != null) {
    return {ariaRoleDescription: {value: ariaRoleDesc}};
  }
  return mark2 in VG_MARK_INDEX ? {} : {ariaRoleDescription: {value: mark2}};
}
function description2(model) {
  const {encoding, markDef, config, stack: stack3} = model;
  const channelDef = encoding.description;
  if (channelDef) {
    return wrapCondition(model, channelDef, "description", (cDef) => textRef(cDef, model.config));
  }
  const descriptionValue = getMarkPropOrConfig("description", markDef, config);
  if (descriptionValue != null) {
    return {
      description: signalOrValueRef(descriptionValue)
    };
  }
  if (config.aria === false) {
    return {};
  }
  const data4 = tooltipData(encoding, stack3, config);
  if (isEmpty(data4)) {
    return void 0;
  }
  return {
    description: {
      signal: entries(data4).map(({key: key2, value: value3}) => `${key2} + ": " + (${value3})`).join(' + "; " + ')
    }
  };
}

// node_modules/vega-lite/build/src/compile/mark/encode/nonposition.js
function nonPosition(channel, model, opt = {}) {
  const {markDef, encoding, config} = model;
  const {vgChannel} = opt;
  let {defaultRef, defaultValue} = opt;
  if (defaultRef === void 0) {
    defaultValue = defaultValue !== null && defaultValue !== void 0 ? defaultValue : getMarkPropOrConfig(channel, markDef, config, {vgChannel, ignoreVgConfig: true});
    if (defaultValue !== void 0) {
      defaultRef = signalOrValueRef(defaultValue);
    }
  }
  const channelDef = encoding[channel];
  return wrapCondition(model, channelDef, vgChannel !== null && vgChannel !== void 0 ? vgChannel : channel, (cDef) => {
    return midPoint({
      channel,
      channelDef: cDef,
      markDef,
      config,
      scaleName: model.scaleName(channel),
      scale: model.getScaleComponent(channel),
      stack: null,
      defaultRef
    });
  });
}

// node_modules/vega-lite/build/src/compile/mark/encode/color.js
function color4(model, opt = {filled: void 0}) {
  var _a2, _b, _c, _d;
  const {markDef, encoding, config} = model;
  const {type: markType2} = markDef;
  const filled2 = (_a2 = opt.filled) !== null && _a2 !== void 0 ? _a2 : getMarkPropOrConfig("filled", markDef, config);
  const transparentIfNeeded = contains2(["bar", "point", "circle", "square", "geoshape"], markType2) ? "transparent" : void 0;
  const defaultFill = (_c = (_b = getMarkPropOrConfig(filled2 === true ? "color" : void 0, markDef, config, {vgChannel: "fill"})) !== null && _b !== void 0 ? _b : config.mark[filled2 === true && "color"]) !== null && _c !== void 0 ? _c : transparentIfNeeded;
  const defaultStroke = (_d = getMarkPropOrConfig(filled2 === false ? "color" : void 0, markDef, config, {vgChannel: "stroke"})) !== null && _d !== void 0 ? _d : config.mark[filled2 === false && "color"];
  const colorVgChannel = filled2 ? "fill" : "stroke";
  const fillStrokeMarkDefAndConfig = Object.assign(Object.assign({}, defaultFill ? {fill: signalOrValueRef(defaultFill)} : {}), defaultStroke ? {stroke: signalOrValueRef(defaultStroke)} : {});
  if (markDef.color && (filled2 ? markDef.fill : markDef.stroke)) {
    warn3(message_exports.droppingColor("property", {fill: "fill" in markDef, stroke: "stroke" in markDef}));
  }
  return Object.assign(Object.assign(Object.assign(Object.assign({}, fillStrokeMarkDefAndConfig), nonPosition("color", model, {
    vgChannel: colorVgChannel,
    defaultValue: filled2 ? defaultFill : defaultStroke
  })), nonPosition("fill", model, {
    defaultValue: encoding.fill ? defaultFill : void 0
  })), nonPosition("stroke", model, {
    defaultValue: encoding.stroke ? defaultStroke : void 0
  }));
}

// node_modules/vega-lite/build/src/compile/mark/encode/offset.js
function getOffset(channel, markDef) {
  const offsetChannel = getOffsetChannel(channel);
  const markDefOffsetValue = markDef[offsetChannel];
  if (markDefOffsetValue) {
    return markDefOffsetValue;
  }
  return void 0;
}

// node_modules/vega-lite/build/src/compile/mark/encode/position-point.js
function pointPosition(channel, model, {defaultPos, vgChannel, isMidPoint}) {
  const {encoding, markDef, config, stack: stack3} = model;
  const channelDef = encoding[channel];
  const channel2Def = encoding[getSecondaryRangeChannel(channel)];
  const scaleName = model.scaleName(channel);
  const scale7 = model.getScaleComponent(channel);
  const offset4 = getOffset(channel, markDef);
  const defaultRef = pointPositionDefaultRef({
    model,
    defaultPos,
    channel,
    scaleName,
    scale: scale7
  });
  const valueRef = !channelDef && isXorY(channel) && (encoding.latitude || encoding.longitude) ? {field: model.getName(channel)} : positionRef({
    channel,
    channelDef,
    channel2Def,
    markDef,
    config,
    isMidPoint,
    scaleName,
    scale: scale7,
    stack: stack3,
    offset: offset4,
    defaultRef
  });
  return valueRef ? {[vgChannel || channel]: valueRef} : void 0;
}
function positionRef(params2) {
  const {channel, channelDef, isMidPoint, scaleName, stack: stack3, offset: offset4, markDef, config} = params2;
  if (isFieldOrDatumDef(channelDef) && stack3 && channel === stack3.fieldChannel) {
    if (isFieldDef(channelDef)) {
      const band2 = getBand({
        channel,
        fieldDef: channelDef,
        isMidPoint,
        markDef,
        stack: stack3,
        config
      });
      if (band2 !== void 0) {
        return interpolatedSignalRef({
          scaleName,
          fieldOrDatumDef: channelDef,
          startSuffix: "start",
          band: band2,
          offset: offset4
        });
      }
    }
    return valueRefForFieldOrDatumDef(channelDef, scaleName, {suffix: "end"}, {offset: offset4});
  }
  return midPointRefWithPositionInvalidTest(params2);
}
function pointPositionDefaultRef({model, defaultPos, channel, scaleName, scale: scale7}) {
  const {markDef, config} = model;
  return () => {
    const mainChannel = getMainRangeChannel(channel);
    const vgChannel = getVgPositionChannel(channel);
    const definedValueOrConfig = getMarkPropOrConfig(channel, markDef, config, {vgChannel});
    if (definedValueOrConfig !== void 0) {
      return widthHeightValueOrSignalRef(channel, definedValueOrConfig);
    }
    switch (defaultPos) {
      case "zeroOrMin":
      case "zeroOrMax":
        if (scaleName) {
          const scaleType2 = scale7.get("type");
          if (contains2([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType2)) {
          } else {
            if (scale7.domainDefinitelyIncludesZero()) {
              return {
                scale: scaleName,
                value: 0
              };
            }
          }
        }
        if (defaultPos === "zeroOrMin") {
          return mainChannel === "y" ? {field: {group: "height"}} : {value: 0};
        } else {
          switch (mainChannel) {
            case "radius":
              return {
                signal: `min(${model.width.signal},${model.height.signal})/2`
              };
            case "theta":
              return {signal: "2*PI"};
            case "x":
              return {field: {group: "width"}};
            case "y":
              return {value: 0};
          }
        }
        break;
      case "mid": {
        const sizeRef = model[getSizeChannel(channel)];
        return Object.assign(Object.assign({}, sizeRef), {mult: 0.5});
      }
    }
    return void 0;
  };
}

// node_modules/vega-lite/build/src/compile/mark/encode/position-align.js
var ALIGNED_X_CHANNEL = {
  left: "x",
  center: "xc",
  right: "x2"
};
var BASELINED_Y_CHANNEL = {
  top: "y",
  middle: "yc",
  bottom: "y2"
};
function vgAlignedPositionChannel(channel, markDef, config, defaultAlign = "middle") {
  if (channel === "radius" || channel === "theta") {
    return getVgPositionChannel(channel);
  }
  const alignChannel = channel === "x" ? "align" : "baseline";
  const align2 = getMarkPropOrConfig(alignChannel, markDef, config);
  if (channel === "x") {
    return ALIGNED_X_CHANNEL[align2 || (defaultAlign === "top" ? "left" : "center")];
  } else {
    return BASELINED_Y_CHANNEL[align2 || defaultAlign];
  }
}

// node_modules/vega-lite/build/src/compile/mark/encode/position-range.js
function pointOrRangePosition(channel, model, {defaultPos, defaultPos2, range: range5}) {
  if (range5) {
    return rangePosition(channel, model, {defaultPos, defaultPos2});
  }
  return pointPosition(channel, model, {defaultPos});
}
function rangePosition(channel, model, {defaultPos, defaultPos2}) {
  const {markDef, config} = model;
  const channel2 = getSecondaryRangeChannel(channel);
  const sizeChannel = getSizeChannel(channel);
  const pos2Mixins = pointPosition2OrSize(model, defaultPos2, channel2);
  const vgChannel = pos2Mixins[sizeChannel] ? vgAlignedPositionChannel(channel, markDef, config) : getVgPositionChannel(channel);
  return Object.assign(Object.assign({}, pointPosition(channel, model, {defaultPos, vgChannel})), pos2Mixins);
}
function pointPosition2OrSize(model, defaultPos, channel) {
  const {encoding, mark: mark2, markDef, stack: stack3, config} = model;
  const baseChannel = getMainRangeChannel(channel);
  const sizeChannel = getSizeChannel(channel);
  const vgChannel = getVgPositionChannel(channel);
  const channelDef = encoding[baseChannel];
  const scaleName = model.scaleName(baseChannel);
  const scale7 = model.getScaleComponent(baseChannel);
  const offset4 = channel in encoding || channel in markDef ? getOffset(channel, model.markDef) : getOffset(baseChannel, model.markDef);
  if (!channelDef && (channel === "x2" || channel === "y2") && (encoding.latitude || encoding.longitude)) {
    return {[vgChannel]: {field: model.getName(channel)}};
  }
  const valueRef = position2Ref({
    channel,
    channelDef,
    channel2Def: encoding[channel],
    markDef,
    config,
    scaleName,
    scale: scale7,
    stack: stack3,
    offset: offset4,
    defaultRef: void 0
  });
  if (valueRef !== void 0) {
    return {[vgChannel]: valueRef};
  }
  return position2orSize(channel, markDef) || position2orSize(channel, {
    [channel]: getMarkStyleConfig(channel, markDef, config.style),
    [sizeChannel]: getMarkStyleConfig(sizeChannel, markDef, config.style)
  }) || position2orSize(channel, config[mark2]) || position2orSize(channel, config.mark) || {
    [vgChannel]: pointPositionDefaultRef({
      model,
      defaultPos,
      channel,
      scaleName,
      scale: scale7
    })()
  };
}
function position2Ref({channel, channelDef, channel2Def, markDef, config, scaleName, scale: scale7, stack: stack3, offset: offset4, defaultRef}) {
  if (isFieldOrDatumDef(channelDef) && stack3 && channel.charAt(0) === stack3.fieldChannel.charAt(0)) {
    return valueRefForFieldOrDatumDef(channelDef, scaleName, {suffix: "start"}, {offset: offset4});
  }
  return midPointRefWithPositionInvalidTest({
    channel,
    channelDef: channel2Def,
    scaleName,
    scale: scale7,
    stack: stack3,
    markDef,
    config,
    offset: offset4,
    defaultRef
  });
}
function position2orSize(channel, markDef) {
  const sizeChannel = getSizeChannel(channel);
  const vgChannel = getVgPositionChannel(channel);
  if (markDef[vgChannel] !== void 0) {
    return {[vgChannel]: widthHeightValueOrSignalRef(channel, markDef[vgChannel])};
  } else if (markDef[channel] !== void 0) {
    return {[vgChannel]: widthHeightValueOrSignalRef(channel, markDef[channel])};
  } else if (markDef[sizeChannel]) {
    return {[sizeChannel]: widthHeightValueOrSignalRef(channel, markDef[sizeChannel])};
  }
  return void 0;
}

// node_modules/vega-lite/build/src/compile/mark/encode/position-rect.js
function rectPosition(model, channel, mark2) {
  var _a2, _b, _c, _d;
  const {config, encoding, markDef, stack: stack3} = model;
  const channel2 = getSecondaryRangeChannel(channel);
  const sizeChannel = getSizeChannel(channel);
  const channelDef = encoding[channel];
  const channelDef2 = encoding[channel2];
  const scale7 = model.getScaleComponent(channel);
  const scaleType2 = scale7 ? scale7.get("type") : void 0;
  const scaleName = model.scaleName(channel);
  const orient3 = markDef.orient;
  const hasSizeDef = (_b = (_a2 = encoding[sizeChannel]) !== null && _a2 !== void 0 ? _a2 : encoding.size) !== null && _b !== void 0 ? _b : getMarkPropOrConfig("size", markDef, config, {vgChannel: sizeChannel});
  const isBarBand = mark2 === "bar" && (channel === "x" ? orient3 === "vertical" : orient3 === "horizontal");
  if (isFieldDef(channelDef) && (isBinning(channelDef.bin) || isBinned(channelDef.bin) || channelDef.timeUnit && !channelDef2) && !hasSizeDef && !hasDiscreteDomain(scaleType2)) {
    const band2 = getBand({channel, fieldDef: channelDef, stack: stack3, markDef, config});
    const axis = (_c = model.component.axes[channel]) === null || _c === void 0 ? void 0 : _c[0];
    const axisTranslate = (_d = axis === null || axis === void 0 ? void 0 : axis.get("translate")) !== null && _d !== void 0 ? _d : 0.5;
    return rectBinPosition({
      fieldDef: channelDef,
      fieldDef2: channelDef2,
      channel,
      markDef,
      scaleName,
      band: band2,
      axisTranslate,
      spacing: isXorY(channel) ? getMarkPropOrConfig("binSpacing", markDef, config) : void 0,
      reverse: scale7.get("reverse"),
      config
    });
  } else if ((isFieldOrDatumDef(channelDef) && hasDiscreteDomain(scaleType2) || isBarBand) && !channelDef2) {
    return positionAndSize(mark2, channelDef, channel, model);
  } else {
    return rangePosition(channel, model, {defaultPos: "zeroOrMax", defaultPos2: "zeroOrMin"});
  }
}
function defaultSizeRef(mark2, sizeChannel, scaleName, scale7, config, band2) {
  if (scale7) {
    const scaleType2 = scale7.get("type");
    if (scaleType2 === "point" || scaleType2 === "band") {
      if (config[mark2].discreteBandSize !== void 0) {
        return {value: config[mark2].discreteBandSize};
      }
      if (scaleType2 === ScaleType.POINT) {
        const scaleRange = scale7.get("range");
        if (isVgRangeStep(scaleRange) && isNumber_default(scaleRange.step)) {
          return {value: scaleRange.step - 2};
        }
        return {value: DEFAULT_STEP - 2};
      } else {
        return {scale: scaleName, band: band2};
      }
    } else {
      return {value: config[mark2].continuousBandSize};
    }
  }
  const step = getViewConfigDiscreteStep(config.view, sizeChannel);
  const value3 = getFirstDefined(config[mark2].discreteBandSize, step - 2);
  return value3 !== void 0 ? {value: value3} : void 0;
}
function positionAndSize(mark2, fieldDef, channel, model) {
  var _a2;
  const {markDef, encoding, config, stack: stack3} = model;
  const orient3 = markDef.orient;
  const scaleName = model.scaleName(channel);
  const scale7 = model.getScaleComponent(channel);
  const vgSizeChannel = getSizeChannel(channel);
  const channel2 = getSecondaryRangeChannel(channel);
  const useVlSizeChannel = orient3 === "horizontal" && channel === "y" || orient3 === "vertical" && channel === "x";
  const sizeFromMarkOrConfig = getMarkPropOrConfig(useVlSizeChannel ? "size" : vgSizeChannel, markDef, config, {
    vgChannel: vgSizeChannel
  });
  let sizeMixins;
  if (encoding.size || sizeFromMarkOrConfig !== void 0) {
    if (useVlSizeChannel) {
      sizeMixins = nonPosition("size", model, {vgChannel: vgSizeChannel, defaultValue: sizeFromMarkOrConfig});
    } else {
      warn3(message_exports.cannotApplySizeToNonOrientedMark(markDef.type));
    }
  }
  const band2 = (_a2 = isFieldOrDatumDef(fieldDef) ? getBand({channel, fieldDef, markDef, stack: stack3, config}) : void 0) !== null && _a2 !== void 0 ? _a2 : 1;
  sizeMixins = sizeMixins || {[vgSizeChannel]: defaultSizeRef(mark2, vgSizeChannel, scaleName, scale7, config, band2)};
  const center = (scale7 === null || scale7 === void 0 ? void 0 : scale7.get("type")) !== "band" || !("band" in sizeMixins[vgSizeChannel]);
  const vgChannel = vgAlignedPositionChannel(channel, markDef, config, center ? "middle" : "top");
  const offset4 = getOffset(channel, markDef);
  const posRef = midPointRefWithPositionInvalidTest({
    channel,
    channelDef: fieldDef,
    markDef,
    config,
    scaleName,
    scale: scale7,
    stack: stack3,
    offset: offset4,
    defaultRef: pointPositionDefaultRef({model, defaultPos: "mid", channel, scaleName, scale: scale7}),
    band: center ? 0.5 : (1 - band2) / 2
  });
  if (vgSizeChannel) {
    return Object.assign({[vgChannel]: posRef}, sizeMixins);
  } else {
    const vgChannel2 = getVgPositionChannel(channel2);
    const sizeRef = sizeMixins[vgSizeChannel];
    const sizeOffset = offset4 ? Object.assign(Object.assign({}, sizeRef), {offset: offset4}) : sizeRef;
    return {
      [vgChannel]: posRef,
      [vgChannel2]: isArray_default(posRef) ? [posRef[0], Object.assign(Object.assign({}, posRef[1]), {offset: sizeOffset})] : Object.assign(Object.assign({}, posRef), {offset: sizeOffset})
    };
  }
}
function getBinSpacing(channel, spacing, reverse4, translate4, offset4) {
  if (isPolarPositionChannel(channel)) {
    return 0;
  }
  const spacingOffset = channel === "x" || channel === "y2" ? -spacing / 2 : spacing / 2;
  if (isSignalRef(reverse4)) {
    const offsetExpr = signalOrStringValue(offset4);
    return {
      signal: `${reverse4.signal} ? ${translate4 - spacingOffset}${offsetExpr ? "-" + offsetExpr : ""} : ${translate4 + spacingOffset}${offsetExpr ? "+" + offsetExpr : ""}`
    };
  } else {
    if (isSignalRef(offset4)) {
      const translateAndSpacingOffset = translate4 + (reverse4 ? -spacingOffset : spacingOffset);
      return {
        signal: `${translateAndSpacingOffset || ""}${reverse4 ? " - " : translateAndSpacingOffset ? " + " : ""}${offset4.signal}`
      };
    }
    offset4 = offset4 || 0;
    return translate4 + (reverse4 ? -offset4 - spacingOffset : +offset4 + spacingOffset);
  }
}
function rectBinPosition({fieldDef, fieldDef2, channel, band: band2, scaleName, markDef, spacing = 0, axisTranslate, reverse: reverse4, config}) {
  const channel2 = getSecondaryRangeChannel(channel);
  const vgChannel = getVgPositionChannel(channel);
  const vgChannel2 = getVgPositionChannel(channel2);
  const offset4 = getOffset(channel, markDef);
  if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {
    return {
      [vgChannel2]: rectBinRef({
        channel,
        fieldDef,
        scaleName,
        markDef,
        band: (1 - band2) / 2,
        offset: getBinSpacing(channel2, spacing, reverse4, axisTranslate, offset4),
        config
      }),
      [vgChannel]: rectBinRef({
        channel,
        fieldDef,
        scaleName,
        markDef,
        band: 1 - (1 - band2) / 2,
        offset: getBinSpacing(channel, spacing, reverse4, axisTranslate, offset4),
        config
      })
    };
  } else if (isBinned(fieldDef.bin)) {
    const startRef = valueRefForFieldOrDatumDef(fieldDef, scaleName, {}, {offset: getBinSpacing(channel2, spacing, reverse4, axisTranslate, offset4)});
    if (isFieldDef(fieldDef2)) {
      return {
        [vgChannel2]: startRef,
        [vgChannel]: valueRefForFieldOrDatumDef(fieldDef2, scaleName, {}, {offset: getBinSpacing(channel, spacing, reverse4, axisTranslate, offset4)})
      };
    } else if (isBinParams(fieldDef.bin) && fieldDef.bin.step) {
      return {
        [vgChannel2]: startRef,
        [vgChannel]: {
          signal: `scale("${scaleName}", ${vgField(fieldDef, {expr: "datum"})} + ${fieldDef.bin.step})`,
          offset: getBinSpacing(channel, spacing, reverse4, axisTranslate, offset4)
        }
      };
    }
  }
  warn3(message_exports.channelRequiredForBinned(channel2));
  return void 0;
}
function rectBinRef({channel, fieldDef, scaleName, markDef, band: band2, offset: offset4, config}) {
  const r2 = interpolatedSignalRef({
    scaleName,
    fieldOrDatumDef: fieldDef,
    band: band2,
    offset: offset4
  });
  return wrapPositionInvalidTest({
    fieldDef,
    channel,
    markDef,
    ref: r2,
    config
  });
}

// node_modules/vega-lite/build/src/compile/mark/encode/base.js
var ALWAYS_IGNORE = new Set(["aria"]);
function baseEncodeEntry(model, ignore) {
  const {fill: fill2 = void 0, stroke: stroke2 = void 0} = ignore.color === "include" ? color4(model) : {};
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, markDefProperties(model.markDef, ignore)), wrapAllFieldsInvalid(model, "fill", fill2)), wrapAllFieldsInvalid(model, "stroke", stroke2)), nonPosition("opacity", model)), nonPosition("fillOpacity", model)), nonPosition("strokeOpacity", model)), nonPosition("strokeWidth", model)), nonPosition("strokeDash", model)), tooltip(model)), text2(model, "href")), aria(model));
}
function wrapAllFieldsInvalid(model, channel, valueRef) {
  const {config, mark: mark2, markDef} = model;
  const invalid = getMarkPropOrConfig("invalid", markDef, config);
  if (invalid === "hide" && valueRef && !isPathMark(mark2)) {
    const test2 = allFieldsInvalidPredicate(model, {invalid: true, channels: SCALE_CHANNELS});
    if (test2) {
      return {
        [channel]: [
          {test: test2, value: null},
          ...array_default4(valueRef)
        ]
      };
    }
  }
  return valueRef ? {[channel]: valueRef} : {};
}
function markDefProperties(mark2, ignore) {
  return VG_MARK_CONFIGS.reduce((m2, prop) => {
    if (!ALWAYS_IGNORE.has(prop) && mark2[prop] !== void 0 && ignore[prop] !== "ignore") {
      m2[prop] = signalOrValueRef(mark2[prop]);
    }
    return m2;
  }, {});
}
function allFieldsInvalidPredicate(model, {invalid = false, channels}) {
  const filterIndex = channels.reduce((aggregator, channel) => {
    const scaleComponent = model.getScaleComponent(channel);
    if (scaleComponent) {
      const scaleType2 = scaleComponent.get("type");
      const field4 = model.vgField(channel, {expr: "datum"});
      if (field4 && hasContinuousDomain(scaleType2)) {
        aggregator[field4] = true;
      }
    }
    return aggregator;
  }, {});
  const fields = keys3(filterIndex);
  if (fields.length > 0) {
    const op = invalid ? "||" : "&&";
    return fields.map((field4) => fieldInvalidPredicate(field4, invalid)).join(` ${op} `);
  }
  return void 0;
}

// node_modules/vega-lite/build/src/compile/mark/encode/defined.js
function defined(model) {
  const {config, markDef} = model;
  const invalid = getMarkPropOrConfig("invalid", markDef, config);
  if (invalid) {
    const signal = allFieldsInvalidPredicate2(model, {channels: POSITION_SCALE_CHANNELS});
    if (signal) {
      return {defined: {signal}};
    }
  }
  return {};
}
function allFieldsInvalidPredicate2(model, {invalid = false, channels}) {
  const filterIndex = channels.reduce((aggregator, channel) => {
    const scaleComponent = model.getScaleComponent(channel);
    if (scaleComponent) {
      const scaleType2 = scaleComponent.get("type");
      const field4 = model.vgField(channel, {expr: "datum"});
      if (field4 && hasContinuousDomain(scaleType2)) {
        aggregator[field4] = true;
      }
    }
    return aggregator;
  }, {});
  const fields = keys3(filterIndex);
  if (fields.length > 0) {
    const op = invalid ? "||" : "&&";
    return fields.map((field4) => fieldInvalidPredicate(field4, invalid)).join(` ${op} `);
  }
  return void 0;
}
function valueIfDefined(prop, value3) {
  if (value3 !== void 0) {
    return {[prop]: signalOrValueRef(value3)};
  }
  return void 0;
}

// node_modules/vega-lite/build/src/compile/selection/transforms/nearest.js
var VORONOI = "voronoi";
var nearest = {
  has: (selCmpt) => {
    return selCmpt.type !== "interval" && selCmpt.nearest;
  },
  parse: (model, selCmpt) => {
    if (selCmpt.events) {
      for (const s of selCmpt.events) {
        s.markname = model.getName(VORONOI);
      }
    }
  },
  marks: (model, selCmpt, marks) => {
    const {x: x5, y: y5} = selCmpt.project.hasChannel;
    const markType2 = model.mark;
    if (isPathMark(markType2)) {
      warn3(message_exports.nearestNotSupportForContinuous(markType2));
      return marks;
    }
    const cellDef = {
      name: model.getName(VORONOI),
      type: "path",
      interactive: true,
      from: {data: model.getName("marks")},
      encode: {
        update: Object.assign({fill: {value: "transparent"}, strokeWidth: {value: 0.35}, stroke: {value: "transparent"}, isVoronoi: {value: true}}, tooltip(model, {reactiveGeom: true}))
      },
      transform: [
        {
          type: "voronoi",
          x: {expr: x5 || !y5 ? "datum.datum.x || 0" : "0"},
          y: {expr: y5 || !x5 ? "datum.datum.y || 0" : "0"},
          size: [model.getSizeSignalRef("width"), model.getSizeSignalRef("height")]
        }
      ]
    };
    let index4 = 0;
    let exists = false;
    marks.forEach((mark2, i) => {
      var _a2;
      const name4 = (_a2 = mark2.name) !== null && _a2 !== void 0 ? _a2 : "";
      if (name4 === model.component.mark[0].name) {
        index4 = i;
      } else if (name4.indexOf(VORONOI) >= 0) {
        exists = true;
      }
    });
    if (!exists) {
      marks.splice(index4 + 1, 0, cellDef);
    }
    return marks;
  }
};
var nearest_default = nearest;

// node_modules/vega-lite/build/src/compile/data/dataflow.js
var DataFlowNode = class {
  constructor(parent, debugName) {
    this.debugName = debugName;
    this._children = [];
    this._parent = null;
    if (parent) {
      this.parent = parent;
    }
  }
  clone() {
    throw new Error("Cannot clone node");
  }
  get parent() {
    return this._parent;
  }
  set parent(parent) {
    this._parent = parent;
    if (parent) {
      parent.addChild(this);
    }
  }
  get children() {
    return this._children;
  }
  numChildren() {
    return this._children.length;
  }
  addChild(child, loc) {
    if (this._children.indexOf(child) > -1) {
      console.warn("Attempt to add the same child twice.");
      return;
    }
    if (loc !== void 0) {
      this._children.splice(loc, 0, child);
    } else {
      this._children.push(child);
    }
  }
  removeChild(oldChild) {
    const loc = this._children.indexOf(oldChild);
    this._children.splice(loc, 1);
    return loc;
  }
  remove() {
    let loc = this._parent.removeChild(this);
    for (const child of this._children) {
      child._parent = this._parent;
      this._parent.addChild(child, loc++);
    }
  }
  insertAsParentOf(other) {
    const parent = other.parent;
    parent.removeChild(this);
    this.parent = parent;
    other.parent = this;
  }
  swapWithParent() {
    const parent = this._parent;
    const newParent = parent.parent;
    for (const child of this._children) {
      child.parent = parent;
    }
    this._children = [];
    parent.removeChild(this);
    parent.parent.removeChild(parent);
    this.parent = newParent;
    parent.parent = this;
  }
};
var OutputNode = class extends DataFlowNode {
  constructor(parent, source4, type2, refCounts) {
    super(parent, source4);
    this.type = type2;
    this.refCounts = refCounts;
    this._source = this._name = source4;
    if (this.refCounts && !(this._name in this.refCounts)) {
      this.refCounts[this._name] = 0;
    }
  }
  clone() {
    const cloneObj = new this.constructor();
    cloneObj.debugName = "clone_" + this.debugName;
    cloneObj._source = this._source;
    cloneObj._name = "clone_" + this._name;
    cloneObj.type = this.type;
    cloneObj.refCounts = this.refCounts;
    cloneObj.refCounts[cloneObj._name] = 0;
    return cloneObj;
  }
  dependentFields() {
    return new Set();
  }
  producedFields() {
    return new Set();
  }
  hash() {
    if (this._hash === void 0) {
      this._hash = `Output ${uniqueId()}`;
    }
    return this._hash;
  }
  getSource() {
    this.refCounts[this._name]++;
    return this._source;
  }
  isRequired() {
    return !!this.refCounts[this._name];
  }
  setSource(source4) {
    this._source = source4;
  }
};

// node_modules/vega-lite/build/src/compile/data/timeunit.js
var TimeUnitNode = class extends DataFlowNode {
  constructor(parent, formula) {
    super(parent);
    this.formula = formula;
  }
  clone() {
    return new TimeUnitNode(null, duplicate(this.formula));
  }
  static makeFromEncoding(parent, model) {
    const formula = model.reduceFieldDef((timeUnitComponent, fieldDef, channel) => {
      const {field: field4, timeUnit} = fieldDef;
      const channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : void 0;
      const band2 = isUnitModel(model) && hasBand(channel, fieldDef, channelDef2, model.stack, model.markDef, model.config);
      if (timeUnit) {
        const as = vgField(fieldDef, {forAs: true});
        timeUnitComponent[hash({
          as,
          field: field4,
          timeUnit
        })] = Object.assign({
          as,
          field: field4,
          timeUnit
        }, band2 ? {band: true} : {});
      }
      return timeUnitComponent;
    }, {});
    if (isEmpty(formula)) {
      return null;
    }
    return new TimeUnitNode(parent, formula);
  }
  static makeFromTransform(parent, t) {
    const _a2 = Object.assign({}, t), {timeUnit} = _a2, other = __rest(_a2, ["timeUnit"]);
    const normalizedTimeUnit = normalizeTimeUnit(timeUnit);
    const component = Object.assign(Object.assign({}, other), {timeUnit: normalizedTimeUnit});
    return new TimeUnitNode(parent, {
      [hash(component)]: component
    });
  }
  merge(other) {
    this.formula = Object.assign({}, this.formula);
    for (const key2 in other.formula) {
      if (!this.formula[key2] || other.formula[key2].band) {
        this.formula[key2] = other.formula[key2];
      }
    }
    for (const child of other.children) {
      other.removeChild(child);
      child.parent = this;
    }
    other.remove();
  }
  producedFields() {
    return new Set(vals(this.formula).map((f) => f.as));
  }
  dependentFields() {
    return new Set(vals(this.formula).map((f) => f.field));
  }
  hash() {
    return `TimeUnit ${hash(this.formula)}`;
  }
  assemble() {
    const transforms2 = [];
    for (const f of vals(this.formula)) {
      const {field: field4, as, timeUnit} = f;
      const _a2 = normalizeTimeUnit(timeUnit), {unit: unit2, utc} = _a2, params2 = __rest(_a2, ["unit", "utc"]);
      transforms2.push(Object.assign(Object.assign(Object.assign(Object.assign({field: replacePathInField(field4), type: "timeunit"}, unit2 ? {units: getTimeUnitParts(unit2)} : {}), utc ? {timezone: "utc"} : {}), params2), {as: [as, `${as}_end`]}));
    }
    return transforms2;
  }
};

// node_modules/vega-lite/build/src/compile/selection/transforms/project.js
var TUPLE_FIELDS = "_tuple_fields";
var SelectionProjectionComponent = class {
  constructor(...items2) {
    this.items = items2;
    this.hasChannel = {};
    this.hasField = {};
  }
};
var project2 = {
  has: () => {
    return true;
  },
  parse: (model, selCmpt, selDef) => {
    var _a2, _b, _c;
    const name4 = selCmpt.name;
    const proj = (_a2 = selCmpt.project) !== null && _a2 !== void 0 ? _a2 : selCmpt.project = new SelectionProjectionComponent();
    const parsed = {};
    const timeUnits2 = {};
    const signals = new Set();
    const signalName = (p, range5) => {
      const suffix = range5 === "visual" ? p.channel : p.field;
      let sg = varName(`${name4}_${suffix}`);
      for (let counter = 1; signals.has(sg); counter++) {
        sg = varName(`${name4}_${suffix}_${counter}`);
      }
      signals.add(sg);
      return {[range5]: sg};
    };
    if (!selDef.fields && !selDef.encodings) {
      const cfg = model.config.selection[selDef.type];
      if (selDef.init) {
        for (const init2 of array_default4(selDef.init)) {
          for (const key2 of keys3(init2)) {
            if (isSingleDefUnitChannel(key2)) {
              (selDef.encodings || (selDef.encodings = [])).push(key2);
            } else {
              if (selDef.type === "interval") {
                warn3('Interval selections should be initialized using "x" and/or "y" keys.');
                selDef.encodings = cfg.encodings;
              } else {
                (selDef.fields || (selDef.fields = [])).push(key2);
              }
            }
          }
        }
      } else {
        selDef.encodings = cfg.encodings;
        selDef.fields = cfg.fields;
      }
    }
    for (const field4 of (_b = selDef.fields) !== null && _b !== void 0 ? _b : []) {
      const p = {type: "E", field: field4};
      p.signals = Object.assign({}, signalName(p, "data"));
      proj.items.push(p);
      proj.hasField[field4] = p;
    }
    for (const channel of (_c = selDef.encodings) !== null && _c !== void 0 ? _c : []) {
      const fieldDef = model.fieldDef(channel);
      if (fieldDef) {
        let field4 = fieldDef.field;
        if (fieldDef.aggregate) {
          warn3(message_exports.cannotProjectAggregate(channel, fieldDef.aggregate));
          continue;
        } else if (!field4) {
          warn3(message_exports.cannotProjectOnChannelWithoutField(channel));
          continue;
        }
        if (fieldDef.timeUnit) {
          field4 = model.vgField(channel);
          const component = {
            timeUnit: fieldDef.timeUnit,
            as: field4,
            field: fieldDef.field
          };
          timeUnits2[hash(component)] = component;
        }
        if (!parsed[field4]) {
          let type2 = "E";
          if (selCmpt.type === "interval") {
            const scaleType2 = model.getScaleComponent(channel).get("type");
            if (hasContinuousDomain(scaleType2)) {
              type2 = "R";
            }
          } else if (fieldDef.bin) {
            type2 = "R-RE";
          }
          const p = {field: field4, channel, type: type2};
          p.signals = Object.assign(Object.assign({}, signalName(p, "data")), signalName(p, "visual"));
          proj.items.push(parsed[field4] = p);
          proj.hasField[field4] = proj.hasChannel[channel] = parsed[field4];
        }
      } else {
        warn3(message_exports.cannotProjectOnChannelWithoutField(channel));
      }
    }
    if (selDef.init) {
      const parseInit = (i) => {
        return proj.items.map((p) => i[p.channel] !== void 0 ? i[p.channel] : i[p.field]);
      };
      if (selDef.type === "interval") {
        selCmpt.init = parseInit(selDef.init);
      } else {
        const init2 = array_default4(selDef.init);
        selCmpt.init = init2.map(parseInit);
      }
    }
    if (!isEmpty(timeUnits2)) {
      proj.timeUnit = new TimeUnitNode(null, timeUnits2);
    }
  },
  signals: (model, selCmpt, allSignals) => {
    const name4 = selCmpt.name + TUPLE_FIELDS;
    const hasSignal2 = allSignals.filter((s) => s.name === name4);
    return hasSignal2.length > 0 ? allSignals : allSignals.concat({
      name: name4,
      value: selCmpt.project.items.map((proj) => {
        const {signals, hasLegend} = proj, rest = __rest(proj, ["signals", "hasLegend"]);
        rest.field = replacePathInField(rest.field);
        return rest;
      })
    });
  }
};
var project_default = project2;

// node_modules/vega-lite/build/src/compile/selection/transforms/inputs.js
var inputBindings = {
  has: (selCmpt) => {
    return selCmpt.type === "single" && selCmpt.resolve === "global" && selCmpt.bind && selCmpt.bind !== "scales" && !isLegendBinding(selCmpt.bind);
  },
  parse: (model, selCmpt, selDef, origDef) => {
    if (!origDef.on)
      delete selCmpt.events;
    if (!origDef.clear)
      delete selCmpt.clear;
  },
  topLevelSignals: (model, selCmpt, signals) => {
    const name4 = selCmpt.name;
    const proj = selCmpt.project;
    const bind3 = selCmpt.bind;
    const init2 = selCmpt.init && selCmpt.init[0];
    const datum3 = nearest_default.has(selCmpt) ? "(item().isVoronoi ? datum.datum : datum)" : "datum";
    proj.items.forEach((p, i) => {
      var _a2, _b;
      const sgname = varName(`${name4}_${p.field}`);
      const hasSignal2 = signals.filter((s) => s.name === sgname);
      if (!hasSignal2.length) {
        signals.unshift(Object.assign(Object.assign({name: sgname}, init2 ? {init: assembleInit(init2[i])} : {value: null}), {on: selCmpt.events ? [
          {
            events: selCmpt.events,
            update: `datum && item().mark.marktype !== 'group' ? ${datum3}[${$2(p.field)}] : null`
          }
        ] : [], bind: (_b = (_a2 = bind3[p.field]) !== null && _a2 !== void 0 ? _a2 : bind3[p.channel]) !== null && _b !== void 0 ? _b : bind3}));
      }
    });
    return signals;
  },
  signals: (model, selCmpt, signals) => {
    const name4 = selCmpt.name;
    const proj = selCmpt.project;
    const signal = signals.filter((s) => s.name === name4 + TUPLE)[0];
    const fields = name4 + TUPLE_FIELDS;
    const values4 = proj.items.map((p) => varName(`${name4}_${p.field}`));
    const valid = values4.map((v) => `${v} !== null`).join(" && ");
    if (values4.length) {
      signal.update = `${valid} ? {fields: ${fields}, values: [${values4.join(", ")}]} : null`;
    }
    delete signal.value;
    delete signal.on;
    return signals;
  }
};
var inputs_default = inputBindings;

// node_modules/vega-lite/build/src/compile/selection/transforms/toggle.js
var TOGGLE = "_toggle";
var toggle = {
  has: (selCmpt) => {
    return selCmpt.type === "multi" && !!selCmpt.toggle;
  },
  signals: (model, selCmpt, signals) => {
    return signals.concat({
      name: selCmpt.name + TOGGLE,
      value: false,
      on: [{events: selCmpt.events, update: selCmpt.toggle}]
    });
  },
  modifyExpr: (model, selCmpt) => {
    const tpl = selCmpt.name + TUPLE;
    const signal = selCmpt.name + TOGGLE;
    return `${signal} ? null : ${tpl}, ` + (selCmpt.resolve === "global" ? `${signal} ? null : true, ` : `${signal} ? null : {unit: ${unitName(model)}}, `) + `${signal} ? ${tpl} : null`;
  }
};
var toggle_default = toggle;

// node_modules/vega-lite/build/src/compile/selection/transforms/clear.js
var clear = {
  has: (selCmpt) => {
    return selCmpt.clear !== void 0 && selCmpt.clear !== false;
  },
  parse: (model, selCmpt, selDef) => {
    if (selDef.clear) {
      selCmpt.clear = isString_default(selDef.clear) ? eventSelector(selDef.clear, "scope") : selDef.clear;
    }
  },
  topLevelSignals: (model, selCmpt, signals) => {
    if (inputs_default.has(selCmpt)) {
      for (const proj of selCmpt.project.items) {
        const idx = signals.findIndex((n) => n.name === varName(`${selCmpt.name}_${proj.field}`));
        if (idx !== -1) {
          signals[idx].on.push({events: selCmpt.clear, update: "null"});
        }
      }
    }
    return signals;
  },
  signals: (model, selCmpt, signals) => {
    function addClear(idx, update3) {
      if (idx !== -1 && signals[idx].on) {
        signals[idx].on.push({events: selCmpt.clear, update: update3});
      }
    }
    if (selCmpt.type === "interval") {
      for (const proj of selCmpt.project.items) {
        const vIdx = signals.findIndex((n) => n.name === proj.signals.visual);
        addClear(vIdx, "[0, 0]");
        if (vIdx === -1) {
          const dIdx = signals.findIndex((n) => n.name === proj.signals.data);
          addClear(dIdx, "null");
        }
      }
    } else {
      let tIdx = signals.findIndex((n) => n.name === selCmpt.name + TUPLE);
      addClear(tIdx, "null");
      if (toggle_default.has(selCmpt)) {
        tIdx = signals.findIndex((n) => n.name === selCmpt.name + TOGGLE);
        addClear(tIdx, "false");
      }
    }
    return signals;
  }
};
var clear_default = clear;

// node_modules/vega-lite/build/src/compile/selection/transforms/scales.js
var scaleBindings = {
  has: (selCmpt) => {
    return selCmpt.type === "interval" && selCmpt.resolve === "global" && selCmpt.bind && selCmpt.bind === "scales";
  },
  parse: (model, selCmpt) => {
    const bound2 = selCmpt.scales = [];
    for (const proj of selCmpt.project.items) {
      const channel = proj.channel;
      if (!isScaleChannel(channel)) {
        continue;
      }
      const scale7 = model.getScaleComponent(channel);
      const scaleType2 = scale7 ? scale7.get("type") : void 0;
      if (!scale7 || !hasContinuousDomain(scaleType2)) {
        warn3(message_exports.SCALE_BINDINGS_CONTINUOUS);
        continue;
      }
      const extent2 = {selection: selCmpt.name, field: proj.field};
      scale7.set("selectionExtent", extent2, true);
      bound2.push(proj);
    }
  },
  topLevelSignals: (model, selCmpt, signals) => {
    const bound2 = selCmpt.scales.filter((proj) => signals.filter((s) => s.name === proj.signals.data).length === 0);
    if (!model.parent || isTopLevelLayer(model) || bound2.length === 0) {
      return signals;
    }
    const namedSg = signals.filter((s) => s.name === selCmpt.name)[0];
    let update3 = namedSg.update;
    if (update3.indexOf(VL_SELECTION_RESOLVE) >= 0) {
      namedSg.update = `{${bound2.map((proj) => `${$2(proj.field)}: ${proj.signals.data}`).join(", ")}}`;
    } else {
      for (const proj of bound2) {
        const mapping = `${$2(proj.field)}: ${proj.signals.data}`;
        if (update3.indexOf(mapping) < 0) {
          update3 = `${update3.substring(0, update3.length - 1)}, ${mapping}}`;
        }
      }
      namedSg.update = update3;
    }
    return signals.concat(bound2.map((proj) => ({name: proj.signals.data})));
  },
  signals: (model, selCmpt, signals) => {
    if (model.parent && !isTopLevelLayer(model)) {
      for (const proj of selCmpt.scales) {
        const signal = signals.filter((s) => s.name === proj.signals.data)[0];
        signal.push = "outer";
        delete signal.value;
        delete signal.update;
      }
    }
    return signals;
  }
};
var scales_default = scaleBindings;
function domain3(model, channel) {
  const scale7 = $2(model.scaleName(channel));
  return `domain(${scale7})`;
}
function isTopLevelLayer(model) {
  var _a2;
  return model.parent && isLayerModel(model.parent) && ((_a2 = !model.parent.parent) !== null && _a2 !== void 0 ? _a2 : isTopLevelLayer(model.parent.parent));
}

// node_modules/vega-lite/build/src/compile/selection/transforms/legends.js
var legendBindings = {
  has: (selCmpt) => {
    const spec = selCmpt.resolve === "global" && selCmpt.bind && isLegendBinding(selCmpt.bind);
    const projLen = selCmpt.project.items.length === 1 && selCmpt.project.items[0].field !== SELECTION_ID2;
    if (spec && !projLen) {
      warn3(message_exports.LEGEND_BINDINGS_PROJECT_LENGTH);
    }
    return spec && projLen;
  },
  parse: (model, selCmpt, selDef, origDef) => {
    var _a2;
    if (!origDef.on)
      delete selCmpt.events;
    if (!origDef.clear)
      delete selCmpt.clear;
    if (origDef.on || origDef.clear) {
      const legendFilter = 'event.item && indexof(event.item.mark.role, "legend") < 0';
      for (const evt2 of selCmpt.events) {
        evt2.filter = array_default4((_a2 = evt2.filter) !== null && _a2 !== void 0 ? _a2 : []);
        if (evt2.filter.indexOf(legendFilter) < 0) {
          evt2.filter.push(legendFilter);
        }
      }
    }
    const evt = isLegendStreamBinding(selCmpt.bind) ? selCmpt.bind.legend : "click";
    const stream2 = isString_default(evt) ? eventSelector(evt, "view") : array_default4(evt);
    selCmpt.bind = {legend: {merge: stream2}};
  },
  topLevelSignals: (model, selCmpt, signals) => {
    const selName = selCmpt.name;
    const stream2 = isLegendStreamBinding(selCmpt.bind) && selCmpt.bind.legend;
    const markName = (name4) => (s) => {
      const ds = duplicate(s);
      ds.markname = name4;
      return ds;
    };
    for (const proj of selCmpt.project.items) {
      if (!proj.hasLegend)
        continue;
      const prefix = `${varName(proj.field)}_legend`;
      const sgName = `${selName}_${prefix}`;
      const hasSignal2 = signals.filter((s) => s.name === sgName);
      if (hasSignal2.length === 0) {
        const events4 = stream2.merge.map(markName(`${prefix}_symbols`)).concat(stream2.merge.map(markName(`${prefix}_labels`))).concat(stream2.merge.map(markName(`${prefix}_entries`)));
        signals.unshift(Object.assign(Object.assign({name: sgName}, !selCmpt.init ? {value: null} : {}), {on: [
          {events: events4, update: "datum.value || item().items[0].items[0].datum.value", force: true},
          {events: stream2.merge, update: `!event.item || !datum ? null : ${sgName}`, force: true}
        ]}));
      }
    }
    return signals;
  },
  signals: (model, selCmpt, signals) => {
    const name4 = selCmpt.name;
    const proj = selCmpt.project;
    const tuple = signals.find((s) => s.name === name4 + TUPLE);
    const fields = name4 + TUPLE_FIELDS;
    const values4 = proj.items.filter((p) => p.hasLegend).map((p) => varName(`${name4}_${varName(p.field)}_legend`));
    const valid = values4.map((v) => `${v} !== null`).join(" && ");
    const update3 = `${valid} ? {fields: ${fields}, values: [${values4.join(", ")}]} : null`;
    if (selCmpt.events && values4.length > 0) {
      tuple.on.push({
        events: values4.map((signal) => ({signal})),
        update: update3
      });
    } else if (values4.length > 0) {
      tuple.update = update3;
      delete tuple.value;
      delete tuple.on;
    }
    const toggle2 = signals.find((s) => s.name === name4 + TOGGLE);
    const events4 = isLegendStreamBinding(selCmpt.bind) && selCmpt.bind.legend;
    if (toggle2) {
      if (!selCmpt.events)
        toggle2.on[0].events = events4;
      else
        toggle2.on.push(Object.assign(Object.assign({}, toggle2.on[0]), {events: events4}));
    }
    return signals;
  }
};
var legends_default = legendBindings;
function parseInteractiveLegend(model, channel, legendCmpt) {
  var _a2;
  const field4 = (_a2 = model.fieldDef(channel)) === null || _a2 === void 0 ? void 0 : _a2.field;
  forEachSelection(model, (selCmpt) => {
    var _a3, _b;
    const proj = (_a3 = selCmpt.project.hasField[field4]) !== null && _a3 !== void 0 ? _a3 : selCmpt.project.hasChannel[channel];
    if (proj && legendBindings.has(selCmpt)) {
      const legendSelections = (_b = legendCmpt.get("selections")) !== null && _b !== void 0 ? _b : [];
      legendSelections.push(selCmpt.name);
      legendCmpt.set("selections", legendSelections, false);
      proj.hasLegend = true;
    }
  });
}

// node_modules/vega-lite/build/src/compile/selection/transforms/translate.js
var ANCHOR = "_translate_anchor";
var DELTA = "_translate_delta";
var translate3 = {
  has: (selCmpt) => {
    return selCmpt.type === "interval" && selCmpt.translate;
  },
  signals: (model, selCmpt, signals) => {
    const name4 = selCmpt.name;
    const hasScales = scales_default.has(selCmpt);
    const anchor = name4 + ANCHOR;
    const {x: x5, y: y5} = selCmpt.project.hasChannel;
    let events4 = eventSelector(selCmpt.translate, "scope");
    if (!hasScales) {
      events4 = events4.map((e) => (e.between[0].markname = name4 + BRUSH, e));
    }
    signals.push({
      name: anchor,
      value: {},
      on: [
        {
          events: events4.map((e) => e.between[0]),
          update: "{x: x(unit), y: y(unit)" + (x5 !== void 0 ? ", extent_x: " + (hasScales ? domain3(model, X3) : `slice(${x5.signals.visual})`) : "") + (y5 !== void 0 ? ", extent_y: " + (hasScales ? domain3(model, Y3) : `slice(${y5.signals.visual})`) : "") + "}"
        }
      ]
    }, {
      name: name4 + DELTA,
      value: {},
      on: [
        {
          events: events4,
          update: `{x: ${anchor}.x - x(unit), y: ${anchor}.y - y(unit)}`
        }
      ]
    });
    if (x5 !== void 0) {
      onDelta(model, selCmpt, x5, "width", signals);
    }
    if (y5 !== void 0) {
      onDelta(model, selCmpt, y5, "height", signals);
    }
    return signals;
  }
};
var translate_default = translate3;
function onDelta(model, selCmpt, proj, size, signals) {
  var _a2;
  const name4 = selCmpt.name;
  const anchor = name4 + ANCHOR;
  const delta = name4 + DELTA;
  const channel = proj.channel;
  const hasScales = scales_default.has(selCmpt);
  const signal = signals.filter((s) => s.name === proj.signals[hasScales ? "data" : "visual"])[0];
  const sizeSg = model.getSizeSignalRef(size).signal;
  const scaleCmpt = model.getScaleComponent(channel);
  const scaleType2 = scaleCmpt.get("type");
  const sign3 = hasScales && channel === X3 ? "-" : "";
  const extent2 = `${anchor}.extent_${channel}`;
  const offset4 = `${sign3}${delta}.${channel} / ` + (hasScales ? `${sizeSg}` : `span(${extent2})`);
  const panFn = !hasScales ? "panLinear" : scaleType2 === "log" ? "panLog" : scaleType2 === "pow" ? "panPow" : "panLinear";
  const update3 = `${panFn}(${extent2}, ${offset4}` + (hasScales && scaleType2 === "pow" ? `, ${(_a2 = scaleCmpt.get("exponent")) !== null && _a2 !== void 0 ? _a2 : 1}` : "") + ")";
  signal.on.push({
    events: {signal: delta},
    update: hasScales ? update3 : `clampRange(${update3}, 0, ${sizeSg})`
  });
}

// node_modules/vega-lite/build/src/compile/selection/transforms/zoom.js
var ANCHOR2 = "_zoom_anchor";
var DELTA2 = "_zoom_delta";
var zoom2 = {
  has: (selCmpt) => {
    return selCmpt.type === "interval" && selCmpt.zoom;
  },
  signals: (model, selCmpt, signals) => {
    const name4 = selCmpt.name;
    const hasScales = scales_default.has(selCmpt);
    const delta = name4 + DELTA2;
    const {x: x5, y: y5} = selCmpt.project.hasChannel;
    const sx = $2(model.scaleName(X3));
    const sy = $2(model.scaleName(Y3));
    let events4 = eventSelector(selCmpt.zoom, "scope");
    if (!hasScales) {
      events4 = events4.map((e) => (e.markname = name4 + BRUSH, e));
    }
    signals.push({
      name: name4 + ANCHOR2,
      on: [
        {
          events: events4,
          update: !hasScales ? `{x: x(unit), y: y(unit)}` : "{" + [sx ? `x: invert(${sx}, x(unit))` : "", sy ? `y: invert(${sy}, y(unit))` : ""].filter((expr2) => !!expr2).join(", ") + "}"
        }
      ]
    }, {
      name: delta,
      on: [
        {
          events: events4,
          force: true,
          update: "pow(1.001, event.deltaY * pow(16, event.deltaMode))"
        }
      ]
    });
    if (x5 !== void 0) {
      onDelta2(model, selCmpt, x5, "width", signals);
    }
    if (y5 !== void 0) {
      onDelta2(model, selCmpt, y5, "height", signals);
    }
    return signals;
  }
};
var zoom_default2 = zoom2;
function onDelta2(model, selCmpt, proj, size, signals) {
  var _a2;
  const name4 = selCmpt.name;
  const channel = proj.channel;
  const hasScales = scales_default.has(selCmpt);
  const signal = signals.filter((s) => s.name === proj.signals[hasScales ? "data" : "visual"])[0];
  const sizeSg = model.getSizeSignalRef(size).signal;
  const scaleCmpt = model.getScaleComponent(channel);
  const scaleType2 = scaleCmpt.get("type");
  const base2 = hasScales ? domain3(model, channel) : signal.name;
  const delta = name4 + DELTA2;
  const anchor = `${name4}${ANCHOR2}.${channel}`;
  const zoomFn = !hasScales ? "zoomLinear" : scaleType2 === "log" ? "zoomLog" : scaleType2 === "pow" ? "zoomPow" : "zoomLinear";
  const update3 = `${zoomFn}(${base2}, ${anchor}, ${delta}` + (hasScales && scaleType2 === "pow" ? `, ${(_a2 = scaleCmpt.get("exponent")) !== null && _a2 !== void 0 ? _a2 : 1}` : "") + ")";
  signal.on.push({
    events: {signal: delta},
    update: hasScales ? update3 : `clampRange(${update3}, 0, ${sizeSg})`
  });
}

// node_modules/vega-lite/build/src/compile/selection/transforms/transforms.js
var compilers = [project_default, toggle_default, scales_default, legends_default, translate_default, zoom_default2, inputs_default, nearest_default, clear_default];
function forEachTransform(selCmpt, cb) {
  for (const t of compilers) {
    if (t.has(selCmpt)) {
      cb(t);
    }
  }
}

// node_modules/vega-lite/build/src/compile/selection/assemble.js
function assembleInit(init2, isExpr2 = true, wrap3 = identity5) {
  if (isArray_default(init2)) {
    const assembled = init2.map((v) => assembleInit(v, isExpr2, wrap3));
    return isExpr2 ? `[${assembled.join(", ")}]` : assembled;
  } else if (isDateTime(init2)) {
    if (isExpr2) {
      return wrap3(dateTimeToExpr(init2));
    } else {
      return wrap3(dateTimeToTimestamp(init2));
    }
  }
  return isExpr2 ? wrap3(JSON.stringify(init2)) : init2;
}
function assembleUnitSelectionSignals(model, signals) {
  forEachSelection(model, (selCmpt, selCompiler) => {
    const name4 = selCmpt.name;
    let modifyExpr = selCompiler.modifyExpr(model, selCmpt);
    signals.push(...selCompiler.signals(model, selCmpt));
    forEachTransform(selCmpt, (txCompiler) => {
      if (txCompiler.signals) {
        signals = txCompiler.signals(model, selCmpt, signals);
      }
      if (txCompiler.modifyExpr) {
        modifyExpr = txCompiler.modifyExpr(model, selCmpt, modifyExpr);
      }
    });
    signals.push({
      name: name4 + MODIFY,
      on: [
        {
          events: {signal: selCmpt.name + TUPLE},
          update: `modify(${$2(selCmpt.name + STORE)}, ${modifyExpr})`
        }
      ]
    });
  });
  return cleanupEmptyOnArray(signals);
}
function assembleFacetSignals(model, signals) {
  if (model.component.selection && keys3(model.component.selection).length) {
    const name4 = $2(model.getName("cell"));
    signals.unshift({
      name: "facet",
      value: {},
      on: [
        {
          events: eventSelector("mousemove", "scope"),
          update: `isTuple(facet) ? facet : group(${name4}).datum`
        }
      ]
    });
  }
  return cleanupEmptyOnArray(signals);
}
function assembleTopLevelSignals(model, signals) {
  let hasSelections = false;
  forEachSelection(model, (selCmpt, selCompiler) => {
    const name4 = selCmpt.name;
    const store = $2(name4 + STORE);
    const hasSg = signals.filter((s) => s.name === name4);
    if (hasSg.length === 0) {
      const resolve2 = selCmpt.resolve === "global" ? "union" : selCmpt.resolve;
      const isMulti = selCmpt.type === "multi" ? ", true)" : ")";
      signals.push({
        name: selCmpt.name,
        update: `${VL_SELECTION_RESOLVE}(${store}, ${$2(resolve2)}${isMulti}`
      });
    }
    hasSelections = true;
    if (selCompiler.topLevelSignals) {
      signals = selCompiler.topLevelSignals(model, selCmpt, signals);
    }
    forEachTransform(selCmpt, (txCompiler) => {
      if (txCompiler.topLevelSignals) {
        signals = txCompiler.topLevelSignals(model, selCmpt, signals);
      }
    });
  });
  if (hasSelections) {
    const hasUnit = signals.filter((s) => s.name === "unit");
    if (hasUnit.length === 0) {
      signals.unshift({
        name: "unit",
        value: {},
        on: [{events: "mousemove", update: "isTuple(group()) ? group() : unit"}]
      });
    }
  }
  return cleanupEmptyOnArray(signals);
}
function assembleUnitSelectionData(model, data4) {
  const dataCopy = [...data4];
  forEachSelection(model, (selCmpt) => {
    const init2 = {name: selCmpt.name + STORE};
    if (selCmpt.init) {
      const fields = selCmpt.project.items.map((proj) => {
        const {signals} = proj, rest = __rest(proj, ["signals"]);
        return rest;
      });
      const insert2 = selCmpt.init.map((i) => assembleInit(i, false));
      init2.values = selCmpt.type === "interval" ? [{unit: unitName(model, {escape: false}), fields, values: insert2}] : insert2.map((i) => ({unit: unitName(model, {escape: false}), fields, values: i}));
    }
    const contains3 = dataCopy.filter((d) => d.name === selCmpt.name + STORE);
    if (!contains3.length) {
      dataCopy.push(init2);
    }
  });
  return dataCopy;
}
function assembleUnitSelectionMarks(model, marks) {
  forEachSelection(model, (selCmpt, selCompiler) => {
    marks = selCompiler.marks ? selCompiler.marks(model, selCmpt, marks) : marks;
    forEachTransform(selCmpt, (txCompiler) => {
      if (txCompiler.marks) {
        marks = txCompiler.marks(model, selCmpt, marks);
      }
    });
  });
  return marks;
}
function assembleLayerSelectionMarks(model, marks) {
  for (const child of model.children) {
    if (isUnitModel(child)) {
      marks = assembleUnitSelectionMarks(child, marks);
    }
  }
  return marks;
}
function assembleSelectionScaleDomain(model, extent2) {
  const name4 = extent2.selection;
  const selCmpt = model.getSelectionComponent(name4, varName(name4));
  return {signal: parseSelectionBinExtent(selCmpt, extent2)};
}
function cleanupEmptyOnArray(signals) {
  return signals.map((s) => {
    if (s.on && !s.on.length)
      delete s.on;
    return s;
  });
}

// node_modules/vega-lite/build/src/compile/selection/interval.js
var BRUSH = "_brush";
var SCALE_TRIGGER = "_scale_trigger";
var interval2 = {
  signals: (model, selCmpt) => {
    const name4 = selCmpt.name;
    const fieldsSg = name4 + TUPLE_FIELDS;
    const hasScales = scales_default.has(selCmpt);
    const signals = [];
    const dataSignals = [];
    const scaleTriggers = [];
    if (selCmpt.translate && !hasScales) {
      const filterExpr = `!event.item || event.item.mark.name !== ${$2(name4 + BRUSH)}`;
      events3(selCmpt, (on2, evt) => {
        var _a2;
        const filters2 = array_default4((_a2 = evt.between[0].filter) !== null && _a2 !== void 0 ? _a2 : evt.between[0].filter = []);
        if (filters2.indexOf(filterExpr) < 0) {
          filters2.push(filterExpr);
        }
        return on2;
      });
    }
    selCmpt.project.items.forEach((proj, i) => {
      const channel = proj.channel;
      if (channel !== X3 && channel !== Y3) {
        warn3("Interval selections only support x and y encoding channels.");
        return;
      }
      const init3 = selCmpt.init ? selCmpt.init[i] : null;
      const cs = channelSignals(model, selCmpt, proj, init3);
      const dname = proj.signals.data;
      const vname = proj.signals.visual;
      const scaleName = $2(model.scaleName(channel));
      const scaleType2 = model.getScaleComponent(channel).get("type");
      const toNum = hasContinuousDomain(scaleType2) ? "+" : "";
      signals.push(...cs);
      dataSignals.push(dname);
      scaleTriggers.push({
        scaleName: model.scaleName(channel),
        expr: `(!isArray(${dname}) || (${toNum}invert(${scaleName}, ${vname})[0] === ${toNum}${dname}[0] && ${toNum}invert(${scaleName}, ${vname})[1] === ${toNum}${dname}[1]))`
      });
    });
    if (!hasScales) {
      signals.push({
        name: name4 + SCALE_TRIGGER,
        value: {},
        on: [
          {
            events: scaleTriggers.map((t) => ({scale: t.scaleName})),
            update: scaleTriggers.map((t) => t.expr).join(" && ") + ` ? ${name4 + SCALE_TRIGGER} : {}`
          }
        ]
      });
    }
    const init2 = selCmpt.init;
    const update3 = `unit: ${unitName(model)}, fields: ${fieldsSg}, values`;
    return signals.concat(Object.assign(Object.assign({name: name4 + TUPLE}, init2 ? {init: `{${update3}: ${assembleInit(init2)}}`} : {}), {on: [
      {
        events: [{signal: dataSignals.join(" || ")}],
        update: dataSignals.join(" && ") + ` ? {${update3}: [${dataSignals}]} : null`
      }
    ]}));
  },
  modifyExpr: (model, selCmpt) => {
    const tpl = selCmpt.name + TUPLE;
    return tpl + ", " + (selCmpt.resolve === "global" ? "true" : `{unit: ${unitName(model)}}`);
  },
  marks: (model, selCmpt, marks) => {
    const name4 = selCmpt.name;
    const {x: x5, y: y5} = selCmpt.project.hasChannel;
    const xvname = x5 && x5.signals.visual;
    const yvname = y5 && y5.signals.visual;
    const store = `data(${$2(selCmpt.name + STORE)})`;
    if (scales_default.has(selCmpt)) {
      return marks;
    }
    const update3 = {
      x: x5 !== void 0 ? {signal: `${xvname}[0]`} : {value: 0},
      y: y5 !== void 0 ? {signal: `${yvname}[0]`} : {value: 0},
      x2: x5 !== void 0 ? {signal: `${xvname}[1]`} : {field: {group: "width"}},
      y2: y5 !== void 0 ? {signal: `${yvname}[1]`} : {field: {group: "height"}}
    };
    if (selCmpt.resolve === "global") {
      for (const key2 of keys3(update3)) {
        update3[key2] = [
          Object.assign({test: `${store}.length && ${store}[0].unit === ${unitName(model)}`}, update3[key2]),
          {value: 0}
        ];
      }
    }
    const _a2 = selCmpt.mark, {fill: fill2, fillOpacity, cursor: cursor3} = _a2, stroke2 = __rest(_a2, ["fill", "fillOpacity", "cursor"]);
    const vgStroke = keys3(stroke2).reduce((def2, k) => {
      def2[k] = [
        {
          test: [x5 !== void 0 && `${xvname}[0] !== ${xvname}[1]`, y5 !== void 0 && `${yvname}[0] !== ${yvname}[1]`].filter((t) => t).join(" && "),
          value: stroke2[k]
        },
        {value: null}
      ];
      return def2;
    }, {});
    return [
      {
        name: name4 + BRUSH + "_bg",
        type: "rect",
        clip: true,
        encode: {
          enter: {
            fill: {value: fill2},
            fillOpacity: {value: fillOpacity}
          },
          update: update3
        }
      },
      ...marks,
      {
        name: name4 + BRUSH,
        type: "rect",
        clip: true,
        encode: {
          enter: Object.assign(Object.assign({}, cursor3 ? {cursor: {value: cursor3}} : {}), {fill: {value: "transparent"}}),
          update: Object.assign(Object.assign({}, update3), vgStroke)
        }
      }
    ];
  }
};
var interval_default2 = interval2;
function channelSignals(model, selCmpt, proj, init2) {
  const channel = proj.channel;
  const vname = proj.signals.visual;
  const dname = proj.signals.data;
  const hasScales = scales_default.has(selCmpt);
  const scaleName = $2(model.scaleName(channel));
  const scale7 = model.getScaleComponent(channel);
  const scaleType2 = scale7 ? scale7.get("type") : void 0;
  const scaled = (str) => `scale(${scaleName}, ${str})`;
  const size = model.getSizeSignalRef(channel === X3 ? "width" : "height").signal;
  const coord = `${channel}(unit)`;
  const on2 = events3(selCmpt, (def2, evt) => {
    return [
      ...def2,
      {events: evt.between[0], update: `[${coord}, ${coord}]`},
      {events: evt, update: `[${vname}[0], clamp(${coord}, 0, ${size})]`}
    ];
  });
  on2.push({
    events: {signal: selCmpt.name + SCALE_TRIGGER},
    update: hasContinuousDomain(scaleType2) ? `[${scaled(`${dname}[0]`)}, ${scaled(`${dname}[1]`)}]` : `[0, 0]`
  });
  return hasScales ? [{name: dname, on: []}] : [
    Object.assign(Object.assign({name: vname}, init2 ? {init: assembleInit(init2, true, scaled)} : {value: []}), {on: on2}),
    Object.assign(Object.assign({name: dname}, init2 ? {init: assembleInit(init2)} : {}), {on: [
      {
        events: {signal: vname},
        update: `${vname}[0] === ${vname}[1] ? null : invert(${scaleName}, ${vname})`
      }
    ]})
  ];
}
function events3(selCmpt, cb) {
  return selCmpt.events.reduce((on2, evt) => {
    if (!evt.between) {
      warn3(`${evt} is not an ordered event stream for interval selections.`);
      return on2;
    }
    return cb(on2, evt);
  }, []);
}

// node_modules/vega-lite/build/src/compile/selection/multi.js
function singleOrMultiSignals(model, selCmpt) {
  const name4 = selCmpt.name;
  const fieldsSg = name4 + TUPLE_FIELDS;
  const project3 = selCmpt.project;
  const datum3 = "(item().isVoronoi ? datum.datum : datum)";
  const values4 = project3.items.map((p) => {
    const fieldDef = model.fieldDef(p.channel);
    return fieldDef && fieldDef.bin ? `[${datum3}[${$2(model.vgField(p.channel, {}))}], ${datum3}[${$2(model.vgField(p.channel, {binSuffix: "end"}))}]]` : `${datum3}[${$2(p.field)}]`;
  }).join(", ");
  const update3 = `unit: ${unitName(model)}, fields: ${fieldsSg}, values`;
  const events4 = selCmpt.events;
  return [
    {
      name: name4 + TUPLE,
      on: events4 ? [
        {
          events: events4,
          update: `datum && item().mark.marktype !== 'group' ? {${update3}: [${values4}]} : null`,
          force: true
        }
      ] : []
    }
  ];
}
var multi = {
  signals: singleOrMultiSignals,
  modifyExpr: (model, selCmpt) => {
    const tpl = selCmpt.name + TUPLE;
    return tpl + ", " + (selCmpt.resolve === "global" ? "null" : `{unit: ${unitName(model)}}`);
  }
};
var multi_default = multi;

// node_modules/vega-lite/build/src/compile/selection/single.js
var single = {
  signals: singleOrMultiSignals,
  modifyExpr: (model, selCmpt) => {
    const tpl = selCmpt.name + TUPLE;
    return tpl + ", " + (selCmpt.resolve === "global" ? "true" : `{unit: ${unitName(model)}}`);
  }
};
var single_default = single;

// node_modules/vega-lite/build/src/compile/selection/index.js
var STORE = "_store";
var TUPLE = "_tuple";
var MODIFY = "_modify";
var VL_SELECTION_RESOLVE = "vlSelectionResolve";
var compilers2 = {single: single_default, multi: multi_default, interval: interval_default2};
function forEachSelection(model, cb) {
  const selections = model.component.selection;
  if (selections) {
    for (const sel of vals(selections)) {
      const success = cb(sel, compilers2[sel.type]);
      if (success === true)
        break;
    }
  }
}
function getFacetModel(model) {
  let parent = model.parent;
  while (parent) {
    if (isFacetModel(parent)) {
      break;
    }
    parent = parent.parent;
  }
  return parent;
}
function unitName(model, {escape: escape2} = {escape: true}) {
  let name4 = escape2 ? $2(model.name) : model.name;
  const facetModel = getFacetModel(model);
  if (facetModel) {
    const {facet} = facetModel;
    for (const channel of FACET_CHANNELS) {
      if (facet[channel]) {
        name4 += ` + '__facet_${channel}_' + (facet[${$2(facetModel.vgField(channel))}])`;
      }
    }
  }
  return name4;
}
function requiresSelectionId(model) {
  let identifier = false;
  forEachSelection(model, (selCmpt) => {
    identifier = identifier || selCmpt.project.items.some((proj) => proj.field === SELECTION_ID2);
  });
  return identifier;
}

// node_modules/vega-lite/node_modules/vega-expression/src/ast.js
var RawCode2 = "RawCode";
var Literal2 = "Literal";
var Property2 = "Property";
var Identifier3 = "Identifier";
var ArrayExpression2 = "ArrayExpression";
var BinaryExpression2 = "BinaryExpression";
var CallExpression2 = "CallExpression";
var ConditionalExpression2 = "ConditionalExpression";
var LogicalExpression2 = "LogicalExpression";
var MemberExpression2 = "MemberExpression";
var ObjectExpression2 = "ObjectExpression";
var UnaryExpression2 = "UnaryExpression";
function ASTNode2(type2) {
  this.type = type2;
}
ASTNode2.prototype.visit = function(visitor) {
  let c2, i, n;
  if (visitor(this))
    return 1;
  for (c2 = children3(this), i = 0, n = c2.length; i < n; ++i) {
    if (c2[i].visit(visitor))
      return 1;
  }
};
function children3(node) {
  switch (node.type) {
    case ArrayExpression2:
      return node.elements;
    case BinaryExpression2:
    case LogicalExpression2:
      return [node.left, node.right];
    case CallExpression2:
      return [node.callee].concat(node.arguments);
    case ConditionalExpression2:
      return [node.test, node.consequent, node.alternate];
    case MemberExpression2:
      return [node.object, node.property];
    case ObjectExpression2:
      return node.properties;
    case Property2:
      return [node.key, node.value];
    case UnaryExpression2:
      return [node.argument];
    case Identifier3:
    case Literal2:
    case RawCode2:
    default:
      return [];
  }
}

// node_modules/vega-lite/node_modules/vega-expression/src/parser.js
var TokenName2;
var source3;
var index3;
var length2;
var lookahead2;
var TokenBooleanLiteral2 = 1;
var TokenEOF2 = 2;
var TokenIdentifier2 = 3;
var TokenKeyword2 = 4;
var TokenNullLiteral2 = 5;
var TokenNumericLiteral2 = 6;
var TokenPunctuator2 = 7;
var TokenStringLiteral2 = 8;
var TokenRegularExpression2 = 9;
TokenName2 = {};
TokenName2[TokenBooleanLiteral2] = "Boolean";
TokenName2[TokenEOF2] = "<end>";
TokenName2[TokenIdentifier2] = "Identifier";
TokenName2[TokenKeyword2] = "Keyword";
TokenName2[TokenNullLiteral2] = "Null";
TokenName2[TokenNumericLiteral2] = "Numeric";
TokenName2[TokenPunctuator2] = "Punctuator";
TokenName2[TokenStringLiteral2] = "String";
TokenName2[TokenRegularExpression2] = "RegularExpression";
var SyntaxArrayExpression2 = "ArrayExpression";
var SyntaxBinaryExpression2 = "BinaryExpression";
var SyntaxCallExpression2 = "CallExpression";
var SyntaxConditionalExpression2 = "ConditionalExpression";
var SyntaxIdentifier2 = "Identifier";
var SyntaxLiteral2 = "Literal";
var SyntaxLogicalExpression2 = "LogicalExpression";
var SyntaxMemberExpression2 = "MemberExpression";
var SyntaxObjectExpression2 = "ObjectExpression";
var SyntaxProperty2 = "Property";
var SyntaxUnaryExpression2 = "UnaryExpression";
var MessageUnexpectedToken2 = "Unexpected token %0";
var MessageUnexpectedNumber2 = "Unexpected number";
var MessageUnexpectedString2 = "Unexpected string";
var MessageUnexpectedIdentifier2 = "Unexpected identifier";
var MessageUnexpectedReserved2 = "Unexpected reserved word";
var MessageUnexpectedEOS2 = "Unexpected end of input";
var MessageInvalidRegExp2 = "Invalid regular expression";
var MessageUnterminatedRegExp2 = "Invalid regular expression: missing /";
var MessageStrictOctalLiteral2 = "Octal literals are not allowed in strict mode.";
var MessageStrictDuplicateProperty2 = "Duplicate data property in object literal not allowed in strict mode";
var ILLEGAL3 = "ILLEGAL";
var DISABLED2 = "Disabled.";
var RegexNonAsciiIdentifierStart2 = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
var RegexNonAsciiIdentifierPart2 = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
function assert2(condition, message) {
  if (!condition) {
    throw new Error("ASSERT: " + message);
  }
}
function isDecimalDigit2(ch2) {
  return ch2 >= 48 && ch2 <= 57;
}
function isHexDigit2(ch2) {
  return "0123456789abcdefABCDEF".indexOf(ch2) >= 0;
}
function isOctalDigit2(ch2) {
  return "01234567".indexOf(ch2) >= 0;
}
function isWhiteSpace2(ch2) {
  return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(ch2) >= 0;
}
function isLineTerminator2(ch2) {
  return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
}
function isIdentifierStart2(ch2) {
  return ch2 === 36 || ch2 === 95 || ch2 >= 65 && ch2 <= 90 || ch2 >= 97 && ch2 <= 122 || ch2 === 92 || ch2 >= 128 && RegexNonAsciiIdentifierStart2.test(String.fromCharCode(ch2));
}
function isIdentifierPart2(ch2) {
  return ch2 === 36 || ch2 === 95 || ch2 >= 65 && ch2 <= 90 || ch2 >= 97 && ch2 <= 122 || ch2 >= 48 && ch2 <= 57 || ch2 === 92 || ch2 >= 128 && RegexNonAsciiIdentifierPart2.test(String.fromCharCode(ch2));
}
var keywords2 = {
  if: 1,
  in: 1,
  do: 1,
  var: 1,
  for: 1,
  new: 1,
  try: 1,
  let: 1,
  this: 1,
  else: 1,
  case: 1,
  void: 1,
  with: 1,
  enum: 1,
  while: 1,
  break: 1,
  catch: 1,
  throw: 1,
  const: 1,
  yield: 1,
  class: 1,
  super: 1,
  return: 1,
  typeof: 1,
  delete: 1,
  switch: 1,
  export: 1,
  import: 1,
  public: 1,
  static: 1,
  default: 1,
  finally: 1,
  extends: 1,
  package: 1,
  private: 1,
  function: 1,
  continue: 1,
  debugger: 1,
  interface: 1,
  protected: 1,
  instanceof: 1,
  implements: 1
};
function skipComment2() {
  var ch2;
  while (index3 < length2) {
    ch2 = source3.charCodeAt(index3);
    if (isWhiteSpace2(ch2) || isLineTerminator2(ch2)) {
      ++index3;
    } else {
      break;
    }
  }
}
function scanHexEscape2(prefix) {
  var i, len, ch2, code = 0;
  len = prefix === "u" ? 4 : 2;
  for (i = 0; i < len; ++i) {
    if (index3 < length2 && isHexDigit2(source3[index3])) {
      ch2 = source3[index3++];
      code = code * 16 + "0123456789abcdef".indexOf(ch2.toLowerCase());
    } else {
      throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
    }
  }
  return String.fromCharCode(code);
}
function scanUnicodeCodePointEscape2() {
  var ch2, code, cu1, cu2;
  ch2 = source3[index3];
  code = 0;
  if (ch2 === "}") {
    throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
  }
  while (index3 < length2) {
    ch2 = source3[index3++];
    if (!isHexDigit2(ch2)) {
      break;
    }
    code = code * 16 + "0123456789abcdef".indexOf(ch2.toLowerCase());
  }
  if (code > 1114111 || ch2 !== "}") {
    throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
  }
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  cu1 = (code - 65536 >> 10) + 55296;
  cu2 = (code - 65536 & 1023) + 56320;
  return String.fromCharCode(cu1, cu2);
}
function getEscapedIdentifier2() {
  var ch2, id4;
  ch2 = source3.charCodeAt(index3++);
  id4 = String.fromCharCode(ch2);
  if (ch2 === 92) {
    if (source3.charCodeAt(index3) !== 117) {
      throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
    }
    ++index3;
    ch2 = scanHexEscape2("u");
    if (!ch2 || ch2 === "\\" || !isIdentifierStart2(ch2.charCodeAt(0))) {
      throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
    }
    id4 = ch2;
  }
  while (index3 < length2) {
    ch2 = source3.charCodeAt(index3);
    if (!isIdentifierPart2(ch2)) {
      break;
    }
    ++index3;
    id4 += String.fromCharCode(ch2);
    if (ch2 === 92) {
      id4 = id4.substr(0, id4.length - 1);
      if (source3.charCodeAt(index3) !== 117) {
        throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
      }
      ++index3;
      ch2 = scanHexEscape2("u");
      if (!ch2 || ch2 === "\\" || !isIdentifierPart2(ch2.charCodeAt(0))) {
        throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
      }
      id4 += ch2;
    }
  }
  return id4;
}
function getIdentifier2() {
  var start, ch2;
  start = index3++;
  while (index3 < length2) {
    ch2 = source3.charCodeAt(index3);
    if (ch2 === 92) {
      index3 = start;
      return getEscapedIdentifier2();
    }
    if (isIdentifierPart2(ch2)) {
      ++index3;
    } else {
      break;
    }
  }
  return source3.slice(start, index3);
}
function scanIdentifier2() {
  var start, id4, type2;
  start = index3;
  id4 = source3.charCodeAt(index3) === 92 ? getEscapedIdentifier2() : getIdentifier2();
  if (id4.length === 1) {
    type2 = TokenIdentifier2;
  } else if (keywords2.hasOwnProperty(id4)) {
    type2 = TokenKeyword2;
  } else if (id4 === "null") {
    type2 = TokenNullLiteral2;
  } else if (id4 === "true" || id4 === "false") {
    type2 = TokenBooleanLiteral2;
  } else {
    type2 = TokenIdentifier2;
  }
  return {
    type: type2,
    value: id4,
    start,
    end: index3
  };
}
function scanPunctuator2() {
  var start = index3, code = source3.charCodeAt(index3), code2, ch1 = source3[index3], ch2, ch3, ch4;
  switch (code) {
    case 46:
    case 40:
    case 41:
    case 59:
    case 44:
    case 123:
    case 125:
    case 91:
    case 93:
    case 58:
    case 63:
    case 126:
      ++index3;
      return {
        type: TokenPunctuator2,
        value: String.fromCharCode(code),
        start,
        end: index3
      };
    default:
      code2 = source3.charCodeAt(index3 + 1);
      if (code2 === 61) {
        switch (code) {
          case 43:
          case 45:
          case 47:
          case 60:
          case 62:
          case 94:
          case 124:
          case 37:
          case 38:
          case 42:
            index3 += 2;
            return {
              type: TokenPunctuator2,
              value: String.fromCharCode(code) + String.fromCharCode(code2),
              start,
              end: index3
            };
          case 33:
          case 61:
            index3 += 2;
            if (source3.charCodeAt(index3) === 61) {
              ++index3;
            }
            return {
              type: TokenPunctuator2,
              value: source3.slice(start, index3),
              start,
              end: index3
            };
        }
      }
  }
  ch4 = source3.substr(index3, 4);
  if (ch4 === ">>>=") {
    index3 += 4;
    return {
      type: TokenPunctuator2,
      value: ch4,
      start,
      end: index3
    };
  }
  ch3 = ch4.substr(0, 3);
  if (ch3 === ">>>" || ch3 === "<<=" || ch3 === ">>=") {
    index3 += 3;
    return {
      type: TokenPunctuator2,
      value: ch3,
      start,
      end: index3
    };
  }
  ch2 = ch3.substr(0, 2);
  if (ch1 === ch2[1] && "+-<>&|".indexOf(ch1) >= 0 || ch2 === "=>") {
    index3 += 2;
    return {
      type: TokenPunctuator2,
      value: ch2,
      start,
      end: index3
    };
  }
  if ("<>=!+-*%&|^/".indexOf(ch1) >= 0) {
    ++index3;
    return {
      type: TokenPunctuator2,
      value: ch1,
      start,
      end: index3
    };
  }
  throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
}
function scanHexLiteral2(start) {
  var number7 = "";
  while (index3 < length2) {
    if (!isHexDigit2(source3[index3])) {
      break;
    }
    number7 += source3[index3++];
  }
  if (number7.length === 0) {
    throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
  }
  if (isIdentifierStart2(source3.charCodeAt(index3))) {
    throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
  }
  return {
    type: TokenNumericLiteral2,
    value: parseInt("0x" + number7, 16),
    start,
    end: index3
  };
}
function scanOctalLiteral2(start) {
  var number7 = "0" + source3[index3++];
  while (index3 < length2) {
    if (!isOctalDigit2(source3[index3])) {
      break;
    }
    number7 += source3[index3++];
  }
  if (isIdentifierStart2(source3.charCodeAt(index3)) || isDecimalDigit2(source3.charCodeAt(index3))) {
    throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
  }
  return {
    type: TokenNumericLiteral2,
    value: parseInt(number7, 8),
    octal: true,
    start,
    end: index3
  };
}
function scanNumericLiteral2() {
  var number7, start, ch2;
  ch2 = source3[index3];
  assert2(isDecimalDigit2(ch2.charCodeAt(0)) || ch2 === ".", "Numeric literal must start with a decimal digit or a decimal point");
  start = index3;
  number7 = "";
  if (ch2 !== ".") {
    number7 = source3[index3++];
    ch2 = source3[index3];
    if (number7 === "0") {
      if (ch2 === "x" || ch2 === "X") {
        ++index3;
        return scanHexLiteral2(start);
      }
      if (isOctalDigit2(ch2)) {
        return scanOctalLiteral2(start);
      }
      if (ch2 && isDecimalDigit2(ch2.charCodeAt(0))) {
        throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
      }
    }
    while (isDecimalDigit2(source3.charCodeAt(index3))) {
      number7 += source3[index3++];
    }
    ch2 = source3[index3];
  }
  if (ch2 === ".") {
    number7 += source3[index3++];
    while (isDecimalDigit2(source3.charCodeAt(index3))) {
      number7 += source3[index3++];
    }
    ch2 = source3[index3];
  }
  if (ch2 === "e" || ch2 === "E") {
    number7 += source3[index3++];
    ch2 = source3[index3];
    if (ch2 === "+" || ch2 === "-") {
      number7 += source3[index3++];
    }
    if (isDecimalDigit2(source3.charCodeAt(index3))) {
      while (isDecimalDigit2(source3.charCodeAt(index3))) {
        number7 += source3[index3++];
      }
    } else {
      throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
    }
  }
  if (isIdentifierStart2(source3.charCodeAt(index3))) {
    throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
  }
  return {
    type: TokenNumericLiteral2,
    value: parseFloat(number7),
    start,
    end: index3
  };
}
function scanStringLiteral2() {
  var str = "", quote, start, ch2, code, octal = false;
  quote = source3[index3];
  assert2(quote === "'" || quote === '"', "String literal must starts with a quote");
  start = index3;
  ++index3;
  while (index3 < length2) {
    ch2 = source3[index3++];
    if (ch2 === quote) {
      quote = "";
      break;
    } else if (ch2 === "\\") {
      ch2 = source3[index3++];
      if (!ch2 || !isLineTerminator2(ch2.charCodeAt(0))) {
        switch (ch2) {
          case "u":
          case "x":
            if (source3[index3] === "{") {
              ++index3;
              str += scanUnicodeCodePointEscape2();
            } else {
              str += scanHexEscape2(ch2);
            }
            break;
          case "n":
            str += "\n";
            break;
          case "r":
            str += "\r";
            break;
          case "t":
            str += "	";
            break;
          case "b":
            str += "\b";
            break;
          case "f":
            str += "\f";
            break;
          case "v":
            str += "\v";
            break;
          default:
            if (isOctalDigit2(ch2)) {
              code = "01234567".indexOf(ch2);
              if (code !== 0) {
                octal = true;
              }
              if (index3 < length2 && isOctalDigit2(source3[index3])) {
                octal = true;
                code = code * 8 + "01234567".indexOf(source3[index3++]);
                if ("0123".indexOf(ch2) >= 0 && index3 < length2 && isOctalDigit2(source3[index3])) {
                  code = code * 8 + "01234567".indexOf(source3[index3++]);
                }
              }
              str += String.fromCharCode(code);
            } else {
              str += ch2;
            }
            break;
        }
      } else {
        if (ch2 === "\r" && source3[index3] === "\n") {
          ++index3;
        }
      }
    } else if (isLineTerminator2(ch2.charCodeAt(0))) {
      break;
    } else {
      str += ch2;
    }
  }
  if (quote !== "") {
    throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
  }
  return {
    type: TokenStringLiteral2,
    value: str,
    octal,
    start,
    end: index3
  };
}
function testRegExp2(pattern, flags) {
  var tmp = pattern;
  if (flags.indexOf("u") >= 0) {
    tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function($0, $1) {
      if (parseInt($1, 16) <= 1114111) {
        return "x";
      }
      throwError2({}, MessageInvalidRegExp2);
    }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
  }
  try {
    new RegExp(tmp);
  } catch (e) {
    throwError2({}, MessageInvalidRegExp2);
  }
  try {
    return new RegExp(pattern, flags);
  } catch (exception) {
    return null;
  }
}
function scanRegExpBody2() {
  var ch2, str, classMarker, terminated, body;
  ch2 = source3[index3];
  assert2(ch2 === "/", "Regular expression literal must start with a slash");
  str = source3[index3++];
  classMarker = false;
  terminated = false;
  while (index3 < length2) {
    ch2 = source3[index3++];
    str += ch2;
    if (ch2 === "\\") {
      ch2 = source3[index3++];
      if (isLineTerminator2(ch2.charCodeAt(0))) {
        throwError2({}, MessageUnterminatedRegExp2);
      }
      str += ch2;
    } else if (isLineTerminator2(ch2.charCodeAt(0))) {
      throwError2({}, MessageUnterminatedRegExp2);
    } else if (classMarker) {
      if (ch2 === "]") {
        classMarker = false;
      }
    } else {
      if (ch2 === "/") {
        terminated = true;
        break;
      } else if (ch2 === "[") {
        classMarker = true;
      }
    }
  }
  if (!terminated) {
    throwError2({}, MessageUnterminatedRegExp2);
  }
  body = str.substr(1, str.length - 2);
  return {
    value: body,
    literal: str
  };
}
function scanRegExpFlags2() {
  var ch2, str, flags;
  str = "";
  flags = "";
  while (index3 < length2) {
    ch2 = source3[index3];
    if (!isIdentifierPart2(ch2.charCodeAt(0))) {
      break;
    }
    ++index3;
    if (ch2 === "\\" && index3 < length2) {
      throwError2({}, MessageUnexpectedToken2, ILLEGAL3);
    } else {
      flags += ch2;
      str += ch2;
    }
  }
  if (flags.search(/[^gimuy]/g) >= 0) {
    throwError2({}, MessageInvalidRegExp2, flags);
  }
  return {
    value: flags,
    literal: str
  };
}
function scanRegExp2() {
  var start, body, flags, value3;
  lookahead2 = null;
  skipComment2();
  start = index3;
  body = scanRegExpBody2();
  flags = scanRegExpFlags2();
  value3 = testRegExp2(body.value, flags.value);
  return {
    literal: body.literal + flags.literal,
    value: value3,
    regex: {
      pattern: body.value,
      flags: flags.value
    },
    start,
    end: index3
  };
}
function isIdentifierName2(token) {
  return token.type === TokenIdentifier2 || token.type === TokenKeyword2 || token.type === TokenBooleanLiteral2 || token.type === TokenNullLiteral2;
}
function advance2() {
  var ch2;
  skipComment2();
  if (index3 >= length2) {
    return {
      type: TokenEOF2,
      start: index3,
      end: index3
    };
  }
  ch2 = source3.charCodeAt(index3);
  if (isIdentifierStart2(ch2)) {
    return scanIdentifier2();
  }
  if (ch2 === 40 || ch2 === 41 || ch2 === 59) {
    return scanPunctuator2();
  }
  if (ch2 === 39 || ch2 === 34) {
    return scanStringLiteral2();
  }
  if (ch2 === 46) {
    if (isDecimalDigit2(source3.charCodeAt(index3 + 1))) {
      return scanNumericLiteral2();
    }
    return scanPunctuator2();
  }
  if (isDecimalDigit2(ch2)) {
    return scanNumericLiteral2();
  }
  return scanPunctuator2();
}
function lex2() {
  var token;
  token = lookahead2;
  index3 = token.end;
  lookahead2 = advance2();
  index3 = token.end;
  return token;
}
function peek3() {
  var pos;
  pos = index3;
  lookahead2 = advance2();
  index3 = pos;
}
function finishArrayExpression2(elements) {
  var node = new ASTNode2(SyntaxArrayExpression2);
  node.elements = elements;
  return node;
}
function finishBinaryExpression2(operator2, left, right) {
  var node = new ASTNode2(operator2 === "||" || operator2 === "&&" ? SyntaxLogicalExpression2 : SyntaxBinaryExpression2);
  node.operator = operator2;
  node.left = left;
  node.right = right;
  return node;
}
function finishCallExpression2(callee, args) {
  var node = new ASTNode2(SyntaxCallExpression2);
  node.callee = callee;
  node.arguments = args;
  return node;
}
function finishConditionalExpression2(test2, consequent, alternate) {
  var node = new ASTNode2(SyntaxConditionalExpression2);
  node.test = test2;
  node.consequent = consequent;
  node.alternate = alternate;
  return node;
}
function finishIdentifier2(name4) {
  var node = new ASTNode2(SyntaxIdentifier2);
  node.name = name4;
  return node;
}
function finishLiteral2(token) {
  var node = new ASTNode2(SyntaxLiteral2);
  node.value = token.value;
  node.raw = source3.slice(token.start, token.end);
  if (token.regex) {
    if (node.raw === "//") {
      node.raw = "/(?:)/";
    }
    node.regex = token.regex;
  }
  return node;
}
function finishMemberExpression2(accessor3, object2, property2) {
  var node = new ASTNode2(SyntaxMemberExpression2);
  node.computed = accessor3 === "[";
  node.object = object2;
  node.property = property2;
  if (!node.computed)
    property2.member = true;
  return node;
}
function finishObjectExpression2(properties) {
  var node = new ASTNode2(SyntaxObjectExpression2);
  node.properties = properties;
  return node;
}
function finishProperty2(kind, key2, value3) {
  var node = new ASTNode2(SyntaxProperty2);
  node.key = key2;
  node.value = value3;
  node.kind = kind;
  return node;
}
function finishUnaryExpression2(operator2, argument) {
  var node = new ASTNode2(SyntaxUnaryExpression2);
  node.operator = operator2;
  node.argument = argument;
  node.prefix = true;
  return node;
}
function throwError2(token, messageFormat) {
  var error3, args = Array.prototype.slice.call(arguments, 2), msg = messageFormat.replace(/%(\d)/g, function(whole, index4) {
    assert2(index4 < args.length, "Message reference must be in range");
    return args[index4];
  });
  error3 = new Error(msg);
  error3.index = index3;
  error3.description = msg;
  throw error3;
}
function throwUnexpected2(token) {
  if (token.type === TokenEOF2) {
    throwError2(token, MessageUnexpectedEOS2);
  }
  if (token.type === TokenNumericLiteral2) {
    throwError2(token, MessageUnexpectedNumber2);
  }
  if (token.type === TokenStringLiteral2) {
    throwError2(token, MessageUnexpectedString2);
  }
  if (token.type === TokenIdentifier2) {
    throwError2(token, MessageUnexpectedIdentifier2);
  }
  if (token.type === TokenKeyword2) {
    throwError2(token, MessageUnexpectedReserved2);
  }
  throwError2(token, MessageUnexpectedToken2, token.value);
}
function expect2(value3) {
  var token = lex2();
  if (token.type !== TokenPunctuator2 || token.value !== value3) {
    throwUnexpected2(token);
  }
}
function match2(value3) {
  return lookahead2.type === TokenPunctuator2 && lookahead2.value === value3;
}
function matchKeyword2(keyword) {
  return lookahead2.type === TokenKeyword2 && lookahead2.value === keyword;
}
function parseArrayInitialiser2() {
  var elements = [];
  index3 = lookahead2.start;
  expect2("[");
  while (!match2("]")) {
    if (match2(",")) {
      lex2();
      elements.push(null);
    } else {
      elements.push(parseConditionalExpression2());
      if (!match2("]")) {
        expect2(",");
      }
    }
  }
  lex2();
  return finishArrayExpression2(elements);
}
function parseObjectPropertyKey2() {
  var token;
  index3 = lookahead2.start;
  token = lex2();
  if (token.type === TokenStringLiteral2 || token.type === TokenNumericLiteral2) {
    if (token.octal) {
      throwError2(token, MessageStrictOctalLiteral2);
    }
    return finishLiteral2(token);
  }
  return finishIdentifier2(token.value);
}
function parseObjectProperty2() {
  var token, key2, id4, value3;
  index3 = lookahead2.start;
  token = lookahead2;
  if (token.type === TokenIdentifier2) {
    id4 = parseObjectPropertyKey2();
    expect2(":");
    value3 = parseConditionalExpression2();
    return finishProperty2("init", id4, value3);
  }
  if (token.type === TokenEOF2 || token.type === TokenPunctuator2) {
    throwUnexpected2(token);
  } else {
    key2 = parseObjectPropertyKey2();
    expect2(":");
    value3 = parseConditionalExpression2();
    return finishProperty2("init", key2, value3);
  }
}
function parseObjectInitialiser2() {
  var properties = [], property2, name4, key2, map4 = {}, toString2 = String;
  index3 = lookahead2.start;
  expect2("{");
  while (!match2("}")) {
    property2 = parseObjectProperty2();
    if (property2.key.type === SyntaxIdentifier2) {
      name4 = property2.key.name;
    } else {
      name4 = toString2(property2.key.value);
    }
    key2 = "$" + name4;
    if (Object.prototype.hasOwnProperty.call(map4, key2)) {
      throwError2({}, MessageStrictDuplicateProperty2);
    } else {
      map4[key2] = true;
    }
    properties.push(property2);
    if (!match2("}")) {
      expect2(",");
    }
  }
  expect2("}");
  return finishObjectExpression2(properties);
}
function parseGroupExpression2() {
  var expr2;
  expect2("(");
  expr2 = parseExpression2();
  expect2(")");
  return expr2;
}
var legalKeywords2 = {
  if: 1
};
function parsePrimaryExpression2() {
  var type2, token, expr2;
  if (match2("(")) {
    return parseGroupExpression2();
  }
  if (match2("[")) {
    return parseArrayInitialiser2();
  }
  if (match2("{")) {
    return parseObjectInitialiser2();
  }
  type2 = lookahead2.type;
  index3 = lookahead2.start;
  if (type2 === TokenIdentifier2 || legalKeywords2[lookahead2.value]) {
    expr2 = finishIdentifier2(lex2().value);
  } else if (type2 === TokenStringLiteral2 || type2 === TokenNumericLiteral2) {
    if (lookahead2.octal) {
      throwError2(lookahead2, MessageStrictOctalLiteral2);
    }
    expr2 = finishLiteral2(lex2());
  } else if (type2 === TokenKeyword2) {
    throw new Error(DISABLED2);
  } else if (type2 === TokenBooleanLiteral2) {
    token = lex2();
    token.value = token.value === "true";
    expr2 = finishLiteral2(token);
  } else if (type2 === TokenNullLiteral2) {
    token = lex2();
    token.value = null;
    expr2 = finishLiteral2(token);
  } else if (match2("/") || match2("/=")) {
    expr2 = finishLiteral2(scanRegExp2());
    peek3();
  } else {
    throwUnexpected2(lex2());
  }
  return expr2;
}
function parseArguments2() {
  var args = [];
  expect2("(");
  if (!match2(")")) {
    while (index3 < length2) {
      args.push(parseConditionalExpression2());
      if (match2(")")) {
        break;
      }
      expect2(",");
    }
  }
  expect2(")");
  return args;
}
function parseNonComputedProperty2() {
  var token;
  index3 = lookahead2.start;
  token = lex2();
  if (!isIdentifierName2(token)) {
    throwUnexpected2(token);
  }
  return finishIdentifier2(token.value);
}
function parseNonComputedMember2() {
  expect2(".");
  return parseNonComputedProperty2();
}
function parseComputedMember2() {
  var expr2;
  expect2("[");
  expr2 = parseExpression2();
  expect2("]");
  return expr2;
}
function parseLeftHandSideExpressionAllowCall2() {
  var expr2, args, property2;
  expr2 = parsePrimaryExpression2();
  for (; ; ) {
    if (match2(".")) {
      property2 = parseNonComputedMember2();
      expr2 = finishMemberExpression2(".", expr2, property2);
    } else if (match2("(")) {
      args = parseArguments2();
      expr2 = finishCallExpression2(expr2, args);
    } else if (match2("[")) {
      property2 = parseComputedMember2();
      expr2 = finishMemberExpression2("[", expr2, property2);
    } else {
      break;
    }
  }
  return expr2;
}
function parsePostfixExpression2() {
  var expr2 = parseLeftHandSideExpressionAllowCall2();
  if (lookahead2.type === TokenPunctuator2) {
    if (match2("++") || match2("--")) {
      throw new Error(DISABLED2);
    }
  }
  return expr2;
}
function parseUnaryExpression2() {
  var token, expr2;
  if (lookahead2.type !== TokenPunctuator2 && lookahead2.type !== TokenKeyword2) {
    expr2 = parsePostfixExpression2();
  } else if (match2("++") || match2("--")) {
    throw new Error(DISABLED2);
  } else if (match2("+") || match2("-") || match2("~") || match2("!")) {
    token = lex2();
    expr2 = parseUnaryExpression2();
    expr2 = finishUnaryExpression2(token.value, expr2);
  } else if (matchKeyword2("delete") || matchKeyword2("void") || matchKeyword2("typeof")) {
    throw new Error(DISABLED2);
  } else {
    expr2 = parsePostfixExpression2();
  }
  return expr2;
}
function binaryPrecedence2(token) {
  var prec = 0;
  if (token.type !== TokenPunctuator2 && token.type !== TokenKeyword2) {
    return 0;
  }
  switch (token.value) {
    case "||":
      prec = 1;
      break;
    case "&&":
      prec = 2;
      break;
    case "|":
      prec = 3;
      break;
    case "^":
      prec = 4;
      break;
    case "&":
      prec = 5;
      break;
    case "==":
    case "!=":
    case "===":
    case "!==":
      prec = 6;
      break;
    case "<":
    case ">":
    case "<=":
    case ">=":
    case "instanceof":
    case "in":
      prec = 7;
      break;
    case "<<":
    case ">>":
    case ">>>":
      prec = 8;
      break;
    case "+":
    case "-":
      prec = 9;
      break;
    case "*":
    case "/":
    case "%":
      prec = 11;
      break;
    default:
      break;
  }
  return prec;
}
function parseBinaryExpression2() {
  var marker, markers, expr2, token, prec, stack3, right, operator2, left, i;
  marker = lookahead2;
  left = parseUnaryExpression2();
  token = lookahead2;
  prec = binaryPrecedence2(token);
  if (prec === 0) {
    return left;
  }
  token.prec = prec;
  lex2();
  markers = [marker, lookahead2];
  right = parseUnaryExpression2();
  stack3 = [left, token, right];
  while ((prec = binaryPrecedence2(lookahead2)) > 0) {
    while (stack3.length > 2 && prec <= stack3[stack3.length - 2].prec) {
      right = stack3.pop();
      operator2 = stack3.pop().value;
      left = stack3.pop();
      markers.pop();
      expr2 = finishBinaryExpression2(operator2, left, right);
      stack3.push(expr2);
    }
    token = lex2();
    token.prec = prec;
    stack3.push(token);
    markers.push(lookahead2);
    expr2 = parseUnaryExpression2();
    stack3.push(expr2);
  }
  i = stack3.length - 1;
  expr2 = stack3[i];
  markers.pop();
  while (i > 1) {
    markers.pop();
    expr2 = finishBinaryExpression2(stack3[i - 1].value, stack3[i - 2], expr2);
    i -= 2;
  }
  return expr2;
}
function parseConditionalExpression2() {
  var expr2, consequent, alternate;
  expr2 = parseBinaryExpression2();
  if (match2("?")) {
    lex2();
    consequent = parseConditionalExpression2();
    expect2(":");
    alternate = parseConditionalExpression2();
    expr2 = finishConditionalExpression2(expr2, consequent, alternate);
  }
  return expr2;
}
function parseExpression2() {
  var expr2 = parseConditionalExpression2();
  if (match2(",")) {
    throw new Error(DISABLED2);
  }
  return expr2;
}
function parser_default(code) {
  source3 = code;
  index3 = 0;
  length2 = source3.length;
  lookahead2 = null;
  peek3();
  var expr2 = parseExpression2();
  if (lookahead2.type !== TokenEOF2) {
    throw new Error("Unexpect token after expression.");
  }
  return expr2;
}

// node_modules/vega-lite/node_modules/vega-expression/node_modules/vega-util/build/vega-util.module.js
function accessor2(fn, fields, name4) {
  fn.fields = fields || [];
  fn.fname = name4;
  return fn;
}
function getter2(path3) {
  return path3.length === 1 ? get13(path3[0]) : getN3(path3);
}
var get13 = (field4) => function(obj) {
  return obj[field4];
};
var getN3 = (path3) => {
  const len = path3.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path3[i]];
    }
    return obj;
  };
};
function error2(message) {
  throw Error(message);
}
function splitAccessPath2(p) {
  const path3 = [], n = p.length;
  let q = null, b2 = 0, s = "", i, j, c2;
  p = p + "";
  function push() {
    path3.push(s + p.substring(i, j));
    s = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c2 = p[j];
    if (c2 === "\\") {
      s += p.substring(i, j);
      s += p.substring(++j, ++j);
      i = j;
    } else if (c2 === q) {
      push();
      q = null;
      b2 = -1;
    } else if (q) {
      continue;
    } else if (i === b2 && c2 === '"') {
      i = j + 1;
      q = c2;
    } else if (i === b2 && c2 === "'") {
      i = j + 1;
      q = c2;
    } else if (c2 === "." && !b2) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c2 === "[") {
      if (j > i)
        push();
      b2 = i = j + 1;
    } else if (c2 === "]") {
      if (!b2)
        error2("Access path missing open bracket: " + p);
      if (b2 > 0)
        push();
      b2 = 0;
      i = j + 1;
    }
  }
  if (b2)
    error2("Access path missing closing bracket: " + p);
  if (q)
    error2("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path3;
}
function field3(field4, name4, opt) {
  const path3 = splitAccessPath2(field4);
  field4 = path3.length === 1 ? path3[0] : field4;
  return accessor2((opt && opt.get || getter2)(path3), [field4], name4 || field4);
}
var id3 = field3("id");
var identity6 = accessor2((_) => _, [], "identity");
var zero5 = accessor2(() => 0, [], "zero");
var one5 = accessor2(() => 1, [], "one");
var truthy3 = accessor2(() => true, [], "true");
var falsy3 = accessor2(() => false, [], "false");
var isArray2 = Array.isArray;

// node_modules/vega-lite/build/src/compile/data/expressions.js
function getName(node) {
  const name4 = [];
  if (node.type === "Identifier") {
    return [node.name];
  }
  if (node.type === "Literal") {
    return [node.value];
  }
  if (node.type === "MemberExpression") {
    name4.push(...getName(node.object));
    name4.push(...getName(node.property));
  }
  return name4;
}
function startsWithDatum(node) {
  if (node.object.type === "MemberExpression") {
    return startsWithDatum(node.object);
  }
  return node.object.name === "datum";
}
function getDependentFields(expression3) {
  const ast = parser_default(expression3);
  const dependents = new Set();
  ast.visit((node) => {
    if (node.type === "MemberExpression" && startsWithDatum(node)) {
      dependents.add(getName(node).slice(1).join("."));
    }
  });
  return dependents;
}

// node_modules/vega-lite/build/src/compile/data/filter.js
var FilterNode = class extends DataFlowNode {
  constructor(parent, model, filter4) {
    super(parent);
    this.model = model;
    this.filter = filter4;
    this.expr = expression2(this.model, this.filter, this);
    this._dependentFields = getDependentFields(this.expr);
  }
  clone() {
    return new FilterNode(null, this.model, duplicate(this.filter));
  }
  dependentFields() {
    return this._dependentFields;
  }
  producedFields() {
    return new Set();
  }
  assemble() {
    return {
      type: "filter",
      expr: this.expr
    };
  }
  hash() {
    return `Filter ${this.expr}`;
  }
};

// node_modules/vega-lite/build/src/compile/selection/parse.js
function parseUnitSelection(model, selDefs) {
  var _a2;
  const selCmpts = {};
  const selectionConfig = model.config.selection;
  for (const name4 of keys3(selDefs !== null && selDefs !== void 0 ? selDefs : {})) {
    const selDef = duplicate(selDefs[name4]);
    const _b = selectionConfig[selDef.type], {fields, encodings} = _b, cfg = __rest(_b, ["fields", "encodings"]);
    for (const key2 in cfg) {
      if (key2 === "encodings" && selDef.fields || key2 === "fields" && selDef.encodings) {
        continue;
      }
      if (key2 === "mark") {
        selDef[key2] = Object.assign(Object.assign({}, cfg[key2]), selDef[key2]);
      }
      if (selDef[key2] === void 0 || selDef[key2] === true) {
        selDef[key2] = (_a2 = cfg[key2]) !== null && _a2 !== void 0 ? _a2 : selDef[key2];
      }
    }
    const safeName = varName(name4);
    const selCmpt = selCmpts[safeName] = Object.assign(Object.assign({}, selDef), {name: safeName, events: isString_default(selDef.on) ? eventSelector(selDef.on, "scope") : duplicate(selDef.on)});
    forEachTransform(selCmpt, (txCompiler) => {
      if (txCompiler.has(selCmpt) && txCompiler.parse) {
        txCompiler.parse(model, selCmpt, selDef, selDefs[name4]);
      }
    });
  }
  return selCmpts;
}
function parseSelectionPredicate(model, selections, dfnode, datum3 = "datum") {
  const stores = [];
  function expr2(name4) {
    const vname = varName(name4);
    const selCmpt = model.getSelectionComponent(vname, name4);
    const store = $2(vname + STORE);
    if (selCmpt.project.timeUnit) {
      const child = dfnode !== null && dfnode !== void 0 ? dfnode : model.component.data.raw;
      const tunode = selCmpt.project.timeUnit.clone();
      if (child.parent) {
        tunode.insertAsParentOf(child);
      } else {
        child.parent = tunode;
      }
    }
    if (selCmpt.empty !== "none") {
      stores.push(store);
    }
    return `vlSelectionTest(${store}, ${datum3}` + (selCmpt.resolve === "global" ? ")" : `, ${$2(selCmpt.resolve)})`);
  }
  const predicateStr = logicalExpr(selections, expr2);
  return (stores.length ? "!(" + stores.map((s) => `length(data(${s}))`).join(" || ") + ") || " : "") + `(${predicateStr})`;
}
function parseSelectionBinExtent(selCmpt, extent2) {
  const encoding = extent2["encoding"];
  let field4 = extent2["field"];
  if (!encoding && !field4) {
    field4 = selCmpt.project.items[0].field;
    if (selCmpt.project.items.length > 1) {
      warn3(`A "field" or "encoding" must be specified when using a selection as a scale domain. Using "field": ${$2(field4)}.`);
    }
  } else if (encoding && !field4) {
    const encodings = selCmpt.project.items.filter((p) => p.channel === encoding);
    if (!encodings.length || encodings.length > 1) {
      field4 = selCmpt.project.items[0].field;
      warn3((!encodings.length ? "No " : "Multiple ") + `matching ${$2(encoding)} encoding found for selection ${$2(extent2.selection)}. Using "field": ${$2(field4)}.`);
    } else {
      field4 = encodings[0].field;
    }
  }
  return `${selCmpt.name}[${$2(field4)}]`;
}
function materializeSelections(model, main5) {
  forEachSelection(model, (selCmpt) => {
    const selection2 = selCmpt.name;
    const lookupName = model.getName(`lookup_${selection2}`);
    model.component.data.outputNodes[lookupName] = selCmpt.materialized = new OutputNode(new FilterNode(main5, model, {selection: selection2}), lookupName, "lookup", model.component.data.outputNodeRefCounts);
  });
}

// node_modules/vega-lite/build/src/compile/predicate.js
function expression2(model, filterOp, node) {
  return logicalExpr(filterOp, (predicate) => {
    if (isString_default(predicate)) {
      return predicate;
    } else if (isSelectionPredicate(predicate)) {
      return parseSelectionPredicate(model, predicate.selection, node);
    } else {
      return fieldFilterExpression(predicate);
    }
  });
}

// node_modules/vega-lite/build/src/compile/axis/assemble.js
function assembleTitle(title2, config) {
  if (!title2) {
    return void 0;
  }
  if (isArray_default(title2) && !isText(title2)) {
    return title2.map((fieldDef) => defaultTitle(fieldDef, config)).join(", ");
  }
  return title2;
}
function setAxisEncode(axis, part, vgProp, vgRef) {
  var _a2, _b, _c;
  axis.encode = (_a2 = axis.encode) !== null && _a2 !== void 0 ? _a2 : {};
  axis.encode[part] = (_b = axis.encode[part]) !== null && _b !== void 0 ? _b : {};
  axis.encode[part].update = (_c = axis.encode[part].update) !== null && _c !== void 0 ? _c : {};
  axis.encode[part].update[vgProp] = vgRef;
}
function assembleAxis(axisCmpt, kind, config, opt = {header: false}) {
  var _a2, _b;
  const _c = axisCmpt.combine(), {disable, orient: orient3, scale: scale7, labelExpr, title: title2, zindex} = _c, axis = __rest(_c, ["disable", "orient", "scale", "labelExpr", "title", "zindex"]);
  if (disable) {
    return void 0;
  }
  for (const prop in axis) {
    const propType = AXIS_PROPERTY_TYPE[prop];
    const propValue = axis[prop];
    if (propType && propType !== kind && propType !== "both") {
      delete axis[prop];
    } else if (isConditionalAxisValue(propValue)) {
      const {condition} = propValue, valueOrSignalRef = __rest(propValue, ["condition"]);
      const conditions = array_default4(condition);
      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];
      if (propIndex) {
        const {vgProp, part} = propIndex;
        const vgRef = [
          ...conditions.map((c2) => {
            const {test: test2} = c2, valueOrSignalCRef = __rest(c2, ["test"]);
            return Object.assign({test: expression2(null, test2)}, valueOrSignalCRef);
          }),
          valueOrSignalRef
        ];
        setAxisEncode(axis, part, vgProp, vgRef);
        delete axis[prop];
      } else if (propIndex === null) {
        const signalRef = {
          signal: conditions.map((c2) => {
            const {test: test2} = c2, valueOrSignalCRef = __rest(c2, ["test"]);
            return `${expression2(null, test2)} ? ${exprFromValueOrSignalRef(valueOrSignalCRef)} : `;
          }).join("") + exprFromValueOrSignalRef(valueOrSignalRef)
        };
        axis[prop] = signalRef;
      }
    } else if (isSignalRef(propValue)) {
      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];
      if (propIndex) {
        const {vgProp, part} = propIndex;
        setAxisEncode(axis, part, vgProp, propValue);
        delete axis[prop];
      }
    }
  }
  if (kind === "grid") {
    if (!axis.grid) {
      return void 0;
    }
    if (axis.encode) {
      const {grid} = axis.encode;
      axis.encode = Object.assign({}, grid ? {grid} : {});
      if (isEmpty(axis.encode)) {
        delete axis.encode;
      }
    }
    return Object.assign(Object.assign({
      scale: scale7,
      orient: orient3
    }, axis), {
      domain: false,
      labels: false,
      aria: false,
      maxExtent: 0,
      minExtent: 0,
      ticks: false,
      zindex: getFirstDefined(zindex, 0)
    });
  } else {
    if (!opt.header && axisCmpt.mainExtracted) {
      return void 0;
    }
    if (labelExpr !== void 0) {
      let expr2 = labelExpr;
      if (((_b = (_a2 = axis.encode) === null || _a2 === void 0 ? void 0 : _a2.labels) === null || _b === void 0 ? void 0 : _b.update) && isSignalRef(axis.encode.labels.update.text)) {
        expr2 = replaceAll(labelExpr, "datum.label", axis.encode.labels.update.text.signal);
      }
      setAxisEncode(axis, "labels", "text", {signal: expr2});
    }
    if (axis.labelAlign === null) {
      delete axis.labelAlign;
    }
    if (axis.encode) {
      for (const part of AXIS_PARTS) {
        if (!axisCmpt.hasAxisPart(part)) {
          delete axis.encode[part];
        }
      }
      if (isEmpty(axis.encode)) {
        delete axis.encode;
      }
    }
    const titleString = assembleTitle(title2, config);
    return Object.assign(Object.assign(Object.assign(Object.assign({
      scale: scale7,
      orient: orient3,
      grid: false
    }, titleString ? {title: titleString} : {}), axis), config.aria === false ? {aria: false} : {}), {
      zindex: getFirstDefined(zindex, 0)
    });
  }
}
function assembleAxisSignals(model) {
  const {axes} = model.component;
  const signals = [];
  for (const channel of POSITION_SCALE_CHANNELS) {
    if (axes[channel]) {
      for (const axis of axes[channel]) {
        if (!axis.get("disable") && !axis.get("gridScale")) {
          const sizeType = channel === "x" ? "height" : "width";
          const update3 = model.getSizeSignalRef(sizeType).signal;
          if (sizeType !== update3) {
            signals.push({
              name: sizeType,
              update: update3
            });
          }
        }
      }
    }
  }
  return signals;
}
function assembleAxes(axisComponents, config) {
  const {x: x5 = [], y: y5 = []} = axisComponents;
  return [
    ...x5.map((a2) => assembleAxis(a2, "grid", config)),
    ...y5.map((a2) => assembleAxis(a2, "grid", config)),
    ...x5.map((a2) => assembleAxis(a2, "main", config)),
    ...y5.map((a2) => assembleAxis(a2, "main", config))
  ].filter((a2) => a2);
}

// node_modules/vega-lite/build/src/header.js
var HEADER_TITLE_PROPERTIES_MAP = {
  titleAlign: "align",
  titleAnchor: "anchor",
  titleAngle: "angle",
  titleBaseline: "baseline",
  titleColor: "color",
  titleFont: "font",
  titleFontSize: "fontSize",
  titleFontStyle: "fontStyle",
  titleFontWeight: "fontWeight",
  titleLimit: "limit",
  titleLineHeight: "lineHeight",
  titleOrient: "orient",
  titlePadding: "offset"
};
var HEADER_LABEL_PROPERTIES_MAP = {
  labelAlign: "align",
  labelAnchor: "anchor",
  labelAngle: "angle",
  labelBaseline: "baseline",
  labelColor: "color",
  labelFont: "font",
  labelFontSize: "fontSize",
  labelFontStyle: "fontStyle",
  labelFontWeight: "fontWeight",
  labelLimit: "limit",
  labelLineHeight: "lineHeight",
  labelOrient: "orient",
  labelPadding: "offset"
};
var HEADER_TITLE_PROPERTIES = keys3(HEADER_TITLE_PROPERTIES_MAP);
var HEADER_LABEL_PROPERTIES = keys3(HEADER_LABEL_PROPERTIES_MAP);

// node_modules/vega-lite/build/src/compile/axis/config.js
function getAxisConfigFromConfigTypes(configTypes, config, channel, orient3) {
  return Object.assign.apply(null, [
    {},
    ...configTypes.map((configType) => {
      if (configType === "axisOrient") {
        const orient1 = channel === "x" ? "bottom" : "left";
        const orientConfig1 = config[channel === "x" ? "axisBottom" : "axisLeft"] || {};
        const orientConfig2 = config[channel === "x" ? "axisTop" : "axisRight"] || {};
        const props = new Set([...keys3(orientConfig1), ...keys3(orientConfig2)]);
        const conditionalOrientAxisConfig = {};
        for (const prop of props.values()) {
          conditionalOrientAxisConfig[prop] = {
            signal: `${orient3["signal"]} === "${orient1}" ? ${signalOrStringValue(orientConfig1[prop])} : ${signalOrStringValue(orientConfig2[prop])}`
          };
        }
        return conditionalOrientAxisConfig;
      }
      return config[configType];
    })
  ]);
}
function getAxisConfigs(channel, scaleType2, orient3, config) {
  const typeBasedConfigTypes = scaleType2 === "band" ? ["axisDiscrete", "axisBand"] : scaleType2 === "point" ? ["axisDiscrete", "axisPoint"] : isQuantitative(scaleType2) ? ["axisQuantitative"] : scaleType2 === "time" || scaleType2 === "utc" ? ["axisTemporal"] : [];
  const axisChannel = channel === "x" ? "axisX" : "axisY";
  const axisOrient = isSignalRef(orient3) ? "axisOrient" : "axis" + titleCase(orient3);
  const vlOnlyConfigTypes = [
    ...typeBasedConfigTypes,
    ...typeBasedConfigTypes.map((c2) => axisChannel + c2.substr(4))
  ];
  const vgConfigTypes = ["axis", axisOrient, axisChannel];
  return {
    vlOnlyAxisConfig: getAxisConfigFromConfigTypes(vlOnlyConfigTypes, config, channel, orient3),
    vgAxisConfig: getAxisConfigFromConfigTypes(vgConfigTypes, config, channel, orient3),
    axisConfigStyle: getAxisConfigStyle([...vgConfigTypes, ...vlOnlyConfigTypes], config)
  };
}
function getAxisConfigStyle(axisConfigTypes, config) {
  var _a2;
  const toMerge = [{}];
  for (const configType of axisConfigTypes) {
    let style2 = (_a2 = config[configType]) === null || _a2 === void 0 ? void 0 : _a2.style;
    if (style2) {
      style2 = array_default4(style2);
      for (const s of style2) {
        toMerge.push(config.style[s]);
      }
    }
  }
  return Object.assign.apply(null, toMerge);
}
function getAxisConfig(property2, config, style2, axisConfigs = {}) {
  var _a2;
  const styleConfig = getStyleConfig(property2, style2, config.style);
  if (styleConfig !== void 0) {
    return {
      configFrom: "style",
      configValue: styleConfig
    };
  }
  for (const configFrom of ["vlOnlyAxisConfig", "vgAxisConfig", "axisConfigStyle"]) {
    if (((_a2 = axisConfigs[configFrom]) === null || _a2 === void 0 ? void 0 : _a2[property2]) !== void 0) {
      return {configFrom, configValue: axisConfigs[configFrom][property2]};
    }
  }
  return {};
}

// node_modules/vega-lite/build/src/compile/axis/properties.js
var axisRules = {
  scale: ({model, channel}) => model.scaleName(channel),
  format: ({fieldOrDatumDef, config, axis}) => {
    const {format: format8, formatType} = axis;
    return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format8, formatType, config, true);
  },
  formatType: ({axis, fieldOrDatumDef, scaleType: scaleType2}) => {
    const {formatType} = axis;
    return guideFormatType(formatType, fieldOrDatumDef, scaleType2);
  },
  grid: ({fieldOrDatumDef, axis, scaleType: scaleType2}) => {
    var _a2;
    if (isFieldDef(fieldOrDatumDef) && isBinned(fieldOrDatumDef.bin)) {
      return false;
    } else {
      return (_a2 = axis.grid) !== null && _a2 !== void 0 ? _a2 : defaultGrid(scaleType2, fieldOrDatumDef);
    }
  },
  gridScale: ({model, channel}) => gridScale(model, channel),
  labelAlign: ({axis, labelAngle, orient: orient3, channel}) => axis.labelAlign || defaultLabelAlign(labelAngle, orient3, channel),
  labelAngle: ({labelAngle}) => labelAngle,
  labelBaseline: ({axis, labelAngle, orient: orient3, channel}) => axis.labelBaseline || defaultLabelBaseline(labelAngle, orient3, channel),
  labelFlush: ({axis, fieldOrDatumDef, channel}) => {
    var _a2;
    return (_a2 = axis.labelFlush) !== null && _a2 !== void 0 ? _a2 : defaultLabelFlush(fieldOrDatumDef.type, channel);
  },
  labelOverlap: ({axis, fieldOrDatumDef, scaleType: scaleType2}) => {
    var _a2;
    return (_a2 = axis.labelOverlap) !== null && _a2 !== void 0 ? _a2 : defaultLabelOverlap(fieldOrDatumDef.type, scaleType2);
  },
  orient: ({orient: orient3}) => orient3,
  tickCount: ({channel, model, axis, fieldOrDatumDef, scaleType: scaleType2}) => {
    var _a2;
    const sizeType = channel === "x" ? "width" : channel === "y" ? "height" : void 0;
    const size = sizeType ? model.getSizeSignalRef(sizeType) : void 0;
    return (_a2 = axis.tickCount) !== null && _a2 !== void 0 ? _a2 : defaultTickCount({fieldOrDatumDef, scaleType: scaleType2, size, values: axis.values});
  },
  title: ({axis, model, channel}) => {
    if (axis.title !== void 0) {
      return axis.title;
    }
    const fieldDefTitle = getFieldDefTitle(model, channel);
    if (fieldDefTitle !== void 0) {
      return fieldDefTitle;
    }
    const fieldDef = model.typedFieldDef(channel);
    const channel2 = channel === "x" ? "x2" : "y2";
    const fieldDef2 = model.fieldDef(channel2);
    return mergeTitleFieldDefs(fieldDef ? [toFieldDefBase(fieldDef)] : [], isFieldDef(fieldDef2) ? [toFieldDefBase(fieldDef2)] : []);
  },
  values: ({axis, fieldOrDatumDef}) => values2(axis, fieldOrDatumDef),
  zindex: ({axis, fieldOrDatumDef, mark: mark2}) => {
    var _a2;
    return (_a2 = axis.zindex) !== null && _a2 !== void 0 ? _a2 : defaultZindex(mark2, fieldOrDatumDef);
  }
};
function defaultGrid(scaleType2, fieldDef) {
  return !hasDiscreteDomain(scaleType2) && isFieldDef(fieldDef) && !isBinning(fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin);
}
function gridScale(model, channel) {
  const gridChannel = channel === "x" ? "y" : "x";
  if (model.getScaleComponent(gridChannel)) {
    return model.scaleName(gridChannel);
  }
  return void 0;
}
function getLabelAngle(model, axis, channel, fieldOrDatumDef, axisConfigs) {
  const labelAngle = axis === null || axis === void 0 ? void 0 : axis.labelAngle;
  if (labelAngle !== void 0) {
    return isSignalRef(labelAngle) ? labelAngle : normalizeAngle(labelAngle);
  } else {
    const {configValue: angle2} = getAxisConfig("labelAngle", model.config, axis === null || axis === void 0 ? void 0 : axis.style, axisConfigs);
    if (angle2 !== void 0) {
      return normalizeAngle(angle2);
    } else {
      if (channel === X3 && contains2([NOMINAL, ORDINAL], fieldOrDatumDef.type)) {
        return 270;
      }
      return void 0;
    }
  }
}
function normalizeAngleExpr(angle2) {
  return `(((${angle2.signal} % 360) + 360) % 360)`;
}
function defaultLabelBaseline(angle2, orient3, channel, alwaysIncludeMiddle) {
  if (angle2 !== void 0) {
    if (channel === "x") {
      if (isSignalRef(angle2)) {
        const a2 = normalizeAngleExpr(angle2);
        const orientIsTop = isSignalRef(orient3) ? `(${orient3.signal} === "top")` : orient3 === "top";
        return {
          signal: `(45 < ${a2} && ${a2} < 135) || (225 < ${a2} && ${a2} < 315) ? "middle" :(${a2} <= 45 || 315 <= ${a2}) === ${orientIsTop} ? "bottom" : "top"`
        };
      }
      if (45 < angle2 && angle2 < 135 || 225 < angle2 && angle2 < 315) {
        return "middle";
      }
      if (isSignalRef(orient3)) {
        const op = angle2 <= 45 || 315 <= angle2 ? "===" : "!==";
        return {signal: `${orient3.signal} ${op} "top" ? "bottom" : "top"`};
      }
      return (angle2 <= 45 || 315 <= angle2) === (orient3 === "top") ? "bottom" : "top";
    } else {
      if (isSignalRef(angle2)) {
        const a2 = normalizeAngleExpr(angle2);
        const orientIsLeft = isSignalRef(orient3) ? `(${orient3.signal} === "left")` : orient3 === "left";
        const middle = alwaysIncludeMiddle ? '"middle"' : "null";
        return {
          signal: `${a2} <= 45 || 315 <= ${a2} || (135 <= ${a2} && ${a2} <= 225) ? ${middle} : (45 <= ${a2} && ${a2} <= 135) === ${orientIsLeft} ? "top" : "bottom"`
        };
      }
      if (angle2 <= 45 || 315 <= angle2 || 135 <= angle2 && angle2 <= 225) {
        return alwaysIncludeMiddle ? "middle" : null;
      }
      if (isSignalRef(orient3)) {
        const op = 45 <= angle2 && angle2 <= 135 ? "===" : "!==";
        return {signal: `${orient3.signal} ${op} "left" ? "top" : "bottom"`};
      }
      return (45 <= angle2 && angle2 <= 135) === (orient3 === "left") ? "top" : "bottom";
    }
  }
  return void 0;
}
function defaultLabelAlign(angle2, orient3, channel) {
  if (angle2 === void 0) {
    return void 0;
  }
  const isX2 = channel === "x";
  const startAngle = isX2 ? 0 : 90;
  const mainOrient = isX2 ? "bottom" : "left";
  if (isSignalRef(angle2)) {
    const a2 = normalizeAngleExpr(angle2);
    const orientIsMain = isSignalRef(orient3) ? `(${orient3.signal} === "${mainOrient}")` : orient3 === mainOrient;
    return {
      signal: `(${startAngle ? "(" + a2 + " + 90)" : a2} % 180 === 0) ? ${isX2 ? null : '"center"'} :(${startAngle} < ${a2} && ${a2} < ${180 + startAngle}) === ${orientIsMain} ? "left" : "right"`
    };
  }
  if ((angle2 + startAngle) % 180 === 0) {
    return isX2 ? null : "center";
  }
  if (isSignalRef(orient3)) {
    const op = startAngle < angle2 && angle2 < 180 + startAngle ? "===" : "!==";
    const orientIsMain = `${orient3.signal} ${op} "${mainOrient}"`;
    return {
      signal: `${orientIsMain} ? "left" : "right"`
    };
  }
  if ((startAngle < angle2 && angle2 < 180 + startAngle) === (orient3 === mainOrient)) {
    return "left";
  }
  return "right";
}
function defaultLabelFlush(type2, channel) {
  if (channel === "x" && contains2(["quantitative", "temporal"], type2)) {
    return true;
  }
  return void 0;
}
function defaultLabelOverlap(type2, scaleType2) {
  if (type2 !== "nominal") {
    if (scaleType2 === "log") {
      return "greedy";
    }
    return true;
  }
  return void 0;
}
function defaultOrient(channel) {
  return channel === "x" ? "bottom" : "left";
}
function defaultTickCount({fieldOrDatumDef, scaleType: scaleType2, size, values: vals2}) {
  var _a2;
  if (!vals2 && !hasDiscreteDomain(scaleType2) && scaleType2 !== "log") {
    if (isFieldDef(fieldOrDatumDef)) {
      if (isBinning(fieldOrDatumDef.bin)) {
        return {signal: `ceil(${size.signal}/10)`};
      }
      if (fieldOrDatumDef.timeUnit && contains2(["month", "hours", "day", "quarter"], (_a2 = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a2 === void 0 ? void 0 : _a2.unit)) {
        return void 0;
      }
    }
    return {signal: `ceil(${size.signal}/40)`};
  }
  return void 0;
}
function getFieldDefTitle(model, channel) {
  const channel2 = channel === "x" ? "x2" : "y2";
  const fieldDef = model.fieldDef(channel);
  const fieldDef2 = model.fieldDef(channel2);
  const title1 = fieldDef ? fieldDef.title : void 0;
  const title2 = fieldDef2 ? fieldDef2.title : void 0;
  if (title1 && title2) {
    return mergeTitle(title1, title2);
  } else if (title1) {
    return title1;
  } else if (title2) {
    return title2;
  } else if (title1 !== void 0) {
    return title1;
  } else if (title2 !== void 0) {
    return title2;
  }
  return void 0;
}
function values2(axis, fieldOrDatumDef) {
  const vals2 = axis.values;
  if (isArray_default(vals2)) {
    return valueArray(fieldOrDatumDef, vals2);
  } else if (isSignalRef(vals2)) {
    return vals2;
  }
  return void 0;
}
function defaultZindex(mark2, fieldDef) {
  if (mark2 === "rect" && isDiscrete2(fieldDef)) {
    return 1;
  }
  return 0;
}

// node_modules/vega-lite/build/src/compile/data/calculate.js
var CalculateNode = class extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    this.transform = transform4;
    this._dependentFields = getDependentFields(this.transform.calculate);
  }
  clone() {
    return new CalculateNode(null, duplicate(this.transform));
  }
  static parseAllForSortIndex(parent, model) {
    model.forEachFieldDef((fieldDef, channel) => {
      if (!isScaleFieldDef(fieldDef)) {
        return;
      }
      if (isSortArray(fieldDef.sort)) {
        const {field: field4, timeUnit} = fieldDef;
        const sort2 = fieldDef.sort;
        const calculate = sort2.map((sortValue, i) => {
          return `${fieldFilterExpression({field: field4, timeUnit, equal: sortValue})} ? ${i} : `;
        }).join("") + sort2.length;
        parent = new CalculateNode(parent, {
          calculate,
          as: sortArrayIndexField(fieldDef, channel, {forAs: true})
        });
      }
    });
    return parent;
  }
  producedFields() {
    return new Set([this.transform.as]);
  }
  dependentFields() {
    return this._dependentFields;
  }
  assemble() {
    return {
      type: "formula",
      expr: this.transform.calculate,
      as: this.transform.as
    };
  }
  hash() {
    return `Calculate ${hash(this.transform)}`;
  }
};
function sortArrayIndexField(fieldDef, channel, opt) {
  return vgField(fieldDef, Object.assign({prefix: channel, suffix: "sort_index"}, opt !== null && opt !== void 0 ? opt : {}));
}

// node_modules/vega-lite/build/src/compile/header/common.js
function getHeaderChannel(channel, orient3) {
  if (contains2(["top", "bottom"], orient3)) {
    return "column";
  } else if (contains2(["left", "right"], orient3)) {
    return "row";
  }
  return channel === "row" ? "row" : "column";
}
function getHeaderProperty(prop, facetFieldDef, config, channel) {
  const headerSpecificConfig = channel === "row" ? config.headerRow : channel === "column" ? config.headerColumn : config.headerFacet;
  return getFirstDefined(((facetFieldDef === null || facetFieldDef === void 0 ? void 0 : facetFieldDef.header) || {})[prop], headerSpecificConfig[prop], config.header[prop]);
}
function getHeaderProperties(properties, facetFieldDef, config, channel) {
  const props = {};
  for (const prop of properties) {
    const value3 = getHeaderProperty(prop, facetFieldDef, config, channel);
    if (value3 !== void 0) {
      props[prop] = value3;
    }
  }
  return props;
}

// node_modules/vega-lite/build/src/compile/header/component.js
var HEADER_CHANNELS = ["row", "column"];
var HEADER_TYPES = ["header", "footer"];

// node_modules/vega-lite/build/src/compile/header/assemble.js
function assembleTitleGroup(model, channel) {
  const title2 = model.component.layoutHeaders[channel].title;
  const config = model.config ? model.config : void 0;
  const facetFieldDef = model.component.layoutHeaders[channel].facetFieldDef ? model.component.layoutHeaders[channel].facetFieldDef : void 0;
  const {titleAnchor, titleAngle: ta, titleOrient} = getHeaderProperties(["titleAnchor", "titleAngle", "titleOrient"], facetFieldDef, config, channel);
  const headerChannel = getHeaderChannel(channel, titleOrient);
  const titleAngle = normalizeAngle(ta);
  return {
    name: `${channel}-title`,
    type: "group",
    role: `${headerChannel}-title`,
    title: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({text: title2}, channel === "row" ? {orient: "left"} : {}), {style: "guide-title"}), defaultHeaderGuideBaseline(titleAngle, headerChannel)), defaultHeaderGuideAlign(headerChannel, titleAngle, titleAnchor)), assembleHeaderProperties(config, facetFieldDef, channel, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP))
  };
}
function defaultHeaderGuideAlign(headerChannel, angle2, anchor = "middle") {
  switch (anchor) {
    case "start":
      return {align: "left"};
    case "end":
      return {align: "right"};
  }
  const align2 = defaultLabelAlign(angle2, headerChannel === "row" ? "left" : "top", headerChannel === "row" ? "y" : "x");
  return align2 ? {align: align2} : {};
}
function defaultHeaderGuideBaseline(angle2, channel) {
  const baseline3 = defaultLabelBaseline(angle2, channel === "row" ? "left" : "top", channel === "row" ? "y" : "x", true);
  return baseline3 ? {baseline: baseline3} : {};
}
function assembleHeaderGroups(model, channel) {
  const layoutHeader = model.component.layoutHeaders[channel];
  const groups = [];
  for (const headerType of HEADER_TYPES) {
    if (layoutHeader[headerType]) {
      for (const headerComponent of layoutHeader[headerType]) {
        const group2 = assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent);
        if (group2 != null) {
          groups.push(group2);
        }
      }
    }
  }
  return groups;
}
function getSort(facetFieldDef, channel) {
  var _a2;
  const {sort: sort2} = facetFieldDef;
  if (isSortField(sort2)) {
    return {
      field: vgField(sort2, {expr: "datum"}),
      order: (_a2 = sort2.order) !== null && _a2 !== void 0 ? _a2 : "ascending"
    };
  } else if (isArray_default(sort2)) {
    return {
      field: sortArrayIndexField(facetFieldDef, channel, {expr: "datum"}),
      order: "ascending"
    };
  } else {
    return {
      field: vgField(facetFieldDef, {expr: "datum"}),
      order: sort2 !== null && sort2 !== void 0 ? sort2 : "ascending"
    };
  }
}
function assembleLabelTitle(facetFieldDef, channel, config) {
  const {format: format8, formatType, labelAngle, labelAnchor, labelOrient, labelExpr} = getHeaderProperties(["format", "formatType", "labelAngle", "labelAnchor", "labelOrient", "labelExpr"], facetFieldDef, config, channel);
  const titleTextExpr = formatSignalRef({fieldOrDatumDef: facetFieldDef, format: format8, formatType, expr: "parent", config}).signal;
  const headerChannel = getHeaderChannel(channel, labelOrient);
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({text: {
    signal: labelExpr ? replaceAll(replaceAll(labelExpr, "datum.label", titleTextExpr), "datum.value", vgField(facetFieldDef, {expr: "parent"})) : titleTextExpr
  }}, channel === "row" ? {orient: "left"} : {}), {style: "guide-label", frame: "group"}), defaultHeaderGuideBaseline(labelAngle, headerChannel)), defaultHeaderGuideAlign(headerChannel, labelAngle, labelAnchor)), assembleHeaderProperties(config, facetFieldDef, channel, HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP));
}
function assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent) {
  if (headerComponent) {
    let title2 = null;
    const {facetFieldDef} = layoutHeader;
    const config = model.config ? model.config : void 0;
    if (facetFieldDef && headerComponent.labels) {
      const {labelOrient} = getHeaderProperties(["labelOrient"], facetFieldDef, config, channel);
      if (channel === "row" && !contains2(["top", "bottom"], labelOrient) || channel === "column" && !contains2(["left", "right"], labelOrient)) {
        title2 = assembleLabelTitle(facetFieldDef, channel, config);
      }
    }
    const isFacetWithoutRowCol = isFacetModel(model) && !isFacetMapping(model.facet);
    const axes = headerComponent.axes;
    const hasAxes = (axes === null || axes === void 0 ? void 0 : axes.length) > 0;
    if (title2 || hasAxes) {
      const sizeChannel = channel === "row" ? "height" : "width";
      return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({name: model.getName(`${channel}_${headerType}`), type: "group", role: `${channel}-${headerType}`}, layoutHeader.facetFieldDef ? {
        from: {data: model.getName(channel + "_domain")},
        sort: getSort(facetFieldDef, channel)
      } : {}), hasAxes && isFacetWithoutRowCol ? {
        from: {data: model.getName(`facet_domain_${channel}`)}
      } : {}), title2 ? {title: title2} : {}), headerComponent.sizeSignal ? {
        encode: {
          update: {
            [sizeChannel]: headerComponent.sizeSignal
          }
        }
      } : {}), hasAxes ? {axes} : {});
    }
  }
  return null;
}
var LAYOUT_TITLE_BAND = {
  column: {
    start: 0,
    end: 1
  },
  row: {
    start: 1,
    end: 0
  }
};
function getLayoutTitleBand(titleAnchor, headerChannel) {
  return LAYOUT_TITLE_BAND[headerChannel][titleAnchor];
}
function assembleLayoutTitleBand(headerComponentIndex, config) {
  const titleBand = {};
  for (const channel of FACET_CHANNELS) {
    const headerComponent = headerComponentIndex[channel];
    if (headerComponent === null || headerComponent === void 0 ? void 0 : headerComponent.facetFieldDef) {
      const {titleAnchor, titleOrient} = getHeaderProperties(["titleAnchor", "titleOrient"], headerComponent.facetFieldDef, config, channel);
      const headerChannel = getHeaderChannel(channel, titleOrient);
      const band2 = getLayoutTitleBand(titleAnchor, headerChannel);
      if (band2 !== void 0) {
        titleBand[headerChannel] = band2;
      }
    }
  }
  return isEmpty(titleBand) ? void 0 : titleBand;
}
function assembleHeaderProperties(config, facetFieldDef, channel, properties, propertiesMap) {
  const props = {};
  for (const prop of properties) {
    if (!propertiesMap[prop]) {
      continue;
    }
    const value3 = getHeaderProperty(prop, facetFieldDef, config, channel);
    if (value3 !== void 0) {
      props[propertiesMap[prop]] = value3;
    }
  }
  return props;
}

// node_modules/vega-lite/build/src/compile/layoutsize/assemble.js
function assembleLayoutSignals(model) {
  return [
    ...sizeSignals(model, "width"),
    ...sizeSignals(model, "height"),
    ...sizeSignals(model, "childWidth"),
    ...sizeSignals(model, "childHeight")
  ];
}
function sizeSignals(model, sizeType) {
  const channel = sizeType === "width" ? "x" : "y";
  const size = model.component.layoutSize.get(sizeType);
  if (!size || size === "merged") {
    return [];
  }
  const name4 = model.getSizeSignalRef(sizeType).signal;
  if (size === "step") {
    const scaleComponent = model.getScaleComponent(channel);
    if (scaleComponent) {
      const type2 = scaleComponent.get("type");
      const range5 = scaleComponent.get("range");
      if (hasDiscreteDomain(type2) && isVgRangeStep(range5)) {
        const scaleName = model.scaleName(channel);
        if (isFacetModel(model.parent)) {
          const parentResolve = model.parent.component.resolve;
          if (parentResolve.scale[channel] === "independent") {
            return [stepSignal(scaleName, range5)];
          }
        }
        return [
          stepSignal(scaleName, range5),
          {
            name: name4,
            update: sizeExpr(scaleName, scaleComponent, `domain('${scaleName}').length`)
          }
        ];
      }
    }
    throw new Error("layout size is step although width/height is not step.");
  } else if (size == "container") {
    const isWidth = name4.endsWith("width");
    const expr2 = isWidth ? "containerSize()[0]" : "containerSize()[1]";
    const defaultValue = getViewConfigContinuousSize(model.config.view, isWidth ? "width" : "height");
    const safeExpr = `isFinite(${expr2}) ? ${expr2} : ${defaultValue}`;
    return [{name: name4, init: safeExpr, on: [{update: safeExpr, events: "window:resize"}]}];
  } else {
    return [
      {
        name: name4,
        value: size
      }
    ];
  }
}
function stepSignal(scaleName, range5) {
  return {
    name: scaleName + "_step",
    value: range5.step
  };
}
function sizeExpr(scaleName, scaleComponent, cardinality) {
  const type2 = scaleComponent.get("type");
  const padding3 = scaleComponent.get("padding");
  const paddingOuter2 = getFirstDefined(scaleComponent.get("paddingOuter"), padding3);
  let paddingInner2 = scaleComponent.get("paddingInner");
  paddingInner2 = type2 === "band" ? paddingInner2 !== void 0 ? paddingInner2 : padding3 : 1;
  return `bandspace(${cardinality}, ${paddingInner2}, ${paddingOuter2}) * ${scaleName}_step`;
}

// node_modules/vega-lite/build/src/compile/layoutsize/component.js
function getSizeTypeFromLayoutSizeType(layoutSizeType) {
  return layoutSizeType === "childWidth" ? "width" : layoutSizeType === "childHeight" ? "height" : layoutSizeType;
}

// node_modules/vega-lite/build/src/compile/guide.js
function guideEncodeEntry(encoding, model) {
  return keys3(encoding).reduce((encode15, channel) => {
    const valueDef = encoding[channel];
    return Object.assign(Object.assign({}, encode15), wrapCondition(model, valueDef, channel, (x5) => isSignalRef(x5) ? x5 : {value: x5.value}));
  }, {});
}

// node_modules/vega-lite/build/src/compile/resolve.js
function defaultScaleResolve(channel, model) {
  if (isLayerModel(model) || isFacetModel(model)) {
    return "shared";
  } else if (isConcatModel(model)) {
    return isXorY(channel) ? "independent" : "shared";
  }
  throw new Error("invalid model type for resolve");
}
function parseGuideResolve(resolve2, channel) {
  const channelScaleResolve = resolve2.scale[channel];
  const guide = isXorY(channel) ? "axis" : "legend";
  if (channelScaleResolve === "independent") {
    if (resolve2[guide][channel] === "shared") {
      warn3(message_exports.independentScaleMeansIndependentGuide(channel));
    }
    return "independent";
  }
  return resolve2[guide][channel] || "shared";
}

// node_modules/vega-lite/build/src/compile/legend/component.js
var LEGEND_COMPONENT_PROPERTY_INDEX = Object.assign(Object.assign({}, COMMON_LEGEND_PROPERTY_INDEX), {
  disable: 1,
  labelExpr: 1,
  selections: 1,
  opacity: 1,
  shape: 1,
  stroke: 1,
  fill: 1,
  size: 1,
  strokeWidth: 1,
  strokeDash: 1,
  encode: 1
});
var LEGEND_COMPONENT_PROPERTIES = keys3(LEGEND_COMPONENT_PROPERTY_INDEX);
var LegendComponent = class extends Split {
};

// node_modules/vega-lite/build/src/compile/legend/encode.js
var legendEncodeRules = {
  symbols: symbols3,
  gradient: gradient3,
  labels,
  entries: entries2
};
function symbols3(symbolsSpec, {fieldOrDatumDef, model, channel, legendCmpt, legendType: legendType2}) {
  var _a2, _b, _c, _d, _e;
  if (legendType2 !== "symbol") {
    return void 0;
  }
  const {markDef, encoding, config, mark: mark2} = model;
  const filled2 = markDef.filled && mark2 !== "trail";
  let out = Object.assign(Object.assign({}, applyMarkConfig({}, model, FILL_STROKE_CONFIG)), color4(model, {filled: filled2}));
  const opacity2 = (_a2 = getMaxValue(encoding.opacity)) !== null && _a2 !== void 0 ? _a2 : markDef.opacity;
  if (out.fill) {
    if (channel === "fill" || filled2 && channel === COLOR) {
      delete out.fill;
    } else {
      if (out.fill["field"]) {
        if (legendCmpt.get("symbolFillColor")) {
          delete out.fill;
        } else {
          out.fill = signalOrValueRef((_b = config.legend.symbolBaseFillColor) !== null && _b !== void 0 ? _b : "black");
          out.fillOpacity = signalOrValueRef(opacity2 !== null && opacity2 !== void 0 ? opacity2 : 1);
        }
      } else if (isArray_default(out.fill)) {
        const fill2 = (_e = (_d = getFirstConditionValue((_c = encoding.fill) !== null && _c !== void 0 ? _c : encoding.color)) !== null && _d !== void 0 ? _d : markDef.fill) !== null && _e !== void 0 ? _e : filled2 && markDef.color;
        if (fill2) {
          out.fill = signalOrValueRef(fill2);
        }
      }
    }
  }
  if (out.stroke) {
    if (channel === "stroke" || !filled2 && channel === COLOR) {
      delete out.stroke;
    } else {
      if (out.stroke["field"]) {
        delete out.stroke;
      } else if (isArray_default(out.stroke)) {
        const stroke2 = getFirstDefined(getFirstConditionValue(encoding.stroke || encoding.color), markDef.stroke, filled2 ? markDef.color : void 0);
        if (stroke2) {
          out.stroke = {value: stroke2};
        }
      }
    }
  }
  if (channel !== OPACITY) {
    const condition = isFieldDef(fieldOrDatumDef) && selectedCondition(model, legendCmpt, fieldOrDatumDef);
    if (condition) {
      out.opacity = [
        Object.assign({test: condition}, signalOrValueRef(opacity2 !== null && opacity2 !== void 0 ? opacity2 : 1)),
        signalOrValueRef(config.legend.unselectedOpacity)
      ];
    } else if (opacity2) {
      out.opacity = signalOrValueRef(opacity2);
    }
  }
  out = Object.assign(Object.assign({}, out), symbolsSpec);
  return isEmpty(out) ? void 0 : out;
}
function gradient3(gradientSpec, {model, legendType: legendType2}) {
  if (legendType2 !== "gradient") {
    return void 0;
  }
  let out = {};
  const opacity2 = getMaxValue(model.encoding.opacity) || model.markDef.opacity;
  if (opacity2) {
    out.opacity = signalOrValueRef(opacity2);
  }
  out = Object.assign(Object.assign({}, out), gradientSpec);
  return isEmpty(out) ? void 0 : out;
}
function labels(specifiedlabelsSpec, {fieldOrDatumDef, model, channel, legendCmpt}) {
  const legend = model.legend(channel) || {};
  const config = model.config;
  const condition = isFieldDef(fieldOrDatumDef) ? selectedCondition(model, legendCmpt, fieldOrDatumDef) : void 0;
  const opacity2 = condition ? [{test: condition, value: 1}, {value: config.legend.unselectedOpacity}] : void 0;
  const {format: format8, formatType} = legend;
  const text4 = isCustomFormatType(formatType) ? formatCustomType({
    fieldOrDatumDef,
    field: "datum.value",
    format: format8,
    formatType,
    config
  }) : void 0;
  const labelsSpec = Object.assign(Object.assign(Object.assign({}, opacity2 ? {opacity: opacity2} : {}), text4 ? {text: text4} : {}), specifiedlabelsSpec);
  return isEmpty(labelsSpec) ? void 0 : labelsSpec;
}
function entries2(entriesSpec, {legendCmpt}) {
  const selections = legendCmpt.get("selections");
  return (selections === null || selections === void 0 ? void 0 : selections.length) ? Object.assign(Object.assign({}, entriesSpec), {fill: {value: "transparent"}}) : entriesSpec;
}
function getMaxValue(channelDef) {
  return getConditionValue(channelDef, (v, conditionalDef) => Math.max(v, conditionalDef.value));
}
function getFirstConditionValue(channelDef) {
  return getConditionValue(channelDef, (v, conditionalDef) => {
    return getFirstDefined(v, conditionalDef.value);
  });
}
function getConditionValue(channelDef, reducer) {
  if (hasConditionalValueDef(channelDef)) {
    return array_default4(channelDef.condition).reduce(reducer, channelDef.value);
  } else if (isValueDef(channelDef)) {
    return channelDef.value;
  }
  return void 0;
}
function selectedCondition(model, legendCmpt, fieldDef) {
  const selections = legendCmpt.get("selections");
  if (!(selections === null || selections === void 0 ? void 0 : selections.length))
    return void 0;
  const field4 = $2(fieldDef.field);
  return selections.map((name4) => {
    const store = $2(varName(name4) + STORE);
    return `(!length(data(${store})) || (${name4}[${field4}] && indexof(${name4}[${field4}], datum.value) >= 0))`;
  }).join(" || ");
}

// node_modules/vega-lite/build/src/compile/legend/properties.js
var legendRules = {
  direction: ({direction}) => direction,
  format: ({fieldOrDatumDef, legend, config}) => {
    const {format: format8, formatType} = legend;
    return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format8, formatType, config, false);
  },
  formatType: ({legend, fieldOrDatumDef, scaleType: scaleType2}) => {
    const {formatType} = legend;
    return guideFormatType(formatType, fieldOrDatumDef, scaleType2);
  },
  gradientLength: (params2) => {
    var _a2, _b;
    const {legend, legendConfig} = params2;
    return (_b = (_a2 = legend.gradientLength) !== null && _a2 !== void 0 ? _a2 : legendConfig.gradientLength) !== null && _b !== void 0 ? _b : defaultGradientLength(params2);
  },
  labelOverlap: ({legend, legendConfig, scaleType: scaleType2}) => {
    var _a2, _b;
    return (_b = (_a2 = legend.labelOverlap) !== null && _a2 !== void 0 ? _a2 : legendConfig.labelOverlap) !== null && _b !== void 0 ? _b : defaultLabelOverlap2(scaleType2);
  },
  symbolType: ({legend, markDef, channel, encoding}) => {
    var _a2;
    return (_a2 = legend.symbolType) !== null && _a2 !== void 0 ? _a2 : defaultSymbolType(markDef.type, channel, encoding.shape, markDef.shape);
  },
  title: ({fieldOrDatumDef, config}) => title(fieldOrDatumDef, config, {allowDisabling: true}),
  type: ({legendType: legendType2, scaleType: scaleType2, channel}) => {
    if (isColorChannel(channel) && isContinuousToContinuous(scaleType2)) {
      if (legendType2 === "gradient") {
        return void 0;
      }
    } else if (legendType2 === "symbol") {
      return void 0;
    }
    return legendType2;
  },
  values: ({fieldOrDatumDef, legend}) => values3(legend, fieldOrDatumDef)
};
function values3(legend, fieldOrDatumDef) {
  const vals2 = legend.values;
  if (isArray_default(vals2)) {
    return valueArray(fieldOrDatumDef, vals2);
  } else if (isSignalRef(vals2)) {
    return vals2;
  }
  return void 0;
}
function defaultSymbolType(mark2, channel, shapeChannelDef, markShape) {
  var _a2;
  if (channel !== "shape") {
    const shape2 = (_a2 = getFirstConditionValue(shapeChannelDef)) !== null && _a2 !== void 0 ? _a2 : markShape;
    if (shape2) {
      return shape2;
    }
  }
  switch (mark2) {
    case "bar":
    case "rect":
    case "image":
    case "square":
      return "square";
    case "line":
    case "trail":
    case "rule":
      return "stroke";
    case "arc":
    case "point":
    case "circle":
    case "tick":
    case "geoshape":
    case "area":
    case "text":
      return "circle";
  }
}
function getLegendType(params2) {
  const {legend} = params2;
  return getFirstDefined(legend.type, defaultType2(params2));
}
function defaultType2({channel, timeUnit, scaleType: scaleType2}) {
  if (isColorChannel(channel)) {
    if (contains2(["quarter", "month", "day"], timeUnit)) {
      return "symbol";
    }
    if (isContinuousToContinuous(scaleType2)) {
      return "gradient";
    }
  }
  return "symbol";
}
function getDirection({legendConfig, legendType: legendType2, orient: orient3, legend}) {
  var _a2, _b;
  return (_b = (_a2 = legend.direction) !== null && _a2 !== void 0 ? _a2 : legendConfig[legendType2 ? "gradientDirection" : "symbolDirection"]) !== null && _b !== void 0 ? _b : defaultDirection(orient3, legendType2);
}
function defaultDirection(orient3, legendType2) {
  switch (orient3) {
    case "top":
    case "bottom":
      return "horizontal";
    case "left":
    case "right":
    case "none":
    case void 0:
      return void 0;
    default:
      return legendType2 === "gradient" ? "horizontal" : void 0;
  }
}
function defaultGradientLength({legendConfig, model, direction, orient: orient3, scaleType: scaleType2}) {
  const {gradientHorizontalMaxLength, gradientHorizontalMinLength, gradientVerticalMaxLength, gradientVerticalMinLength} = legendConfig;
  if (isContinuousToContinuous(scaleType2)) {
    if (direction === "horizontal") {
      if (orient3 === "top" || orient3 === "bottom") {
        return gradientLengthSignal(model, "width", gradientHorizontalMinLength, gradientHorizontalMaxLength);
      } else {
        return gradientHorizontalMinLength;
      }
    } else {
      return gradientLengthSignal(model, "height", gradientVerticalMinLength, gradientVerticalMaxLength);
    }
  }
  return void 0;
}
function gradientLengthSignal(model, sizeType, min4, max4) {
  const sizeSignal = model.getSizeSignalRef(sizeType).signal;
  return {signal: `clamp(${sizeSignal}, ${min4}, ${max4})`};
}
function defaultLabelOverlap2(scaleType2) {
  if (contains2(["quantile", "threshold", "log"], scaleType2)) {
    return "greedy";
  }
  return void 0;
}

// node_modules/vega-lite/build/src/compile/legend/parse.js
function parseLegend2(model) {
  const legendComponent = isUnitModel(model) ? parseUnitLegend(model) : parseNonUnitLegend(model);
  model.component.legends = legendComponent;
  return legendComponent;
}
function parseUnitLegend(model) {
  const {encoding} = model;
  const legendComponent = {};
  for (const channel of [COLOR, ...LEGEND_SCALE_CHANNELS]) {
    const def2 = getFieldOrDatumDef(encoding[channel]);
    if (!def2 || !model.getScaleComponent(channel)) {
      continue;
    }
    if (channel === SHAPE && isFieldDef(def2) && def2.type === GEOJSON) {
      continue;
    }
    legendComponent[channel] = parseLegendForChannel(model, channel);
  }
  return legendComponent;
}
function getLegendDefWithScale(model, channel) {
  const scale7 = model.scaleName(channel);
  if (model.mark === "trail") {
    if (channel === "color") {
      return {stroke: scale7};
    } else if (channel === "size") {
      return {strokeWidth: scale7};
    }
  }
  if (channel === "color") {
    return model.markDef.filled ? {fill: scale7} : {stroke: scale7};
  }
  return {[channel]: scale7};
}
function isExplicit(value3, property2, legend, fieldDef) {
  switch (property2) {
    case "disable":
      return legend !== void 0;
    case "values":
      return !!(legend === null || legend === void 0 ? void 0 : legend.values);
    case "title":
      if (property2 === "title" && value3 === (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.title)) {
        return true;
      }
  }
  return value3 === (legend || {})[property2];
}
function parseLegendForChannel(model, channel) {
  var _a2, _b, _c;
  let legend = model.legend(channel);
  const {markDef, encoding, config} = model;
  const legendConfig = config.legend;
  const legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));
  parseInteractiveLegend(model, channel, legendCmpt);
  const disable = legend !== void 0 ? !legend : legendConfig.disable;
  legendCmpt.set("disable", disable, legend !== void 0);
  if (disable) {
    return legendCmpt;
  }
  legend = legend || {};
  const scaleType2 = model.getScaleComponent(channel).get("type");
  const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
  const timeUnit = isFieldDef(fieldOrDatumDef) ? (_a2 = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a2 === void 0 ? void 0 : _a2.unit : void 0;
  const orient3 = legend.orient || config.legend.orient || "right";
  const legendType2 = getLegendType({legend, channel, timeUnit, scaleType: scaleType2});
  const direction = getDirection({legend, legendType: legendType2, orient: orient3, legendConfig});
  const ruleParams = {
    legend,
    channel,
    model,
    markDef,
    encoding,
    fieldOrDatumDef,
    legendConfig,
    config,
    scaleType: scaleType2,
    orient: orient3,
    legendType: legendType2,
    direction
  };
  for (const property2 of LEGEND_COMPONENT_PROPERTIES) {
    const value3 = property2 in legendRules ? legendRules[property2](ruleParams) : legend[property2];
    if (value3 !== void 0) {
      const explicit = isExplicit(value3, property2, legend, model.fieldDef(channel));
      if (explicit || config.legend[property2] === void 0) {
        legendCmpt.set(property2, value3, explicit);
      }
    }
  }
  const legendEncoding = (_b = legend === null || legend === void 0 ? void 0 : legend.encoding) !== null && _b !== void 0 ? _b : {};
  const selections = legendCmpt.get("selections");
  const legendEncode = {};
  const legendEncodeParams = {fieldOrDatumDef, model, channel, legendCmpt, legendType: legendType2};
  for (const part of ["labels", "legend", "title", "symbols", "gradient", "entries"]) {
    const legendEncodingPart = guideEncodeEntry((_c = legendEncoding[part]) !== null && _c !== void 0 ? _c : {}, model);
    const value3 = part in legendEncodeRules ? legendEncodeRules[part](legendEncodingPart, legendEncodeParams) : legendEncodingPart;
    if (value3 !== void 0 && !isEmpty(value3)) {
      legendEncode[part] = Object.assign(Object.assign(Object.assign({}, (selections === null || selections === void 0 ? void 0 : selections.length) && isFieldDef(fieldOrDatumDef) ? {name: `${varName(fieldOrDatumDef.field)}_legend_${part}`} : {}), (selections === null || selections === void 0 ? void 0 : selections.length) ? {interactive: !!selections} : {}), {update: value3});
    }
  }
  if (!isEmpty(legendEncode)) {
    legendCmpt.set("encode", legendEncode, !!(legend === null || legend === void 0 ? void 0 : legend.encoding));
  }
  return legendCmpt;
}
function parseNonUnitLegend(model) {
  const {legends, resolve: resolve2} = model.component;
  for (const child of model.children) {
    parseLegend2(child);
    for (const channel of keys3(child.component.legends)) {
      resolve2.legend[channel] = parseGuideResolve(model.component.resolve, channel);
      if (resolve2.legend[channel] === "shared") {
        legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);
        if (!legends[channel]) {
          resolve2.legend[channel] = "independent";
          delete legends[channel];
        }
      }
    }
  }
  for (const channel of keys3(legends)) {
    for (const child of model.children) {
      if (!child.component.legends[channel]) {
        continue;
      }
      if (resolve2.legend[channel] === "shared") {
        delete child.component.legends[channel];
      }
    }
  }
  return legends;
}
function mergeLegendComponent(mergedLegend, childLegend) {
  var _a2, _b, _c, _d;
  if (!mergedLegend) {
    return childLegend.clone();
  }
  const mergedOrient = mergedLegend.getWithExplicit("orient");
  const childOrient = childLegend.getWithExplicit("orient");
  if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {
    return void 0;
  }
  let typeMerged = false;
  for (const prop of LEGEND_COMPONENT_PROPERTIES) {
    const mergedValueWithExplicit = mergeValuesWithExplicit(mergedLegend.getWithExplicit(prop), childLegend.getWithExplicit(prop), prop, "legend", (v1, v2) => {
      switch (prop) {
        case "symbolType":
          return mergeSymbolType(v1, v2);
        case "title":
          return mergeTitleComponent(v1, v2);
        case "type":
          typeMerged = true;
          return makeImplicit("symbol");
      }
      return defaultTieBreaker(v1, v2, prop, "legend");
    });
    mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);
  }
  if (typeMerged) {
    if ((_b = (_a2 = mergedLegend.implicit) === null || _a2 === void 0 ? void 0 : _a2.encode) === null || _b === void 0 ? void 0 : _b.gradient) {
      deleteNestedProperty(mergedLegend.implicit, ["encode", "gradient"]);
    }
    if ((_d = (_c = mergedLegend.explicit) === null || _c === void 0 ? void 0 : _c.encode) === null || _d === void 0 ? void 0 : _d.gradient) {
      deleteNestedProperty(mergedLegend.explicit, ["encode", "gradient"]);
    }
  }
  return mergedLegend;
}
function mergeSymbolType(st1, st2) {
  if (st2.value === "circle") {
    return st2;
  }
  return st1;
}

// node_modules/vega-lite/build/src/compile/legend/assemble.js
function setLegendEncode(legend, part, vgProp, vgRef) {
  var _a2, _b, _c;
  legend.encode = (_a2 = legend.encode) !== null && _a2 !== void 0 ? _a2 : {};
  legend.encode[part] = (_b = legend.encode[part]) !== null && _b !== void 0 ? _b : {};
  legend.encode[part].update = (_c = legend.encode[part].update) !== null && _c !== void 0 ? _c : {};
  legend.encode[part].update[vgProp] = vgRef;
}
function assembleLegends(model) {
  const legendComponentIndex = model.component.legends;
  const legendByDomain = {};
  for (const channel of keys3(legendComponentIndex)) {
    const scaleComponent = model.getScaleComponent(channel);
    const domainHash = stringify(scaleComponent.get("domains"));
    if (legendByDomain[domainHash]) {
      for (const mergedLegendComponent of legendByDomain[domainHash]) {
        const merged = mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]);
        if (!merged) {
          legendByDomain[domainHash].push(legendComponentIndex[channel]);
        }
      }
    } else {
      legendByDomain[domainHash] = [legendComponentIndex[channel].clone()];
    }
  }
  const legends = vals(legendByDomain).flat().map((l) => assembleLegend(l, model.config)).filter((l) => l !== void 0);
  return legends;
}
function assembleLegend(legendCmpt, config) {
  var _a2, _b, _c;
  const _d = legendCmpt.combine(), {disable, labelExpr, selections} = _d, legend = __rest(_d, ["disable", "labelExpr", "selections"]);
  if (disable) {
    return void 0;
  }
  if (config.aria === false && legend.aria == void 0) {
    legend.aria = false;
  }
  if ((_a2 = legend.encode) === null || _a2 === void 0 ? void 0 : _a2.symbols) {
    const out = legend.encode.symbols.update;
    if (out.fill && out.fill["value"] !== "transparent" && !out.stroke && !legend.stroke) {
      out.stroke = {value: "transparent"};
    }
    for (const property2 of LEGEND_SCALE_CHANNELS) {
      if (legend[property2]) {
        delete out[property2];
      }
    }
  }
  if (!legend.title) {
    delete legend.title;
  }
  if (labelExpr !== void 0) {
    let expr2 = labelExpr;
    if (((_c = (_b = legend.encode) === null || _b === void 0 ? void 0 : _b.labels) === null || _c === void 0 ? void 0 : _c.update) && isSignalRef(legend.encode.labels.update.text)) {
      expr2 = replaceAll(labelExpr, "datum.label", legend.encode.labels.update.text.signal);
    }
    setLegendEncode(legend, "labels", "text", {signal: expr2});
  }
  for (const prop in legend) {
    const propValue = legend[prop];
    if (isSignalRef(propValue)) {
      const propIndex = SIGNAL_LEGEND_PROP_INDEX[prop];
      if (propIndex) {
        const {vgProp, part} = propIndex;
        setLegendEncode(legend, part, vgProp, propValue);
        delete legend[prop];
      }
    }
  }
  return legend;
}

// node_modules/vega-lite/build/src/compile/projection/assemble.js
function assembleProjections(model) {
  if (isLayerModel(model) || isConcatModel(model)) {
    return assembleProjectionsForModelAndChildren(model);
  } else {
    return assembleProjectionForModel(model);
  }
}
function assembleProjectionsForModelAndChildren(model) {
  return model.children.reduce((projections2, child) => {
    return projections2.concat(child.assembleProjections());
  }, assembleProjectionForModel(model));
}
function assembleProjectionForModel(model) {
  const component = model.component.projection;
  if (!component || component.merged) {
    return [];
  }
  const projection3 = component.combine();
  const {name: name4} = projection3;
  if (!component.data) {
    return [
      Object.assign(Object.assign({name: name4}, {translate: {signal: "[width / 2, height / 2]"}}), projection3)
    ];
  } else {
    const size = {
      signal: `[${component.size.map((ref6) => ref6.signal).join(", ")}]`
    };
    const fits = component.data.reduce((sources, data4) => {
      const source4 = isSignalRef(data4) ? data4.signal : `data('${model.lookupDataSource(data4)}')`;
      if (!contains2(sources, source4)) {
        sources.push(source4);
      }
      return sources;
    }, []);
    if (fits.length <= 0) {
      throw new Error("Projection's fit didn't find any data sources");
    }
    return [
      Object.assign({
        name: name4,
        size,
        fit: {
          signal: fits.length > 1 ? `[${fits.join(", ")}]` : fits[0]
        }
      }, projection3)
    ];
  }
}

// node_modules/vega-lite/build/src/projection.js
var PROJECTION_PROPERTIES = [
  "type",
  "clipAngle",
  "clipExtent",
  "center",
  "rotate",
  "precision",
  "reflectX",
  "reflectY",
  "coefficient",
  "distance",
  "fraction",
  "lobes",
  "parallel",
  "radius",
  "ratio",
  "spacing",
  "tilt"
];

// node_modules/vega-lite/build/src/compile/projection/component.js
var ProjectionComponent = class extends Split {
  constructor(name4, specifiedProjection, size, data4) {
    super(Object.assign({}, specifiedProjection), {name: name4});
    this.specifiedProjection = specifiedProjection;
    this.size = size;
    this.data = data4;
    this.merged = false;
  }
  get isFit() {
    return !!this.data;
  }
};

// node_modules/vega-lite/build/src/compile/projection/parse.js
function parseProjection2(model) {
  model.component.projection = isUnitModel(model) ? parseUnitProjection(model) : parseNonUnitProjections(model);
}
function parseUnitProjection(model) {
  var _a2;
  if (model.hasProjection) {
    const proj = model.specifiedProjection;
    const fit3 = !(proj && (proj.scale != null || proj.translate != null));
    const size = fit3 ? [model.getSizeSignalRef("width"), model.getSizeSignalRef("height")] : void 0;
    const data4 = fit3 ? gatherFitData(model) : void 0;
    return new ProjectionComponent(model.projectionName(true), Object.assign(Object.assign({}, (_a2 = model.config.projection) !== null && _a2 !== void 0 ? _a2 : {}), proj !== null && proj !== void 0 ? proj : {}), size, data4);
  }
  return void 0;
}
function gatherFitData(model) {
  const data4 = [];
  const {encoding} = model;
  for (const posssiblePair of [
    [LONGITUDE, LATITUDE],
    [LONGITUDE2, LATITUDE2]
  ]) {
    if (getFieldOrDatumDef(encoding[posssiblePair[0]]) || getFieldOrDatumDef(encoding[posssiblePair[1]])) {
      data4.push({
        signal: model.getName(`geojson_${data4.length}`)
      });
    }
  }
  if (model.channelHasField(SHAPE) && model.typedFieldDef(SHAPE).type === GEOJSON) {
    data4.push({
      signal: model.getName(`geojson_${data4.length}`)
    });
  }
  if (data4.length === 0) {
    data4.push(model.requestDataName(MAIN));
  }
  return data4;
}
function mergeIfNoConflict(first, second2) {
  const allPropertiesShared = every(PROJECTION_PROPERTIES, (prop) => {
    if (!hasOwnProperty_default(first.explicit, prop) && !hasOwnProperty_default(second2.explicit, prop)) {
      return true;
    }
    if (hasOwnProperty_default(first.explicit, prop) && hasOwnProperty_default(second2.explicit, prop) && stringify(first.get(prop)) === stringify(second2.get(prop))) {
      return true;
    }
    return false;
  });
  const size = stringify(first.size) === stringify(second2.size);
  if (size) {
    if (allPropertiesShared) {
      return first;
    } else if (stringify(first.explicit) === stringify({})) {
      return second2;
    } else if (stringify(second2.explicit) === stringify({})) {
      return first;
    }
  }
  return null;
}
function parseNonUnitProjections(model) {
  if (model.children.length === 0) {
    return void 0;
  }
  let nonUnitProjection;
  for (const child of model.children) {
    parseProjection2(child);
  }
  const mergable = every(model.children, (child) => {
    const projection3 = child.component.projection;
    if (!projection3) {
      return true;
    } else if (!nonUnitProjection) {
      nonUnitProjection = projection3;
      return true;
    } else {
      const merge6 = mergeIfNoConflict(nonUnitProjection, projection3);
      if (merge6) {
        nonUnitProjection = merge6;
      }
      return !!merge6;
    }
  });
  if (nonUnitProjection && mergable) {
    const name4 = model.projectionName(true);
    const modelProjection = new ProjectionComponent(name4, nonUnitProjection.specifiedProjection, nonUnitProjection.size, duplicate(nonUnitProjection.data));
    for (const child of model.children) {
      const projection3 = child.component.projection;
      if (projection3) {
        if (projection3.isFit) {
          modelProjection.data.push(...child.component.projection.data);
        }
        child.renameProjection(projection3.get("name"), name4);
        projection3.merged = true;
      }
    }
    return modelProjection;
  }
  return void 0;
}

// node_modules/vega-lite/build/src/compile/data/bin.js
function rangeFormula(model, fieldDef, channel, config) {
  var _a2, _b;
  if (binRequiresRange(fieldDef, channel)) {
    const guide = isUnitModel(model) ? (_b = (_a2 = model.axis(channel)) !== null && _a2 !== void 0 ? _a2 : model.legend(channel)) !== null && _b !== void 0 ? _b : {} : {};
    const startField = vgField(fieldDef, {expr: "datum"});
    const endField = vgField(fieldDef, {expr: "datum", binSuffix: "end"});
    return {
      formulaAs: vgField(fieldDef, {binSuffix: "range", forAs: true}),
      formula: binFormatExpression(startField, endField, guide.format, guide.formatType, config)
    };
  }
  return {};
}
function binKey(bin4, field4) {
  return `${binToString(bin4)}_${field4}`;
}
function getSignalsFromModel(model, key2) {
  return {
    signal: model.getName(`${key2}_bins`),
    extentSignal: model.getName(`${key2}_extent`)
  };
}
function getBinSignalName(model, field4, bin4) {
  var _a2;
  const normalizedBin = (_a2 = normalizeBin(bin4, void 0)) !== null && _a2 !== void 0 ? _a2 : {};
  const key2 = binKey(normalizedBin, field4);
  return model.getName(`${key2}_bins`);
}
function isBinTransform(t) {
  return "as" in t;
}
function createBinComponent(t, bin4, model) {
  let as;
  let span2;
  if (isBinTransform(t)) {
    as = isString_default(t.as) ? [t.as, `${t.as}_end`] : [t.as[0], t.as[1]];
  } else {
    as = [vgField(t, {forAs: true}), vgField(t, {binSuffix: "end", forAs: true})];
  }
  const normalizedBin = Object.assign({}, normalizeBin(bin4, void 0));
  const key2 = binKey(normalizedBin, t.field);
  const {signal, extentSignal} = getSignalsFromModel(model, key2);
  if (isSelectionExtent(normalizedBin.extent)) {
    const ext = normalizedBin.extent;
    const selName = ext.selection;
    span2 = parseSelectionBinExtent(model.getSelectionComponent(varName(selName), selName), ext);
    delete normalizedBin.extent;
  }
  const binComponent = Object.assign(Object.assign(Object.assign({bin: normalizedBin, field: t.field, as: [as]}, signal ? {signal} : {}), extentSignal ? {extentSignal} : {}), span2 ? {span: span2} : {});
  return {key: key2, binComponent};
}
var BinNode = class extends DataFlowNode {
  constructor(parent, bins2) {
    super(parent);
    this.bins = bins2;
  }
  clone() {
    return new BinNode(null, duplicate(this.bins));
  }
  static makeFromEncoding(parent, model) {
    const bins2 = model.reduceFieldDef((binComponentIndex, fieldDef, channel) => {
      if (isTypedFieldDef(fieldDef) && isBinning(fieldDef.bin)) {
        const {key: key2, binComponent} = createBinComponent(fieldDef, fieldDef.bin, model);
        binComponentIndex[key2] = Object.assign(Object.assign(Object.assign({}, binComponent), binComponentIndex[key2]), rangeFormula(model, fieldDef, channel, model.config));
      }
      return binComponentIndex;
    }, {});
    if (isEmpty(bins2)) {
      return null;
    }
    return new BinNode(parent, bins2);
  }
  static makeFromTransform(parent, t, model) {
    const {key: key2, binComponent} = createBinComponent(t, t.bin, model);
    return new BinNode(parent, {
      [key2]: binComponent
    });
  }
  merge(other, renameSignal) {
    for (const key2 of keys3(other.bins)) {
      if (key2 in this.bins) {
        renameSignal(other.bins[key2].signal, this.bins[key2].signal);
        this.bins[key2].as = unique([...this.bins[key2].as, ...other.bins[key2].as], hash);
      } else {
        this.bins[key2] = other.bins[key2];
      }
    }
    for (const child of other.children) {
      other.removeChild(child);
      child.parent = this;
    }
    other.remove();
  }
  producedFields() {
    return new Set(vals(this.bins).map((c2) => c2.as).flat(2));
  }
  dependentFields() {
    return new Set(vals(this.bins).map((c2) => c2.field));
  }
  hash() {
    return `Bin ${hash(this.bins)}`;
  }
  assemble() {
    return vals(this.bins).flatMap((bin4) => {
      const transform4 = [];
      const [binAs, ...remainingAs] = bin4.as;
      const _a2 = bin4.bin, {extent: extent2} = _a2, params2 = __rest(_a2, ["extent"]);
      const binTrans = Object.assign(Object.assign(Object.assign({type: "bin", field: replacePathInField(bin4.field), as: binAs, signal: bin4.signal}, !isSelectionExtent(extent2) ? {extent: extent2} : {extent: null}), bin4.span ? {span: {signal: `span(${bin4.span})`}} : {}), params2);
      if (!extent2 && bin4.extentSignal) {
        transform4.push({
          type: "extent",
          field: replacePathInField(bin4.field),
          signal: bin4.extentSignal
        });
        binTrans.extent = {signal: bin4.extentSignal};
      }
      transform4.push(binTrans);
      for (const as of remainingAs) {
        for (let i = 0; i < 2; i++) {
          transform4.push({
            type: "formula",
            expr: vgField({field: binAs[i]}, {expr: "datum"}),
            as: as[i]
          });
        }
      }
      if (bin4.formula) {
        transform4.push({
          type: "formula",
          expr: bin4.formula,
          as: bin4.formulaAs
        });
      }
      return transform4;
    });
  }
};

// node_modules/vega-lite/build/src/compile/data/source.js
var SourceNode = class extends DataFlowNode {
  constructor(data4) {
    super(null);
    data4 = data4 !== null && data4 !== void 0 ? data4 : {name: "source"};
    let format8;
    if (!isGenerator(data4)) {
      format8 = data4.format ? Object.assign({}, omit(data4.format, ["parse"])) : {};
    }
    if (isInlineData(data4)) {
      this._data = {values: data4.values};
    } else if (isUrlData(data4)) {
      this._data = {url: data4.url};
      if (!format8.type) {
        let defaultExtension = /(?:\.([^.]+))?$/.exec(data4.url)[1];
        if (!contains2(["json", "csv", "tsv", "dsv", "topojson"], defaultExtension)) {
          defaultExtension = "json";
        }
        format8.type = defaultExtension;
      }
    } else if (isSphereGenerator(data4)) {
      this._data = {values: [{type: "Sphere"}]};
    } else if (isNamedData(data4) || isGenerator(data4)) {
      this._data = {};
    }
    this._generator = isGenerator(data4);
    if (data4.name) {
      this._name = data4.name;
    }
    if (format8 && !isEmpty(format8)) {
      this._data.format = format8;
    }
  }
  dependentFields() {
    return new Set();
  }
  producedFields() {
    return void 0;
  }
  get data() {
    return this._data;
  }
  hasName() {
    return !!this._name;
  }
  get isGenerator() {
    return this._generator;
  }
  get dataName() {
    return this._name;
  }
  set dataName(name4) {
    this._name = name4;
  }
  set parent(parent) {
    throw new Error("Source nodes have to be roots.");
  }
  remove() {
    throw new Error("Source nodes are roots and cannot be removed.");
  }
  hash() {
    throw new Error("Cannot hash sources");
  }
  assemble() {
    return Object.assign(Object.assign({name: this._name}, this._data), {transform: []});
  }
};

// node_modules/vega-lite/build/src/compile/data/debug.js
function checkLinks(nodes) {
  for (const node of nodes) {
    for (const child of node.children) {
      if (child.parent !== node) {
        console.error("Dataflow graph is inconsistent.", node, child);
        return false;
      }
    }
    if (!checkLinks(node.children)) {
      return false;
    }
  }
  return true;
}

// node_modules/vega-lite/build/src/compile/data/graticule.js
var GraticuleNode = class extends DataFlowNode {
  constructor(parent, params2) {
    super(parent);
    this.params = params2;
  }
  clone() {
    return new GraticuleNode(null, this.params);
  }
  dependentFields() {
    return new Set();
  }
  producedFields() {
    return void 0;
  }
  hash() {
    return `Graticule ${hash(this.params)}`;
  }
  assemble() {
    return Object.assign({type: "graticule"}, this.params === true ? {} : this.params);
  }
};

// node_modules/vega-lite/build/src/compile/data/sequence.js
var SequenceNode = class extends DataFlowNode {
  constructor(parent, params2) {
    super(parent);
    this.params = params2;
  }
  clone() {
    return new SequenceNode(null, this.params);
  }
  dependentFields() {
    return new Set();
  }
  producedFields() {
    var _a2;
    return new Set([(_a2 = this.params.as) !== null && _a2 !== void 0 ? _a2 : "data"]);
  }
  hash() {
    return `Hash ${hash(this.params)}`;
  }
  assemble() {
    return Object.assign({type: "sequence"}, this.params);
  }
};

// node_modules/vega-lite/build/src/compile/data/optimizer.js
function isDataSourceNode(node) {
  return node instanceof SourceNode || node instanceof GraticuleNode || node instanceof SequenceNode;
}
var OptimizerBase = class {
  constructor() {
    this._mutated = false;
  }
  setMutated() {
    this._mutated = true;
  }
  get mutatedFlag() {
    return this._mutated;
  }
};
var BottomUpOptimizer = class extends OptimizerBase {
  constructor() {
    super();
    this._continue = false;
  }
  setContinue() {
    this._continue = true;
  }
  get continueFlag() {
    return this._continue;
  }
  get flags() {
    return {continueFlag: this.continueFlag, mutatedFlag: this.mutatedFlag};
  }
  set flags({continueFlag, mutatedFlag}) {
    if (continueFlag) {
      this.setContinue();
    }
    if (mutatedFlag) {
      this.setMutated();
    }
  }
  reset() {
  }
  optimizeNextFromLeaves(node) {
    if (isDataSourceNode(node)) {
      return false;
    }
    const next = node.parent;
    const {continueFlag} = this.run(node);
    if (continueFlag) {
      this.optimizeNextFromLeaves(next);
    }
    return this.mutatedFlag;
  }
};
var TopDownOptimizer = class extends OptimizerBase {
};

// node_modules/vega-lite/build/src/compile/data/aggregate.js
function addDimension(dims, channel, fieldDef, model) {
  const channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : void 0;
  if (isTypedFieldDef(fieldDef) && isUnitModel(model) && hasBand(channel, fieldDef, channelDef2, model.stack, model.markDef, model.config)) {
    dims.add(vgField(fieldDef, {}));
    dims.add(vgField(fieldDef, {suffix: "end"}));
    if (fieldDef.bin && binRequiresRange(fieldDef, channel)) {
      dims.add(vgField(fieldDef, {binSuffix: "range"}));
    }
  } else if (isGeoPositionChannel(channel)) {
    const posChannel = getPositionChannelFromLatLong(channel);
    dims.add(model.getName(posChannel));
  } else {
    dims.add(vgField(fieldDef));
  }
  return dims;
}
function mergeMeasures(parentMeasures, childMeasures) {
  var _a2;
  for (const field4 of keys3(childMeasures)) {
    const ops2 = childMeasures[field4];
    for (const op of keys3(ops2)) {
      if (field4 in parentMeasures) {
        parentMeasures[field4][op] = new Set([...(_a2 = parentMeasures[field4][op]) !== null && _a2 !== void 0 ? _a2 : [], ...ops2[op]]);
      } else {
        parentMeasures[field4] = {[op]: ops2[op]};
      }
    }
  }
}
var AggregateNode = class extends DataFlowNode {
  constructor(parent, dimensions, measures) {
    super(parent);
    this.dimensions = dimensions;
    this.measures = measures;
  }
  clone() {
    return new AggregateNode(null, new Set(this.dimensions), duplicate(this.measures));
  }
  get groupBy() {
    return this.dimensions;
  }
  static makeFromEncoding(parent, model) {
    let isAggregate3 = false;
    model.forEachFieldDef((fd) => {
      if (fd.aggregate) {
        isAggregate3 = true;
      }
    });
    const meas = {};
    const dims = new Set();
    if (!isAggregate3) {
      return null;
    }
    model.forEachFieldDef((fieldDef, channel) => {
      var _a2, _b, _c, _d;
      const {aggregate, field: field4} = fieldDef;
      if (aggregate) {
        if (aggregate === "count") {
          meas["*"] = (_a2 = meas["*"]) !== null && _a2 !== void 0 ? _a2 : {};
          meas["*"]["count"] = new Set([vgField(fieldDef, {forAs: true})]);
        } else {
          if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {
            const op = isArgminDef(aggregate) ? "argmin" : "argmax";
            const argField = aggregate[op];
            meas[argField] = (_b = meas[argField]) !== null && _b !== void 0 ? _b : {};
            meas[argField][op] = new Set([vgField({op, field: argField}, {forAs: true})]);
          } else {
            meas[field4] = (_c = meas[field4]) !== null && _c !== void 0 ? _c : {};
            meas[field4][aggregate] = new Set([vgField(fieldDef, {forAs: true})]);
          }
          if (isScaleChannel(channel) && model.scaleDomain(channel) === "unaggregated") {
            meas[field4] = (_d = meas[field4]) !== null && _d !== void 0 ? _d : {};
            meas[field4]["min"] = new Set([vgField({field: field4, aggregate: "min"}, {forAs: true})]);
            meas[field4]["max"] = new Set([vgField({field: field4, aggregate: "max"}, {forAs: true})]);
          }
        }
      } else {
        addDimension(dims, channel, fieldDef, model);
      }
    });
    if (dims.size + keys3(meas).length === 0) {
      return null;
    }
    return new AggregateNode(parent, dims, meas);
  }
  static makeFromTransform(parent, t) {
    var _a2, _b, _c;
    const dims = new Set();
    const meas = {};
    for (const s of t.aggregate) {
      const {op, field: field4, as} = s;
      if (op) {
        if (op === "count") {
          meas["*"] = (_a2 = meas["*"]) !== null && _a2 !== void 0 ? _a2 : {};
          meas["*"]["count"] = new Set([as ? as : vgField(s, {forAs: true})]);
        } else {
          meas[field4] = (_b = meas[field4]) !== null && _b !== void 0 ? _b : {};
          meas[field4][op] = new Set([as ? as : vgField(s, {forAs: true})]);
        }
      }
    }
    for (const s of (_c = t.groupby) !== null && _c !== void 0 ? _c : []) {
      dims.add(s);
    }
    if (dims.size + keys3(meas).length === 0) {
      return null;
    }
    return new AggregateNode(parent, dims, meas);
  }
  merge(other) {
    if (setEqual(this.dimensions, other.dimensions)) {
      mergeMeasures(this.measures, other.measures);
      return true;
    } else {
      debug3("different dimensions, cannot merge");
      return false;
    }
  }
  addDimensions(fields) {
    fields.forEach(this.dimensions.add, this.dimensions);
  }
  dependentFields() {
    return new Set([...this.dimensions, ...keys3(this.measures)]);
  }
  producedFields() {
    const out = new Set();
    for (const field4 of keys3(this.measures)) {
      for (const op of keys3(this.measures[field4])) {
        const m2 = this.measures[field4][op];
        if (m2.size === 0) {
          out.add(`${op}_${field4}`);
        } else {
          m2.forEach(out.add, out);
        }
      }
    }
    return out;
  }
  hash() {
    return `Aggregate ${hash({dimensions: this.dimensions, measures: this.measures})}`;
  }
  assemble() {
    const ops2 = [];
    const fields = [];
    const as = [];
    for (const field4 of keys3(this.measures)) {
      for (const op of keys3(this.measures[field4])) {
        for (const alias of this.measures[field4][op]) {
          as.push(alias);
          ops2.push(op);
          fields.push(field4 === "*" ? null : replacePathInField(field4));
        }
      }
    }
    const result = {
      type: "aggregate",
      groupby: [...this.dimensions].map(replacePathInField),
      ops: ops2,
      fields,
      as
    };
    return result;
  }
};

// node_modules/vega-lite/build/src/compile/data/facet.js
var FacetNode = class extends DataFlowNode {
  constructor(parent, model, name4, data4) {
    super(parent);
    this.model = model;
    this.name = name4;
    this.data = data4;
    for (const channel of FACET_CHANNELS) {
      const fieldDef = model.facet[channel];
      if (fieldDef) {
        const {bin: bin4, sort: sort2} = fieldDef;
        this[channel] = Object.assign({name: model.getName(`${channel}_domain`), fields: [vgField(fieldDef), ...isBinning(bin4) ? [vgField(fieldDef, {binSuffix: "end"})] : []]}, isSortField(sort2) ? {sortField: sort2} : isArray_default(sort2) ? {sortIndexField: sortArrayIndexField(fieldDef, channel)} : {});
      }
    }
    this.childModel = model.child;
  }
  hash() {
    let out = `Facet`;
    for (const channel of FACET_CHANNELS) {
      if (this[channel]) {
        out += ` ${channel.charAt(0)}:${hash(this[channel])}`;
      }
    }
    return out;
  }
  get fields() {
    var _a2;
    const f = [];
    for (const channel of FACET_CHANNELS) {
      if ((_a2 = this[channel]) === null || _a2 === void 0 ? void 0 : _a2.fields) {
        f.push(...this[channel].fields);
      }
    }
    return f;
  }
  dependentFields() {
    const depFields = new Set(this.fields);
    for (const channel of FACET_CHANNELS) {
      if (this[channel]) {
        if (this[channel].sortField) {
          depFields.add(this[channel].sortField.field);
        }
        if (this[channel].sortIndexField) {
          depFields.add(this[channel].sortIndexField);
        }
      }
    }
    return depFields;
  }
  producedFields() {
    return new Set();
  }
  getSource() {
    return this.name;
  }
  getChildIndependentFieldsWithStep() {
    const childIndependentFieldsWithStep = {};
    for (const channel of POSITION_SCALE_CHANNELS) {
      const childScaleComponent = this.childModel.component.scales[channel];
      if (childScaleComponent && !childScaleComponent.merged) {
        const type2 = childScaleComponent.get("type");
        const range5 = childScaleComponent.get("range");
        if (hasDiscreteDomain(type2) && isVgRangeStep(range5)) {
          const domain4 = assembleDomain(this.childModel, channel);
          const field4 = getFieldFromDomain(domain4);
          if (field4) {
            childIndependentFieldsWithStep[channel] = field4;
          } else {
            warn3(`Unknown field for ${channel}. Cannot calculate view size.`);
          }
        }
      }
    }
    return childIndependentFieldsWithStep;
  }
  assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep) {
    const childChannel = {row: "y", column: "x"}[channel];
    const fields = [];
    const ops2 = [];
    const as = [];
    if (childIndependentFieldsWithStep && childIndependentFieldsWithStep[childChannel]) {
      if (crossedDataName) {
        fields.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);
        ops2.push("max");
      } else {
        fields.push(childIndependentFieldsWithStep[childChannel]);
        ops2.push("distinct");
      }
      as.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);
    }
    const {sortField, sortIndexField} = this[channel];
    if (sortField) {
      const {op = DEFAULT_SORT_OP, field: field4} = sortField;
      fields.push(field4);
      ops2.push(op);
      as.push(vgField(sortField, {forAs: true}));
    } else if (sortIndexField) {
      fields.push(sortIndexField);
      ops2.push("max");
      as.push(sortIndexField);
    }
    return {
      name: this[channel].name,
      source: crossedDataName !== null && crossedDataName !== void 0 ? crossedDataName : this.data,
      transform: [
        Object.assign({type: "aggregate", groupby: this[channel].fields}, fields.length ? {
          fields,
          ops: ops2,
          as
        } : {})
      ]
    };
  }
  assembleFacetHeaderData(childIndependentFieldsWithStep) {
    var _a2, _b;
    const {columns} = this.model.layout;
    const {layoutHeaders: layoutHeaders2} = this.model.component;
    const data4 = [];
    const hasSharedAxis = {};
    for (const headerChannel of HEADER_CHANNELS) {
      for (const headerType of HEADER_TYPES) {
        const headers = (_a2 = layoutHeaders2[headerChannel] && layoutHeaders2[headerChannel][headerType]) !== null && _a2 !== void 0 ? _a2 : [];
        for (const header of headers) {
          if (((_b = header.axes) === null || _b === void 0 ? void 0 : _b.length) > 0) {
            hasSharedAxis[headerChannel] = true;
            break;
          }
        }
      }
      if (hasSharedAxis[headerChannel]) {
        const cardinality = `length(data("${this.facet.name}"))`;
        const stop2 = headerChannel === "row" ? columns ? {signal: `ceil(${cardinality} / ${columns})`} : 1 : columns ? {signal: `min(${cardinality}, ${columns})`} : {signal: cardinality};
        data4.push({
          name: `${this.facet.name}_${headerChannel}`,
          transform: [
            {
              type: "sequence",
              start: 0,
              stop: stop2
            }
          ]
        });
      }
    }
    const {row, column} = hasSharedAxis;
    if (row || column) {
      data4.unshift(this.assembleRowColumnHeaderData("facet", null, childIndependentFieldsWithStep));
    }
    return data4;
  }
  assemble() {
    var _a2, _b;
    const data4 = [];
    let crossedDataName = null;
    const childIndependentFieldsWithStep = this.getChildIndependentFieldsWithStep();
    const {column, row, facet} = this;
    if (column && row && (childIndependentFieldsWithStep.x || childIndependentFieldsWithStep.y)) {
      crossedDataName = `cross_${this.column.name}_${this.row.name}`;
      const fields = [].concat((_a2 = childIndependentFieldsWithStep.x) !== null && _a2 !== void 0 ? _a2 : [], (_b = childIndependentFieldsWithStep.y) !== null && _b !== void 0 ? _b : []);
      const ops2 = fields.map(() => "distinct");
      data4.push({
        name: crossedDataName,
        source: this.data,
        transform: [
          {
            type: "aggregate",
            groupby: this.fields,
            fields,
            ops: ops2
          }
        ]
      });
    }
    for (const channel of [COLUMN, ROW]) {
      if (this[channel]) {
        data4.push(this.assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep));
      }
    }
    if (facet) {
      const facetData = this.assembleFacetHeaderData(childIndependentFieldsWithStep);
      if (facetData) {
        data4.push(...facetData);
      }
    }
    return data4;
  }
};

// node_modules/vega-lite/build/src/compile/data/formatparse.js
function unquote(pattern) {
  if (pattern[0] === "'" && pattern[pattern.length - 1] === "'" || pattern[0] === '"' && pattern[pattern.length - 1] === '"') {
    return pattern.slice(1, -1);
  }
  return pattern;
}
function parseExpression3(field4, parse6) {
  const f = accessPathWithDatum(field4);
  if (parse6 === "number") {
    return `toNumber(${f})`;
  } else if (parse6 === "boolean") {
    return `toBoolean(${f})`;
  } else if (parse6 === "string") {
    return `toString(${f})`;
  } else if (parse6 === "date") {
    return `toDate(${f})`;
  } else if (parse6 === "flatten") {
    return f;
  } else if (parse6.indexOf("date:") === 0) {
    const specifier = unquote(parse6.slice(5, parse6.length));
    return `timeParse(${f},'${specifier}')`;
  } else if (parse6.indexOf("utc:") === 0) {
    const specifier = unquote(parse6.slice(4, parse6.length));
    return `utcParse(${f},'${specifier}')`;
  } else {
    warn3(message_exports.unrecognizedParse(parse6));
    return null;
  }
}
function getImplicitFromFilterTransform(transform4) {
  const implicit2 = {};
  forEachLeaf(transform4.filter, (filter4) => {
    var _a2;
    if (isFieldPredicate(filter4)) {
      let val = null;
      if (isFieldEqualPredicate(filter4)) {
        val = filter4.equal;
      } else if (isFieldRangePredicate(filter4)) {
        val = filter4.range[0];
      } else if (isFieldOneOfPredicate(filter4)) {
        val = ((_a2 = filter4.oneOf) !== null && _a2 !== void 0 ? _a2 : filter4["in"])[0];
      }
      if (val) {
        if (isDateTime(val)) {
          implicit2[filter4.field] = "date";
        } else if (isNumber_default(val)) {
          implicit2[filter4.field] = "number";
        } else if (isString_default(val)) {
          implicit2[filter4.field] = "string";
        }
      }
      if (filter4.timeUnit) {
        implicit2[filter4.field] = "date";
      }
    }
  });
  return implicit2;
}
function getImplicitFromEncoding(model) {
  const implicit2 = {};
  function add6(fieldDef) {
    if (isFieldOrDatumDefForTimeFormat(fieldDef)) {
      implicit2[fieldDef.field] = "date";
    } else if (fieldDef.type === "quantitative" && isMinMaxOp(fieldDef.aggregate)) {
      implicit2[fieldDef.field] = "number";
    } else if (accessPathDepth(fieldDef.field) > 1) {
      if (!(fieldDef.field in implicit2)) {
        implicit2[fieldDef.field] = "flatten";
      }
    } else if (isScaleFieldDef(fieldDef) && isSortField(fieldDef.sort) && accessPathDepth(fieldDef.sort.field) > 1) {
      if (!(fieldDef.sort.field in implicit2)) {
        implicit2[fieldDef.sort.field] = "flatten";
      }
    }
  }
  if (isUnitModel(model) || isFacetModel(model)) {
    model.forEachFieldDef((fieldDef, channel) => {
      if (isTypedFieldDef(fieldDef)) {
        add6(fieldDef);
      } else {
        const mainChannel = getMainRangeChannel(channel);
        const mainFieldDef = model.fieldDef(mainChannel);
        add6(Object.assign(Object.assign({}, fieldDef), {type: mainFieldDef.type}));
      }
    });
  }
  if (isUnitModel(model)) {
    const {mark: mark2, markDef, encoding} = model;
    if (isPathMark(mark2) && !model.encoding.order) {
      const dimensionChannel = markDef.orient === "horizontal" ? "y" : "x";
      const dimensionChannelDef = encoding[dimensionChannel];
      if (isFieldDef(dimensionChannelDef) && dimensionChannelDef.type === "quantitative" && !(dimensionChannelDef.field in implicit2)) {
        implicit2[dimensionChannelDef.field] = "number";
      }
    }
  }
  return implicit2;
}
function getImplicitFromSelection(model) {
  const implicit2 = {};
  if (isUnitModel(model) && model.component.selection) {
    for (const name4 of keys3(model.component.selection)) {
      const selCmpt = model.component.selection[name4];
      for (const proj of selCmpt.project.items) {
        if (!proj.channel && accessPathDepth(proj.field) > 1) {
          implicit2[proj.field] = "flatten";
        }
      }
    }
  }
  return implicit2;
}
var ParseNode = class extends DataFlowNode {
  constructor(parent, parse6) {
    super(parent);
    this._parse = parse6;
  }
  clone() {
    return new ParseNode(null, duplicate(this._parse));
  }
  hash() {
    return `Parse ${hash(this._parse)}`;
  }
  static makeExplicit(parent, model, ancestorParse) {
    let explicit = {};
    const data4 = model.data;
    if (!isGenerator(data4) && data4 && data4.format && data4.format.parse) {
      explicit = data4.format.parse;
    }
    return this.makeWithAncestors(parent, explicit, {}, ancestorParse);
  }
  static makeWithAncestors(parent, explicit, implicit2, ancestorParse) {
    for (const field4 of keys3(implicit2)) {
      const parsedAs = ancestorParse.getWithExplicit(field4);
      if (parsedAs.value !== void 0) {
        if (parsedAs.explicit || parsedAs.value === implicit2[field4] || parsedAs.value === "derived" || implicit2[field4] === "flatten") {
          delete implicit2[field4];
        } else {
          warn3(message_exports.differentParse(field4, implicit2[field4], parsedAs.value));
        }
      }
    }
    for (const field4 of keys3(explicit)) {
      const parsedAs = ancestorParse.get(field4);
      if (parsedAs !== void 0) {
        if (parsedAs === explicit[field4]) {
          delete explicit[field4];
        } else {
          warn3(message_exports.differentParse(field4, explicit[field4], parsedAs));
        }
      }
    }
    const parse6 = new Split(explicit, implicit2);
    ancestorParse.copyAll(parse6);
    const p = {};
    for (const key2 of keys3(parse6.combine())) {
      const val = parse6.get(key2);
      if (val !== null) {
        p[key2] = val;
      }
    }
    if (keys3(p).length === 0 || ancestorParse.parseNothing) {
      return null;
    }
    return new ParseNode(parent, p);
  }
  get parse() {
    return this._parse;
  }
  merge(other) {
    this._parse = Object.assign(Object.assign({}, this._parse), other.parse);
    other.remove();
  }
  assembleFormatParse() {
    const formatParse = {};
    for (const field4 of keys3(this._parse)) {
      const p = this._parse[field4];
      if (accessPathDepth(field4) === 1) {
        formatParse[field4] = p;
      }
    }
    return formatParse;
  }
  producedFields() {
    return new Set(keys3(this._parse));
  }
  dependentFields() {
    return new Set(keys3(this._parse));
  }
  assembleTransforms(onlyNested = false) {
    return keys3(this._parse).filter((field4) => onlyNested ? accessPathDepth(field4) > 1 : true).map((field4) => {
      const expr2 = parseExpression3(field4, this._parse[field4]);
      if (!expr2) {
        return null;
      }
      const formula = {
        type: "formula",
        expr: expr2,
        as: removePathFromField(field4)
      };
      return formula;
    }).filter((t) => t !== null);
  }
};

// node_modules/vega-lite/build/src/compile/data/identifier.js
var IdentifierNode = class extends DataFlowNode {
  clone() {
    return new IdentifierNode(null);
  }
  constructor(parent) {
    super(parent);
  }
  dependentFields() {
    return new Set();
  }
  producedFields() {
    return new Set([SELECTION_ID2]);
  }
  hash() {
    return "Identifier";
  }
  assemble() {
    return {type: "identifier", as: SELECTION_ID2};
  }
};

// node_modules/vega-lite/build/src/compile/data/joinaggregate.js
var JoinAggregateTransformNode = class extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    this.transform = transform4;
  }
  clone() {
    return new JoinAggregateTransformNode(null, duplicate(this.transform));
  }
  addDimensions(fields) {
    this.transform.groupby = unique(this.transform.groupby.concat(fields), (d) => d);
  }
  dependentFields() {
    const out = new Set();
    if (this.transform.groupby) {
      this.transform.groupby.forEach(out.add, out);
    }
    this.transform.joinaggregate.map((w3) => w3.field).filter((f) => f !== void 0).forEach(out.add, out);
    return out;
  }
  producedFields() {
    return new Set(this.transform.joinaggregate.map(this.getDefaultName));
  }
  getDefaultName(joinAggregateFieldDef) {
    var _a2;
    return (_a2 = joinAggregateFieldDef.as) !== null && _a2 !== void 0 ? _a2 : vgField(joinAggregateFieldDef);
  }
  hash() {
    return `JoinAggregateTransform ${hash(this.transform)}`;
  }
  assemble() {
    const fields = [];
    const ops2 = [];
    const as = [];
    for (const joinaggregate of this.transform.joinaggregate) {
      ops2.push(joinaggregate.op);
      as.push(this.getDefaultName(joinaggregate));
      fields.push(joinaggregate.field === void 0 ? null : joinaggregate.field);
    }
    const groupby = this.transform.groupby;
    return Object.assign({
      type: "joinaggregate",
      as,
      ops: ops2,
      fields
    }, groupby !== void 0 ? {groupby} : {});
  }
};

// node_modules/vega-lite/build/src/compile/data/stack.js
function getStackByFields(model) {
  return model.stack.stackBy.reduce((fields, by) => {
    const fieldDef = by.fieldDef;
    const _field = vgField(fieldDef);
    if (_field) {
      fields.push(_field);
    }
    return fields;
  }, []);
}
function isValidAsArray(as) {
  return isArray_default(as) && as.every((s) => isString_default(s)) && as.length > 1;
}
var StackNode = class extends DataFlowNode {
  constructor(parent, stack3) {
    super(parent);
    this._stack = stack3;
  }
  clone() {
    return new StackNode(null, duplicate(this._stack));
  }
  static makeFromTransform(parent, stackTransform) {
    const {stack: stack3, groupby, as, offset: offset4 = "zero"} = stackTransform;
    const sortFields = [];
    const sortOrder = [];
    if (stackTransform.sort !== void 0) {
      for (const sortField of stackTransform.sort) {
        sortFields.push(sortField.field);
        sortOrder.push(getFirstDefined(sortField.order, "ascending"));
      }
    }
    const sort2 = {
      field: sortFields,
      order: sortOrder
    };
    let normalizedAs;
    if (isValidAsArray(as)) {
      normalizedAs = as;
    } else if (isString_default(as)) {
      normalizedAs = [as, as + "_end"];
    } else {
      normalizedAs = [stackTransform.stack + "_start", stackTransform.stack + "_end"];
    }
    return new StackNode(parent, {
      stackField: stack3,
      groupby,
      offset: offset4,
      sort: sort2,
      facetby: [],
      as: normalizedAs
    });
  }
  static makeFromEncoding(parent, model) {
    const stackProperties = model.stack;
    const {encoding} = model;
    if (!stackProperties) {
      return null;
    }
    const {groupbyChannel, fieldChannel, offset: offset4, impute} = stackProperties;
    let dimensionFieldDef;
    if (groupbyChannel) {
      const cDef = encoding[groupbyChannel];
      dimensionFieldDef = getFieldDef(cDef);
    }
    const stackby = getStackByFields(model);
    const orderDef = model.encoding.order;
    let sort2;
    if (isArray_default(orderDef) || isFieldDef(orderDef)) {
      sort2 = sortParams(orderDef);
    } else {
      sort2 = stackby.reduce((s, field4) => {
        s.field.push(field4);
        s.order.push(fieldChannel === "y" ? "descending" : "ascending");
        return s;
      }, {field: [], order: []});
    }
    return new StackNode(parent, {
      dimensionFieldDef,
      stackField: model.vgField(fieldChannel),
      facetby: [],
      stackby,
      sort: sort2,
      offset: offset4,
      impute,
      as: [
        model.vgField(fieldChannel, {suffix: "start", forAs: true}),
        model.vgField(fieldChannel, {suffix: "end", forAs: true})
      ]
    });
  }
  get stack() {
    return this._stack;
  }
  addDimensions(fields) {
    this._stack.facetby.push(...fields);
  }
  dependentFields() {
    const out = new Set();
    out.add(this._stack.stackField);
    this.getGroupbyFields().forEach(out.add, out);
    this._stack.facetby.forEach(out.add, out);
    this._stack.sort.field.forEach(out.add, out);
    return out;
  }
  producedFields() {
    return new Set(this._stack.as);
  }
  hash() {
    return `Stack ${hash(this._stack)}`;
  }
  getGroupbyFields() {
    const {dimensionFieldDef, impute, groupby} = this._stack;
    if (dimensionFieldDef) {
      if (dimensionFieldDef.bin) {
        if (impute) {
          return [vgField(dimensionFieldDef, {binSuffix: "mid"})];
        }
        return [
          vgField(dimensionFieldDef, {}),
          vgField(dimensionFieldDef, {binSuffix: "end"})
        ];
      }
      return [vgField(dimensionFieldDef)];
    }
    return groupby !== null && groupby !== void 0 ? groupby : [];
  }
  assemble() {
    const transform4 = [];
    const {facetby, dimensionFieldDef, stackField: field4, stackby, sort: sort2, offset: offset4, impute, as} = this._stack;
    if (impute && dimensionFieldDef) {
      const {band: band2 = 0.5, bin: bin4} = dimensionFieldDef;
      if (bin4) {
        transform4.push({
          type: "formula",
          expr: `${band2}*` + vgField(dimensionFieldDef, {expr: "datum"}) + `+${1 - band2}*` + vgField(dimensionFieldDef, {expr: "datum", binSuffix: "end"}),
          as: vgField(dimensionFieldDef, {binSuffix: "mid", forAs: true})
        });
      }
      transform4.push({
        type: "impute",
        field: field4,
        groupby: [...stackby, ...facetby],
        key: vgField(dimensionFieldDef, {binSuffix: "mid"}),
        method: "value",
        value: 0
      });
    }
    transform4.push({
      type: "stack",
      groupby: [...this.getGroupbyFields(), ...facetby],
      field: field4,
      sort: sort2,
      as,
      offset: offset4
    });
    return transform4;
  }
};

// node_modules/vega-lite/build/src/compile/data/window.js
var WindowTransformNode = class extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    this.transform = transform4;
  }
  clone() {
    return new WindowTransformNode(null, duplicate(this.transform));
  }
  addDimensions(fields) {
    this.transform.groupby = unique(this.transform.groupby.concat(fields), (d) => d);
  }
  dependentFields() {
    var _a2, _b;
    const out = new Set();
    ((_a2 = this.transform.groupby) !== null && _a2 !== void 0 ? _a2 : []).forEach(out.add, out);
    ((_b = this.transform.sort) !== null && _b !== void 0 ? _b : []).forEach((m2) => out.add(m2.field));
    this.transform.window.map((w3) => w3.field).filter((f) => f !== void 0).forEach(out.add, out);
    return out;
  }
  producedFields() {
    return new Set(this.transform.window.map(this.getDefaultName));
  }
  getDefaultName(windowFieldDef) {
    var _a2;
    return (_a2 = windowFieldDef.as) !== null && _a2 !== void 0 ? _a2 : vgField(windowFieldDef);
  }
  hash() {
    return `WindowTransform ${hash(this.transform)}`;
  }
  assemble() {
    var _a2;
    const fields = [];
    const ops2 = [];
    const as = [];
    const params2 = [];
    for (const window2 of this.transform.window) {
      ops2.push(window2.op);
      as.push(this.getDefaultName(window2));
      params2.push(window2.param === void 0 ? null : window2.param);
      fields.push(window2.field === void 0 ? null : window2.field);
    }
    const frame2 = this.transform.frame;
    const groupby = this.transform.groupby;
    if (frame2 && frame2[0] === null && frame2[1] === null && ops2.every((o) => isAggregateOp(o))) {
      return Object.assign({type: "joinaggregate", as, ops: ops2, fields}, groupby !== void 0 ? {groupby} : {});
    }
    const sortFields = [];
    const sortOrder = [];
    if (this.transform.sort !== void 0) {
      for (const sortField of this.transform.sort) {
        sortFields.push(sortField.field);
        sortOrder.push((_a2 = sortField.order) !== null && _a2 !== void 0 ? _a2 : "ascending");
      }
    }
    const sort2 = {
      field: sortFields,
      order: sortOrder
    };
    const ignorePeers = this.transform.ignorePeers;
    return Object.assign(Object.assign(Object.assign({
      type: "window",
      params: params2,
      as,
      ops: ops2,
      fields,
      sort: sort2
    }, ignorePeers !== void 0 ? {ignorePeers} : {}), groupby !== void 0 ? {groupby} : {}), frame2 !== void 0 ? {frame: frame2} : {});
  }
};

// node_modules/vega-lite/build/src/compile/data/optimizers.js
var MoveParseUp = class extends BottomUpOptimizer {
  run(node) {
    const parent = node.parent;
    if (node instanceof ParseNode) {
      if (isDataSourceNode(parent)) {
        return this.flags;
      }
      if (parent.numChildren() > 1) {
        this.setContinue();
        return this.flags;
      }
      if (parent instanceof ParseNode) {
        this.setMutated();
        parent.merge(node);
      } else {
        if (fieldIntersection(parent.producedFields(), node.dependentFields())) {
          this.setContinue();
          return this.flags;
        }
        this.setMutated();
        node.swapWithParent();
      }
    }
    this.setContinue();
    return this.flags;
  }
};
var MergeIdenticalNodes = class extends TopDownOptimizer {
  mergeNodes(parent, nodes) {
    const mergedNode = nodes.shift();
    for (const node of nodes) {
      parent.removeChild(node);
      node.parent = mergedNode;
      node.remove();
    }
  }
  run(node) {
    const hashes = node.children.map((x5) => x5.hash());
    const buckets = {};
    for (let i = 0; i < hashes.length; i++) {
      if (buckets[hashes[i]] === void 0) {
        buckets[hashes[i]] = [node.children[i]];
      } else {
        buckets[hashes[i]].push(node.children[i]);
      }
    }
    for (const k of keys3(buckets)) {
      if (buckets[k].length > 1) {
        this.setMutated();
        this.mergeNodes(node, buckets[k]);
      }
    }
    for (const child of node.children) {
      this.run(child);
    }
    return this.mutatedFlag;
  }
};
var RemoveUnusedSubtrees = class extends BottomUpOptimizer {
  run(node) {
    if (node instanceof OutputNode || node.numChildren() > 0 || node instanceof FacetNode) {
      return this.flags;
    } else {
      this.setMutated();
      node.remove();
    }
    return this.flags;
  }
};
var RemoveDuplicateTimeUnits = class extends BottomUpOptimizer {
  constructor() {
    super(...arguments);
    this.fields = new Set();
    this.prev = null;
  }
  run(node) {
    this.setContinue();
    if (node instanceof TimeUnitNode) {
      const pfields = node.producedFields();
      if (hasIntersection(pfields, this.fields)) {
        this.setMutated();
        this.prev.remove();
      } else {
        this.fields = new Set([...this.fields, ...pfields]);
      }
      this.prev = node;
    }
    return this.flags;
  }
  reset() {
    this.fields.clear();
  }
};
var MergeTimeUnits = class extends BottomUpOptimizer {
  run(node) {
    this.setContinue();
    const parent = node.parent;
    const timeUnitChildren = parent.children.filter((x5) => x5 instanceof TimeUnitNode);
    const combination = timeUnitChildren.pop();
    for (const timeUnit of timeUnitChildren) {
      this.setMutated();
      combination.merge(timeUnit);
    }
    return this.flags;
  }
};
function cloneSubtree(facet) {
  function clone(node) {
    if (!(node instanceof FacetNode)) {
      const copy5 = node.clone();
      if (copy5 instanceof OutputNode) {
        const newName = FACET_SCALE_PREFIX + copy5.getSource();
        copy5.setSource(newName);
        facet.model.component.data.outputNodes[newName] = copy5;
      } else if (copy5 instanceof AggregateNode || copy5 instanceof StackNode || copy5 instanceof WindowTransformNode || copy5 instanceof JoinAggregateTransformNode) {
        copy5.addDimensions(facet.fields);
      }
      for (const n of node.children.flatMap(clone)) {
        n.parent = copy5;
      }
      return [copy5];
    }
    return node.children.flatMap(clone);
  }
  return clone;
}
function moveFacetDown(node) {
  if (node instanceof FacetNode) {
    if (node.numChildren() === 1 && !(node.children[0] instanceof OutputNode)) {
      const child = node.children[0];
      if (child instanceof AggregateNode || child instanceof StackNode || child instanceof WindowTransformNode || child instanceof JoinAggregateTransformNode) {
        child.addDimensions(node.fields);
      }
      child.swapWithParent();
      moveFacetDown(node);
    } else {
      const facetMain = node.model.component.data.main;
      moveMainDownToFacet(facetMain);
      const cloner = cloneSubtree(node);
      const copy5 = node.children.map(cloner).flat();
      for (const c2 of copy5) {
        c2.parent = facetMain;
      }
    }
  } else {
    node.children.map(moveFacetDown);
  }
}
function moveMainDownToFacet(node) {
  if (node instanceof OutputNode && node.type === MAIN) {
    if (node.numChildren() === 1) {
      const child = node.children[0];
      if (!(child instanceof FacetNode)) {
        child.swapWithParent();
        moveMainDownToFacet(node);
      }
    }
  }
}
var RemoveUnnecessaryOutputNodes = class extends TopDownOptimizer {
  constructor() {
    super();
  }
  run(node) {
    if (node instanceof OutputNode && !node.isRequired()) {
      this.setMutated();
      node.remove();
    }
    for (const child of node.children) {
      this.run(child);
    }
    return this.mutatedFlag;
  }
};
var RemoveUnnecessaryIdentifierNodes = class extends TopDownOptimizer {
  constructor(model) {
    super();
    this.requiresSelectionId = model && requiresSelectionId(model);
  }
  run(node) {
    if (node instanceof IdentifierNode) {
      if (!(this.requiresSelectionId && (isDataSourceNode(node.parent) || node.parent instanceof AggregateNode || node.parent instanceof ParseNode))) {
        this.setMutated();
        node.remove();
      }
    }
    for (const child of node.children) {
      this.run(child);
    }
    return this.mutatedFlag;
  }
};
var MergeParse = class extends BottomUpOptimizer {
  run(node) {
    const parent = node.parent;
    const originalChildren = [...parent.children];
    const parseChildren = parent.children.filter((child) => child instanceof ParseNode);
    if (parent.numChildren() > 1 && parseChildren.length >= 1) {
      const commonParse = {};
      const conflictingParse = new Set();
      for (const parseNode of parseChildren) {
        const parse6 = parseNode.parse;
        for (const k of keys3(parse6)) {
          if (!(k in commonParse)) {
            commonParse[k] = parse6[k];
          } else if (commonParse[k] !== parse6[k]) {
            conflictingParse.add(k);
          }
        }
      }
      for (const field4 of conflictingParse) {
        delete commonParse[field4];
      }
      if (!isEmpty(commonParse)) {
        this.setMutated();
        const mergedParseNode = new ParseNode(parent, commonParse);
        for (const childNode of originalChildren) {
          if (childNode instanceof ParseNode) {
            for (const key2 of keys3(commonParse)) {
              delete childNode.parse[key2];
            }
          }
          parent.removeChild(childNode);
          childNode.parent = mergedParseNode;
          if (childNode instanceof ParseNode && keys3(childNode.parse).length === 0) {
            childNode.remove();
          }
        }
      }
    }
    this.setContinue();
    return this.flags;
  }
};
var MergeAggregates = class extends BottomUpOptimizer {
  run(node) {
    const parent = node.parent;
    const aggChildren = parent.children.filter((child) => child instanceof AggregateNode);
    const groupedAggregates = {};
    for (const agg of aggChildren) {
      const groupBys = hash(agg.groupBy);
      if (!(groupBys in groupedAggregates)) {
        groupedAggregates[groupBys] = [];
      }
      groupedAggregates[groupBys].push(agg);
    }
    for (const group2 of keys3(groupedAggregates)) {
      const mergeableAggs = groupedAggregates[group2];
      if (mergeableAggs.length > 1) {
        const mergedAggs = mergeableAggs.pop();
        for (const agg of mergeableAggs) {
          if (mergedAggs.merge(agg)) {
            parent.removeChild(agg);
            agg.parent = mergedAggs;
            agg.remove();
            this.setMutated();
          }
        }
      }
    }
    this.setContinue();
    return this.flags;
  }
};
var MergeBins = class extends BottomUpOptimizer {
  constructor(model) {
    super();
    this.model = model;
  }
  run(node) {
    const parent = node.parent;
    const moveBinsUp = !(isDataSourceNode(parent) || parent instanceof FilterNode || parent instanceof ParseNode || parent instanceof IdentifierNode);
    const promotableBins = [];
    const remainingBins = [];
    for (const child of parent.children) {
      if (child instanceof BinNode) {
        if (moveBinsUp && !fieldIntersection(parent.producedFields(), child.dependentFields())) {
          promotableBins.push(child);
        } else {
          remainingBins.push(child);
        }
      }
    }
    if (promotableBins.length > 0) {
      const promotedBin = promotableBins.pop();
      for (const bin4 of promotableBins) {
        promotedBin.merge(bin4, this.model.renameSignal.bind(this.model));
      }
      this.setMutated();
      if (parent instanceof BinNode) {
        parent.merge(promotedBin, this.model.renameSignal.bind(this.model));
      } else {
        promotedBin.swapWithParent();
      }
    }
    if (remainingBins.length > 1) {
      const remainingBin = remainingBins.pop();
      for (const bin4 of remainingBins) {
        remainingBin.merge(bin4, this.model.renameSignal.bind(this.model));
      }
      this.setMutated();
    }
    this.setContinue();
    return this.flags;
  }
};
var MergeOutputs = class extends BottomUpOptimizer {
  run(node) {
    const parent = node.parent;
    const children4 = [...parent.children];
    const hasOutputChild = some(children4, (child) => child instanceof OutputNode);
    if (!hasOutputChild || parent.numChildren() <= 1) {
      this.setContinue();
      return this.flags;
    }
    const otherChildren = [];
    let mainOutput;
    for (const child of children4) {
      if (child instanceof OutputNode) {
        let lastOutput = child;
        while (lastOutput.numChildren() === 1) {
          const theChild = lastOutput.children[0];
          if (theChild instanceof OutputNode) {
            lastOutput = theChild;
          } else {
            break;
          }
        }
        otherChildren.push(...lastOutput.children);
        if (mainOutput) {
          parent.removeChild(child);
          child.parent = mainOutput.parent;
          mainOutput.parent.removeChild(mainOutput);
          mainOutput.parent = lastOutput;
          this.setMutated();
        } else {
          mainOutput = lastOutput;
        }
      } else {
        otherChildren.push(child);
      }
    }
    if (otherChildren.length) {
      this.setMutated();
      for (const child of otherChildren) {
        child.parent.removeChild(child);
        child.parent = mainOutput;
      }
    }
    this.setContinue();
    return this.flags;
  }
};

// node_modules/vega-lite/build/src/compile/data/optimize.js
var FACET_SCALE_PREFIX = "scale_";
var MAX_OPTIMIZATION_RUNS = 5;
function getLeaves(roots) {
  const leaves = [];
  function append(node) {
    if (node.numChildren() === 0) {
      leaves.push(node);
    } else {
      for (const child of node.children) {
        append(child);
      }
    }
  }
  for (const child of roots) {
    append(child);
  }
  return leaves;
}
function isTrue(x5) {
  return x5;
}
function runOptimizer(optimizer, nodes) {
  const flags = nodes.map((node) => {
    if (optimizer instanceof BottomUpOptimizer) {
      const runFlags = optimizer.optimizeNextFromLeaves(node);
      optimizer.reset();
      return runFlags;
    } else {
      return optimizer.run(node);
    }
  });
  return flags.some(isTrue);
}
function optimizationDataflowHelper(dataComponent, model) {
  let roots = dataComponent.sources;
  const mutatedFlags = new Set();
  mutatedFlags.add(runOptimizer(new RemoveUnnecessaryOutputNodes(), roots));
  mutatedFlags.add(runOptimizer(new RemoveUnnecessaryIdentifierNodes(model), roots));
  roots = roots.filter((r2) => r2.numChildren() > 0);
  mutatedFlags.add(runOptimizer(new RemoveUnusedSubtrees(), getLeaves(roots)));
  roots = roots.filter((r2) => r2.numChildren() > 0);
  mutatedFlags.add(runOptimizer(new MoveParseUp(), getLeaves(roots)));
  mutatedFlags.add(runOptimizer(new MergeBins(model), getLeaves(roots)));
  mutatedFlags.add(runOptimizer(new RemoveDuplicateTimeUnits(), getLeaves(roots)));
  mutatedFlags.add(runOptimizer(new MergeParse(), getLeaves(roots)));
  mutatedFlags.add(runOptimizer(new MergeAggregates(), getLeaves(roots)));
  mutatedFlags.add(runOptimizer(new MergeTimeUnits(), getLeaves(roots)));
  mutatedFlags.add(runOptimizer(new MergeIdenticalNodes(), roots));
  mutatedFlags.add(runOptimizer(new MergeOutputs(), getLeaves(roots)));
  dataComponent.sources = roots;
  return mutatedFlags.has(true);
}
function optimizeDataflow(data4, model) {
  checkLinks(data4.sources);
  let firstPassCounter = 0;
  let secondPassCounter = 0;
  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {
    if (!optimizationDataflowHelper(data4, model)) {
      break;
    }
    firstPassCounter++;
  }
  data4.sources.map(moveFacetDown);
  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {
    if (!optimizationDataflowHelper(data4, model)) {
      break;
    }
    secondPassCounter++;
  }
  checkLinks(data4.sources);
  if (Math.max(firstPassCounter, secondPassCounter) === MAX_OPTIMIZATION_RUNS) {
    warn3(`Maximum optimization runs(${MAX_OPTIMIZATION_RUNS}) reached.`);
  }
}

// node_modules/vega-lite/build/src/compile/signal.js
var SignalRefWrapper = class {
  constructor(exprGenerator) {
    Object.defineProperty(this, "signal", {
      enumerable: true,
      get: exprGenerator
    });
  }
  static fromName(rename, signalName) {
    return new SignalRefWrapper(() => rename(signalName));
  }
};

// node_modules/vega-lite/build/src/compile/scale/domain.js
function parseScaleDomain2(model) {
  if (isUnitModel(model)) {
    parseUnitScaleDomain(model);
  } else {
    parseNonUnitScaleDomain(model);
  }
}
function parseUnitScaleDomain(model) {
  const localScaleComponents = model.component.scales;
  for (const channel of keys3(localScaleComponents)) {
    const domains = parseDomainForChannel(model, channel);
    const localScaleCmpt = localScaleComponents[channel];
    localScaleCmpt.setWithExplicit("domains", domains);
    parseSelectionDomain(model, channel);
    if (model.component.data.isFaceted) {
      let facetParent = model;
      while (!isFacetModel(facetParent) && facetParent.parent) {
        facetParent = facetParent.parent;
      }
      const resolve2 = facetParent.component.resolve.scale[channel];
      if (resolve2 === "shared") {
        for (const domain4 of domains.value) {
          if (isDataRefDomain(domain4)) {
            domain4.data = FACET_SCALE_PREFIX + domain4.data.replace(FACET_SCALE_PREFIX, "");
          }
        }
      }
    }
  }
}
function parseNonUnitScaleDomain(model) {
  for (const child of model.children) {
    parseScaleDomain2(child);
  }
  const localScaleComponents = model.component.scales;
  for (const channel of keys3(localScaleComponents)) {
    let domains;
    let selectionExtent = null;
    for (const child of model.children) {
      const childComponent = child.component.scales[channel];
      if (childComponent) {
        if (domains === void 0) {
          domains = childComponent.getWithExplicit("domains");
        } else {
          domains = mergeValuesWithExplicit(domains, childComponent.getWithExplicit("domains"), "domains", "scale", domainsTieBreaker);
        }
        const se = childComponent.get("selectionExtent");
        if (selectionExtent && se && selectionExtent.selection !== se.selection) {
          warn3("The same selection must be used to override scale domains in a layered view.");
        }
        selectionExtent = se;
      }
    }
    localScaleComponents[channel].setWithExplicit("domains", domains);
    if (selectionExtent) {
      localScaleComponents[channel].set("selectionExtent", selectionExtent, true);
    }
  }
}
function normalizeUnaggregatedDomain(domain4, fieldDef, scaleType2, scaleConfig) {
  if (domain4 === "unaggregated") {
    const {valid, reason} = canUseUnaggregatedDomain(fieldDef, scaleType2);
    if (!valid) {
      warn3(reason);
      return void 0;
    }
  } else if (domain4 === void 0 && scaleConfig.useUnaggregatedDomain) {
    const {valid} = canUseUnaggregatedDomain(fieldDef, scaleType2);
    if (valid) {
      return "unaggregated";
    }
  }
  return domain4;
}
function parseDomainForChannel(model, channel) {
  const scaleType2 = model.getScaleComponent(channel).get("type");
  const {encoding} = model;
  const domain4 = normalizeUnaggregatedDomain(model.scaleDomain(channel), model.typedFieldDef(channel), scaleType2, model.config.scale);
  if (domain4 !== model.scaleDomain(channel)) {
    model.specifiedScales[channel] = Object.assign(Object.assign({}, model.specifiedScales[channel]), {domain: domain4});
  }
  if (channel === "x" && getFieldOrDatumDef(encoding.x2)) {
    if (getFieldOrDatumDef(encoding.x)) {
      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType2, domain4, model, "x"), parseSingleChannelDomain(scaleType2, domain4, model, "x2"), "domain", "scale", domainsTieBreaker);
    } else {
      return parseSingleChannelDomain(scaleType2, domain4, model, "x2");
    }
  } else if (channel === "y" && getFieldOrDatumDef(encoding.y2)) {
    if (getFieldOrDatumDef(encoding.y)) {
      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType2, domain4, model, "y"), parseSingleChannelDomain(scaleType2, domain4, model, "y2"), "domain", "scale", domainsTieBreaker);
    } else {
      return parseSingleChannelDomain(scaleType2, domain4, model, "y2");
    }
  }
  return parseSingleChannelDomain(scaleType2, domain4, model, channel);
}
function mapDomainToDataSignal(domain4, type2, timeUnit) {
  return domain4.map((v) => {
    const data4 = valueExpr(v, {timeUnit, type: type2});
    return {signal: `{data: ${data4}}`};
  });
}
function convertDomainIfItIsDateTime(domain4, type2, timeUnit) {
  var _a2;
  const normalizedTimeUnit = (_a2 = normalizeTimeUnit(timeUnit)) === null || _a2 === void 0 ? void 0 : _a2.unit;
  if (type2 === "temporal" || normalizedTimeUnit) {
    return mapDomainToDataSignal(domain4, type2, normalizedTimeUnit);
  }
  return [domain4];
}
function parseSingleChannelDomain(scaleType2, domain4, model, channel) {
  const {encoding} = model;
  const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
  const {type: type2} = fieldOrDatumDef;
  const timeUnit = fieldOrDatumDef["timeUnit"];
  if (isDomainUnionWith(domain4)) {
    const defaultDomain = parseSingleChannelDomain(scaleType2, void 0, model, channel);
    const unionWith = convertDomainIfItIsDateTime(domain4.unionWith, type2, timeUnit);
    return makeExplicit([...defaultDomain.value, ...unionWith]);
  } else if (isSignalRef(domain4)) {
    return makeExplicit([domain4]);
  } else if (domain4 && domain4 !== "unaggregated" && !isSelectionDomain(domain4)) {
    return makeExplicit(convertDomainIfItIsDateTime(domain4, type2, timeUnit));
  }
  const stack3 = model.stack;
  if (stack3 && channel === stack3.fieldChannel) {
    if (stack3.offset === "normalize") {
      return makeImplicit([[0, 1]]);
    }
    const data4 = model.requestDataName(MAIN);
    return makeImplicit([
      {
        data: data4,
        field: model.vgField(channel, {suffix: "start"})
      },
      {
        data: data4,
        field: model.vgField(channel, {suffix: "end"})
      }
    ]);
  }
  const sort2 = isScaleChannel(channel) && isFieldDef(fieldOrDatumDef) ? domainSort(model, channel, scaleType2) : void 0;
  if (isDatumDef(fieldOrDatumDef)) {
    const d = convertDomainIfItIsDateTime([fieldOrDatumDef.datum], type2, timeUnit);
    return makeImplicit(d);
  }
  const fieldDef = fieldOrDatumDef;
  if (domain4 === "unaggregated") {
    const data4 = model.requestDataName(MAIN);
    const {field: field4} = fieldOrDatumDef;
    return makeImplicit([
      {
        data: data4,
        field: vgField({field: field4, aggregate: "min"})
      },
      {
        data: data4,
        field: vgField({field: field4, aggregate: "max"})
      }
    ]);
  } else if (isBinning(fieldDef.bin)) {
    if (hasDiscreteDomain(scaleType2)) {
      if (scaleType2 === "bin-ordinal") {
        return makeImplicit([]);
      }
      return makeImplicit([
        {
          data: isBoolean3(sort2) ? model.requestDataName(MAIN) : model.requestDataName(RAW),
          field: model.vgField(channel, binRequiresRange(fieldDef, channel) ? {binSuffix: "range"} : {}),
          sort: sort2 === true || !isObject_default(sort2) ? {
            field: model.vgField(channel, {}),
            op: "min"
          } : sort2
        }
      ]);
    } else {
      const {bin: bin4} = fieldDef;
      if (isBinning(bin4)) {
        const binSignal = getBinSignalName(model, fieldDef.field, bin4);
        return makeImplicit([
          new SignalRefWrapper(() => {
            const signal = model.getSignalName(binSignal);
            return `[${signal}.start, ${signal}.stop]`;
          })
        ]);
      } else {
        return makeImplicit([
          {
            data: model.requestDataName(MAIN),
            field: model.vgField(channel, {})
          }
        ]);
      }
    }
  } else if (fieldDef.timeUnit && contains2(["time", "utc"], scaleType2) && hasBand(channel, fieldDef, isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : void 0, model.stack, model.markDef, model.config)) {
    const data4 = model.requestDataName(MAIN);
    return makeImplicit([
      {
        data: data4,
        field: model.vgField(channel)
      },
      {
        data: data4,
        field: model.vgField(channel, {suffix: "end"})
      }
    ]);
  } else if (sort2) {
    return makeImplicit([
      {
        data: isBoolean3(sort2) ? model.requestDataName(MAIN) : model.requestDataName(RAW),
        field: model.vgField(channel),
        sort: sort2
      }
    ]);
  } else {
    return makeImplicit([
      {
        data: model.requestDataName(MAIN),
        field: model.vgField(channel)
      }
    ]);
  }
}
function normalizeSortField(sort2, isStackedMeasure) {
  const {op, field: field4, order} = sort2;
  return Object.assign(Object.assign({
    op: op !== null && op !== void 0 ? op : isStackedMeasure ? "sum" : DEFAULT_SORT_OP
  }, field4 ? {field: replacePathInField(field4)} : {}), order ? {order} : {});
}
function parseSelectionDomain(model, channel) {
  var _a2;
  const scale7 = model.component.scales[channel];
  const spec = model.specifiedScales[channel].domain;
  const bin4 = (_a2 = model.fieldDef(channel)) === null || _a2 === void 0 ? void 0 : _a2.bin;
  const domain4 = isSelectionDomain(spec) && spec;
  const extent2 = isBinParams(bin4) && isSelectionExtent(bin4.extent) && bin4.extent;
  if (domain4 || extent2) {
    scale7.set("selectionExtent", domain4 !== null && domain4 !== void 0 ? domain4 : extent2, true);
  }
}
function domainSort(model, channel, scaleType2) {
  if (!hasDiscreteDomain(scaleType2)) {
    return void 0;
  }
  const fieldDef = model.fieldDef(channel);
  const sort2 = fieldDef.sort;
  if (isSortArray(sort2)) {
    return {
      op: "min",
      field: sortArrayIndexField(fieldDef, channel),
      order: "ascending"
    };
  }
  const {stack: stack3} = model;
  const stackDimensions = stack3 ? [...stack3.groupbyField ? [stack3.groupbyField] : [], ...stack3.stackBy.map((s) => s.fieldDef.field)] : void 0;
  if (isSortField(sort2)) {
    const isStackedMeasure = stack3 && !contains2(stackDimensions, sort2.field);
    return normalizeSortField(sort2, isStackedMeasure);
  } else if (isSortByEncoding(sort2)) {
    const {encoding, order} = sort2;
    const fieldDefToSortBy = model.fieldDef(encoding);
    const {aggregate, field: field4} = fieldDefToSortBy;
    const isStackedMeasure = stack3 && !contains2(stackDimensions, field4);
    if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {
      return normalizeSortField({
        field: vgField(fieldDefToSortBy),
        order
      }, isStackedMeasure);
    } else if (isAggregateOp(aggregate) || !aggregate) {
      return normalizeSortField({
        op: aggregate,
        field: field4,
        order
      }, isStackedMeasure);
    }
  } else if (sort2 === "descending") {
    return {
      op: "min",
      field: model.vgField(channel),
      order: "descending"
    };
  } else if (contains2(["ascending", void 0], sort2)) {
    return true;
  }
  return void 0;
}
function canUseUnaggregatedDomain(fieldDef, scaleType2) {
  const {aggregate, type: type2} = fieldDef;
  if (!aggregate) {
    return {
      valid: false,
      reason: message_exports.unaggregateDomainHasNoEffectForRawField(fieldDef)
    };
  }
  if (isString_default(aggregate) && !SHARED_DOMAIN_OP_INDEX[aggregate]) {
    return {
      valid: false,
      reason: message_exports.unaggregateDomainWithNonSharedDomainOp(aggregate)
    };
  }
  if (type2 === "quantitative") {
    if (scaleType2 === "log") {
      return {
        valid: false,
        reason: message_exports.unaggregatedDomainWithLogScale(fieldDef)
      };
    }
  }
  return {valid: true};
}
function domainsTieBreaker(v1, v2, property2, propertyOf) {
  if (v1.explicit && v2.explicit) {
    warn3(message_exports.mergeConflictingDomainProperty(property2, propertyOf, v1.value, v2.value));
  }
  return {explicit: v1.explicit, value: [...v1.value, ...v2.value]};
}
function mergeDomains(domains) {
  const uniqueDomains = unique(domains.map((domain4) => {
    if (isDataRefDomain(domain4)) {
      const {sort: _s} = domain4, domainWithoutSort = __rest(domain4, ["sort"]);
      return domainWithoutSort;
    }
    return domain4;
  }), hash);
  const sorts = unique(domains.map((d) => {
    if (isDataRefDomain(d)) {
      const s = d.sort;
      if (s !== void 0 && !isBoolean3(s)) {
        if ("op" in s && s.op === "count") {
          delete s.field;
        }
        if (s.order === "ascending") {
          delete s.order;
        }
      }
      return s;
    }
    return void 0;
  }).filter((s) => s !== void 0), hash);
  if (uniqueDomains.length === 0) {
    return void 0;
  } else if (uniqueDomains.length === 1) {
    const domain4 = domains[0];
    if (isDataRefDomain(domain4) && sorts.length > 0) {
      let sort3 = sorts[0];
      if (sorts.length > 1) {
        warn3(message_exports.MORE_THAN_ONE_SORT);
        sort3 = true;
      } else {
        if (isObject_default(sort3) && "field" in sort3) {
          const sortField = sort3.field;
          if (domain4.field === sortField) {
            sort3 = sort3.order ? {order: sort3.order} : true;
          }
        }
      }
      return Object.assign(Object.assign({}, domain4), {sort: sort3});
    }
    return domain4;
  }
  const unionDomainSorts = unique(sorts.map((s) => {
    if (isBoolean3(s) || !("op" in s) || s.op in MULTIDOMAIN_SORT_OP_INDEX) {
      return s;
    }
    warn3(message_exports.domainSortDropped(s));
    return true;
  }), hash);
  let sort2;
  if (unionDomainSorts.length === 1) {
    sort2 = unionDomainSorts[0];
  } else if (unionDomainSorts.length > 1) {
    warn3(message_exports.MORE_THAN_ONE_SORT);
    sort2 = true;
  }
  const allData = unique(domains.map((d) => {
    if (isDataRefDomain(d)) {
      return d.data;
    }
    return null;
  }), (x5) => x5);
  if (allData.length === 1 && allData[0] !== null) {
    const domain4 = Object.assign({data: allData[0], fields: uniqueDomains.map((d) => d.field)}, sort2 ? {sort: sort2} : {});
    return domain4;
  }
  return Object.assign({fields: uniqueDomains}, sort2 ? {sort: sort2} : {});
}
function getFieldFromDomain(domain4) {
  if (isDataRefDomain(domain4) && isString_default(domain4.field)) {
    return domain4.field;
  } else if (isDataRefUnionedDomain(domain4)) {
    let field4;
    for (const nonUnionDomain of domain4.fields) {
      if (isDataRefDomain(nonUnionDomain) && isString_default(nonUnionDomain.field)) {
        if (!field4) {
          field4 = nonUnionDomain.field;
        } else if (field4 !== nonUnionDomain.field) {
          warn3(message_exports.FACETED_INDEPENDENT_DIFFERENT_SOURCES);
          return field4;
        }
      }
    }
    warn3(message_exports.FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES);
    return field4;
  } else if (isFieldRefUnionDomain(domain4)) {
    warn3(message_exports.FACETED_INDEPENDENT_SAME_SOURCE);
    const field4 = domain4.fields[0];
    return isString_default(field4) ? field4 : void 0;
  }
  return void 0;
}
function assembleDomain(model, channel) {
  const scaleComponent = model.component.scales[channel];
  const domains = scaleComponent.get("domains").map((domain4) => {
    if (isDataRefDomain(domain4)) {
      domain4.data = model.lookupDataSource(domain4.data);
    }
    return domain4;
  });
  return mergeDomains(domains);
}

// node_modules/vega-lite/build/src/compile/scale/assemble.js
function assembleScales(model) {
  if (isLayerModel(model) || isConcatModel(model)) {
    return model.children.reduce((scales2, child) => {
      return scales2.concat(assembleScales(child));
    }, assembleScalesForModel(model));
  } else {
    return assembleScalesForModel(model);
  }
}
function assembleScalesForModel(model) {
  return keys3(model.component.scales).reduce((scales2, channel) => {
    const scaleComponent = model.component.scales[channel];
    if (scaleComponent.merged) {
      return scales2;
    }
    const scale7 = scaleComponent.combine();
    const {name: name4, type: type2, selectionExtent, domains: _d, range: _r, reverse: reverse4} = scale7, otherScaleProps = __rest(scale7, ["name", "type", "selectionExtent", "domains", "range", "reverse"]);
    const range5 = assembleScaleRange(scale7.range, name4, channel);
    let domainRaw;
    if (selectionExtent) {
      domainRaw = assembleSelectionScaleDomain(model, selectionExtent);
    }
    const domain4 = assembleDomain(model, channel);
    scales2.push(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
      name: name4,
      type: type2
    }, domain4 ? {domain: domain4} : {}), domainRaw ? {domainRaw} : {}), {range: range5}), reverse4 !== void 0 ? {reverse: reverse4} : {}), otherScaleProps));
    return scales2;
  }, []);
}
function assembleScaleRange(scaleRange, scaleName, channel) {
  if (isXorY(channel)) {
    if (isVgRangeStep(scaleRange)) {
      return {
        step: {signal: scaleName + "_step"}
      };
    }
  }
  return scaleRange;
}

// node_modules/vega-lite/build/src/compile/scale/component.js
var ScaleComponent = class extends Split {
  constructor(name4, typeWithExplicit) {
    super({}, {name: name4});
    this.merged = false;
    this.setWithExplicit("type", typeWithExplicit);
  }
  domainDefinitelyIncludesZero() {
    if (this.get("zero") !== false) {
      return true;
    }
    return some(this.get("domains"), (d) => isArray_default(d) && d.length === 2 && d[0] <= 0 && d[1] >= 0);
  }
};

// node_modules/vega-lite/build/src/compile/scale/range.js
var RANGE_PROPERTIES = ["range", "scheme"];
function getSizeChannel2(channel) {
  return channel === "x" ? "width" : channel === "y" ? "height" : void 0;
}
function parseUnitScaleRange(model) {
  const localScaleComponents = model.component.scales;
  for (const channel of SCALE_CHANNELS) {
    const localScaleCmpt = localScaleComponents[channel];
    if (!localScaleCmpt) {
      continue;
    }
    const rangeWithExplicit = parseRangeForChannel(channel, model);
    localScaleCmpt.setWithExplicit("range", rangeWithExplicit);
  }
}
function getBinStepSignal(model, channel) {
  const fieldDef = model.fieldDef(channel);
  if (fieldDef && fieldDef.bin && isBinning(fieldDef.bin)) {
    const binSignal = getBinSignalName(model, fieldDef.field, fieldDef.bin);
    const sizeType = getSizeChannel2(channel);
    const sizeSignal = model.getName(sizeType);
    return new SignalRefWrapper(() => {
      const updatedName = model.getSignalName(binSignal);
      const binCount = `(${updatedName}.stop - ${updatedName}.start) / ${updatedName}.step`;
      return `${model.getSignalName(sizeSignal)} / (${binCount})`;
    });
  }
  return void 0;
}
function parseRangeForChannel(channel, model) {
  const specifiedScale = model.specifiedScales[channel];
  const {size} = model;
  const mergedScaleCmpt = model.getScaleComponent(channel);
  const scaleType2 = mergedScaleCmpt.get("type");
  for (const property2 of RANGE_PROPERTIES) {
    if (specifiedScale[property2] !== void 0) {
      const supportedByScaleType = scaleTypeSupportProperty(scaleType2, property2);
      const channelIncompatability = channelScalePropertyIncompatability(channel, property2);
      if (!supportedByScaleType) {
        warn3(message_exports.scalePropertyNotWorkWithScaleType(scaleType2, property2, channel));
      } else if (channelIncompatability) {
        warn3(channelIncompatability);
      } else {
        switch (property2) {
          case "range":
            if (isArray_default(specifiedScale.range) && isXorY(channel)) {
              return makeExplicit(specifiedScale.range.map((v) => {
                if (v === "width" || v === "height") {
                  const sizeSignal = model.getName(v);
                  const getSignalName = model.getSignalName.bind(model);
                  return SignalRefWrapper.fromName(getSignalName, sizeSignal);
                }
                return v;
              }));
            }
            return makeExplicit(specifiedScale.range);
          case "scheme":
            return makeExplicit(parseScheme(specifiedScale[property2]));
        }
      }
    }
  }
  if (channel === X3 || channel === Y3) {
    const sizeChannel = channel === X3 ? "width" : "height";
    const sizeValue = size[sizeChannel];
    if (isStep(sizeValue)) {
      if (hasDiscreteDomain(scaleType2)) {
        return makeExplicit({step: sizeValue.step});
      } else {
        warn3(message_exports.stepDropped(sizeChannel));
      }
    }
  }
  return makeImplicit(defaultRange(channel, model));
}
function parseScheme(scheme2) {
  if (isExtendedScheme(scheme2)) {
    return Object.assign({scheme: scheme2.name}, omit(scheme2, ["name"]));
  }
  return {scheme: scheme2};
}
function defaultRange(channel, model) {
  const {size, config, mark: mark2, encoding} = model;
  const getSignalName = model.getSignalName.bind(model);
  const {type: type2} = getFieldOrDatumDef(encoding[channel]);
  const mergedScaleCmpt = model.getScaleComponent(channel);
  const scaleType2 = mergedScaleCmpt.get("type");
  const {domain: domain4, domainMid} = model.specifiedScales[channel];
  switch (channel) {
    case X3:
    case Y3: {
      if (contains2(["point", "band"], scaleType2)) {
        if (channel === X3 && !size.width) {
          const w3 = getViewConfigDiscreteSize(config.view, "width");
          if (isStep(w3)) {
            return w3;
          }
        } else if (channel === Y3 && !size.height) {
          const h3 = getViewConfigDiscreteSize(config.view, "height");
          if (isStep(h3)) {
            return h3;
          }
        }
      }
      const sizeType = getSizeChannel2(channel);
      const sizeSignal = model.getName(sizeType);
      if (channel === Y3 && hasContinuousDomain(scaleType2)) {
        return [SignalRefWrapper.fromName(getSignalName, sizeSignal), 0];
      } else {
        return [0, SignalRefWrapper.fromName(getSignalName, sizeSignal)];
      }
    }
    case SIZE2: {
      const zero7 = model.component.scales[channel].get("zero");
      const rangeMin = sizeRangeMin(mark2, zero7, config);
      const rangeMax = sizeRangeMax(mark2, size, model, config);
      if (isContinuousToDiscrete(scaleType2)) {
        return interpolateRange2(rangeMin, rangeMax, defaultContinuousToDiscreteCount(scaleType2, config, domain4, channel));
      } else {
        return [rangeMin, rangeMax];
      }
    }
    case THETA:
      return [0, Math.PI * 2];
    case ANGLE:
      return [0, 360];
    case RADIUS: {
      return [
        0,
        new SignalRefWrapper(() => {
          const w3 = model.getSignalName("width");
          const h3 = model.getSignalName("height");
          return `min(${w3},${h3})/2`;
        })
      ];
    }
    case STROKEWIDTH:
      return [config.scale.minStrokeWidth, config.scale.maxStrokeWidth];
    case STROKEDASH:
      return [
        [1, 0],
        [4, 2],
        [2, 1],
        [1, 1],
        [1, 2, 4, 2]
      ];
    case SHAPE:
      return "symbol";
    case COLOR:
    case FILL:
    case STROKE:
      if (scaleType2 === "ordinal") {
        return type2 === "nominal" ? "category" : "ordinal";
      } else {
        if (domainMid !== void 0) {
          return "diverging";
        } else {
          return mark2 === "rect" || mark2 === "geoshape" ? "heatmap" : "ramp";
        }
      }
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
      return [config.scale.minOpacity, config.scale.maxOpacity];
  }
  throw new Error(`Scale range undefined for channel ${channel}`);
}
function defaultContinuousToDiscreteCount(scaleType2, config, domain4, channel) {
  switch (scaleType2) {
    case "quantile":
      return config.scale.quantileCount;
    case "quantize":
      return config.scale.quantizeCount;
    case "threshold":
      if (domain4 !== void 0 && isArray_default(domain4)) {
        return domain4.length + 1;
      } else {
        warn3(message_exports.domainRequiredForThresholdScale(channel));
        return 3;
      }
  }
}
function interpolateRange2(rangeMin, rangeMax, cardinality) {
  const f = () => {
    const rMax = signalOrStringValue(rangeMax);
    const rMin = signalOrStringValue(rangeMin);
    const step = `(${rMax} - ${rMin}) / (${cardinality} - 1)`;
    return `sequence(${rMin}, ${rMax} + ${step}, ${step})`;
  };
  if (isSignalRef(rangeMax)) {
    return new SignalRefWrapper(f);
  } else {
    return {signal: f()};
  }
}
function sizeRangeMin(mark2, zero7, config) {
  if (zero7) {
    if (isSignalRef(zero7)) {
      return {signal: `${zero7.signal} ? 0 : ${sizeRangeMin(mark2, false, config)}`};
    } else {
      return 0;
    }
  }
  switch (mark2) {
    case "bar":
    case "tick":
      return config.scale.minBandSize;
    case "line":
    case "trail":
    case "rule":
      return config.scale.minStrokeWidth;
    case "text":
      return config.scale.minFontSize;
    case "point":
    case "square":
    case "circle":
      return config.scale.minSize;
  }
  throw new Error(message_exports.incompatibleChannel("size", mark2));
}
var MAX_SIZE_RANGE_STEP_RATIO = 0.95;
function sizeRangeMax(mark2, size, model, config) {
  const xyStepSignals = {
    x: getBinStepSignal(model, "x"),
    y: getBinStepSignal(model, "y")
  };
  switch (mark2) {
    case "bar":
    case "tick": {
      if (config.scale.maxBandSize !== void 0) {
        return config.scale.maxBandSize;
      }
      const min4 = minXYStep(size, xyStepSignals, config.view);
      if (isNumber_default(min4)) {
        return min4 - 1;
      } else {
        return new SignalRefWrapper(() => `${min4.signal} - 1`);
      }
    }
    case "line":
    case "trail":
    case "rule":
      return config.scale.maxStrokeWidth;
    case "text":
      return config.scale.maxFontSize;
    case "point":
    case "square":
    case "circle": {
      if (config.scale.maxSize) {
        return config.scale.maxSize;
      }
      const pointStep = minXYStep(size, xyStepSignals, config.view);
      if (isNumber_default(pointStep)) {
        return Math.pow(MAX_SIZE_RANGE_STEP_RATIO * pointStep, 2);
      } else {
        return new SignalRefWrapper(() => `pow(${MAX_SIZE_RANGE_STEP_RATIO} * ${pointStep.signal}, 2)`);
      }
    }
  }
  throw new Error(message_exports.incompatibleChannel("size", mark2));
}
function minXYStep(size, xyStepSignals, viewConfig) {
  const widthStep = isStep(size.width) ? size.width.step : getViewConfigDiscreteStep(viewConfig, "width");
  const heightStep = isStep(size.height) ? size.height.step : getViewConfigDiscreteStep(viewConfig, "height");
  if (xyStepSignals.x || xyStepSignals.y) {
    return new SignalRefWrapper(() => {
      const exprs = [
        xyStepSignals.x ? xyStepSignals.x.signal : widthStep,
        xyStepSignals.y ? xyStepSignals.y.signal : heightStep
      ];
      return `min(${exprs.join(", ")})`;
    });
  }
  return Math.min(widthStep, heightStep);
}

// node_modules/vega-lite/build/src/compile/scale/properties.js
function parseScaleProperty(model, property2) {
  if (isUnitModel(model)) {
    parseUnitScaleProperty(model, property2);
  } else {
    parseNonUnitScaleProperty(model, property2);
  }
}
function parseUnitScaleProperty(model, property2) {
  const localScaleComponents = model.component.scales;
  const {config, encoding, markDef, specifiedScales} = model;
  for (const channel of keys3(localScaleComponents)) {
    const specifiedScale = specifiedScales[channel];
    const localScaleCmpt = localScaleComponents[channel];
    const mergedScaleCmpt = model.getScaleComponent(channel);
    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
    const specifiedValue = specifiedScale[property2];
    const scaleType2 = mergedScaleCmpt.get("type");
    const scalePadding = mergedScaleCmpt.get("padding");
    const scalePaddingInner = mergedScaleCmpt.get("paddingInner");
    const supportedByScaleType = scaleTypeSupportProperty(scaleType2, property2);
    const channelIncompatability = channelScalePropertyIncompatability(channel, property2);
    if (specifiedValue !== void 0) {
      if (!supportedByScaleType) {
        warn3(message_exports.scalePropertyNotWorkWithScaleType(scaleType2, property2, channel));
      } else if (channelIncompatability) {
        warn3(channelIncompatability);
      }
    }
    if (supportedByScaleType && channelIncompatability === void 0) {
      if (specifiedValue !== void 0) {
        localScaleCmpt.copyKeyFromObject(property2, specifiedScale);
      } else {
        const value3 = property2 in scaleRules ? scaleRules[property2]({
          model,
          channel,
          fieldOrDatumDef,
          scaleType: scaleType2,
          scalePadding,
          scalePaddingInner,
          domain: specifiedScale.domain,
          markDef,
          config
        }) : config.scale[property2];
        if (value3 !== void 0) {
          localScaleCmpt.set(property2, value3, false);
        }
      }
    }
  }
}
var scaleRules = {
  bins: ({model, fieldOrDatumDef}) => isFieldDef(fieldOrDatumDef) ? bins(model, fieldOrDatumDef) : void 0,
  interpolate: ({channel, fieldOrDatumDef}) => interpolate2(channel, fieldOrDatumDef.type),
  nice: ({scaleType: scaleType2, channel, fieldOrDatumDef}) => nice2(scaleType2, channel, fieldOrDatumDef),
  padding: ({channel, scaleType: scaleType2, fieldOrDatumDef, markDef, config}) => padding2(channel, scaleType2, config.scale, fieldOrDatumDef, markDef, config.bar),
  paddingInner: ({scalePadding, channel, markDef, config}) => paddingInner(scalePadding, channel, markDef.type, config.scale),
  paddingOuter: ({scalePadding, channel, scaleType: scaleType2, markDef, scalePaddingInner, config}) => paddingOuter(scalePadding, channel, scaleType2, markDef.type, scalePaddingInner, config.scale),
  reverse: ({fieldOrDatumDef, scaleType: scaleType2, channel, config}) => {
    const sort2 = isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : void 0;
    return reverse3(scaleType2, sort2, channel, config.scale);
  },
  zero: ({channel, fieldOrDatumDef, domain: domain4, markDef, scaleType: scaleType2}) => zero6(channel, fieldOrDatumDef, domain4, markDef, scaleType2)
};
function parseScaleRange2(model) {
  if (isUnitModel(model)) {
    parseUnitScaleRange(model);
  } else {
    parseNonUnitScaleProperty(model, "range");
  }
}
function parseNonUnitScaleProperty(model, property2) {
  const localScaleComponents = model.component.scales;
  for (const child of model.children) {
    if (property2 === "range") {
      parseScaleRange2(child);
    } else {
      parseScaleProperty(child, property2);
    }
  }
  for (const channel of keys3(localScaleComponents)) {
    let valueWithExplicit;
    for (const child of model.children) {
      const childComponent = child.component.scales[channel];
      if (childComponent) {
        const childValueWithExplicit = childComponent.getWithExplicit(property2);
        valueWithExplicit = mergeValuesWithExplicit(valueWithExplicit, childValueWithExplicit, property2, "scale", tieBreakByComparing((v1, v2) => {
          switch (property2) {
            case "range":
              if (v1.step && v2.step) {
                return v1.step - v2.step;
              }
              return 0;
          }
          return 0;
        }));
      }
    }
    localScaleComponents[channel].setWithExplicit(property2, valueWithExplicit);
  }
}
function bins(model, fieldDef) {
  const bin4 = fieldDef.bin;
  if (isBinning(bin4)) {
    const binSignal = getBinSignalName(model, fieldDef.field, bin4);
    return new SignalRefWrapper(() => {
      return model.getSignalName(binSignal);
    });
  } else if (isBinned(bin4) && isBinParams(bin4) && bin4.step !== void 0) {
    return {
      step: bin4.step
    };
  }
  return void 0;
}
function interpolate2(channel, type2) {
  if (contains2([COLOR, FILL, STROKE], channel) && type2 !== "nominal") {
    return "hcl";
  }
  return void 0;
}
function nice2(scaleType2, channel, fieldOrDatumDef) {
  var _a2;
  if (((_a2 = getFieldDef(fieldOrDatumDef)) === null || _a2 === void 0 ? void 0 : _a2.bin) || contains2([ScaleType.TIME, ScaleType.UTC], scaleType2)) {
    return void 0;
  }
  return channel in POSITION_SCALE_CHANNEL_INDEX ? true : void 0;
}
function padding2(channel, scaleType2, scaleConfig, fieldOrDatumDef, markDef, barConfig) {
  if (channel in POSITION_SCALE_CHANNEL_INDEX) {
    if (isContinuousToContinuous(scaleType2)) {
      if (scaleConfig.continuousPadding !== void 0) {
        return scaleConfig.continuousPadding;
      }
      const {type: type2, orient: orient3} = markDef;
      if (type2 === "bar" && !(isFieldDef(fieldOrDatumDef) && (fieldOrDatumDef.bin || fieldOrDatumDef.timeUnit))) {
        if (orient3 === "vertical" && channel === "x" || orient3 === "horizontal" && channel === "y") {
          return barConfig.continuousBandSize;
        }
      }
    }
    if (scaleType2 === ScaleType.POINT) {
      return scaleConfig.pointPadding;
    }
  }
  return void 0;
}
function paddingInner(paddingValue, channel, mark2, scaleConfig) {
  if (paddingValue !== void 0) {
    return void 0;
  }
  if (channel in POSITION_SCALE_CHANNEL_INDEX) {
    const {bandPaddingInner, barBandPaddingInner, rectBandPaddingInner} = scaleConfig;
    return getFirstDefined(bandPaddingInner, mark2 === "bar" ? barBandPaddingInner : rectBandPaddingInner);
  }
  return void 0;
}
function paddingOuter(paddingValue, channel, scaleType2, mark2, paddingInnerValue, scaleConfig) {
  if (paddingValue !== void 0) {
    return void 0;
  }
  if (channel in POSITION_SCALE_CHANNEL_INDEX) {
    if (scaleType2 === ScaleType.BAND) {
      const {bandPaddingOuter} = scaleConfig;
      return getFirstDefined(bandPaddingOuter, isSignalRef(paddingInnerValue) ? {signal: `${paddingInnerValue.signal}/2`} : paddingInnerValue / 2);
    }
  }
  return void 0;
}
function reverse3(scaleType2, sort2, channel, scaleConfig) {
  if (channel === "x" && scaleConfig.xReverse !== void 0) {
    if (hasContinuousDomain(scaleType2) && sort2 === "descending") {
      if (isSignalRef(scaleConfig.xReverse)) {
        return {signal: `!${scaleConfig.xReverse.signal}`};
      } else {
        return !scaleConfig.xReverse;
      }
    }
    return scaleConfig.xReverse;
  }
  if (hasContinuousDomain(scaleType2) && sort2 === "descending") {
    return true;
  }
  return void 0;
}
function zero6(channel, fieldDef, specifiedDomain, markDef, scaleType2) {
  const hasCustomDomain = !!specifiedDomain && specifiedDomain !== "unaggregated";
  if (hasCustomDomain) {
    if (hasContinuousDomain(scaleType2)) {
      if (isArray_default(specifiedDomain)) {
        const first = specifiedDomain[0];
        const last = specifiedDomain[specifiedDomain.length - 1];
        if (first <= 0 && last >= 0) {
          return true;
        }
      }
      return false;
    }
  }
  if (channel === "size" && fieldDef.type === "quantitative" && !isContinuousToDiscrete(scaleType2)) {
    return true;
  }
  if (!(isFieldDef(fieldDef) && fieldDef.bin) && contains2([...POSITION_SCALE_CHANNELS, ...POLAR_POSITION_SCALE_CHANNELS], channel)) {
    const {orient: orient3, type: type2} = markDef;
    if (contains2(["bar", "area", "line", "trail"], type2)) {
      if (orient3 === "horizontal" && channel === "y" || orient3 === "vertical" && channel === "x") {
        return false;
      }
    }
    return true;
  }
  return false;
}

// node_modules/vega-lite/build/src/compile/scale/type.js
function scaleType(specifiedScale, channel, fieldDef, mark2) {
  const defaultScaleType = defaultType3(channel, fieldDef, mark2);
  const {type: type2} = specifiedScale;
  if (!isScaleChannel(channel)) {
    return null;
  }
  if (type2 !== void 0) {
    if (!channelSupportScaleType(channel, type2)) {
      warn3(message_exports.scaleTypeNotWorkWithChannel(channel, type2, defaultScaleType));
      return defaultScaleType;
    }
    if (isFieldDef(fieldDef) && !scaleTypeSupportDataType(type2, fieldDef.type)) {
      warn3(message_exports.scaleTypeNotWorkWithFieldDef(type2, defaultScaleType));
      return defaultScaleType;
    }
    return type2;
  }
  return defaultScaleType;
}
function defaultType3(channel, fieldDef, mark2) {
  var _a2;
  switch (fieldDef.type) {
    case "nominal":
    case "ordinal":
      if (isColorChannel(channel) || rangeType(channel) === "discrete") {
        if (channel === "shape" && fieldDef.type === "ordinal") {
          warn3(message_exports.discreteChannelCannotEncode(channel, "ordinal"));
        }
        return "ordinal";
      }
      if (channel in POSITION_SCALE_CHANNEL_INDEX) {
        if (contains2(["rect", "bar", "image", "rule"], mark2)) {
          return "band";
        }
      } else if (mark2 === "arc" && channel in POLAR_POSITION_SCALE_CHANNEL_INDEX) {
        return "band";
      }
      if (fieldDef.band !== void 0 || isPositionFieldOrDatumDef(fieldDef) && ((_a2 = fieldDef.axis) === null || _a2 === void 0 ? void 0 : _a2.tickBand)) {
        return "band";
      }
      return "point";
    case "temporal":
      if (isColorChannel(channel)) {
        return "time";
      } else if (rangeType(channel) === "discrete") {
        warn3(message_exports.discreteChannelCannotEncode(channel, "temporal"));
        return "ordinal";
      } else if (isFieldDef(fieldDef) && fieldDef.timeUnit && normalizeTimeUnit(fieldDef.timeUnit).utc) {
        return "utc";
      }
      return "time";
    case "quantitative":
      if (isColorChannel(channel)) {
        if (isFieldDef(fieldDef) && isBinning(fieldDef.bin)) {
          return "bin-ordinal";
        }
        return "linear";
      } else if (rangeType(channel) === "discrete") {
        warn3(message_exports.discreteChannelCannotEncode(channel, "quantitative"));
        return "ordinal";
      }
      return "linear";
    case "geojson":
      return void 0;
  }
  throw new Error(message_exports.invalidFieldType(fieldDef.type));
}

// node_modules/vega-lite/build/src/compile/scale/parse.js
function parseScales(model, {ignoreRange} = {}) {
  parseScaleCore(model);
  parseScaleDomain2(model);
  for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {
    parseScaleProperty(model, prop);
  }
  if (!ignoreRange) {
    parseScaleRange2(model);
  }
}
function parseScaleCore(model) {
  if (isUnitModel(model)) {
    model.component.scales = parseUnitScaleCore(model);
  } else {
    model.component.scales = parseNonUnitScaleCore(model);
  }
}
function parseUnitScaleCore(model) {
  const {encoding, mark: mark2} = model;
  return SCALE_CHANNELS.reduce((scaleComponents, channel) => {
    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
    if (fieldOrDatumDef && mark2 === GEOSHAPE && channel === SHAPE && fieldOrDatumDef.type === GEOJSON) {
      return scaleComponents;
    }
    let specifiedScale = fieldOrDatumDef && fieldOrDatumDef["scale"];
    if (fieldOrDatumDef && specifiedScale !== null && specifiedScale !== false) {
      specifiedScale = specifiedScale !== null && specifiedScale !== void 0 ? specifiedScale : {};
      const sType = scaleType(specifiedScale, channel, fieldOrDatumDef, mark2);
      scaleComponents[channel] = new ScaleComponent(model.scaleName(channel + "", true), {
        value: sType,
        explicit: specifiedScale.type === sType
      });
    }
    return scaleComponents;
  }, {});
}
var scaleTypeTieBreaker = tieBreakByComparing((st1, st2) => scaleTypePrecedence(st1) - scaleTypePrecedence(st2));
function parseNonUnitScaleCore(model) {
  var _a2;
  const scaleComponents = model.component.scales = {};
  const scaleTypeWithExplicitIndex = {};
  const resolve2 = model.component.resolve;
  for (const child of model.children) {
    parseScaleCore(child);
    for (const channel of keys3(child.component.scales)) {
      resolve2.scale[channel] = (_a2 = resolve2.scale[channel]) !== null && _a2 !== void 0 ? _a2 : defaultScaleResolve(channel, model);
      if (resolve2.scale[channel] === "shared") {
        const explicitScaleType = scaleTypeWithExplicitIndex[channel];
        const childScaleType = child.component.scales[channel].getWithExplicit("type");
        if (explicitScaleType) {
          if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {
            scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit(explicitScaleType, childScaleType, "type", "scale", scaleTypeTieBreaker);
          } else {
            resolve2.scale[channel] = "independent";
            delete scaleTypeWithExplicitIndex[channel];
          }
        } else {
          scaleTypeWithExplicitIndex[channel] = childScaleType;
        }
      }
    }
  }
  for (const channel of keys3(scaleTypeWithExplicitIndex)) {
    const name4 = model.scaleName(channel, true);
    const typeWithExplicit = scaleTypeWithExplicitIndex[channel];
    scaleComponents[channel] = new ScaleComponent(name4, typeWithExplicit);
    for (const child of model.children) {
      const childScale = child.component.scales[channel];
      if (childScale) {
        child.renameScale(childScale.get("name"), name4);
        childScale.merged = true;
      }
    }
  }
  return scaleComponents;
}

// node_modules/vega-lite/build/src/compile/model.js
var NameMap = class {
  constructor() {
    this.nameMap = {};
  }
  rename(oldName, newName) {
    this.nameMap[oldName] = newName;
  }
  has(name4) {
    return this.nameMap[name4] !== void 0;
  }
  get(name4) {
    while (this.nameMap[name4] && name4 !== this.nameMap[name4]) {
      name4 = this.nameMap[name4];
    }
    return name4;
  }
};
function isUnitModel(model) {
  return (model === null || model === void 0 ? void 0 : model.type) === "unit";
}
function isFacetModel(model) {
  return (model === null || model === void 0 ? void 0 : model.type) === "facet";
}
function isConcatModel(model) {
  return (model === null || model === void 0 ? void 0 : model.type) === "concat";
}
function isLayerModel(model) {
  return (model === null || model === void 0 ? void 0 : model.type) === "layer";
}
var Model = class {
  constructor(spec, type2, parent, parentGivenName, config, resolve2, view) {
    var _a2, _b;
    this.type = type2;
    this.parent = parent;
    this.config = config;
    this.view = view;
    this.children = [];
    this.correctDataNames = (mark2) => {
      if (mark2.from && mark2.from.data) {
        mark2.from.data = this.lookupDataSource(mark2.from.data);
      }
      if (mark2.from && mark2.from.facet && mark2.from.facet.data) {
        mark2.from.facet.data = this.lookupDataSource(mark2.from.facet.data);
      }
      return mark2;
    };
    this.parent = parent;
    this.config = config;
    this.name = (_a2 = spec.name) !== null && _a2 !== void 0 ? _a2 : parentGivenName;
    this.title = isText(spec.title) ? {text: spec.title} : spec.title;
    this.scaleNameMap = parent ? parent.scaleNameMap : new NameMap();
    this.projectionNameMap = parent ? parent.projectionNameMap : new NameMap();
    this.signalNameMap = parent ? parent.signalNameMap : new NameMap();
    this.data = spec.data;
    this.description = spec.description;
    this.transforms = normalizeTransform((_b = spec.transform) !== null && _b !== void 0 ? _b : []);
    this.layout = type2 === "layer" || type2 === "unit" ? {} : extractCompositionLayout(spec, type2, config);
    this.component = {
      data: {
        sources: parent ? parent.component.data.sources : [],
        outputNodes: parent ? parent.component.data.outputNodes : {},
        outputNodeRefCounts: parent ? parent.component.data.outputNodeRefCounts : {},
        isFaceted: isFacetSpec(spec) || parent && parent.component.data.isFaceted && spec.data === void 0
      },
      layoutSize: new Split(),
      layoutHeaders: {row: {}, column: {}, facet: {}},
      mark: null,
      resolve: Object.assign({scale: {}, axis: {}, legend: {}}, resolve2 ? duplicate(resolve2) : {}),
      selection: null,
      scales: null,
      projection: null,
      axes: {},
      legends: {}
    };
  }
  get width() {
    return this.getSizeSignalRef("width");
  }
  get height() {
    return this.getSizeSignalRef("height");
  }
  parse() {
    this.parseScale();
    this.parseLayoutSize();
    this.renameTopLevelLayoutSizeSignal();
    this.parseSelections();
    this.parseProjection();
    this.parseData();
    this.parseAxesAndHeaders();
    this.parseLegends();
    this.parseMarkGroup();
  }
  parseScale() {
    parseScales(this);
  }
  parseProjection() {
    parseProjection2(this);
  }
  renameTopLevelLayoutSizeSignal() {
    if (this.getName("width") !== "width") {
      this.renameSignal(this.getName("width"), "width");
    }
    if (this.getName("height") !== "height") {
      this.renameSignal(this.getName("height"), "height");
    }
  }
  parseLegends() {
    parseLegend2(this);
  }
  assembleGroupStyle() {
    var _a2, _b;
    if (this.type === "unit" || this.type === "layer") {
      return (_b = (_a2 = this.view) === null || _a2 === void 0 ? void 0 : _a2.style) !== null && _b !== void 0 ? _b : "cell";
    }
    return void 0;
  }
  assembleEncodeFromView(view) {
    const {style: _} = view, baseView = __rest(view, ["style"]);
    const e = {};
    for (const property2 of keys3(baseView)) {
      const value3 = baseView[property2];
      if (value3 !== void 0) {
        e[property2] = signalOrValueRef(value3);
      }
    }
    return e;
  }
  assembleGroupEncodeEntry(isTopLevel) {
    let encodeEntry2 = {};
    if (this.view) {
      encodeEntry2 = this.assembleEncodeFromView(this.view);
    }
    if (!isTopLevel) {
      if (this.description) {
        encodeEntry2["description"] = signalOrValueRef(this.description);
      }
      if (this.type === "unit" || this.type === "layer") {
        return Object.assign({width: this.getSizeSignalRef("width"), height: this.getSizeSignalRef("height")}, encodeEntry2 !== null && encodeEntry2 !== void 0 ? encodeEntry2 : {});
      }
    }
    return isEmpty(encodeEntry2) ? void 0 : encodeEntry2;
  }
  assembleLayout() {
    if (!this.layout) {
      return void 0;
    }
    const _a2 = this.layout, {spacing} = _a2, layout = __rest(_a2, ["spacing"]);
    const {component, config} = this;
    const titleBand = assembleLayoutTitleBand(component.layoutHeaders, config);
    return Object.assign(Object.assign(Object.assign({padding: spacing}, this.assembleDefaultLayout()), layout), titleBand ? {titleBand} : {});
  }
  assembleDefaultLayout() {
    return {};
  }
  assembleHeaderMarks() {
    const {layoutHeaders: layoutHeaders2} = this.component;
    let headerMarks = [];
    for (const channel of FACET_CHANNELS) {
      if (layoutHeaders2[channel].title) {
        headerMarks.push(assembleTitleGroup(this, channel));
      }
    }
    for (const channel of HEADER_CHANNELS) {
      headerMarks = headerMarks.concat(assembleHeaderGroups(this, channel));
    }
    return headerMarks;
  }
  assembleAxes() {
    return assembleAxes(this.component.axes, this.config);
  }
  assembleLegends() {
    return assembleLegends(this);
  }
  assembleProjections() {
    return assembleProjections(this);
  }
  assembleTitle() {
    var _a2, _b, _c;
    const _d = (_a2 = this.title) !== null && _a2 !== void 0 ? _a2 : {}, {encoding} = _d, titleNoEncoding = __rest(_d, ["encoding"]);
    const title2 = Object.assign(Object.assign(Object.assign({}, extractTitleConfig(this.config.title).nonMark), titleNoEncoding), encoding ? {encode: {update: encoding}} : {});
    if (title2.text) {
      if (contains2(["unit", "layer"], this.type)) {
        if (contains2(["middle", void 0], title2.anchor)) {
          title2.frame = (_b = title2.frame) !== null && _b !== void 0 ? _b : "group";
        }
      } else {
        title2.anchor = (_c = title2.anchor) !== null && _c !== void 0 ? _c : "start";
      }
      return isEmpty(title2) ? void 0 : title2;
    }
    return void 0;
  }
  assembleGroup(signals = []) {
    const group2 = {};
    signals = signals.concat(this.assembleSignals());
    if (signals.length > 0) {
      group2.signals = signals;
    }
    const layout = this.assembleLayout();
    if (layout) {
      group2.layout = layout;
    }
    group2.marks = [].concat(this.assembleHeaderMarks(), this.assembleMarks());
    const scales2 = !this.parent || isFacetModel(this.parent) ? assembleScales(this) : [];
    if (scales2.length > 0) {
      group2.scales = scales2;
    }
    const axes = this.assembleAxes();
    if (axes.length > 0) {
      group2.axes = axes;
    }
    const legends = this.assembleLegends();
    if (legends.length > 0) {
      group2.legends = legends;
    }
    return group2;
  }
  getName(text4) {
    return varName((this.name ? this.name + "_" : "") + text4);
  }
  requestDataName(name4) {
    var _a2;
    const fullName = this.getName(name4);
    const refCounts = this.component.data.outputNodeRefCounts;
    refCounts[fullName] = ((_a2 = refCounts[fullName]) !== null && _a2 !== void 0 ? _a2 : 0) + 1;
    return fullName;
  }
  getSizeSignalRef(layoutSizeType) {
    if (isFacetModel(this.parent)) {
      const sizeType = getSizeTypeFromLayoutSizeType(layoutSizeType);
      const channel = getPositionScaleChannel(sizeType);
      const scaleComponent = this.component.scales[channel];
      if (scaleComponent && !scaleComponent.merged) {
        const type2 = scaleComponent.get("type");
        const range5 = scaleComponent.get("range");
        if (hasDiscreteDomain(type2) && isVgRangeStep(range5)) {
          const scaleName = scaleComponent.get("name");
          const domain4 = assembleDomain(this, channel);
          const field4 = getFieldFromDomain(domain4);
          if (field4) {
            const fieldRef2 = vgField({aggregate: "distinct", field: field4}, {expr: "datum"});
            return {
              signal: sizeExpr(scaleName, scaleComponent, fieldRef2)
            };
          } else {
            warn3(`Unknown field for ${channel}. Cannot calculate view size.`);
            return null;
          }
        }
      }
    }
    return {
      signal: this.signalNameMap.get(this.getName(layoutSizeType))
    };
  }
  lookupDataSource(name4) {
    const node = this.component.data.outputNodes[name4];
    if (!node) {
      return name4;
    }
    return node.getSource();
  }
  getSignalName(oldSignalName) {
    return this.signalNameMap.get(oldSignalName);
  }
  renameSignal(oldName, newName) {
    this.signalNameMap.rename(oldName, newName);
  }
  renameScale(oldName, newName) {
    this.scaleNameMap.rename(oldName, newName);
  }
  renameProjection(oldName, newName) {
    this.projectionNameMap.rename(oldName, newName);
  }
  scaleName(originalScaleName, parse6) {
    if (parse6) {
      return this.getName(originalScaleName);
    }
    if (isChannel(originalScaleName) && isScaleChannel(originalScaleName) && this.component.scales[originalScaleName] || this.scaleNameMap.has(this.getName(originalScaleName))) {
      return this.scaleNameMap.get(this.getName(originalScaleName));
    }
    return void 0;
  }
  projectionName(parse6) {
    if (parse6) {
      return this.getName("projection");
    }
    if (this.component.projection && !this.component.projection.merged || this.projectionNameMap.has(this.getName("projection"))) {
      return this.projectionNameMap.get(this.getName("projection"));
    }
    return void 0;
  }
  getScaleComponent(channel) {
    if (!this.component.scales) {
      throw new Error("getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().");
    }
    const localScaleComponent = this.component.scales[channel];
    if (localScaleComponent && !localScaleComponent.merged) {
      return localScaleComponent;
    }
    return this.parent ? this.parent.getScaleComponent(channel) : void 0;
  }
  getSelectionComponent(variableName, origName) {
    let sel = this.component.selection[variableName];
    if (!sel && this.parent) {
      sel = this.parent.getSelectionComponent(variableName, origName);
    }
    if (!sel) {
      throw new Error(message_exports.selectionNotFound(origName));
    }
    return sel;
  }
  hasAxisOrientSignalRef() {
    var _a2, _b;
    return ((_a2 = this.component.axes.x) === null || _a2 === void 0 ? void 0 : _a2.some((a2) => a2.hasOrientSignalRef())) || ((_b = this.component.axes.y) === null || _b === void 0 ? void 0 : _b.some((a2) => a2.hasOrientSignalRef()));
  }
};
var ModelWithField = class extends Model {
  vgField(channel, opt = {}) {
    const fieldDef = this.fieldDef(channel);
    if (!fieldDef) {
      return void 0;
    }
    return vgField(fieldDef, opt);
  }
  reduceFieldDef(f, init2) {
    return reduce(this.getMapping(), (acc, cd, c2) => {
      const fieldDef = getFieldDef(cd);
      if (fieldDef) {
        return f(acc, fieldDef, c2);
      }
      return acc;
    }, init2);
  }
  forEachFieldDef(f, t) {
    forEach(this.getMapping(), (cd, c2) => {
      const fieldDef = getFieldDef(cd);
      if (fieldDef) {
        f(fieldDef, c2);
      }
    }, t);
  }
};

// node_modules/vega-lite/build/src/compile/data/density.js
var DensityTransformNode = class extends DataFlowNode {
  constructor(parent, transform4) {
    var _a2, _b, _c;
    super(parent);
    this.transform = transform4;
    this.transform = duplicate(transform4);
    const specifiedAs = (_a2 = this.transform.as) !== null && _a2 !== void 0 ? _a2 : [void 0, void 0];
    this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : "value", (_c = specifiedAs[1]) !== null && _c !== void 0 ? _c : "density"];
  }
  clone() {
    return new DensityTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    var _a2;
    return new Set([this.transform.density, ...(_a2 = this.transform.groupby) !== null && _a2 !== void 0 ? _a2 : []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `DensityTransform ${hash(this.transform)}`;
  }
  assemble() {
    const _a2 = this.transform, {density} = _a2, rest = __rest(_a2, ["density"]);
    const result = Object.assign({type: "kde", field: density}, rest);
    return result;
  }
};

// node_modules/vega-lite/build/src/compile/data/filterinvalid.js
var FilterInvalidNode = class extends DataFlowNode {
  constructor(parent, filter4) {
    super(parent);
    this.filter = filter4;
  }
  clone() {
    return new FilterInvalidNode(null, Object.assign({}, this.filter));
  }
  static make(parent, model) {
    const {config, mark: mark2, markDef} = model;
    const invalid = getMarkPropOrConfig("invalid", markDef, config);
    if (invalid !== "filter") {
      return null;
    }
    const filter4 = model.reduceFieldDef((aggregator, fieldDef, channel) => {
      const scaleComponent = isScaleChannel(channel) && model.getScaleComponent(channel);
      if (scaleComponent) {
        const scaleType2 = scaleComponent.get("type");
        if (hasContinuousDomain(scaleType2) && fieldDef.aggregate !== "count" && !isPathMark(mark2)) {
          aggregator[fieldDef.field] = fieldDef;
        }
      }
      return aggregator;
    }, {});
    if (!keys3(filter4).length) {
      return null;
    }
    return new FilterInvalidNode(parent, filter4);
  }
  dependentFields() {
    return new Set(keys3(this.filter));
  }
  producedFields() {
    return new Set();
  }
  hash() {
    return `FilterInvalid ${hash(this.filter)}`;
  }
  assemble() {
    const filters2 = keys3(this.filter).reduce((vegaFilters, field4) => {
      const fieldDef = this.filter[field4];
      const ref6 = vgField(fieldDef, {expr: "datum"});
      if (fieldDef !== null) {
        if (fieldDef.type === "temporal") {
          vegaFilters.push(`(isDate(${ref6}) || (isValid(${ref6}) && isFinite(+${ref6})))`);
        } else if (fieldDef.type === "quantitative") {
          vegaFilters.push(`isValid(${ref6})`);
          vegaFilters.push(`isFinite(+${ref6})`);
        } else {
        }
      }
      return vegaFilters;
    }, []);
    return filters2.length > 0 ? {
      type: "filter",
      expr: filters2.join(" && ")
    } : null;
  }
};

// node_modules/vega-lite/build/src/compile/data/flatten.js
var FlattenTransformNode = class extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    this.transform = transform4;
    this.transform = duplicate(transform4);
    const {flatten: flatten2, as = []} = this.transform;
    this.transform.as = flatten2.map((f, i) => {
      var _a2;
      return (_a2 = as[i]) !== null && _a2 !== void 0 ? _a2 : f;
    });
  }
  clone() {
    return new FlattenTransformNode(this.parent, duplicate(this.transform));
  }
  dependentFields() {
    return new Set(this.transform.flatten);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `FlattenTransform ${hash(this.transform)}`;
  }
  assemble() {
    const {flatten: fields, as} = this.transform;
    const result = {
      type: "flatten",
      fields,
      as
    };
    return result;
  }
};

// node_modules/vega-lite/build/src/compile/data/fold.js
var FoldTransformNode = class extends DataFlowNode {
  constructor(parent, transform4) {
    var _a2, _b, _c;
    super(parent);
    this.transform = transform4;
    this.transform = duplicate(transform4);
    const specifiedAs = (_a2 = this.transform.as) !== null && _a2 !== void 0 ? _a2 : [void 0, void 0];
    this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : "key", (_c = specifiedAs[1]) !== null && _c !== void 0 ? _c : "value"];
  }
  clone() {
    return new FoldTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    return new Set(this.transform.fold);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `FoldTransform ${hash(this.transform)}`;
  }
  assemble() {
    const {fold, as} = this.transform;
    const result = {
      type: "fold",
      fields: fold,
      as
    };
    return result;
  }
};

// node_modules/vega-lite/build/src/compile/data/geojson.js
var GeoJSONNode = class extends DataFlowNode {
  constructor(parent, fields, geojson, signal) {
    super(parent);
    this.fields = fields;
    this.geojson = geojson;
    this.signal = signal;
  }
  clone() {
    return new GeoJSONNode(null, duplicate(this.fields), this.geojson, this.signal);
  }
  static parseAll(parent, model) {
    if (model.component.projection && !model.component.projection.isFit) {
      return parent;
    }
    let geoJsonCounter = 0;
    for (const coordinates of [
      [LONGITUDE, LATITUDE],
      [LONGITUDE2, LATITUDE2]
    ]) {
      const pair = coordinates.map((channel) => {
        const def2 = getFieldOrDatumDef(model.encoding[channel]);
        return isFieldDef(def2) ? def2.field : isDatumDef(def2) ? {expr: `${def2.datum}`} : isValueDef(def2) ? {expr: `${def2["value"]}`} : void 0;
      });
      if (pair[0] || pair[1]) {
        parent = new GeoJSONNode(parent, pair, null, model.getName(`geojson_${geoJsonCounter++}`));
      }
    }
    if (model.channelHasField(SHAPE)) {
      const fieldDef = model.typedFieldDef(SHAPE);
      if (fieldDef.type === GEOJSON) {
        parent = new GeoJSONNode(parent, null, fieldDef.field, model.getName(`geojson_${geoJsonCounter++}`));
      }
    }
    return parent;
  }
  dependentFields() {
    var _a2;
    const fields = ((_a2 = this.fields) !== null && _a2 !== void 0 ? _a2 : []).filter(isString_default);
    return new Set([...this.geojson ? [this.geojson] : [], ...fields]);
  }
  producedFields() {
    return new Set();
  }
  hash() {
    return `GeoJSON ${this.geojson} ${this.signal} ${hash(this.fields)}`;
  }
  assemble() {
    return Object.assign(Object.assign(Object.assign({type: "geojson"}, this.fields ? {fields: this.fields} : {}), this.geojson ? {geojson: this.geojson} : {}), {signal: this.signal});
  }
};

// node_modules/vega-lite/build/src/compile/data/geopoint.js
var GeoPointNode = class extends DataFlowNode {
  constructor(parent, projection3, fields, as) {
    super(parent);
    this.projection = projection3;
    this.fields = fields;
    this.as = as;
  }
  clone() {
    return new GeoPointNode(null, this.projection, duplicate(this.fields), duplicate(this.as));
  }
  static parseAll(parent, model) {
    if (!model.projectionName()) {
      return parent;
    }
    for (const coordinates of [
      [LONGITUDE, LATITUDE],
      [LONGITUDE2, LATITUDE2]
    ]) {
      const pair = coordinates.map((channel) => {
        const def2 = getFieldOrDatumDef(model.encoding[channel]);
        return isFieldDef(def2) ? def2.field : isDatumDef(def2) ? {expr: `${def2.datum}`} : isValueDef(def2) ? {expr: `${def2["value"]}`} : void 0;
      });
      const suffix = coordinates[0] === LONGITUDE2 ? "2" : "";
      if (pair[0] || pair[1]) {
        parent = new GeoPointNode(parent, model.projectionName(), pair, [
          model.getName("x" + suffix),
          model.getName("y" + suffix)
        ]);
      }
    }
    return parent;
  }
  dependentFields() {
    return new Set(this.fields.filter(isString_default));
  }
  producedFields() {
    return new Set(this.as);
  }
  hash() {
    return `Geopoint ${this.projection} ${hash(this.fields)} ${hash(this.as)}`;
  }
  assemble() {
    return {
      type: "geopoint",
      projection: this.projection,
      fields: this.fields,
      as: this.as
    };
  }
};

// node_modules/vega-lite/build/src/compile/data/impute.js
var ImputeNode = class extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    this.transform = transform4;
  }
  clone() {
    return new ImputeNode(null, duplicate(this.transform));
  }
  dependentFields() {
    var _a2;
    return new Set([this.transform.impute, this.transform.key, ...(_a2 = this.transform.groupby) !== null && _a2 !== void 0 ? _a2 : []]);
  }
  producedFields() {
    return new Set([this.transform.impute]);
  }
  processSequence(keyvals) {
    const {start = 0, stop: stop2, step} = keyvals;
    const result = [start, stop2, ...step ? [step] : []].join(",");
    return {signal: `sequence(${result})`};
  }
  static makeFromTransform(parent, imputeTransform) {
    return new ImputeNode(parent, imputeTransform);
  }
  static makeFromEncoding(parent, model) {
    const encoding = model.encoding;
    const xDef = encoding.x;
    const yDef = encoding.y;
    if (isFieldDef(xDef) && isFieldDef(yDef)) {
      const imputedChannel = xDef.impute ? xDef : yDef.impute ? yDef : void 0;
      if (imputedChannel === void 0) {
        return void 0;
      }
      const keyChannel = xDef.impute ? yDef : yDef.impute ? xDef : void 0;
      const {method: method2, value: value3, frame: frame2, keyvals} = imputedChannel.impute;
      const groupbyFields = pathGroupingFields(model.mark, encoding);
      return new ImputeNode(parent, Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({impute: imputedChannel.field, key: keyChannel.field}, method2 ? {method: method2} : {}), value3 !== void 0 ? {value: value3} : {}), frame2 ? {frame: frame2} : {}), keyvals !== void 0 ? {keyvals} : {}), groupbyFields.length ? {groupby: groupbyFields} : {}));
    }
    return null;
  }
  hash() {
    return `Impute ${hash(this.transform)}`;
  }
  assemble() {
    const {impute, key: key2, keyvals, method: method2, groupby, value: value3, frame: frame2 = [null, null]} = this.transform;
    const imputeTransform = Object.assign(Object.assign(Object.assign(Object.assign({type: "impute", field: impute, key: key2}, keyvals ? {keyvals: isImputeSequence(keyvals) ? this.processSequence(keyvals) : keyvals} : {}), {method: "value"}), groupby ? {groupby} : {}), {value: !method2 || method2 === "value" ? value3 : null});
    if (method2 && method2 !== "value") {
      const deriveNewField = Object.assign({type: "window", as: [`imputed_${impute}_value`], ops: [method2], fields: [impute], frame: frame2, ignorePeers: false}, groupby ? {groupby} : {});
      const replaceOriginal = {
        type: "formula",
        expr: `datum.${impute} === null ? datum.imputed_${impute}_value : datum.${impute}`,
        as: impute
      };
      return [imputeTransform, deriveNewField, replaceOriginal];
    } else {
      return [imputeTransform];
    }
  }
};

// node_modules/vega-lite/build/src/compile/data/loess.js
var LoessTransformNode = class extends DataFlowNode {
  constructor(parent, transform4) {
    var _a2, _b, _c;
    super(parent);
    this.transform = transform4;
    this.transform = duplicate(transform4);
    const specifiedAs = (_a2 = this.transform.as) !== null && _a2 !== void 0 ? _a2 : [void 0, void 0];
    this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : transform4.on, (_c = specifiedAs[1]) !== null && _c !== void 0 ? _c : transform4.loess];
  }
  clone() {
    return new LoessTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    var _a2;
    return new Set([this.transform.loess, this.transform.on, ...(_a2 = this.transform.groupby) !== null && _a2 !== void 0 ? _a2 : []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `LoessTransform ${hash(this.transform)}`;
  }
  assemble() {
    const _a2 = this.transform, {loess: loess2, on: on2} = _a2, rest = __rest(_a2, ["loess", "on"]);
    const result = Object.assign({type: "loess", x: on2, y: loess2}, rest);
    return result;
  }
};

// node_modules/vega-lite/build/src/compile/data/lookup.js
var LookupNode = class extends DataFlowNode {
  constructor(parent, transform4, secondary) {
    super(parent);
    this.transform = transform4;
    this.secondary = secondary;
  }
  clone() {
    return new LookupNode(null, duplicate(this.transform), this.secondary);
  }
  static make(parent, model, transform4, counter) {
    const sources = model.component.data.sources;
    const {from} = transform4;
    let fromOutputNode = null;
    if (isLookupData(from)) {
      let fromSource = findSource(from.data, sources);
      if (!fromSource) {
        fromSource = new SourceNode(from.data);
        sources.push(fromSource);
      }
      const fromOutputName = model.getName(`lookup_${counter}`);
      fromOutputNode = new OutputNode(fromSource, fromOutputName, "lookup", model.component.data.outputNodeRefCounts);
      model.component.data.outputNodes[fromOutputName] = fromOutputNode;
    } else if (isLookupSelection(from)) {
      const selName = from.selection;
      transform4 = Object.assign({as: selName}, transform4);
      fromOutputNode = model.getSelectionComponent(varName(selName), selName).materialized;
      if (!fromOutputNode) {
        throw new Error(message_exports.noSameUnitLookup(selName));
      }
    }
    return new LookupNode(parent, transform4, fromOutputNode.getSource());
  }
  dependentFields() {
    return new Set([this.transform.lookup]);
  }
  producedFields() {
    return new Set(this.transform.as ? array_default4(this.transform.as) : this.transform.from.fields);
  }
  hash() {
    return `Lookup ${hash({transform: this.transform, secondary: this.secondary})}`;
  }
  assemble() {
    let foreign;
    if (this.transform.from.fields) {
      foreign = Object.assign({values: this.transform.from.fields}, this.transform.as ? {as: array_default4(this.transform.as)} : {});
    } else {
      let asName = this.transform.as;
      if (!isString_default(asName)) {
        warn3(message_exports.NO_FIELDS_NEEDS_AS);
        asName = "_lookup";
      }
      foreign = {
        as: [asName]
      };
    }
    return Object.assign(Object.assign({type: "lookup", from: this.secondary, key: this.transform.from.key, fields: [this.transform.lookup]}, foreign), this.transform.default ? {default: this.transform.default} : {});
  }
};

// node_modules/vega-lite/build/src/compile/data/quantile.js
var QuantileTransformNode = class extends DataFlowNode {
  constructor(parent, transform4) {
    var _a2, _b, _c;
    super(parent);
    this.transform = transform4;
    this.transform = duplicate(transform4);
    const specifiedAs = (_a2 = this.transform.as) !== null && _a2 !== void 0 ? _a2 : [void 0, void 0];
    this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : "prob", (_c = specifiedAs[1]) !== null && _c !== void 0 ? _c : "value"];
  }
  clone() {
    return new QuantileTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    var _a2;
    return new Set([this.transform.quantile, ...(_a2 = this.transform.groupby) !== null && _a2 !== void 0 ? _a2 : []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `QuantileTransform ${hash(this.transform)}`;
  }
  assemble() {
    const _a2 = this.transform, {quantile: quantile3} = _a2, rest = __rest(_a2, ["quantile"]);
    const result = Object.assign({type: "quantile", field: quantile3}, rest);
    return result;
  }
};

// node_modules/vega-lite/build/src/compile/data/regression.js
var RegressionTransformNode = class extends DataFlowNode {
  constructor(parent, transform4) {
    var _a2, _b, _c;
    super(parent);
    this.transform = transform4;
    this.transform = duplicate(transform4);
    const specifiedAs = (_a2 = this.transform.as) !== null && _a2 !== void 0 ? _a2 : [void 0, void 0];
    this.transform.as = [(_b = specifiedAs[0]) !== null && _b !== void 0 ? _b : transform4.on, (_c = specifiedAs[1]) !== null && _c !== void 0 ? _c : transform4.regression];
  }
  clone() {
    return new RegressionTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    var _a2;
    return new Set([this.transform.regression, this.transform.on, ...(_a2 = this.transform.groupby) !== null && _a2 !== void 0 ? _a2 : []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `RegressionTransform ${hash(this.transform)}`;
  }
  assemble() {
    const _a2 = this.transform, {regression, on: on2} = _a2, rest = __rest(_a2, ["regression", "on"]);
    const result = Object.assign({type: "regression", x: on2, y: regression}, rest);
    return result;
  }
};

// node_modules/vega-lite/build/src/compile/data/pivot.js
var PivotTransformNode = class extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    this.transform = transform4;
  }
  clone() {
    return new PivotTransformNode(null, duplicate(this.transform));
  }
  addDimensions(fields) {
    var _a2;
    this.transform.groupby = unique(((_a2 = this.transform.groupby) !== null && _a2 !== void 0 ? _a2 : []).concat(fields), (d) => d);
  }
  producedFields() {
    return void 0;
  }
  dependentFields() {
    var _a2;
    return new Set([this.transform.pivot, this.transform.value, ...(_a2 = this.transform.groupby) !== null && _a2 !== void 0 ? _a2 : []]);
  }
  hash() {
    return `PivotTransform ${hash(this.transform)}`;
  }
  assemble() {
    const {pivot, value: value3, groupby, limit, op} = this.transform;
    return Object.assign(Object.assign(Object.assign({type: "pivot", field: pivot, value: value3}, limit !== void 0 ? {limit} : {}), op !== void 0 ? {op} : {}), groupby !== void 0 ? {groupby} : {});
  }
};

// node_modules/vega-lite/build/src/compile/data/sample.js
var SampleTransformNode = class extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    this.transform = transform4;
  }
  clone() {
    return new SampleTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    return new Set();
  }
  producedFields() {
    return new Set();
  }
  hash() {
    return `SampleTransform ${hash(this.transform)}`;
  }
  assemble() {
    return {
      type: "sample",
      size: this.transform.sample
    };
  }
};

// node_modules/vega-lite/build/src/compile/data/assemble.js
function makeWalkTree(data4) {
  let datasetIndex = 0;
  function walkTree(node, dataSource) {
    var _a2;
    if (node instanceof SourceNode) {
      if (!node.isGenerator && !isUrlData(node.data)) {
        data4.push(dataSource);
        const newData = {
          name: null,
          source: dataSource.name,
          transform: []
        };
        dataSource = newData;
      }
    }
    if (node instanceof ParseNode) {
      if (node.parent instanceof SourceNode && !dataSource.source) {
        dataSource.format = Object.assign(Object.assign({}, (_a2 = dataSource.format) !== null && _a2 !== void 0 ? _a2 : {}), {parse: node.assembleFormatParse()});
        dataSource.transform.push(...node.assembleTransforms(true));
      } else {
        dataSource.transform.push(...node.assembleTransforms());
      }
    }
    if (node instanceof FacetNode) {
      if (!dataSource.name) {
        dataSource.name = `data_${datasetIndex++}`;
      }
      if (!dataSource.source || dataSource.transform.length > 0) {
        data4.push(dataSource);
        node.data = dataSource.name;
      } else {
        node.data = dataSource.source;
      }
      for (const d of node.assemble()) {
        data4.push(d);
      }
      return;
    }
    if (node instanceof GraticuleNode || node instanceof SequenceNode || node instanceof FilterInvalidNode || node instanceof FilterNode || node instanceof CalculateNode || node instanceof GeoPointNode || node instanceof GeoJSONNode || node instanceof AggregateNode || node instanceof LookupNode || node instanceof WindowTransformNode || node instanceof JoinAggregateTransformNode || node instanceof FoldTransformNode || node instanceof FlattenTransformNode || node instanceof DensityTransformNode || node instanceof LoessTransformNode || node instanceof QuantileTransformNode || node instanceof RegressionTransformNode || node instanceof IdentifierNode || node instanceof SampleTransformNode || node instanceof PivotTransformNode) {
      dataSource.transform.push(node.assemble());
    }
    if (node instanceof BinNode || node instanceof TimeUnitNode || node instanceof ImputeNode || node instanceof StackNode) {
      dataSource.transform.push(...node.assemble());
    }
    if (node instanceof OutputNode) {
      if (dataSource.source && dataSource.transform.length === 0) {
        node.setSource(dataSource.source);
      } else if (node.parent instanceof OutputNode) {
        node.setSource(dataSource.name);
      } else {
        if (!dataSource.name) {
          dataSource.name = `data_${datasetIndex++}`;
        }
        node.setSource(dataSource.name);
        if (node.numChildren() === 1) {
          data4.push(dataSource);
          const newData = {
            name: null,
            source: dataSource.name,
            transform: []
          };
          dataSource = newData;
        }
      }
    }
    switch (node.numChildren()) {
      case 0:
        if (node instanceof OutputNode && (!dataSource.source || dataSource.transform.length > 0)) {
          data4.push(dataSource);
        }
        break;
      case 1:
        walkTree(node.children[0], dataSource);
        break;
      default: {
        if (!dataSource.name) {
          dataSource.name = `data_${datasetIndex++}`;
        }
        let source4 = dataSource.name;
        if (!dataSource.source || dataSource.transform.length > 0) {
          data4.push(dataSource);
        } else {
          source4 = dataSource.source;
        }
        for (const child of node.children) {
          const newData = {
            name: null,
            source: source4,
            transform: []
          };
          walkTree(child, newData);
        }
        break;
      }
    }
  }
  return walkTree;
}
function assembleFacetData(root2) {
  const data4 = [];
  const walkTree = makeWalkTree(data4);
  for (const child of root2.children) {
    walkTree(child, {
      source: root2.name,
      name: null,
      transform: []
    });
  }
  return data4;
}
function assembleRootData(dataComponent, datasets) {
  var _a2, _b;
  const data4 = [];
  const walkTree = makeWalkTree(data4);
  let sourceIndex = 0;
  for (const root2 of dataComponent.sources) {
    if (!root2.hasName()) {
      root2.dataName = `source_${sourceIndex++}`;
    }
    const newData = root2.assemble();
    walkTree(root2, newData);
  }
  for (const d of data4) {
    if (d.transform.length === 0) {
      delete d.transform;
    }
  }
  let whereTo = 0;
  for (const [i, d] of data4.entries()) {
    if (((_a2 = d.transform) !== null && _a2 !== void 0 ? _a2 : []).length === 0 && !d.source) {
      data4.splice(whereTo++, 0, data4.splice(i, 1)[0]);
    }
  }
  for (const d of data4) {
    for (const t of (_b = d.transform) !== null && _b !== void 0 ? _b : []) {
      if (t.type === "lookup") {
        t.from = dataComponent.outputNodes[t.from].getSource();
      }
    }
  }
  for (const d of data4) {
    if (d.name in datasets) {
      d.values = datasets[d.name];
    }
  }
  return data4;
}

// node_modules/vega-lite/build/src/compile/header/parse.js
function getHeaderType(orient3) {
  if (orient3 === "top" || orient3 === "left" || isSignalRef(orient3)) {
    return "header";
  }
  return "footer";
}
function parseFacetHeaders(model) {
  for (const channel of FACET_CHANNELS) {
    parseFacetHeader(model, channel);
  }
  mergeChildAxis(model, "x");
  mergeChildAxis(model, "y");
}
function parseFacetHeader(model, channel) {
  var _a2;
  const {facet, config, child, component} = model;
  if (model.channelHasField(channel)) {
    const fieldDef = facet[channel];
    const titleConfig = getHeaderProperty("title", null, config, channel);
    let title2 = title(fieldDef, config, {
      allowDisabling: true,
      includeDefault: titleConfig === void 0 || !!titleConfig
    });
    if (child.component.layoutHeaders[channel].title) {
      title2 = isArray_default(title2) ? title2.join(", ") : title2;
      title2 += " / " + child.component.layoutHeaders[channel].title;
      child.component.layoutHeaders[channel].title = null;
    }
    const labelOrient = getHeaderProperty("labelOrient", fieldDef, config, channel);
    const header = (_a2 = fieldDef.header) !== null && _a2 !== void 0 ? _a2 : {};
    const labels3 = getFirstDefined(header.labels, config.header.labels, true);
    const headerType = contains2(["bottom", "right"], labelOrient) ? "footer" : "header";
    component.layoutHeaders[channel] = {
      title: title2,
      facetFieldDef: fieldDef,
      [headerType]: channel === "facet" ? [] : [makeHeaderComponent(model, channel, labels3)]
    };
  }
}
function makeHeaderComponent(model, channel, labels3) {
  const sizeType = channel === "row" ? "height" : "width";
  return {
    labels: labels3,
    sizeSignal: model.child.component.layoutSize.get(sizeType) ? model.child.getSizeSignalRef(sizeType) : void 0,
    axes: []
  };
}
function mergeChildAxis(model, channel) {
  var _a2;
  const {child} = model;
  if (child.component.axes[channel]) {
    const {layoutHeaders: layoutHeaders2, resolve: resolve2} = model.component;
    resolve2.axis[channel] = parseGuideResolve(resolve2, channel);
    if (resolve2.axis[channel] === "shared") {
      const headerChannel = channel === "x" ? "column" : "row";
      const layoutHeader = layoutHeaders2[headerChannel];
      for (const axisComponent of child.component.axes[channel]) {
        const headerType = getHeaderType(axisComponent.get("orient"));
        layoutHeader[headerType] = (_a2 = layoutHeader[headerType]) !== null && _a2 !== void 0 ? _a2 : [makeHeaderComponent(model, headerChannel, false)];
        const mainAxis = assembleAxis(axisComponent, "main", model.config, {header: true});
        if (mainAxis) {
          layoutHeader[headerType][0].axes.push(mainAxis);
        }
        axisComponent.mainExtracted = true;
      }
    } else {
    }
  }
}

// node_modules/vega-lite/build/src/compile/layoutsize/parse.js
function parseLayerLayoutSize(model) {
  parseChildrenLayoutSize(model);
  parseNonUnitLayoutSizeForChannel(model, "width");
  parseNonUnitLayoutSizeForChannel(model, "height");
}
function parseConcatLayoutSize(model) {
  parseChildrenLayoutSize(model);
  const widthType = model.layout.columns === 1 ? "width" : "childWidth";
  const heightType = model.layout.columns === void 0 ? "height" : "childHeight";
  parseNonUnitLayoutSizeForChannel(model, widthType);
  parseNonUnitLayoutSizeForChannel(model, heightType);
}
function parseChildrenLayoutSize(model) {
  for (const child of model.children) {
    child.parseLayoutSize();
  }
}
function parseNonUnitLayoutSizeForChannel(model, layoutSizeType) {
  const sizeType = getSizeTypeFromLayoutSizeType(layoutSizeType);
  const channel = getPositionScaleChannel(sizeType);
  const resolve2 = model.component.resolve;
  const layoutSizeCmpt = model.component.layoutSize;
  let mergedSize;
  for (const child of model.children) {
    const childSize = child.component.layoutSize.getWithExplicit(sizeType);
    const scaleResolve = resolve2.scale[channel];
    if (scaleResolve === "independent" && childSize.value === "step") {
      mergedSize = void 0;
      break;
    }
    if (mergedSize) {
      if (scaleResolve === "independent" && mergedSize.value !== childSize.value) {
        mergedSize = void 0;
        break;
      }
      mergedSize = mergeValuesWithExplicit(mergedSize, childSize, sizeType, "");
    } else {
      mergedSize = childSize;
    }
  }
  if (mergedSize) {
    for (const child of model.children) {
      model.renameSignal(child.getName(sizeType), model.getName(layoutSizeType));
      child.component.layoutSize.set(sizeType, "merged", false);
    }
    layoutSizeCmpt.setWithExplicit(layoutSizeType, mergedSize);
  } else {
    layoutSizeCmpt.setWithExplicit(layoutSizeType, {
      explicit: false,
      value: void 0
    });
  }
}
function parseUnitLayoutSize(model) {
  const {size, component} = model;
  for (const channel of POSITION_SCALE_CHANNELS) {
    const sizeType = getSizeChannel(channel);
    if (size[sizeType]) {
      const specifiedSize = size[sizeType];
      component.layoutSize.set(sizeType, isStep(specifiedSize) ? "step" : specifiedSize, true);
    } else {
      const defaultSize2 = defaultUnitSize(model, sizeType);
      component.layoutSize.set(sizeType, defaultSize2, false);
    }
  }
}
function defaultUnitSize(model, sizeType) {
  const channel = sizeType === "width" ? "x" : "y";
  const config = model.config;
  const scaleComponent = model.getScaleComponent(channel);
  if (scaleComponent) {
    const scaleType2 = scaleComponent.get("type");
    const range5 = scaleComponent.get("range");
    if (hasDiscreteDomain(scaleType2)) {
      const size = getViewConfigDiscreteSize(config.view, sizeType);
      if (isVgRangeStep(range5) || isStep(size)) {
        return "step";
      } else {
        return size;
      }
    } else {
      return getViewConfigContinuousSize(config.view, sizeType);
    }
  } else if (model.hasProjection || model.mark === "arc") {
    return getViewConfigContinuousSize(config.view, sizeType);
  } else {
    const size = getViewConfigDiscreteSize(config.view, sizeType);
    return isStep(size) ? size.step : size;
  }
}

// node_modules/vega-lite/build/src/compile/facet.js
function facetSortFieldName(fieldDef, sort2, opt) {
  return vgField(sort2, Object.assign({suffix: `by_${vgField(fieldDef)}`}, opt !== null && opt !== void 0 ? opt : {}));
}
var FacetModel = class extends ModelWithField {
  constructor(spec, parent, parentGivenName, config) {
    super(spec, "facet", parent, parentGivenName, config, spec.resolve);
    this.child = buildModel(spec.spec, this, this.getName("child"), void 0, config);
    this.children = [this.child];
    this.facet = this.initFacet(spec.facet, config);
  }
  initFacet(facet, config) {
    if (!isFacetMapping(facet)) {
      return {facet: initChannelDef(facet, "facet", config)};
    }
    return reduce(facet, (normalizedFacet, fieldDef, channel) => {
      if (!contains2([ROW, COLUMN], channel)) {
        warn3(message_exports.incompatibleChannel(channel, "facet"));
        return normalizedFacet;
      }
      if (fieldDef.field === void 0) {
        warn3(message_exports.emptyFieldDef(fieldDef, channel));
        return normalizedFacet;
      }
      normalizedFacet[channel] = initChannelDef(fieldDef, channel, config);
      return normalizedFacet;
    }, {});
  }
  channelHasField(channel) {
    return !!this.facet[channel];
  }
  fieldDef(channel) {
    return this.facet[channel];
  }
  parseData() {
    this.component.data = parseData2(this);
    this.child.parseData();
  }
  parseLayoutSize() {
    parseChildrenLayoutSize(this);
  }
  parseSelections() {
    this.child.parseSelections();
    this.component.selection = this.child.component.selection;
  }
  parseMarkGroup() {
    this.child.parseMarkGroup();
  }
  parseAxesAndHeaders() {
    this.child.parseAxesAndHeaders();
    parseFacetHeaders(this);
  }
  assembleSelectionTopLevelSignals(signals) {
    return this.child.assembleSelectionTopLevelSignals(signals);
  }
  assembleSignals() {
    this.child.assembleSignals();
    return [];
  }
  assembleSelectionData(data4) {
    return this.child.assembleSelectionData(data4);
  }
  getHeaderLayoutMixins() {
    var _a2, _b, _c;
    const layoutMixins = {};
    for (const channel of FACET_CHANNELS) {
      for (const headerType of HEADER_TYPES) {
        const layoutHeaderComponent = this.component.layoutHeaders[channel];
        const headerComponent = layoutHeaderComponent[headerType];
        const {facetFieldDef} = layoutHeaderComponent;
        if (facetFieldDef) {
          const titleOrient = getHeaderProperty("titleOrient", facetFieldDef, this.config, channel);
          if (contains2(["right", "bottom"], titleOrient)) {
            const headerChannel = getHeaderChannel(channel, titleOrient);
            layoutMixins.titleAnchor = (_a2 = layoutMixins.titleAnchor) !== null && _a2 !== void 0 ? _a2 : {};
            layoutMixins.titleAnchor[headerChannel] = "end";
          }
        }
        if (headerComponent === null || headerComponent === void 0 ? void 0 : headerComponent[0]) {
          const sizeType = channel === "row" ? "height" : "width";
          const bandType = headerType === "header" ? "headerBand" : "footerBand";
          if (channel !== "facet" && !this.child.component.layoutSize.get(sizeType)) {
            layoutMixins[bandType] = (_b = layoutMixins[bandType]) !== null && _b !== void 0 ? _b : {};
            layoutMixins[bandType][channel] = 0.5;
          }
          if (layoutHeaderComponent.title) {
            layoutMixins.offset = (_c = layoutMixins.offset) !== null && _c !== void 0 ? _c : {};
            layoutMixins.offset[channel === "row" ? "rowTitle" : "columnTitle"] = 10;
          }
        }
      }
    }
    return layoutMixins;
  }
  assembleDefaultLayout() {
    const {column, row} = this.facet;
    const columns = column ? this.columnDistinctSignal() : row ? 1 : void 0;
    let align2 = "all";
    if (!row && this.component.resolve.scale.x === "independent") {
      align2 = "none";
    } else if (!column && this.component.resolve.scale.y === "independent") {
      align2 = "none";
    }
    return Object.assign(Object.assign(Object.assign({}, this.getHeaderLayoutMixins()), columns ? {columns} : {}), {bounds: "full", align: align2});
  }
  assembleLayoutSignals() {
    return this.child.assembleLayoutSignals();
  }
  columnDistinctSignal() {
    if (this.parent && this.parent instanceof FacetModel) {
      return void 0;
    } else {
      const facetLayoutDataName = this.getName("column_domain");
      return {signal: `length(data('${facetLayoutDataName}'))`};
    }
  }
  assembleGroup(signals) {
    if (this.parent && this.parent instanceof FacetModel) {
      return Object.assign(Object.assign({}, this.channelHasField("column") ? {
        encode: {
          update: {
            columns: {field: vgField(this.facet.column, {prefix: "distinct"})}
          }
        }
      } : {}), super.assembleGroup(signals));
    }
    return super.assembleGroup(signals);
  }
  getCardinalityAggregateForChild() {
    const fields = [];
    const ops2 = [];
    const as = [];
    if (this.child instanceof FacetModel) {
      if (this.child.channelHasField("column")) {
        const field4 = vgField(this.child.facet.column);
        fields.push(field4);
        ops2.push("distinct");
        as.push(`distinct_${field4}`);
      }
    } else {
      for (const channel of POSITION_SCALE_CHANNELS) {
        const childScaleComponent = this.child.component.scales[channel];
        if (childScaleComponent && !childScaleComponent.merged) {
          const type2 = childScaleComponent.get("type");
          const range5 = childScaleComponent.get("range");
          if (hasDiscreteDomain(type2) && isVgRangeStep(range5)) {
            const domain4 = assembleDomain(this.child, channel);
            const field4 = getFieldFromDomain(domain4);
            if (field4) {
              fields.push(field4);
              ops2.push("distinct");
              as.push(`distinct_${field4}`);
            } else {
              warn3(`Unknown field for ${channel}. Cannot calculate view size.`);
            }
          }
        }
      }
    }
    return {fields, ops: ops2, as};
  }
  assembleFacet() {
    const {name: name4, data: data4} = this.component.data.facetRoot;
    const {row, column} = this.facet;
    const {fields, ops: ops2, as} = this.getCardinalityAggregateForChild();
    const groupby = [];
    for (const channel of FACET_CHANNELS) {
      const fieldDef = this.facet[channel];
      if (fieldDef) {
        groupby.push(vgField(fieldDef));
        const {bin: bin4, sort: sort2} = fieldDef;
        if (isBinning(bin4)) {
          groupby.push(vgField(fieldDef, {binSuffix: "end"}));
        }
        if (isSortField(sort2)) {
          const {field: field4, op = DEFAULT_SORT_OP} = sort2;
          const outputName = facetSortFieldName(fieldDef, sort2);
          if (row && column) {
            fields.push(outputName);
            ops2.push("max");
            as.push(outputName);
          } else {
            fields.push(field4);
            ops2.push(op);
            as.push(outputName);
          }
        } else if (isArray_default(sort2)) {
          const outputName = sortArrayIndexField(fieldDef, channel);
          fields.push(outputName);
          ops2.push("max");
          as.push(outputName);
        }
      }
    }
    const cross2 = !!row && !!column;
    return Object.assign({
      name: name4,
      data: data4,
      groupby
    }, cross2 || fields.length > 0 ? {
      aggregate: Object.assign(Object.assign({}, cross2 ? {cross: cross2} : {}), fields.length ? {fields, ops: ops2, as} : {})
    } : {});
  }
  facetSortFields(channel) {
    const {facet} = this;
    const fieldDef = facet[channel];
    if (fieldDef) {
      if (isSortField(fieldDef.sort)) {
        return [facetSortFieldName(fieldDef, fieldDef.sort, {expr: "datum"})];
      } else if (isArray_default(fieldDef.sort)) {
        return [sortArrayIndexField(fieldDef, channel, {expr: "datum"})];
      }
      return [vgField(fieldDef, {expr: "datum"})];
    }
    return [];
  }
  facetSortOrder(channel) {
    const {facet} = this;
    const fieldDef = facet[channel];
    if (fieldDef) {
      const {sort: sort2} = fieldDef;
      const order = (isSortField(sort2) ? sort2.order : !isArray_default(sort2) && sort2) || "ascending";
      return [order];
    }
    return [];
  }
  assembleLabelTitle() {
    const {facet, config} = this;
    if (facet.facet) {
      return assembleLabelTitle(facet.facet, "facet", config);
    }
    const ORTHOGONAL_ORIENT = {
      row: ["top", "bottom"],
      column: ["left", "right"]
    };
    for (const channel of HEADER_CHANNELS) {
      if (facet[channel]) {
        const labelOrient = getHeaderProperty("labelOrient", facet[channel], config, channel);
        if (contains2(ORTHOGONAL_ORIENT[channel], labelOrient)) {
          return assembleLabelTitle(facet[channel], channel, config);
        }
      }
    }
    return void 0;
  }
  assembleMarks() {
    const {child} = this;
    const facetRoot = this.component.data.facetRoot;
    const data4 = assembleFacetData(facetRoot);
    const encodeEntry2 = child.assembleGroupEncodeEntry(false);
    const title2 = this.assembleLabelTitle() || child.assembleTitle();
    const style2 = child.assembleGroupStyle();
    const markGroup = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({name: this.getName("cell"), type: "group"}, title2 ? {title: title2} : {}), style2 ? {style: style2} : {}), {
      from: {
        facet: this.assembleFacet()
      },
      sort: {
        field: FACET_CHANNELS.map((c2) => this.facetSortFields(c2)).flat(),
        order: FACET_CHANNELS.map((c2) => this.facetSortOrder(c2)).flat()
      }
    }), data4.length > 0 ? {data: data4} : {}), encodeEntry2 ? {encode: {update: encodeEntry2}} : {}), child.assembleGroup(assembleFacetSignals(this, [])));
    return [markGroup];
  }
  getMapping() {
    return this.facet;
  }
};

// node_modules/vega-lite/build/src/compile/data/joinaggregatefacet.js
function makeJoinAggregateFromFacet(parent, facet) {
  const {row, column} = facet;
  if (row && column) {
    let newParent = null;
    for (const fieldDef of [row, column]) {
      if (isSortField(fieldDef.sort)) {
        const {field: field4, op = DEFAULT_SORT_OP} = fieldDef.sort;
        parent = newParent = new JoinAggregateTransformNode(parent, {
          joinaggregate: [
            {
              op,
              field: field4,
              as: facetSortFieldName(fieldDef, fieldDef.sort, {forAs: true})
            }
          ],
          groupby: [vgField(fieldDef)]
        });
      }
    }
    return newParent;
  }
  return null;
}

// node_modules/vega-lite/build/src/compile/data/parse.js
function findSource(data4, sources) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
  for (const other of sources) {
    const otherData = other.data;
    if (data4.name && other.hasName() && data4.name !== other.dataName) {
      continue;
    }
    if (((_a2 = data4["format"]) === null || _a2 === void 0 ? void 0 : _a2.mesh) && ((_b = otherData.format) === null || _b === void 0 ? void 0 : _b.feature)) {
      continue;
    }
    if ((((_c = data4["format"]) === null || _c === void 0 ? void 0 : _c.feature) || ((_d = otherData.format) === null || _d === void 0 ? void 0 : _d.feature)) && ((_e = data4["format"]) === null || _e === void 0 ? void 0 : _e.feature) !== ((_f = otherData.format) === null || _f === void 0 ? void 0 : _f.feature)) {
      continue;
    }
    if ((((_g = data4["format"]) === null || _g === void 0 ? void 0 : _g.mesh) || ((_h = otherData.format) === null || _h === void 0 ? void 0 : _h.mesh)) && ((_j = data4["format"]) === null || _j === void 0 ? void 0 : _j.mesh) !== ((_k = otherData.format) === null || _k === void 0 ? void 0 : _k.mesh)) {
      continue;
    }
    if (isInlineData(data4) && isInlineData(otherData)) {
      if (deepEqual(data4.values, otherData.values)) {
        return other;
      }
    } else if (isUrlData(data4) && isUrlData(otherData)) {
      if (data4.url === otherData.url) {
        return other;
      }
    } else if (isNamedData(data4)) {
      if (data4.name === other.dataName) {
        return other;
      }
    }
  }
  return null;
}
function parseRoot(model, sources) {
  if (model.data || !model.parent) {
    if (model.data === null) {
      const source4 = new SourceNode({values: []});
      sources.push(source4);
      return source4;
    }
    const existingSource = findSource(model.data, sources);
    if (existingSource) {
      if (!isGenerator(model.data)) {
        existingSource.data.format = mergeDeep({}, model.data.format, existingSource.data.format);
      }
      if (!existingSource.hasName() && model.data.name) {
        existingSource.dataName = model.data.name;
      }
      return existingSource;
    } else {
      const source4 = new SourceNode(model.data);
      sources.push(source4);
      return source4;
    }
  } else {
    return model.parent.component.data.facetRoot ? model.parent.component.data.facetRoot : model.parent.component.data.main;
  }
}
function parseTransformArray(head, model, ancestorParse) {
  var _a2, _b;
  let lookupCounter = 0;
  for (const t of model.transforms) {
    let derivedType = void 0;
    let transformNode;
    if (isCalculate(t)) {
      transformNode = head = new CalculateNode(head, t);
      derivedType = "derived";
    } else if (isFilter(t)) {
      const implicit2 = getImplicitFromFilterTransform(t);
      transformNode = head = (_a2 = ParseNode.makeWithAncestors(head, {}, implicit2, ancestorParse)) !== null && _a2 !== void 0 ? _a2 : head;
      head = new FilterNode(head, model, t.filter);
    } else if (isBin(t)) {
      transformNode = head = BinNode.makeFromTransform(head, t, model);
      derivedType = "number";
    } else if (isTimeUnit(t)) {
      derivedType = "date";
      const parsedAs = ancestorParse.getWithExplicit(t.field);
      if (parsedAs.value === void 0) {
        head = new ParseNode(head, {[t.field]: derivedType});
        ancestorParse.set(t.field, derivedType, false);
      }
      transformNode = head = TimeUnitNode.makeFromTransform(head, t);
    } else if (isAggregate2(t)) {
      transformNode = head = AggregateNode.makeFromTransform(head, t);
      derivedType = "number";
      if (requiresSelectionId(model)) {
        head = new IdentifierNode(head);
      }
    } else if (isLookup(t)) {
      transformNode = head = LookupNode.make(head, model, t, lookupCounter++);
      derivedType = "derived";
    } else if (isWindow(t)) {
      transformNode = head = new WindowTransformNode(head, t);
      derivedType = "number";
    } else if (isJoinAggregate(t)) {
      transformNode = head = new JoinAggregateTransformNode(head, t);
      derivedType = "number";
    } else if (isStack(t)) {
      transformNode = head = StackNode.makeFromTransform(head, t);
      derivedType = "derived";
    } else if (isFold(t)) {
      transformNode = head = new FoldTransformNode(head, t);
      derivedType = "derived";
    } else if (isFlatten(t)) {
      transformNode = head = new FlattenTransformNode(head, t);
      derivedType = "derived";
    } else if (isPivot(t)) {
      transformNode = head = new PivotTransformNode(head, t);
      derivedType = "derived";
    } else if (isSample(t)) {
      head = new SampleTransformNode(head, t);
    } else if (isImpute(t)) {
      transformNode = head = ImputeNode.makeFromTransform(head, t);
      derivedType = "derived";
    } else if (isDensity(t)) {
      transformNode = head = new DensityTransformNode(head, t);
      derivedType = "derived";
    } else if (isQuantile2(t)) {
      transformNode = head = new QuantileTransformNode(head, t);
      derivedType = "derived";
    } else if (isRegression(t)) {
      transformNode = head = new RegressionTransformNode(head, t);
      derivedType = "derived";
    } else if (isLoess(t)) {
      transformNode = head = new LoessTransformNode(head, t);
      derivedType = "derived";
    } else {
      warn3(message_exports.invalidTransformIgnored(t));
      continue;
    }
    if (transformNode && derivedType !== void 0) {
      for (const field4 of (_b = transformNode.producedFields()) !== null && _b !== void 0 ? _b : []) {
        ancestorParse.set(field4, derivedType, false);
      }
    }
  }
  return head;
}
function parseData2(model) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
  let head = parseRoot(model, model.component.data.sources);
  const {outputNodes, outputNodeRefCounts} = model.component.data;
  const ancestorParse = model.parent ? model.parent.component.data.ancestorParse.clone() : new AncestorParse();
  const data4 = model.data;
  if (isGenerator(data4)) {
    if (isSequenceGenerator(data4)) {
      head = new SequenceNode(head, data4.sequence);
    } else if (isGraticuleGenerator(data4)) {
      head = new GraticuleNode(head, data4.graticule);
    }
    ancestorParse.parseNothing = true;
  } else if (((_a2 = data4 === null || data4 === void 0 ? void 0 : data4.format) === null || _a2 === void 0 ? void 0 : _a2.parse) === null) {
    ancestorParse.parseNothing = true;
  }
  head = (_b = ParseNode.makeExplicit(head, model, ancestorParse)) !== null && _b !== void 0 ? _b : head;
  head = new IdentifierNode(head);
  const parentIsLayer = model.parent && isLayerModel(model.parent);
  if (isUnitModel(model) || isFacetModel(model)) {
    if (parentIsLayer) {
      head = (_c = BinNode.makeFromEncoding(head, model)) !== null && _c !== void 0 ? _c : head;
    }
  }
  if (model.transforms.length > 0) {
    head = parseTransformArray(head, model, ancestorParse);
  }
  const implicitSelection = getImplicitFromSelection(model);
  const implicitEncoding = getImplicitFromEncoding(model);
  head = (_d = ParseNode.makeWithAncestors(head, {}, Object.assign(Object.assign({}, implicitSelection), implicitEncoding), ancestorParse)) !== null && _d !== void 0 ? _d : head;
  if (isUnitModel(model)) {
    head = GeoJSONNode.parseAll(head, model);
    head = GeoPointNode.parseAll(head, model);
  }
  if (isUnitModel(model) || isFacetModel(model)) {
    if (!parentIsLayer) {
      head = (_e = BinNode.makeFromEncoding(head, model)) !== null && _e !== void 0 ? _e : head;
    }
    head = (_f = TimeUnitNode.makeFromEncoding(head, model)) !== null && _f !== void 0 ? _f : head;
    head = CalculateNode.parseAllForSortIndex(head, model);
  }
  const rawName = model.getName(RAW);
  const raw = new OutputNode(head, rawName, RAW, outputNodeRefCounts);
  outputNodes[rawName] = raw;
  head = raw;
  if (isUnitModel(model)) {
    const agg = AggregateNode.makeFromEncoding(head, model);
    if (agg) {
      head = agg;
      if (requiresSelectionId(model)) {
        head = new IdentifierNode(head);
      }
    }
    head = (_g = ImputeNode.makeFromEncoding(head, model)) !== null && _g !== void 0 ? _g : head;
    head = (_h = StackNode.makeFromEncoding(head, model)) !== null && _h !== void 0 ? _h : head;
  }
  if (isUnitModel(model)) {
    head = (_j = FilterInvalidNode.make(head, model)) !== null && _j !== void 0 ? _j : head;
  }
  const mainName = model.getName(MAIN);
  const main5 = new OutputNode(head, mainName, MAIN, outputNodeRefCounts);
  outputNodes[mainName] = main5;
  head = main5;
  if (isUnitModel(model)) {
    materializeSelections(model, main5);
  }
  let facetRoot = null;
  if (isFacetModel(model)) {
    const facetName = model.getName("facet");
    head = (_k = makeJoinAggregateFromFacet(head, model.facet)) !== null && _k !== void 0 ? _k : head;
    facetRoot = new FacetNode(head, model, facetName, main5.getSource());
    outputNodes[facetName] = facetRoot;
  }
  return Object.assign(Object.assign({}, model.component.data), {
    outputNodes,
    outputNodeRefCounts,
    raw,
    main: main5,
    facetRoot,
    ancestorParse
  });
}

// node_modules/vega-lite/build/src/compile/concat.js
var ConcatModel = class extends Model {
  constructor(spec, parent, parentGivenName, config) {
    var _a2, _b, _c, _d;
    super(spec, "concat", parent, parentGivenName, config, spec.resolve);
    if (((_b = (_a2 = spec.resolve) === null || _a2 === void 0 ? void 0 : _a2.axis) === null || _b === void 0 ? void 0 : _b.x) === "shared" || ((_d = (_c = spec.resolve) === null || _c === void 0 ? void 0 : _c.axis) === null || _d === void 0 ? void 0 : _d.y) === "shared") {
      warn3(message_exports.CONCAT_CANNOT_SHARE_AXIS);
    }
    this.children = this.getChildren(spec).map((child, i) => {
      return buildModel(child, this, this.getName("concat_" + i), void 0, config);
    });
  }
  parseData() {
    this.component.data = parseData2(this);
    for (const child of this.children) {
      child.parseData();
    }
  }
  parseSelections() {
    this.component.selection = {};
    for (const child of this.children) {
      child.parseSelections();
      for (const key2 of keys3(child.component.selection)) {
        this.component.selection[key2] = child.component.selection[key2];
      }
    }
  }
  parseMarkGroup() {
    for (const child of this.children) {
      child.parseMarkGroup();
    }
  }
  parseAxesAndHeaders() {
    for (const child of this.children) {
      child.parseAxesAndHeaders();
    }
  }
  getChildren(spec) {
    if (isVConcatSpec(spec)) {
      return spec.vconcat;
    } else if (isHConcatSpec(spec)) {
      return spec.hconcat;
    }
    return spec.concat;
  }
  parseLayoutSize() {
    parseConcatLayoutSize(this);
  }
  parseAxisGroup() {
    return null;
  }
  assembleSelectionTopLevelSignals(signals) {
    return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);
  }
  assembleSignals() {
    this.children.forEach((child) => child.assembleSignals());
    return [];
  }
  assembleLayoutSignals() {
    const layoutSignals = assembleLayoutSignals(this);
    for (const child of this.children) {
      layoutSignals.push(...child.assembleLayoutSignals());
    }
    return layoutSignals;
  }
  assembleSelectionData(data4) {
    return this.children.reduce((db, child) => child.assembleSelectionData(db), data4);
  }
  assembleMarks() {
    return this.children.map((child) => {
      const title2 = child.assembleTitle();
      const style2 = child.assembleGroupStyle();
      const encodeEntry2 = child.assembleGroupEncodeEntry(false);
      return Object.assign(Object.assign(Object.assign(Object.assign({type: "group", name: child.getName("group")}, title2 ? {title: title2} : {}), style2 ? {style: style2} : {}), encodeEntry2 ? {encode: {update: encodeEntry2}} : {}), child.assembleGroup());
    });
  }
  assembleDefaultLayout() {
    const columns = this.layout.columns;
    return Object.assign(Object.assign({}, columns != null ? {columns} : {}), {
      bounds: "full",
      align: "each"
    });
  }
};

// node_modules/vega-lite/build/src/compile/axis/component.js
function isFalseOrNull(v) {
  return v === false || v === null;
}
var AXIS_COMPONENT_PROPERTIES_INDEX = Object.assign(Object.assign({disable: 1, gridScale: 1, scale: 1}, COMMON_AXIS_PROPERTIES_INDEX), {labelExpr: 1, encode: 1});
var AXIS_COMPONENT_PROPERTIES = keys3(AXIS_COMPONENT_PROPERTIES_INDEX);
var AxisComponent = class extends Split {
  constructor(explicit = {}, implicit2 = {}, mainExtracted = false) {
    super();
    this.explicit = explicit;
    this.implicit = implicit2;
    this.mainExtracted = mainExtracted;
  }
  clone() {
    return new AxisComponent(duplicate(this.explicit), duplicate(this.implicit), this.mainExtracted);
  }
  hasAxisPart(part) {
    if (part === "axis") {
      return true;
    }
    if (part === "grid" || part === "title") {
      return !!this.get(part);
    }
    return !isFalseOrNull(this.get(part));
  }
  hasOrientSignalRef() {
    return isSignalRef(this.explicit.orient);
  }
};

// node_modules/vega-lite/build/src/compile/axis/encode.js
function labels2(model, channel, specifiedLabelsSpec) {
  var _a2;
  const {encoding, config} = model;
  const fieldOrDatumDef = (_a2 = getFieldOrDatumDef(encoding[channel])) !== null && _a2 !== void 0 ? _a2 : getFieldOrDatumDef(encoding[getSecondaryRangeChannel(channel)]);
  const axis = model.axis(channel) || {};
  const {format: format8, formatType} = axis;
  if (isCustomFormatType(formatType)) {
    return Object.assign({text: formatCustomType({
      fieldOrDatumDef,
      field: "datum.value",
      format: format8,
      formatType,
      config
    })}, specifiedLabelsSpec);
  }
  return specifiedLabelsSpec;
}

// node_modules/vega-lite/build/src/compile/axis/parse.js
function parseUnitAxes(model) {
  return POSITION_SCALE_CHANNELS.reduce((axis, channel) => {
    if (model.component.scales[channel]) {
      axis[channel] = [parseAxis2(channel, model)];
    }
    return axis;
  }, {});
}
var OPPOSITE_ORIENT = {
  bottom: "top",
  top: "bottom",
  left: "right",
  right: "left"
};
function parseLayerAxes(model) {
  var _a2;
  const {axes, resolve: resolve2} = model.component;
  const axisCount = {top: 0, bottom: 0, right: 0, left: 0};
  for (const child of model.children) {
    child.parseAxesAndHeaders();
    for (const channel of keys3(child.component.axes)) {
      resolve2.axis[channel] = parseGuideResolve(model.component.resolve, channel);
      if (resolve2.axis[channel] === "shared") {
        axes[channel] = mergeAxisComponents(axes[channel], child.component.axes[channel]);
        if (!axes[channel]) {
          resolve2.axis[channel] = "independent";
          delete axes[channel];
        }
      }
    }
  }
  for (const channel of POSITION_SCALE_CHANNELS) {
    for (const child of model.children) {
      if (!child.component.axes[channel]) {
        continue;
      }
      if (resolve2.axis[channel] === "independent") {
        axes[channel] = ((_a2 = axes[channel]) !== null && _a2 !== void 0 ? _a2 : []).concat(child.component.axes[channel]);
        for (const axisComponent of child.component.axes[channel]) {
          const {value: orient3, explicit} = axisComponent.getWithExplicit("orient");
          if (isSignalRef(orient3)) {
            continue;
          }
          if (axisCount[orient3] > 0 && !explicit) {
            const oppositeOrient = OPPOSITE_ORIENT[orient3];
            if (axisCount[orient3] > axisCount[oppositeOrient]) {
              axisComponent.set("orient", oppositeOrient, false);
            }
          }
          axisCount[orient3]++;
        }
      }
      delete child.component.axes[channel];
    }
    if (resolve2.axis[channel] === "independent" && axes[channel] && axes[channel].length > 1) {
      for (const axisCmpt of axes[channel]) {
        if (!!axisCmpt.get("grid") && !axisCmpt.explicit.grid) {
          axisCmpt.implicit.grid = false;
        }
      }
    }
  }
}
function mergeAxisComponents(mergedAxisCmpts, childAxisCmpts) {
  if (mergedAxisCmpts) {
    if (mergedAxisCmpts.length !== childAxisCmpts.length) {
      return void 0;
    }
    const length3 = mergedAxisCmpts.length;
    for (let i = 0; i < length3; i++) {
      const merged = mergedAxisCmpts[i];
      const child = childAxisCmpts[i];
      if (!!merged !== !!child) {
        return void 0;
      } else if (merged && child) {
        const mergedOrient = merged.getWithExplicit("orient");
        const childOrient = child.getWithExplicit("orient");
        if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {
          return void 0;
        } else {
          mergedAxisCmpts[i] = mergeAxisComponent(merged, child);
        }
      }
    }
  } else {
    return childAxisCmpts.map((axisComponent) => axisComponent.clone());
  }
  return mergedAxisCmpts;
}
function mergeAxisComponent(merged, child) {
  for (const prop of AXIS_COMPONENT_PROPERTIES) {
    const mergedValueWithExplicit = mergeValuesWithExplicit(merged.getWithExplicit(prop), child.getWithExplicit(prop), prop, "axis", (v1, v2) => {
      switch (prop) {
        case "title":
          return mergeTitleComponent(v1, v2);
        case "gridScale":
          return {
            explicit: v1.explicit,
            value: getFirstDefined(v1.value, v2.value)
          };
      }
      return defaultTieBreaker(v1, v2, prop, "axis");
    });
    merged.setWithExplicit(prop, mergedValueWithExplicit);
  }
  return merged;
}
function isExplicit2(value3, property2, axis, model, channel) {
  if (property2 === "disable") {
    return axis !== void 0;
  }
  axis = axis || {};
  switch (property2) {
    case "titleAngle":
    case "labelAngle":
      return value3 === (isSignalRef(axis.labelAngle) ? axis.labelAngle : normalizeAngle(axis.labelAngle));
    case "values":
      return !!axis.values;
    case "encode":
      return !!axis.encoding || !!axis.labelAngle;
    case "title":
      if (value3 === getFieldDefTitle(model, channel)) {
        return true;
      }
  }
  return value3 === axis[property2];
}
var propsToAlwaysIncludeConfig = new Set([
  "grid",
  "translate",
  "format",
  "formatType",
  "orient",
  "labelExpr",
  "tickCount",
  "position",
  "tickMinStep"
]);
function parseAxis2(channel, model) {
  var _a2, _b, _c;
  let axis = model.axis(channel);
  const axisComponent = new AxisComponent();
  const fieldOrDatumDef = getFieldOrDatumDef(model.encoding[channel]);
  const {mark: mark2, config} = model;
  const orient3 = (axis === null || axis === void 0 ? void 0 : axis.orient) || ((_a2 = config[channel === "x" ? "axisX" : "axisY"]) === null || _a2 === void 0 ? void 0 : _a2.orient) || ((_b = config.axis) === null || _b === void 0 ? void 0 : _b.orient) || defaultOrient(channel);
  const scaleType2 = model.getScaleComponent(channel).get("type");
  const axisConfigs = getAxisConfigs(channel, scaleType2, orient3, model.config);
  const disable = axis !== void 0 ? !axis : getAxisConfig("disable", config, axis === null || axis === void 0 ? void 0 : axis.style, axisConfigs).configValue;
  axisComponent.set("disable", disable, axis !== void 0);
  if (disable) {
    return axisComponent;
  }
  axis = axis || {};
  const labelAngle = getLabelAngle(model, axis, channel, fieldOrDatumDef, axisConfigs);
  const ruleParams = {
    fieldOrDatumDef,
    axis,
    channel,
    model,
    scaleType: scaleType2,
    orient: orient3,
    labelAngle,
    mark: mark2,
    config
  };
  for (const property2 of AXIS_COMPONENT_PROPERTIES) {
    const value3 = property2 in axisRules ? axisRules[property2](ruleParams) : isAxisProperty(property2) ? axis[property2] : void 0;
    const hasValue = value3 !== void 0;
    const explicit = isExplicit2(value3, property2, axis, model, channel);
    if (hasValue && explicit) {
      axisComponent.set(property2, value3, explicit);
    } else {
      const {configValue = void 0, configFrom = void 0} = isAxisProperty(property2) && property2 !== "values" ? getAxisConfig(property2, model.config, axis.style, axisConfigs) : {};
      const hasConfigValue = configValue !== void 0;
      if (hasValue && !hasConfigValue) {
        axisComponent.set(property2, value3, explicit);
      } else if (!(configFrom === "vgAxisConfig") || propsToAlwaysIncludeConfig.has(property2) && hasConfigValue || isConditionalAxisValue(configValue) || isSignalRef(configValue)) {
        axisComponent.set(property2, configValue, false);
      }
    }
  }
  const axisEncoding = (_c = axis.encoding) !== null && _c !== void 0 ? _c : {};
  const axisEncode = AXIS_PARTS.reduce((e, part) => {
    var _a3;
    if (!axisComponent.hasAxisPart(part)) {
      return e;
    }
    const axisEncodingPart = guideEncodeEntry((_a3 = axisEncoding[part]) !== null && _a3 !== void 0 ? _a3 : {}, model);
    const value3 = part === "labels" ? labels2(model, channel, axisEncodingPart) : axisEncodingPart;
    if (value3 !== void 0 && !isEmpty(value3)) {
      e[part] = {update: value3};
    }
    return e;
  }, {});
  if (!isEmpty(axisEncode)) {
    axisComponent.set("encode", axisEncode, !!axis.encoding || axis.labelAngle !== void 0);
  }
  return axisComponent;
}

// node_modules/vega-lite/build/src/compile/layoutsize/init.js
function initLayoutSize({encoding, size}) {
  for (const channel of POSITION_SCALE_CHANNELS) {
    const sizeType = getSizeChannel(channel);
    if (isStep(size[sizeType])) {
      if (isContinuousFieldOrDatumDef(encoding[channel])) {
        delete size[sizeType];
        warn3(message_exports.stepDropped(sizeType));
      }
    }
  }
  return size;
}

// node_modules/vega-lite/build/src/compile/mark/init.js
function initMarkdef(mark2, encoding, config, {graticule: graticule2}) {
  const markDef = isMarkDef(mark2) ? Object.assign({}, mark2) : {type: mark2};
  const specifiedOrient = getMarkPropOrConfig("orient", markDef, config);
  markDef.orient = orient2(markDef.type, encoding, specifiedOrient);
  if (specifiedOrient !== void 0 && specifiedOrient !== markDef.orient) {
    warn3(message_exports.orientOverridden(markDef.orient, specifiedOrient));
  }
  if (markDef.type === "bar" && markDef.orient) {
    const cornerRadiusEnd = getMarkPropOrConfig("cornerRadiusEnd", markDef, config);
    if (cornerRadiusEnd !== void 0) {
      const newProps = markDef.orient === "horizontal" && encoding.x2 || markDef.orient === "vertical" && encoding.y2 ? ["cornerRadius"] : BAR_CORNER_RADIUS_INDEX[markDef.orient];
      for (const newProp of newProps) {
        markDef[newProp] = cornerRadiusEnd;
      }
      if (markDef.cornerRadiusEnd !== void 0) {
        delete markDef.cornerRadiusEnd;
      }
    }
  }
  const specifiedOpacity = getMarkPropOrConfig("opacity", markDef, config);
  if (specifiedOpacity === void 0) {
    markDef.opacity = opacity(markDef.type, encoding);
  }
  const specifiedFilled = markDef.filled;
  if (specifiedFilled === void 0) {
    markDef.filled = graticule2 ? false : filled(markDef, config);
  }
  const specifiedCursor = getMarkPropOrConfig("cursor", markDef, config);
  if (specifiedCursor === void 0) {
    markDef.cursor = cursor2(markDef, encoding, config);
  }
  return markDef;
}
function cursor2(markDef, encoding, config) {
  if (encoding.href || markDef.href || getMarkPropOrConfig("href", markDef, config)) {
    return "pointer";
  }
  return markDef.cursor;
}
function opacity(mark2, encoding) {
  if (contains2([POINT, TICK, CIRCLE, SQUARE], mark2)) {
    if (!isAggregate(encoding)) {
      return 0.7;
    }
  }
  return void 0;
}
function filled(markDef, config) {
  const filledConfig = getMarkConfig("filled", markDef, config);
  const mark2 = markDef.type;
  return getFirstDefined(filledConfig, mark2 !== POINT && mark2 !== LINE && mark2 !== RULE);
}
function orient2(mark2, encoding, specifiedOrient) {
  switch (mark2) {
    case POINT:
    case CIRCLE:
    case SQUARE:
    case TEXT:
    case RECT:
    case IMAGE:
      return void 0;
  }
  const {x: x5, y: y5, x2: x22, y2: y22} = encoding;
  switch (mark2) {
    case BAR:
      if (isFieldDef(x5) && (isBinned(x5.bin) || isFieldDef(y5) && y5.aggregate && !x5.aggregate)) {
        return "vertical";
      }
      if (isFieldDef(y5) && (isBinned(y5.bin) || isFieldDef(x5) && x5.aggregate && !y5.aggregate)) {
        return "horizontal";
      }
      if (y22 || x22) {
        if (specifiedOrient) {
          return specifiedOrient;
        }
        if (!x22) {
          if (isFieldDef(x5) && x5.type === QUANTITATIVE && !isBinning(x5.bin) || isNumericDataDef(x5)) {
            return "horizontal";
          }
        }
        if (!y22) {
          if (isFieldDef(y5) && y5.type === QUANTITATIVE && !isBinning(y5.bin) || isNumericDataDef(y5)) {
            return "vertical";
          }
        }
      }
    case RULE:
      if (x22 && !(isFieldDef(x5) && isBinned(x5.bin)) && y22 && !(isFieldDef(y5) && isBinned(y5.bin))) {
        return void 0;
      }
    case AREA:
      if (y22) {
        if (isFieldDef(y5) && isBinned(y5.bin)) {
          return "horizontal";
        } else {
          return "vertical";
        }
      } else if (x22) {
        if (isFieldDef(x5) && isBinned(x5.bin)) {
          return "vertical";
        } else {
          return "horizontal";
        }
      } else if (mark2 === RULE) {
        if (x5 && !y5) {
          return "vertical";
        } else if (y5 && !x5) {
          return "horizontal";
        }
      }
    case LINE:
    case TICK: {
      const xIsContinuous = isContinuousFieldOrDatumDef(x5);
      const yIsContinuous = isContinuousFieldOrDatumDef(y5);
      if (xIsContinuous && !yIsContinuous) {
        return mark2 !== "tick" ? "horizontal" : "vertical";
      } else if (!xIsContinuous && yIsContinuous) {
        return mark2 !== "tick" ? "vertical" : "horizontal";
      } else if (xIsContinuous && yIsContinuous) {
        const xDef = x5;
        const yDef = y5;
        const xIsTemporal = xDef.type === TEMPORAL;
        const yIsTemporal = yDef.type === TEMPORAL;
        if (xIsTemporal && !yIsTemporal) {
          return mark2 !== "tick" ? "vertical" : "horizontal";
        } else if (!xIsTemporal && yIsTemporal) {
          return mark2 !== "tick" ? "horizontal" : "vertical";
        }
        if (!xDef.aggregate && yDef.aggregate) {
          return mark2 !== "tick" ? "vertical" : "horizontal";
        } else if (xDef.aggregate && !yDef.aggregate) {
          return mark2 !== "tick" ? "horizontal" : "vertical";
        }
        if (specifiedOrient) {
          return specifiedOrient;
        }
        return "vertical";
      } else {
        if (specifiedOrient) {
          return specifiedOrient;
        }
        return void 0;
      }
    }
  }
  return "vertical";
}

// node_modules/vega-lite/build/src/compile/mark/arc.js
var arc3 = {
  vgMark: "arc",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "ignore"
    })), pointPosition("x", model, {defaultPos: "mid"})), pointPosition("y", model, {defaultPos: "mid"})), rectPosition(model, "radius", "arc")), rectPosition(model, "theta", "arc"));
  }
};

// node_modules/vega-lite/build/src/compile/mark/area.js
var area3 = {
  vgMark: "area",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "include",
      size: "ignore",
      theta: "ignore"
    })), pointOrRangePosition("x", model, {
      defaultPos: "zeroOrMin",
      defaultPos2: "zeroOrMin",
      range: model.markDef.orient === "horizontal"
    })), pointOrRangePosition("y", model, {
      defaultPos: "zeroOrMin",
      defaultPos2: "zeroOrMin",
      range: model.markDef.orient === "vertical"
    })), defined(model));
  }
};

// node_modules/vega-lite/build/src/compile/mark/bar.js
var bar = {
  vgMark: "rect",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    })), rectPosition(model, "x", "bar")), rectPosition(model, "y", "bar"));
  }
};

// node_modules/vega-lite/build/src/compile/mark/geoshape.js
var geoshape = {
  vgMark: "shape",
  encodeEntry: (model) => {
    return Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "ignore"
    }));
  },
  postEncodingTransform: (model) => {
    const {encoding} = model;
    const shapeDef = encoding.shape;
    const transform4 = Object.assign({type: "geoshape", projection: model.projectionName()}, shapeDef && isFieldDef(shapeDef) && shapeDef.type === GEOJSON ? {field: vgField(shapeDef, {expr: "datum"})} : {});
    return [transform4];
  }
};

// node_modules/vega-lite/build/src/compile/mark/image.js
var image2 = {
  vgMark: "image",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "ignore",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    })), rectPosition(model, "x", "image")), rectPosition(model, "y", "image")), text2(model, "url"));
  }
};

// node_modules/vega-lite/build/src/compile/mark/line.js
var line3 = {
  vgMark: "line",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "ignore"
    })), pointPosition("x", model, {defaultPos: "mid"})), pointPosition("y", model, {defaultPos: "mid"})), nonPosition("size", model, {
      vgChannel: "strokeWidth"
    })), defined(model));
  }
};
var trail2 = {
  vgMark: "trail",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "include",
      orient: "ignore",
      theta: "ignore"
    })), pointPosition("x", model, {defaultPos: "mid"})), pointPosition("y", model, {defaultPos: "mid"})), nonPosition("size", model)), defined(model));
  }
};

// node_modules/vega-lite/build/src/compile/mark/point.js
function encodeEntry(model, fixedShape) {
  const {config} = model;
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
    align: "ignore",
    baseline: "ignore",
    color: "include",
    size: "include",
    orient: "ignore",
    theta: "ignore"
  })), pointPosition("x", model, {defaultPos: "mid"})), pointPosition("y", model, {defaultPos: "mid"})), nonPosition("size", model)), nonPosition("angle", model)), shapeMixins(model, config, fixedShape));
}
function shapeMixins(model, config, fixedShape) {
  if (fixedShape) {
    return {shape: {value: fixedShape}};
  }
  return nonPosition("shape", model);
}
var point7 = {
  vgMark: "symbol",
  encodeEntry: (model) => {
    return encodeEntry(model);
  }
};
var circle2 = {
  vgMark: "symbol",
  encodeEntry: (model) => {
    return encodeEntry(model, "circle");
  }
};
var square = {
  vgMark: "symbol",
  encodeEntry: (model) => {
    return encodeEntry(model, "square");
  }
};

// node_modules/vega-lite/build/src/compile/mark/rect.js
var rect2 = {
  vgMark: "rect",
  encodeEntry: (model) => {
    return Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    })), rectPosition(model, "x", "rect")), rectPosition(model, "y", "rect"));
  }
};

// node_modules/vega-lite/build/src/compile/mark/rule.js
var rule3 = {
  vgMark: "rule",
  encodeEntry: (model) => {
    const {markDef} = model;
    const orient3 = markDef.orient;
    if (!model.encoding.x && !model.encoding.y && !model.encoding.latitude && !model.encoding.longitude) {
      return {};
    }
    return Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    })), pointOrRangePosition("x", model, {
      defaultPos: orient3 === "horizontal" ? "zeroOrMax" : "mid",
      defaultPos2: "zeroOrMin",
      range: orient3 !== "vertical"
    })), pointOrRangePosition("y", model, {
      defaultPos: orient3 === "vertical" ? "zeroOrMax" : "mid",
      defaultPos2: "zeroOrMin",
      range: orient3 !== "horizontal"
    })), nonPosition("size", model, {
      vgChannel: "strokeWidth"
    }));
  }
};

// node_modules/vega-lite/build/src/compile/mark/text.js
var text3 = {
  vgMark: "text",
  encodeEntry: (model) => {
    const {config, encoding} = model;
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "include",
      baseline: "include",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "include"
    })), pointPosition("x", model, {defaultPos: "mid"})), pointPosition("y", model, {defaultPos: "mid"})), text2(model)), nonPosition("size", model, {
      vgChannel: "fontSize"
    })), nonPosition("angle", model)), valueIfDefined("align", align(model.markDef, encoding, config))), valueIfDefined("baseline", baseline2(model.markDef, encoding, config))), pointPosition("radius", model, {defaultPos: null, isMidPoint: true})), pointPosition("theta", model, {defaultPos: null, isMidPoint: true}));
  }
};
function align(markDef, encoding, config) {
  const a2 = getMarkPropOrConfig("align", markDef, config);
  if (a2 === void 0) {
    return "center";
  }
  return void 0;
}
function baseline2(markDef, encoding, config) {
  const b2 = getMarkPropOrConfig("baseline", markDef, config);
  if (b2 === void 0) {
    return "middle";
  }
  return void 0;
}

// node_modules/vega-lite/build/src/compile/mark/tick.js
var tick = {
  vgMark: "rect",
  encodeEntry: (model) => {
    const {config, markDef} = model;
    const orient3 = markDef.orient;
    const vgSizeChannel = orient3 === "horizontal" ? "width" : "height";
    const vgThicknessChannel = orient3 === "horizontal" ? "height" : "width";
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    })), pointPosition("x", model, {defaultPos: "mid", vgChannel: "xc"})), pointPosition("y", model, {defaultPos: "mid", vgChannel: "yc"})), nonPosition("size", model, {
      defaultValue: defaultSize(model),
      vgChannel: vgSizeChannel
    })), {[vgThicknessChannel]: signalOrValueRef(getMarkPropOrConfig("thickness", markDef, config))});
  }
};
function defaultSize(model) {
  var _a2;
  const {config, markDef} = model;
  const {orient: orient3} = markDef;
  const vgSizeChannel = orient3 === "horizontal" ? "width" : "height";
  const scale7 = model.getScaleComponent(orient3 === "horizontal" ? "x" : "y");
  const markPropOrConfig = (_a2 = getMarkPropOrConfig("size", markDef, config, {vgChannel: vgSizeChannel})) !== null && _a2 !== void 0 ? _a2 : config.tick.bandSize;
  if (markPropOrConfig !== void 0) {
    return markPropOrConfig;
  } else {
    const scaleRange = scale7 ? scale7.get("range") : void 0;
    if (scaleRange && isVgRangeStep(scaleRange) && isNumber_default(scaleRange.step)) {
      return scaleRange.step * 3 / 4;
    }
    const defaultViewStep = getViewConfigDiscreteStep(config.view, vgSizeChannel);
    return defaultViewStep * 3 / 4;
  }
}

// node_modules/vega-lite/build/src/compile/mark/mark.js
var markCompiler = {
  arc: arc3,
  area: area3,
  bar,
  circle: circle2,
  geoshape,
  image: image2,
  line: line3,
  point: point7,
  rect: rect2,
  rule: rule3,
  square,
  text: text3,
  tick,
  trail: trail2
};
function parseMarkGroups(model) {
  if (contains2([LINE, AREA, TRAIL], model.mark)) {
    return parsePathMark(model);
  } else if (contains2([BAR], model.mark)) {
    return getStackGroups(model);
  } else {
    return getMarkGroups(model);
  }
}
var FACETED_PATH_PREFIX = "faceted_path_";
function parsePathMark(model) {
  const details = pathGroupingFields(model.mark, model.encoding);
  const pathMarks = getMarkGroups(model, {
    fromPrefix: details.length > 0 ? FACETED_PATH_PREFIX : ""
  });
  if (details.length > 0) {
    return [
      {
        name: model.getName("pathgroup"),
        type: "group",
        from: {
          facet: {
            name: FACETED_PATH_PREFIX + model.requestDataName(MAIN),
            data: model.requestDataName(MAIN),
            groupby: details
          }
        },
        encode: {
          update: {
            width: {field: {group: "width"}},
            height: {field: {group: "height"}}
          }
        },
        marks: pathMarks
      }
    ];
  } else {
    return pathMarks;
  }
}
var STACK_GROUP_PREFIX = "stack_group_";
function getStackGroups(model) {
  const hasCornerRadius2 = VG_CORNERRADIUS_CHANNELS.some((prop) => getMarkPropOrConfig(prop, model.markDef, model.config));
  if (model.stack && !model.fieldDef("size") && hasCornerRadius2) {
    const [mark2] = getMarkGroups(model, {fromPrefix: STACK_GROUP_PREFIX});
    const fieldScale = model.scaleName(model.stack.fieldChannel);
    const stackField = (opt = {}) => model.vgField(model.stack.fieldChannel, opt);
    const stackFieldGroup = (func, expr2) => {
      const vgFieldMinMax = [
        stackField({prefix: "min", suffix: "start", expr: expr2}),
        stackField({prefix: "max", suffix: "start", expr: expr2}),
        stackField({prefix: "min", suffix: "end", expr: expr2}),
        stackField({prefix: "max", suffix: "end", expr: expr2})
      ];
      return `${func}(${vgFieldMinMax.map((field4) => `scale('${fieldScale}',${field4})`).join(",")})`;
    };
    let groupUpdate;
    let innerGroupUpdate;
    if (model.stack.fieldChannel === "x") {
      groupUpdate = Object.assign(Object.assign({}, pick2(mark2.encode.update, ["y", "yc", "y2", "height", ...VG_CORNERRADIUS_CHANNELS])), {x: {signal: stackFieldGroup("min", "datum")}, x2: {signal: stackFieldGroup("max", "datum")}, clip: {value: true}});
      innerGroupUpdate = {
        x: {field: {group: "x"}, mult: -1},
        height: {field: {group: "height"}}
      };
      mark2.encode.update = Object.assign(Object.assign({}, omit(mark2.encode.update, ["y", "yc", "y2"])), {height: {field: {group: "height"}}});
    } else {
      groupUpdate = Object.assign(Object.assign({}, pick2(mark2.encode.update, ["x", "xc", "x2", "width"])), {y: {signal: stackFieldGroup("min", "datum")}, y2: {signal: stackFieldGroup("max", "datum")}, clip: {value: true}});
      innerGroupUpdate = {
        y: {field: {group: "y"}, mult: -1},
        width: {field: {group: "width"}}
      };
      mark2.encode.update = Object.assign(Object.assign({}, omit(mark2.encode.update, ["x", "xc", "x2"])), {width: {field: {group: "width"}}});
    }
    for (const key2 of VG_CORNERRADIUS_CHANNELS) {
      const configValue = getMarkConfig(key2, model.markDef, model.config);
      if (mark2.encode.update[key2]) {
        groupUpdate[key2] = mark2.encode.update[key2];
        delete mark2.encode.update[key2];
      } else if (configValue) {
        groupUpdate[key2] = signalOrValueRef(configValue);
      }
      if (configValue) {
        mark2.encode.update[key2] = {value: 0};
      }
    }
    const groupByField = model.fieldDef(model.stack.groupbyChannel);
    const groupby = vgField(groupByField) ? [vgField(groupByField)] : [];
    if ((groupByField === null || groupByField === void 0 ? void 0 : groupByField.bin) || (groupByField === null || groupByField === void 0 ? void 0 : groupByField.timeUnit)) {
      groupby.push(vgField(groupByField, {binSuffix: "end"}));
    }
    const strokeProperties = [
      "stroke",
      "strokeWidth",
      "strokeJoin",
      "strokeCap",
      "strokeDash",
      "strokeDashOffset",
      "strokeMiterLimit",
      "strokeOpacity"
    ];
    groupUpdate = strokeProperties.reduce((encode15, prop) => {
      if (mark2.encode.update[prop]) {
        return Object.assign(Object.assign({}, encode15), {[prop]: mark2.encode.update[prop]});
      } else {
        const configValue = getMarkConfig(prop, model.markDef, model.config);
        if (configValue !== void 0) {
          return Object.assign(Object.assign({}, encode15), {[prop]: signalOrValueRef(configValue)});
        } else {
          return encode15;
        }
      }
    }, groupUpdate);
    if (groupUpdate.stroke) {
      groupUpdate.strokeForeground = {value: true};
      groupUpdate.strokeOffset = {value: 0};
    }
    return [
      {
        type: "group",
        from: {
          facet: {
            data: model.requestDataName(MAIN),
            name: STACK_GROUP_PREFIX + model.requestDataName(MAIN),
            groupby,
            aggregate: {
              fields: [
                stackField({suffix: "start"}),
                stackField({suffix: "start"}),
                stackField({suffix: "end"}),
                stackField({suffix: "end"})
              ],
              ops: ["min", "max", "min", "max"]
            }
          }
        },
        encode: {
          update: groupUpdate
        },
        marks: [
          {
            type: "group",
            encode: {update: innerGroupUpdate},
            marks: [mark2]
          }
        ]
      }
    ];
  } else {
    return getMarkGroups(model);
  }
}
function getSort2(model) {
  const {encoding, stack: stack3, mark: mark2, markDef, config} = model;
  const order = encoding.order;
  if (!isArray_default(order) && isValueDef(order) && isNullOrFalse(order.value) || !order && isNullOrFalse(getMarkPropOrConfig("order", markDef, config))) {
    return void 0;
  } else if ((isArray_default(order) || isFieldDef(order)) && !stack3) {
    return sortParams(order, {expr: "datum"});
  } else if (isPathMark(mark2)) {
    const dimensionChannel = markDef.orient === "horizontal" ? "y" : "x";
    const dimensionChannelDef = encoding[dimensionChannel];
    if (isFieldDef(dimensionChannelDef)) {
      const s = dimensionChannelDef.sort;
      if (isArray_default(s)) {
        return {
          field: vgField(dimensionChannelDef, {prefix: dimensionChannel, suffix: "sort_index", expr: "datum"})
        };
      } else if (isSortField(s)) {
        return {
          field: vgField({
            aggregate: isAggregate(model.encoding) ? s.op : void 0,
            field: s.field
          }, {expr: "datum"})
        };
      } else if (isSortByEncoding(s)) {
        const fieldDefToSort = model.fieldDef(s.encoding);
        return {
          field: vgField(fieldDefToSort, {expr: "datum"}),
          order: s.order
        };
      } else if (s === null) {
        return void 0;
      } else {
        return {
          field: vgField(dimensionChannelDef, {
            binSuffix: model.stack && model.stack.impute ? "mid" : void 0,
            expr: "datum"
          })
        };
      }
    }
    return void 0;
  }
  return void 0;
}
function getMarkGroups(model, opt = {fromPrefix: ""}) {
  const {mark: mark2, markDef, config} = model;
  const clip3 = getFirstDefined(markDef.clip, scaleClip(model), projectionClip(model));
  const style2 = getStyles(markDef);
  const key2 = model.encoding.key;
  const sort2 = getSort2(model);
  const interactive2 = interactiveFlag(model);
  const aria2 = getMarkPropOrConfig("aria", markDef, config);
  const postEncodingTransform = markCompiler[mark2].postEncodingTransform ? markCompiler[mark2].postEncodingTransform(model) : null;
  return [
    Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({name: model.getName("marks"), type: markCompiler[mark2].vgMark}, clip3 ? {clip: true} : {}), style2 ? {style: style2} : {}), key2 ? {key: key2.field} : {}), sort2 ? {sort: sort2} : {}), interactive2 ? interactive2 : {}), aria2 === false ? {aria: aria2} : {}), {from: {data: opt.fromPrefix + model.requestDataName(MAIN)}, encode: {
      update: markCompiler[mark2].encodeEntry(model)
    }}), postEncodingTransform ? {
      transform: postEncodingTransform
    } : {})
  ];
}
function scaleClip(model) {
  const xScale = model.getScaleComponent("x");
  const yScale = model.getScaleComponent("y");
  return xScale && xScale.get("selectionExtent") || yScale && yScale.get("selectionExtent") ? true : void 0;
}
function projectionClip(model) {
  const projection3 = model.component.projection;
  return projection3 && !projection3.isFit ? true : void 0;
}
function interactiveFlag(model) {
  if (!model.component.selection)
    return null;
  const unitCount = keys3(model.component.selection).length;
  let parentCount = unitCount;
  let parent = model.parent;
  while (parent && parentCount === 0) {
    parentCount = keys3(parent.component.selection).length;
    parent = parent.parent;
  }
  return parentCount ? {interactive: unitCount > 0} : null;
}

// node_modules/vega-lite/build/src/compile/unit.js
var UnitModel = class extends ModelWithField {
  constructor(spec, parent, parentGivenName, parentGivenSize = {}, config) {
    var _a2, _b;
    super(spec, "unit", parent, parentGivenName, config, void 0, isFrameMixins(spec) ? spec.view : void 0);
    this.specifiedScales = {};
    this.specifiedAxes = {};
    this.specifiedLegends = {};
    this.specifiedProjection = {};
    this.selection = {};
    this.children = [];
    const mark2 = isMarkDef(spec.mark) ? spec.mark.type : spec.mark;
    this.markDef = initMarkdef(spec.mark, (_a2 = spec.encoding) !== null && _a2 !== void 0 ? _a2 : {}, config, {
      graticule: spec.data && isGraticuleGenerator(spec.data)
    });
    const encoding = this.encoding = initEncoding((_b = spec.encoding) !== null && _b !== void 0 ? _b : {}, this.markDef, config);
    this.size = initLayoutSize({
      encoding,
      size: isFrameMixins(spec) ? Object.assign(Object.assign(Object.assign({}, parentGivenSize), spec.width ? {width: spec.width} : {}), spec.height ? {height: spec.height} : {}) : parentGivenSize
    });
    this.stack = stack(mark2, encoding);
    this.specifiedScales = this.initScales(mark2, encoding);
    this.specifiedAxes = this.initAxes(encoding);
    this.specifiedLegends = this.initLegend(encoding);
    this.specifiedProjection = spec.projection;
    this.selection = spec.selection;
  }
  get hasProjection() {
    const {encoding} = this;
    const isGeoShapeMark = this.mark === GEOSHAPE;
    const hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some((channel) => isFieldOrDatumDef(encoding[channel]));
    return isGeoShapeMark || hasGeoPosition;
  }
  scaleDomain(channel) {
    const scale7 = this.specifiedScales[channel];
    return scale7 ? scale7.domain : void 0;
  }
  axis(channel) {
    return this.specifiedAxes[channel];
  }
  legend(channel) {
    return this.specifiedLegends[channel];
  }
  initScales(mark2, encoding) {
    return SCALE_CHANNELS.reduce((scales2, channel) => {
      var _a2;
      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
      if (fieldOrDatumDef) {
        scales2[channel] = (_a2 = fieldOrDatumDef.scale) !== null && _a2 !== void 0 ? _a2 : {};
      }
      return scales2;
    }, {});
  }
  initAxes(encoding) {
    return POSITION_SCALE_CHANNELS.reduce((_axis, channel) => {
      const channelDef = encoding[channel];
      if (isFieldOrDatumDef(channelDef) || channel === X3 && isFieldOrDatumDef(encoding.x2) || channel === Y3 && isFieldOrDatumDef(encoding.y2)) {
        const axisSpec = isFieldOrDatumDef(channelDef) ? channelDef.axis : void 0;
        _axis[channel] = axisSpec ? Object.assign({}, axisSpec) : axisSpec;
      }
      return _axis;
    }, {});
  }
  initLegend(encoding) {
    return NONPOSITION_SCALE_CHANNELS.reduce((_legend, channel) => {
      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
      if (fieldOrDatumDef && supportLegend(channel)) {
        const legend = fieldOrDatumDef.legend;
        _legend[channel] = legend ? Object.assign({}, legend) : legend;
      }
      return _legend;
    }, {});
  }
  parseData() {
    this.component.data = parseData2(this);
  }
  parseLayoutSize() {
    parseUnitLayoutSize(this);
  }
  parseSelections() {
    this.component.selection = parseUnitSelection(this, this.selection);
  }
  parseMarkGroup() {
    this.component.mark = parseMarkGroups(this);
  }
  parseAxesAndHeaders() {
    this.component.axes = parseUnitAxes(this);
  }
  assembleSelectionTopLevelSignals(signals) {
    return assembleTopLevelSignals(this, signals);
  }
  assembleSignals() {
    return [...assembleAxisSignals(this), ...assembleUnitSelectionSignals(this, [])];
  }
  assembleSelectionData(data4) {
    return assembleUnitSelectionData(this, data4);
  }
  assembleLayout() {
    return null;
  }
  assembleLayoutSignals() {
    return assembleLayoutSignals(this);
  }
  assembleMarks() {
    var _a2;
    let marks = (_a2 = this.component.mark) !== null && _a2 !== void 0 ? _a2 : [];
    if (!this.parent || !isLayerModel(this.parent)) {
      marks = assembleUnitSelectionMarks(this, marks);
    }
    return marks.map(this.correctDataNames);
  }
  getMapping() {
    return this.encoding;
  }
  get mark() {
    return this.markDef.type;
  }
  channelHasField(channel) {
    return channelHasField(this.encoding, channel);
  }
  fieldDef(channel) {
    const channelDef = this.encoding[channel];
    return getFieldDef(channelDef);
  }
  typedFieldDef(channel) {
    const fieldDef = this.fieldDef(channel);
    if (isTypedFieldDef(fieldDef)) {
      return fieldDef;
    }
    return null;
  }
};

// node_modules/vega-lite/build/src/compile/layer.js
var LayerModel = class extends Model {
  constructor(spec, parent, parentGivenName, parentGivenSize, config) {
    super(spec, "layer", parent, parentGivenName, config, spec.resolve, spec.view);
    const layoutSize = Object.assign(Object.assign(Object.assign({}, parentGivenSize), spec.width ? {width: spec.width} : {}), spec.height ? {height: spec.height} : {});
    this.children = spec.layer.map((layer2, i) => {
      if (isLayerSpec(layer2)) {
        return new LayerModel(layer2, this, this.getName("layer_" + i), layoutSize, config);
      } else if (isUnitSpec(layer2)) {
        return new UnitModel(layer2, this, this.getName("layer_" + i), layoutSize, config);
      }
      throw new Error(message_exports.invalidSpec(layer2));
    });
  }
  parseData() {
    this.component.data = parseData2(this);
    for (const child of this.children) {
      child.parseData();
    }
  }
  parseLayoutSize() {
    parseLayerLayoutSize(this);
  }
  parseSelections() {
    this.component.selection = {};
    for (const child of this.children) {
      child.parseSelections();
      for (const key2 of keys3(child.component.selection)) {
        this.component.selection[key2] = child.component.selection[key2];
      }
    }
  }
  parseMarkGroup() {
    for (const child of this.children) {
      child.parseMarkGroup();
    }
  }
  parseAxesAndHeaders() {
    parseLayerAxes(this);
  }
  assembleSelectionTopLevelSignals(signals) {
    return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);
  }
  assembleSignals() {
    return this.children.reduce((signals, child) => {
      return signals.concat(child.assembleSignals());
    }, assembleAxisSignals(this));
  }
  assembleLayoutSignals() {
    return this.children.reduce((signals, child) => {
      return signals.concat(child.assembleLayoutSignals());
    }, assembleLayoutSignals(this));
  }
  assembleSelectionData(data4) {
    return this.children.reduce((db, child) => child.assembleSelectionData(db), data4);
  }
  assembleTitle() {
    let title2 = super.assembleTitle();
    if (title2) {
      return title2;
    }
    for (const child of this.children) {
      title2 = child.assembleTitle();
      if (title2) {
        return title2;
      }
    }
    return void 0;
  }
  assembleLayout() {
    return null;
  }
  assembleMarks() {
    return assembleLayerSelectionMarks(this, this.children.flatMap((child) => {
      return child.assembleMarks();
    }));
  }
  assembleLegends() {
    return this.children.reduce((legends, child) => {
      return legends.concat(child.assembleLegends());
    }, assembleLegends(this));
  }
};

// node_modules/vega-lite/build/src/compile/buildmodel.js
function buildModel(spec, parent, parentGivenName, unitSize, config) {
  if (isFacetSpec(spec)) {
    return new FacetModel(spec, parent, parentGivenName, config);
  } else if (isLayerSpec(spec)) {
    return new LayerModel(spec, parent, parentGivenName, unitSize, config);
  } else if (isUnitSpec(spec)) {
    return new UnitModel(spec, parent, parentGivenName, unitSize, config);
  } else if (isAnyConcatSpec(spec)) {
    return new ConcatModel(spec, parent, parentGivenName, config);
  }
  throw new Error(message_exports.invalidSpec(spec));
}

// node_modules/vega-lite/build/src/compile/compile.js
function compile(inputSpec, opt = {}) {
  if (opt.logger) {
    set5(opt.logger);
  }
  if (opt.fieldTitle) {
    setTitleFormatter(opt.fieldTitle);
  }
  try {
    const config = initConfig(mergeConfig2(opt.config, inputSpec.config));
    const spec = normalize2(inputSpec, config);
    const model = buildModel(spec, null, "", void 0, config);
    model.parse();
    optimizeDataflow(model.component.data, model);
    const vgSpec = assembleTopLevelModel(model, getTopLevelProperties(inputSpec, spec.autosize, config, model), inputSpec.datasets, inputSpec.usermeta);
    return {
      spec: vgSpec,
      normalized: spec
    };
  } finally {
    if (opt.logger) {
      reset2();
    }
    if (opt.fieldTitle) {
      resetTitleFormatter();
    }
  }
}
function getTopLevelProperties(inputSpec, autosize, config, model) {
  const width2 = model.component.layoutSize.get("width");
  const height2 = model.component.layoutSize.get("height");
  if (autosize === void 0) {
    autosize = {type: "pad"};
    if (model.hasAxisOrientSignalRef()) {
      autosize.resize = true;
    }
  } else if (isString_default(autosize)) {
    autosize = {type: autosize};
  }
  if (width2 && height2 && isFitType(autosize.type)) {
    if (width2 === "step" && height2 === "step") {
      warn3(message_exports.droppingFit());
      autosize.type = "pad";
    } else if (width2 === "step" || height2 === "step") {
      const sizeType = width2 === "step" ? "width" : "height";
      warn3(message_exports.droppingFit(getPositionScaleChannel(sizeType)));
      const inverseSizeType = sizeType === "width" ? "height" : "width";
      autosize.type = getFitType(inverseSizeType);
    }
  }
  return Object.assign(Object.assign(Object.assign({}, keys3(autosize).length === 1 && autosize.type ? autosize.type === "pad" ? {} : {autosize: autosize.type} : {autosize}), extractTopLevelProperties(config)), extractTopLevelProperties(inputSpec));
}
function assembleTopLevelModel(model, topLevelProperties, datasets = {}, usermeta) {
  const vgConfig = model.config ? stripAndRedirectConfig(model.config) : void 0;
  const data4 = [].concat(model.assembleSelectionData([]), assembleRootData(model.component.data, datasets));
  const projections2 = model.assembleProjections();
  const title2 = model.assembleTitle();
  const style2 = model.assembleGroupStyle();
  const encodeEntry2 = model.assembleGroupEncodeEntry(true);
  let layoutSignals = model.assembleLayoutSignals();
  layoutSignals = layoutSignals.filter((signal) => {
    if ((signal.name === "width" || signal.name === "height") && signal.value !== void 0) {
      topLevelProperties[signal.name] = +signal.value;
      return false;
    }
    return true;
  });
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({$schema: "https://vega.github.io/schema/vega/v5.json"}, model.description ? {description: model.description} : {}), topLevelProperties), title2 ? {title: title2} : {}), style2 ? {style: style2} : {}), encodeEntry2 ? {encode: {update: encodeEntry2}} : {}), {data: data4}), projections2.length > 0 ? {projections: projections2} : {}), model.assembleGroup([...layoutSignals, ...model.assembleSelectionTopLevelSignals([])])), vgConfig ? {config: vgConfig} : {}), usermeta ? {usermeta} : {});
}

// node_modules/vega-lite/build/src/transformextract.js
var TransformExtractMapper = class extends SpecMapper {
  mapUnit(spec, {config}) {
    if (spec.encoding) {
      const {encoding: oldEncoding, transform: oldTransforms} = spec;
      const {bins: bins2, timeUnits: timeUnits2, aggregate, groupby, encoding} = extractTransformsFromEncoding(oldEncoding, config);
      const transform4 = [
        ...oldTransforms ? oldTransforms : [],
        ...bins2,
        ...timeUnits2,
        ...aggregate.length === 0 ? [] : [{aggregate, groupby}]
      ];
      return Object.assign(Object.assign(Object.assign({}, spec), transform4.length > 0 ? {transform: transform4} : {}), {encoding});
    } else {
      return spec;
    }
  }
};
var extractor = new TransformExtractMapper();
function extractTransforms(spec, config) {
  return extractor.map(spec, {config});
}

// node_modules/vega-lite/build/src/index.js
var version3 = package_default.version;

// node_modules/vega-embed/build/src/embed.js
var import_vega_schema_url_parser = __toModule(require_vega_schema_url_parser());

// node_modules/vega-themes/build/vega-themes.module.js
var vega_themes_module_exports = {};
__export(vega_themes_module_exports, {
  dark: () => darkTheme,
  excel: () => excelTheme,
  fivethirtyeight: () => fiveThirtyEightTheme,
  ggplot2: () => ggplot2Theme,
  googlecharts: () => googlechartsTheme,
  latimes: () => latimesTheme,
  quartz: () => quartzTheme,
  urbaninstitute: () => urbanInstituteTheme,
  version: () => version$1,
  vox: () => voxTheme
});
var name2 = "vega-themes";
var version4 = "2.10.0";
var description3 = "Themes for stylized Vega and Vega-Lite visualizations.";
var keywords3 = [
  "vega",
  "vega-lite",
  "themes",
  "style"
];
var license2 = "BSD-3-Clause";
var author2 = {
  name: "UW Interactive Data Lab",
  url: "https://idl.cs.washington.edu"
};
var contributors = [
  {
    name: "Emily Gu",
    url: "https://github.com/emilygu"
  },
  {
    name: "Arvind Satyanarayan",
    url: "http://arvindsatya.com"
  },
  {
    name: "Jeffrey Heer",
    url: "https://idl.cs.washington.edu"
  },
  {
    name: "Dominik Moritz",
    url: "https://www.domoritz.de"
  }
];
var main3 = "build/vega-themes.js";
var module2 = "build/vega-themes.module.js";
var unpkg2 = "build/vega-themes.min.js";
var jsdelivr2 = "build/vega-themes.min.js";
var types2 = "build/vega-themes.module.d.ts";
var repository2 = {
  type: "git",
  url: "https://github.com/vega/vega-themes.git"
};
var files = [
  "src",
  "build"
];
var scripts2 = {
  prebuild: "yarn clean",
  build: "rollup -c",
  clean: "rimraf build && rimraf examples/build",
  "copy:data": "rsync -r node_modules/vega-datasets/data/* examples/data",
  "copy:build": "rsync -r build/* examples/build",
  "deploy:gh": "yarn build && mkdir -p examples/build && rsync -r build/* examples/build && gh-pages -d examples",
  prepublishOnly: "yarn clean && yarn build",
  preversion: "yarn lint",
  serve: "browser-sync start -s -f build examples --serveStatic examples",
  start: "yarn build && concurrently --kill-others -n Server,Rollup 'yarn serve' 'rollup -c -w'",
  prepare: "beemo create-config",
  eslintbase: "beemo eslint .",
  format: "yarn eslintbase --fix",
  lint: "yarn eslintbase"
};
var devDependencies2 = {
  "@rollup/plugin-json": "^4.1.0",
  "@rollup/plugin-node-resolve": "^11.2.0",
  "@wessberg/rollup-plugin-ts": "^1.3.8",
  "browser-sync": "^2.26.14",
  concurrently: "^6.0.0",
  "gh-pages": "^3.1.0",
  rollup: "^2.39.1",
  "rollup-plugin-bundle-size": "^1.0.3",
  "rollup-plugin-terser": "^7.0.2",
  typescript: "^4.2.2",
  vega: "^5.19.1",
  "vega-lite": "^5.0.0",
  "vega-lite-dev-config": "^0.16.1"
};
var peerDependencies2 = {
  vega: "*",
  "vega-lite": "*"
};
var pkg = {
  name: name2,
  version: version4,
  description: description3,
  keywords: keywords3,
  license: license2,
  author: author2,
  contributors,
  main: main3,
  module: module2,
  unpkg: unpkg2,
  jsdelivr: jsdelivr2,
  types: types2,
  repository: repository2,
  files,
  scripts: scripts2,
  devDependencies: devDependencies2,
  peerDependencies: peerDependencies2
};
var lightColor = "#fff";
var medColor = "#888";
var darkTheme = {
  background: "#333",
  title: {
    color: lightColor,
    subtitleColor: lightColor
  },
  style: {
    "guide-label": {
      fill: lightColor
    },
    "guide-title": {
      fill: lightColor
    }
  },
  axis: {
    domainColor: lightColor,
    gridColor: medColor,
    tickColor: lightColor
  }
};
var markColor = "#4572a7";
var excelTheme = {
  background: "#fff",
  arc: {fill: markColor},
  area: {fill: markColor},
  line: {stroke: markColor, strokeWidth: 2},
  path: {stroke: markColor},
  rect: {fill: markColor},
  shape: {stroke: markColor},
  symbol: {fill: markColor, strokeWidth: 1.5, size: 50},
  axis: {
    bandPosition: 0.5,
    grid: true,
    gridColor: "#000000",
    gridOpacity: 1,
    gridWidth: 0.5,
    labelPadding: 10,
    tickSize: 5,
    tickWidth: 0.5
  },
  axisBand: {
    grid: false,
    tickExtra: true
  },
  legend: {
    labelBaseline: "middle",
    labelFontSize: 11,
    symbolSize: 50,
    symbolType: "square"
  },
  range: {
    category: [
      "#4572a7",
      "#aa4643",
      "#8aa453",
      "#71598e",
      "#4598ae",
      "#d98445",
      "#94aace",
      "#d09393",
      "#b9cc98",
      "#a99cbc"
    ]
  }
};
var markColor$1 = "#30a2da";
var axisColor = "#cbcbcb";
var guideLabelColor = "#999";
var guideTitleColor = "#333";
var backgroundColor = "#f0f0f0";
var blackTitle = "#333";
var fiveThirtyEightTheme = {
  arc: {fill: markColor$1},
  area: {fill: markColor$1},
  axis: {
    domainColor: axisColor,
    grid: true,
    gridColor: axisColor,
    gridWidth: 1,
    labelColor: guideLabelColor,
    labelFontSize: 10,
    titleColor: guideTitleColor,
    tickColor: axisColor,
    tickSize: 10,
    titleFontSize: 14,
    titlePadding: 10,
    labelPadding: 4
  },
  axisBand: {
    grid: false
  },
  background: backgroundColor,
  group: {
    fill: backgroundColor
  },
  legend: {
    labelColor: blackTitle,
    labelFontSize: 11,
    padding: 1,
    symbolSize: 30,
    symbolType: "square",
    titleColor: blackTitle,
    titleFontSize: 14,
    titlePadding: 10
  },
  line: {
    stroke: markColor$1,
    strokeWidth: 2
  },
  path: {stroke: markColor$1, strokeWidth: 0.5},
  rect: {fill: markColor$1},
  range: {
    category: [
      "#30a2da",
      "#fc4f30",
      "#e5ae38",
      "#6d904f",
      "#8b8b8b",
      "#b96db8",
      "#ff9e27",
      "#56cc60",
      "#52d2ca",
      "#52689e",
      "#545454",
      "#9fe4f8"
    ],
    diverging: ["#cc0020", "#e77866", "#f6e7e1", "#d6e8ed", "#91bfd9", "#1d78b5"],
    heatmap: ["#d6e8ed", "#cee0e5", "#91bfd9", "#549cc6", "#1d78b5"]
  },
  point: {
    filled: true,
    shape: "circle"
  },
  shape: {stroke: markColor$1},
  bar: {
    binSpacing: 2,
    fill: markColor$1,
    stroke: null
  },
  title: {
    anchor: "start",
    fontSize: 24,
    fontWeight: 600,
    offset: 20
  }
};
var markColor$2 = "#000";
var ggplot2Theme = {
  group: {
    fill: "#e5e5e5"
  },
  arc: {fill: markColor$2},
  area: {fill: markColor$2},
  line: {stroke: markColor$2},
  path: {stroke: markColor$2},
  rect: {fill: markColor$2},
  shape: {stroke: markColor$2},
  symbol: {fill: markColor$2, size: 40},
  axis: {
    domain: false,
    grid: true,
    gridColor: "#FFFFFF",
    gridOpacity: 1,
    labelColor: "#7F7F7F",
    labelPadding: 4,
    tickColor: "#7F7F7F",
    tickSize: 5.67,
    titleFontSize: 16,
    titleFontWeight: "normal"
  },
  legend: {
    labelBaseline: "middle",
    labelFontSize: 11,
    symbolSize: 40
  },
  range: {
    category: [
      "#000000",
      "#7F7F7F",
      "#1A1A1A",
      "#999999",
      "#333333",
      "#B0B0B0",
      "#4D4D4D",
      "#C9C9C9",
      "#666666",
      "#DCDCDC"
    ]
  }
};
var headlineFontSize = 22;
var headlineFontWeight = "normal";
var labelFont = "Benton Gothic, sans-serif";
var labelFontSize = 11.5;
var labelFontWeight = "normal";
var markColor$3 = "#82c6df";
var titleFont = "Benton Gothic Bold, sans-serif";
var titleFontWeight = "normal";
var titleFontSize = 13;
var colorSchemes = {
  "category-6": ["#ec8431", "#829eb1", "#c89d29", "#3580b1", "#adc839", "#ab7fb4"],
  "fire-7": ["#fbf2c7", "#f9e39c", "#f8d36e", "#f4bb6a", "#e68a4f", "#d15a40", "#ab4232"],
  "fireandice-6": ["#e68a4f", "#f4bb6a", "#f9e39c", "#dadfe2", "#a6b7c6", "#849eae"],
  "ice-7": ["#edefee", "#dadfe2", "#c4ccd2", "#a6b7c6", "#849eae", "#607785", "#47525d"]
};
var latimesTheme = {
  background: "#ffffff",
  title: {
    anchor: "start",
    color: "#000000",
    font: titleFont,
    fontSize: headlineFontSize,
    fontWeight: headlineFontWeight
  },
  arc: {fill: markColor$3},
  area: {fill: markColor$3},
  line: {stroke: markColor$3, strokeWidth: 2},
  path: {stroke: markColor$3},
  rect: {fill: markColor$3},
  shape: {stroke: markColor$3},
  symbol: {fill: markColor$3, size: 30},
  axis: {
    labelFont,
    labelFontSize,
    labelFontWeight,
    titleFont,
    titleFontSize,
    titleFontWeight
  },
  axisX: {
    labelAngle: 0,
    labelPadding: 4,
    tickSize: 3
  },
  axisY: {
    labelBaseline: "middle",
    maxExtent: 45,
    minExtent: 45,
    tickSize: 2,
    titleAlign: "left",
    titleAngle: 0,
    titleX: -45,
    titleY: -11
  },
  legend: {
    labelFont,
    labelFontSize,
    symbolType: "square",
    titleFont,
    titleFontSize,
    titleFontWeight
  },
  range: {
    category: colorSchemes["category-6"],
    diverging: colorSchemes["fireandice-6"],
    heatmap: colorSchemes["fire-7"],
    ordinal: colorSchemes["fire-7"],
    ramp: colorSchemes["fire-7"]
  }
};
var markColor$4 = "#ab5787";
var axisColor$1 = "#979797";
var quartzTheme = {
  background: "#f9f9f9",
  arc: {fill: markColor$4},
  area: {fill: markColor$4},
  line: {stroke: markColor$4},
  path: {stroke: markColor$4},
  rect: {fill: markColor$4},
  shape: {stroke: markColor$4},
  symbol: {fill: markColor$4, size: 30},
  axis: {
    domainColor: axisColor$1,
    domainWidth: 0.5,
    gridWidth: 0.2,
    labelColor: axisColor$1,
    tickColor: axisColor$1,
    tickWidth: 0.2,
    titleColor: axisColor$1
  },
  axisBand: {
    grid: false
  },
  axisX: {
    grid: true,
    tickSize: 10
  },
  axisY: {
    domain: false,
    grid: true,
    tickSize: 0
  },
  legend: {
    labelFontSize: 11,
    padding: 1,
    symbolSize: 30,
    symbolType: "square"
  },
  range: {
    category: [
      "#ab5787",
      "#51b2e5",
      "#703c5c",
      "#168dd9",
      "#d190b6",
      "#00609f",
      "#d365ba",
      "#154866",
      "#666666",
      "#c4c4c4"
    ]
  }
};
var markColor$5 = "#3e5c69";
var voxTheme = {
  background: "#fff",
  arc: {fill: markColor$5},
  area: {fill: markColor$5},
  line: {stroke: markColor$5},
  path: {stroke: markColor$5},
  rect: {fill: markColor$5},
  shape: {stroke: markColor$5},
  symbol: {fill: markColor$5},
  axis: {
    domainWidth: 0.5,
    grid: true,
    labelPadding: 2,
    tickSize: 5,
    tickWidth: 0.5,
    titleFontWeight: "normal"
  },
  axisBand: {
    grid: false
  },
  axisX: {
    gridWidth: 0.2
  },
  axisY: {
    gridDash: [3],
    gridWidth: 0.4
  },
  legend: {
    labelFontSize: 11,
    padding: 1,
    symbolType: "square"
  },
  range: {
    category: ["#3e5c69", "#6793a6", "#182429", "#0570b0", "#3690c0", "#74a9cf", "#a6bddb", "#e2ddf2"]
  }
};
var markColor$6 = "#1696d2";
var axisColor$2 = "#000000";
var backgroundColor$1 = "#FFFFFF";
var font2 = "Lato";
var labelFont$1 = "Lato";
var sourceFont = "Lato";
var gridColor = "#DEDDDD";
var titleFontSize$1 = 18;
var colorSchemes$1 = {
  "main-colors": ["#1696d2", "#d2d2d2", "#000000", "#fdbf11", "#ec008b", "#55b748", "#5c5859", "#db2b27"],
  "shades-blue": ["#CFE8F3", "#A2D4EC", "#73BFE2", "#46ABDB", "#1696D2", "#12719E", "#0A4C6A", "#062635"],
  "shades-gray": ["#F5F5F5", "#ECECEC", "#E3E3E3", "#DCDBDB", "#D2D2D2", "#9D9D9D", "#696969", "#353535"],
  "shades-yellow": ["#FFF2CF", "#FCE39E", "#FDD870", "#FCCB41", "#FDBF11", "#E88E2D", "#CA5800", "#843215"],
  "shades-magenta": ["#F5CBDF", "#EB99C2", "#E46AA7", "#E54096", "#EC008B", "#AF1F6B", "#761548", "#351123"],
  "shades-green": ["#DCEDD9", "#BCDEB4", "#98CF90", "#78C26D", "#55B748", "#408941", "#2C5C2D", "#1A2E19"],
  "shades-black": ["#D5D5D4", "#ADABAC", "#848081", "#5C5859", "#332D2F", "#262223", "#1A1717", "#0E0C0D"],
  "shades-red": ["#F8D5D4", "#F1AAA9", "#E9807D", "#E25552", "#DB2B27", "#A4201D", "#6E1614", "#370B0A"],
  "one-group": ["#1696d2", "#000000"],
  "two-groups-cat-1": ["#1696d2", "#000000"],
  "two-groups-cat-2": ["#1696d2", "#fdbf11"],
  "two-groups-cat-3": ["#1696d2", "#db2b27"],
  "two-groups-seq": ["#a2d4ec", "#1696d2"],
  "three-groups-cat": ["#1696d2", "#fdbf11", "#000000"],
  "three-groups-seq": ["#a2d4ec", "#1696d2", "#0a4c6a"],
  "four-groups-cat-1": ["#000000", "#d2d2d2", "#fdbf11", "#1696d2"],
  "four-groups-cat-2": ["#1696d2", "#ec0008b", "#fdbf11", "#5c5859"],
  "four-groups-seq": ["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a"],
  "five-groups-cat-1": ["#1696d2", "#fdbf11", "#d2d2d2", "#ec008b", "#000000"],
  "five-groups-cat-2": ["#1696d2", "#0a4c6a", "#d2d2d2", "#fdbf11", "#332d2f"],
  "five-groups-seq": ["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a", "#000000"],
  "six-groups-cat-1": ["#1696d2", "#ec008b", "#fdbf11", "#000000", "#d2d2d2", "#55b748"],
  "six-groups-cat-2": ["#1696d2", "#d2d2d2", "#ec008b", "#fdbf11", "#332d2f", "#0a4c6a"],
  "six-groups-seq": ["#cfe8f3", "#a2d4ec", "#73bfe2", "#46abdb", "#1696d2", "#12719e"],
  "diverging-colors": ["#ca5800", "#fdbf11", "#fdd870", "#fff2cf", "#cfe8f3", "#73bfe2", "#1696d2", "#0a4c6a"]
};
var urbanInstituteTheme = {
  background: backgroundColor$1,
  title: {
    anchor: "start",
    fontSize: titleFontSize$1,
    font: font2
  },
  axisX: {
    domain: true,
    domainColor: axisColor$2,
    domainWidth: 1,
    grid: false,
    labelFontSize: 12,
    labelFont: labelFont$1,
    labelAngle: 0,
    tickColor: axisColor$2,
    tickSize: 5,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: font2
  },
  axisY: {
    domain: false,
    domainWidth: 1,
    grid: true,
    gridColor,
    gridWidth: 1,
    labelFontSize: 12,
    labelFont: labelFont$1,
    labelPadding: 8,
    ticks: false,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: font2,
    titleAngle: 0,
    titleY: -10,
    titleX: 18
  },
  legend: {
    labelFontSize: 12,
    labelFont: labelFont$1,
    symbolSize: 100,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: font2,
    orient: "right",
    offset: 10
  },
  view: {
    stroke: "transparent"
  },
  range: {
    category: colorSchemes$1["six-groups-cat-1"],
    diverging: colorSchemes$1["diverging-colors"],
    heatmap: colorSchemes$1["diverging-colors"],
    ordinal: colorSchemes$1["six-groups-seq"],
    ramp: colorSchemes$1["shades-blue"]
  },
  area: {
    fill: markColor$6
  },
  rect: {
    fill: markColor$6
  },
  line: {
    color: markColor$6,
    stroke: markColor$6,
    strokeWidth: 5
  },
  trail: {
    color: markColor$6,
    stroke: markColor$6,
    strokeWidth: 0,
    size: 1
  },
  path: {
    stroke: markColor$6,
    strokeWidth: 0.5
  },
  point: {
    filled: true
  },
  text: {
    font: sourceFont,
    color: markColor$6,
    fontSize: 11,
    align: "center",
    fontWeight: 400,
    size: 11
  },
  style: {
    bar: {
      fill: markColor$6,
      stroke: null
    }
  },
  arc: {fill: markColor$6},
  shape: {stroke: markColor$6},
  symbol: {fill: markColor$6, size: 30}
};
var markColor$7 = "#3366CC";
var gridColor$1 = "#ccc";
var defaultFont = "Arial, sans-serif";
var googlechartsTheme = {
  arc: {fill: markColor$7},
  area: {fill: markColor$7},
  path: {stroke: markColor$7},
  rect: {fill: markColor$7},
  shape: {stroke: markColor$7},
  symbol: {stroke: markColor$7},
  circle: {fill: markColor$7},
  background: "#fff",
  padding: {
    top: 10,
    right: 10,
    bottom: 10,
    left: 10
  },
  style: {
    "guide-label": {
      font: defaultFont,
      fontSize: 12
    },
    "guide-title": {
      font: defaultFont,
      fontSize: 12
    },
    "group-title": {
      font: defaultFont,
      fontSize: 12
    }
  },
  title: {
    font: defaultFont,
    fontSize: 14,
    fontWeight: "bold",
    dy: -3,
    anchor: "start"
  },
  axis: {
    gridColor: gridColor$1,
    tickColor: gridColor$1,
    domain: false,
    grid: true
  },
  range: {
    category: [
      "#4285F4",
      "#DB4437",
      "#F4B400",
      "#0F9D58",
      "#AB47BC",
      "#00ACC1",
      "#FF7043",
      "#9E9D24",
      "#5C6BC0",
      "#F06292",
      "#00796B",
      "#C2185B"
    ],
    heatmap: ["#c6dafc", "#5e97f6", "#2a56c6"]
  }
};
var version$1 = pkg.version;

// node_modules/vega-tooltip/build/package.json
var name3 = "vega-tooltip";
var version5 = "0.23.2";
var description4 = "A tooltip plugin for Vega-Lite and Vega visualizations.";
var main4 = "build/vega-tooltip.js";
var module3 = "build/src/index.js";
var unpkg3 = "build/vega-tooltip.min.js";
var jsdelivr3 = "build/vega-tooltip.min.js";
var typings = "build/src/index.d.ts";
var repository3 = {
  type: "git",
  url: "https://github.com/vega/vega-tooltip.git"
};
var keywords4 = [
  "vega-lite",
  "vega",
  "tooltip"
];
var author3 = {
  name: "UW Interactive Data Lab",
  url: "https://idl.cs.washington.edu"
};
var collaborators2 = [
  "Dominik Moritz",
  "Sira Horradarn",
  "Zening Qu",
  "Kanit Wongsuphasawat",
  "Yuri Astrakhan",
  "Jeffrey Heer"
];
var license3 = "BSD-3-Clause";
var bugs2 = {
  url: "https://github.com/vega/vega-tooltip/issues"
};
var homepage2 = "https://github.com/vega/vega-tooltip#readme";
var scripts3 = {
  prepare: "beemo create-config --silent",
  "tsc:src": "tsc -b tsconfig.src.json",
  build: "yarn tsc:src && rollup -c",
  clean: "rm -rf build examples/data && rm -f src/style.ts",
  "copy:data": "rsync -r node_modules/vega-datasets/data/* examples/data",
  "copy:build": "rsync -r build/* examples/build",
  "deploy:gh": "yarn build && yarn copy:build && gh-pages -d examples && yarn clean",
  prettierbase: "beemo prettier 'examples/*.{html,scss,css}'",
  eslintbase: "beemo eslint .",
  format: "yarn eslintbase --fix && yarn prettierbase --write",
  lint: "yarn eslintbase && yarn prettierbase --check",
  postbuild: "terser build/vega-tooltip.js -c -m -o build/vega-tooltip.min.js",
  prebuild: "mkdir -p build && yarn copy:data && ./build-style.sh",
  prepublishOnly: "yarn clean && yarn build",
  preversion: "yarn lint",
  start: "yarn build && concurrently --kill-others -n Server,Typescript,Rollup 'browser-sync start -s -f build examples --serveStatic examples' 'yarn tsc:src -w' 'rollup -c -w'",
  pretest: "./build-style.sh",
  test: "jest"
};
var devDependencies3 = {
  "@rollup/plugin-commonjs": "13.0.0",
  "@rollup/plugin-json": "^4.1.0",
  "@rollup/plugin-node-resolve": "^8.1.0",
  "@types/jest": "^26.0.4",
  "browser-sync": "^2.26.7",
  codecov: "^3.7.0",
  concurrently: "^5.2.0",
  "gh-pages": "^3.1.0",
  jest: "^26.1.0",
  "node-sass": "^4.14.1",
  path: "^0.12.7",
  rollup: "^2.21.0",
  terser: "^4.8.0",
  "ts-jest": "^26.1.1",
  typescript: "^3.9.6",
  "vega-datasets": "^2.1.0",
  "vega-lite-dev-config": "^0.11.8",
  "vega-typings": "^0.18.0"
};
var dependencies2 = {
  "vega-util": "^1.14.1"
};
var beemo = {
  module: "vega-lite-dev-config",
  drivers: [
    "prettier",
    "eslint"
  ]
};
var jest2 = {
  testURL: "http://localhost/",
  transform: {
    "^.+\\.tsx?$": "ts-jest"
  },
  testRegex: "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
  moduleFileExtensions: [
    "ts",
    "tsx",
    "js",
    "jsx",
    "json",
    "node"
  ],
  testPathIgnorePatterns: [
    "node_modules",
    "<rootDir>/build",
    "src"
  ]
};
var package_default2 = {
  name: name3,
  version: version5,
  description: description4,
  main: main4,
  module: module3,
  unpkg: unpkg3,
  jsdelivr: jsdelivr3,
  typings,
  repository: repository3,
  keywords: keywords4,
  author: author3,
  collaborators: collaborators2,
  license: license3,
  bugs: bugs2,
  homepage: homepage2,
  scripts: scripts3,
  devDependencies: devDependencies3,
  dependencies: dependencies2,
  beemo,
  jest: jest2
};

// node_modules/vega-tooltip/build/src/style.js
var style_default = `#vg-tooltip-element {
  visibility: hidden;
  padding: 8px;
  position: fixed;
  z-index: 1000;
  font-family: sans-serif;
  font-size: 11px;
  border-radius: 3px;
  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
  /* The default theme is the light theme. */
  background-color: rgba(255, 255, 255, 0.95);
  border: 1px solid #d9d9d9;
  color: black; }
  #vg-tooltip-element.visible {
    visibility: visible; }
  #vg-tooltip-element h2 {
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 13px; }
  #vg-tooltip-element img {
    max-width: 200px;
    max-height: 200px; }
  #vg-tooltip-element table {
    border-spacing: 0; }
    #vg-tooltip-element table tr {
      border: none; }
      #vg-tooltip-element table tr td {
        overflow: hidden;
        text-overflow: ellipsis;
        padding-top: 2px;
        padding-bottom: 2px; }
        #vg-tooltip-element table tr td.key {
          color: #808080;
          max-width: 150px;
          text-align: right;
          padding-right: 4px; }
        #vg-tooltip-element table tr td.value {
          display: block;
          max-width: 300px;
          max-height: 7em;
          text-align: left; }
  #vg-tooltip-element.dark-theme {
    background-color: rgba(32, 32, 32, 0.9);
    border: 1px solid #f5f5f5;
    color: white; }
    #vg-tooltip-element.dark-theme td.key {
      color: #bfbfbf; }
`;

// node_modules/vega-tooltip/build/src/defaults.js
var EL_ID = "vg-tooltip-element";
var DEFAULT_OPTIONS = {
  offsetX: 10,
  offsetY: 10,
  id: EL_ID,
  styleId: "vega-tooltip-style",
  theme: "light",
  disableDefaultStyle: false,
  sanitize: escapeHTML,
  maxDepth: 2
};
function escapeHTML(value3) {
  return String(value3).replace(/&/g, "&amp;").replace(/</g, "&lt;");
}
function createDefaultStyle(id4) {
  if (!/^[A-Za-z]+[-:.\w]*$/.test(id4)) {
    throw new Error("Invalid HTML ID");
  }
  return style_default.toString().replace(EL_ID, id4);
}

// node_modules/vega-tooltip/build/src/formatValue.js
var __rest2 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function formatValue3(value3, valueToHtml, maxDepth2) {
  if (isArray(value3)) {
    return `[${value3.map((v) => valueToHtml(isString(v) ? v : stringify3(v, maxDepth2))).join(", ")}]`;
  }
  if (isObject(value3)) {
    let content2 = "";
    const _a2 = value3, {title: title2, image: image3} = _a2, rest = __rest2(_a2, ["title", "image"]);
    if (title2) {
      content2 += `<h2>${valueToHtml(title2)}</h2>`;
    }
    if (image3) {
      content2 += `<img src="${valueToHtml(image3)}">`;
    }
    const keys4 = Object.keys(rest);
    if (keys4.length > 0) {
      content2 += "<table>";
      for (const key2 of keys4) {
        let val = rest[key2];
        if (val === void 0) {
          continue;
        }
        if (isObject(val)) {
          val = stringify3(val, maxDepth2);
        }
        content2 += `<tr><td class="key">${valueToHtml(key2)}:</td><td class="value">${valueToHtml(val)}</td></tr>`;
      }
      content2 += `</table>`;
    }
    return content2 || "{}";
  }
  return valueToHtml(value3);
}
function replacer(maxDepth2) {
  const stack3 = [];
  return function(key2, value3) {
    if (typeof value3 !== "object" || value3 === null) {
      return value3;
    }
    const pos = stack3.indexOf(this) + 1;
    stack3.length = pos;
    if (stack3.length > maxDepth2) {
      return "[Object]";
    }
    if (stack3.indexOf(value3) >= 0) {
      return "[Circular]";
    }
    stack3.push(value3);
    return value3;
  };
}
function stringify3(obj, maxDepth2) {
  return JSON.stringify(obj, replacer(maxDepth2));
}

// node_modules/vega-tooltip/build/src/position.js
function calculatePosition(event2, tooltipBox, offsetX, offsetY) {
  let x5 = event2.clientX + offsetX;
  if (x5 + tooltipBox.width > window.innerWidth) {
    x5 = +event2.clientX - offsetX - tooltipBox.width;
  }
  let y5 = event2.clientY + offsetY;
  if (y5 + tooltipBox.height > window.innerHeight) {
    y5 = +event2.clientY - offsetY - tooltipBox.height;
  }
  return {x: x5, y: y5};
}

// node_modules/vega-tooltip/build/src/Handler.js
var Handler2 = class {
  constructor(options2) {
    this.options = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options2);
    const elementId = this.options.id;
    this.call = this.tooltipHandler.bind(this);
    if (!this.options.disableDefaultStyle && !document.getElementById(this.options.styleId)) {
      const style2 = document.createElement("style");
      style2.setAttribute("id", this.options.styleId);
      style2.innerHTML = createDefaultStyle(elementId);
      const head = document.head;
      if (head.childNodes.length > 0) {
        head.insertBefore(style2, head.childNodes[0]);
      } else {
        head.appendChild(style2);
      }
    }
    this.el = document.getElementById(elementId);
    if (!this.el) {
      this.el = document.createElement("div");
      this.el.setAttribute("id", elementId);
      this.el.classList.add("vg-tooltip");
      document.body.appendChild(this.el);
    }
  }
  tooltipHandler(handler, event2, item, value3) {
    if (value3 == null || value3 === "") {
      this.el.classList.remove("visible", `${this.options.theme}-theme`);
      return;
    }
    this.el.innerHTML = formatValue3(value3, this.options.sanitize, this.options.maxDepth);
    this.el.classList.add("visible", `${this.options.theme}-theme`);
    const {x: x5, y: y5} = calculatePosition(event2, this.el.getBoundingClientRect(), this.options.offsetX, this.options.offsetY);
    this.el.setAttribute("style", `top: ${y5}px; left: ${x5}px`);
  }
};

// node_modules/vega-tooltip/build/src/index.js
var version6 = package_default2.version;

// node_modules/vega-embed/build/src/post.js
function post_default(window2, url, data4) {
  const editor = window2.open(url);
  const wait = 1e4;
  const step = 250;
  const {origin} = new URL(url);
  let count2 = ~~(wait / step);
  function listen(evt) {
    if (evt.source === editor) {
      count2 = 0;
      window2.removeEventListener("message", listen, false);
    }
  }
  window2.addEventListener("message", listen, false);
  function send() {
    if (count2 <= 0) {
      return;
    }
    editor.postMessage(data4, origin);
    setTimeout(send, step);
    count2 -= 1;
  }
  setTimeout(send, step);
}

// node_modules/vega-embed/build/src/style.js
var style_default2 = `.vega-embed {
  position: relative;
  display: inline-block; }
  .vega-embed.has-actions {
    padding-right: 38px; }
  .vega-embed details:not([open]) > :not(summary) {
    display: none !important; }
  .vega-embed summary {
    list-style: none;
    position: absolute;
    top: 0;
    right: 0;
    padding: 6px;
    z-index: 1000;
    background: white;
    box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
    color: #1b1e23;
    border: 1px solid #aaa;
    border-radius: 999px;
    opacity: 0.2;
    transition: opacity 0.4s ease-in;
    outline: none;
    cursor: pointer;
    line-height: 0px; }
    .vega-embed summary::-webkit-details-marker {
      display: none; }
    .vega-embed summary:active {
      box-shadow: #aaa 0px 0px 0px 1px inset; }
    .vega-embed summary svg {
      width: 14px;
      height: 14px; }
  .vega-embed details[open] summary {
    opacity: 0.7; }
  .vega-embed:hover summary,
  .vega-embed:focus summary {
    opacity: 1 !important;
    transition: opacity 0.2s ease; }
  .vega-embed .vega-actions {
    position: absolute;
    z-index: 1001;
    top: 35px;
    right: -9px;
    display: flex;
    flex-direction: column;
    padding-bottom: 8px;
    padding-top: 8px;
    border-radius: 4px;
    box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.2);
    border: 1px solid #d9d9d9;
    background: white;
    animation-duration: 0.15s;
    animation-name: scale-in;
    animation-timing-function: cubic-bezier(0.2, 0, 0.13, 1.5);
    text-align: left; }
    .vega-embed .vega-actions a {
      padding: 8px 16px;
      font-family: sans-serif;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      color: #434a56;
      text-decoration: none; }
      .vega-embed .vega-actions a:hover {
        background-color: #f7f7f9;
        color: black; }
    .vega-embed .vega-actions::before, .vega-embed .vega-actions::after {
      content: "";
      display: inline-block;
      position: absolute; }
    .vega-embed .vega-actions::before {
      left: auto;
      right: 14px;
      top: -16px;
      border: 8px solid #0000;
      border-bottom-color: #d9d9d9; }
    .vega-embed .vega-actions::after {
      left: auto;
      right: 15px;
      top: -14px;
      border: 7px solid #0000;
      border-bottom-color: #fff; }

.vega-embed-wrapper {
  max-width: 100%;
  overflow: scroll;
  padding-right: 14px; }

@keyframes scale-in {
  from {
    opacity: 0;
    transform: scale(0.6); }
  to {
    opacity: 1;
    transform: scale(1); } }
`;

// node_modules/vega-embed/build/src/util.js
if (!String.prototype.startsWith) {
  String.prototype.startsWith = function(search, pos) {
    return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  };
}
function mergeDeep2(dest, ...src) {
  for (const s of src) {
    deepMerge_2(dest, s);
  }
  return dest;
}
function deepMerge_2(dest, src) {
  for (const property2 of Object.keys(src)) {
    writeConfig(dest, property2, src[property2], true);
  }
}

// node_modules/vega-embed/build/src/embed.js
var _a;
var vega = vega_module_exports;
var vegaLite = src_exports2;
var w2 = typeof window !== "undefined" ? window : void 0;
if (vegaLite === void 0 && ((_a = w2 === null || w2 === void 0 ? void 0 : w2["vl"]) === null || _a === void 0 ? void 0 : _a.compile)) {
  vegaLite = w2["vl"];
}
var DEFAULT_ACTIONS = {export: {svg: true, png: true}, source: true, compiled: true, editor: true};
var I18N = {
  CLICK_TO_VIEW_ACTIONS: "Click to view actions",
  COMPILED_ACTION: "View Compiled Vega",
  EDITOR_ACTION: "Open in Vega Editor",
  PNG_ACTION: "Save as PNG",
  SOURCE_ACTION: "View Source",
  SVG_ACTION: "Save as SVG"
};
var NAMES = {
  vega: "Vega",
  "vega-lite": "Vega-Lite"
};
var VERSION = {
  vega: vega.version,
  "vega-lite": vegaLite ? vegaLite.version : "not available"
};
var PREPROCESSOR = {
  vega: (vgSpec) => vgSpec,
  "vega-lite": (vlSpec, config) => vegaLite.compile(vlSpec, {config}).spec
};
var SVG_CIRCLES = `
<svg viewBox="0 0 16 16" fill="currentColor" stroke="none" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">
  <circle r="2" cy="8" cx="2"></circle>
  <circle r="2" cy="8" cx="8"></circle>
  <circle r="2" cy="8" cx="14"></circle>
</svg>`;
function isTooltipHandler(h3) {
  return typeof h3 === "function";
}
function viewSource(source4, sourceHeader, sourceFooter, mode) {
  const header = `<html><head>${sourceHeader}</head><body><pre><code class="json">`;
  const footer = `</code></pre>${sourceFooter}</body></html>`;
  const win = window.open("");
  win.document.write(header + source4 + footer);
  win.document.title = `${NAMES[mode]} JSON Source`;
}
function guessMode(spec, providedMode) {
  var _a2;
  if (spec.$schema) {
    const parsed = import_vega_schema_url_parser.default(spec.$schema);
    if (providedMode && providedMode !== parsed.library) {
      console.warn(`The given visualization spec is written in ${NAMES[parsed.library]}, but mode argument sets ${(_a2 = NAMES[providedMode]) !== null && _a2 !== void 0 ? _a2 : providedMode}.`);
    }
    const mode = parsed.library;
    if (!import_semver.satisfies(VERSION[mode], `^${parsed.version.slice(1)}`)) {
      console.warn(`The input spec uses ${NAMES[mode]} ${parsed.version}, but the current version of ${NAMES[mode]} is v${VERSION[mode]}.`);
    }
    return mode;
  }
  if ("mark" in spec || "encoding" in spec || "layer" in spec || "hconcat" in spec || "vconcat" in spec || "facet" in spec || "repeat" in spec) {
    return "vega-lite";
  }
  if ("marks" in spec || "signals" in spec || "scales" in spec || "axes" in spec) {
    return "vega";
  }
  return providedMode !== null && providedMode !== void 0 ? providedMode : "vega";
}
function isLoader(o) {
  return !!(o && "load" in o);
}
function embed(el, spec, opts = {}) {
  var _a2, _b, _c;
  return __awaiter(this, void 0, void 0, function* () {
    const loader2 = isLoader(opts.loader) ? opts.loader : vega.loader(opts.loader);
    const parsedSpec = isString(spec) ? JSON.parse(yield loader2.load(spec)) : spec;
    const usermetaOpts = yield loadOpts((_a2 = parsedSpec.usermeta && parsedSpec.usermeta["embedOptions"]) !== null && _a2 !== void 0 ? _a2 : {}, loader2);
    const parsedOpts = yield loadOpts(opts, loader2);
    const mergedOpts = Object.assign(Object.assign({}, mergeDeep2(parsedOpts, usermetaOpts)), {config: mergeConfig((_b = parsedOpts.config) !== null && _b !== void 0 ? _b : {}, (_c = usermetaOpts.config) !== null && _c !== void 0 ? _c : {})});
    return yield _embed(el, parsedSpec, mergedOpts, loader2);
  });
}
function loadOpts(opt, loader2) {
  var _a2;
  return __awaiter(this, void 0, void 0, function* () {
    const config = isString(opt.config) ? JSON.parse(yield loader2.load(opt.config)) : (_a2 = opt.config) !== null && _a2 !== void 0 ? _a2 : {};
    const patch2 = isString(opt.patch) ? JSON.parse(yield loader2.load(opt.patch)) : opt.patch;
    return Object.assign(Object.assign(Object.assign({}, opt), patch2 ? {patch: patch2} : {}), config ? {config} : {});
  });
}
function _embed(el, spec, opts = {}, loader2) {
  var _a2, _b, _c, _d, _e, _f;
  return __awaiter(this, void 0, void 0, function* () {
    const config = opts.theme ? mergeConfig(vega_themes_module_exports[opts.theme], (_a2 = opts.config) !== null && _a2 !== void 0 ? _a2 : {}) : opts.config;
    const actions = isBoolean(opts.actions) ? opts.actions : mergeDeep2({}, DEFAULT_ACTIONS, (_b = opts.actions) !== null && _b !== void 0 ? _b : {});
    const i18n = Object.assign(Object.assign({}, I18N), opts.i18n);
    const renderer = (_c = opts.renderer) !== null && _c !== void 0 ? _c : "canvas";
    const logLevel = (_d = opts.logLevel) !== null && _d !== void 0 ? _d : vega.Warn;
    const downloadFileName = (_e = opts.downloadFileName) !== null && _e !== void 0 ? _e : "visualization";
    if (opts.defaultStyle !== false) {
      const ID = "vega-embed-style";
      if (!document.getElementById(ID)) {
        const style2 = document.createElement("style");
        style2.id = ID;
        style2.innerText = opts.defaultStyle === void 0 || opts.defaultStyle === true ? (style_default2 !== null && style_default2 !== void 0 ? style_default2 : "").toString() : opts.defaultStyle;
        document.head.appendChild(style2);
      }
    }
    const mode = guessMode(spec, opts.mode);
    let vgSpec = PREPROCESSOR[mode](spec, config);
    if (mode === "vega-lite") {
      if (vgSpec.$schema) {
        const parsed = import_vega_schema_url_parser.default(vgSpec.$schema);
        if (!import_semver.satisfies(VERSION.vega, `^${parsed.version.slice(1)}`)) {
          console.warn(`The compiled spec uses Vega ${parsed.version}, but current version is v${VERSION.vega}.`);
        }
      }
    }
    const div = typeof el === "string" ? document.querySelector(el) : el;
    if (!div) {
      throw Error(`${el} does not exist`);
    }
    div.classList.add("vega-embed");
    if (actions) {
      div.classList.add("has-actions");
    }
    div.innerHTML = "";
    const patch2 = opts.patch;
    if (patch2) {
      if (patch2 instanceof Function) {
        vgSpec = patch2(vgSpec);
      } else {
        vgSpec = applyPatch(vgSpec, patch2, true, false).newDocument;
      }
    }
    if (opts.formatLocale) {
      vega.formatLocale(opts.formatLocale);
    }
    if (opts.timeFormatLocale) {
      vega.timeFormatLocale(opts.timeFormatLocale);
    }
    const runtime2 = vega.parse(vgSpec, mode === "vega-lite" ? {} : config);
    const view = new vega.View(runtime2, {
      loader: loader2,
      logLevel,
      renderer
    });
    if (opts.tooltip !== false) {
      let handler;
      if (isTooltipHandler(opts.tooltip)) {
        handler = opts.tooltip;
      } else {
        handler = new Handler2(opts.tooltip === true ? {} : opts.tooltip).call;
      }
      view.tooltip(handler);
    }
    let {hover: hover2} = opts;
    if (hover2 === void 0) {
      hover2 = mode === "vega";
    }
    if (hover2) {
      const {hoverSet, updateSet} = typeof hover2 === "boolean" ? {} : hover2;
      view.hover(hoverSet, updateSet);
    }
    if (opts) {
      if (opts.width != null) {
        view.width(opts.width);
      }
      if (opts.height != null) {
        view.height(opts.height);
      }
      if (opts.padding != null) {
        view.padding(opts.padding);
      }
    }
    yield view.initialize(el).runAsync();
    let documentClickHandler;
    if (actions !== false) {
      let wrapper = div;
      if (opts.defaultStyle !== false) {
        const details = document.createElement("details");
        details.title = i18n.CLICK_TO_VIEW_ACTIONS;
        div.append(details);
        wrapper = details;
        const summary = document.createElement("summary");
        summary.innerHTML = SVG_CIRCLES;
        details.append(summary);
        documentClickHandler = (ev) => {
          if (!details.contains(ev.target)) {
            details.removeAttribute("open");
          }
        };
        document.addEventListener("click", documentClickHandler);
      }
      const ctrl = document.createElement("div");
      wrapper.append(ctrl);
      ctrl.classList.add("vega-actions");
      if (actions === true || actions.export !== false) {
        for (const ext of ["svg", "png"]) {
          if (actions === true || actions.export === true || actions.export[ext]) {
            const i18nExportAction = i18n[`${ext.toUpperCase()}_ACTION`];
            const exportLink = document.createElement("a");
            exportLink.text = i18nExportAction;
            exportLink.href = "#";
            exportLink.target = "_blank";
            exportLink.download = `${downloadFileName}.${ext}`;
            exportLink.addEventListener("mousedown", function(e) {
              return __awaiter(this, void 0, void 0, function* () {
                e.preventDefault();
                const url = yield view.toImageURL(ext, opts.scaleFactor);
                this.href = url;
              });
            });
            ctrl.append(exportLink);
          }
        }
      }
      if (actions === true || actions.source !== false) {
        const viewSourceLink = document.createElement("a");
        viewSourceLink.text = i18n.SOURCE_ACTION;
        viewSourceLink.href = "#";
        viewSourceLink.addEventListener("click", function(e) {
          var _a3, _b2;
          viewSource(import_json_stringify_pretty_compact.default(spec), (_a3 = opts.sourceHeader) !== null && _a3 !== void 0 ? _a3 : "", (_b2 = opts.sourceFooter) !== null && _b2 !== void 0 ? _b2 : "", mode);
          e.preventDefault();
        });
        ctrl.append(viewSourceLink);
      }
      if (mode === "vega-lite" && (actions === true || actions.compiled !== false)) {
        const compileLink = document.createElement("a");
        compileLink.text = i18n.COMPILED_ACTION;
        compileLink.href = "#";
        compileLink.addEventListener("click", function(e) {
          var _a3, _b2;
          viewSource(import_json_stringify_pretty_compact.default(vgSpec), (_a3 = opts.sourceHeader) !== null && _a3 !== void 0 ? _a3 : "", (_b2 = opts.sourceFooter) !== null && _b2 !== void 0 ? _b2 : "", "vega");
          e.preventDefault();
        });
        ctrl.append(compileLink);
      }
      if (actions === true || actions.editor !== false) {
        const editorUrl = (_f = opts.editorUrl) !== null && _f !== void 0 ? _f : "https://vega.github.io/editor/";
        const editorLink = document.createElement("a");
        editorLink.text = i18n.EDITOR_ACTION;
        editorLink.href = "#";
        editorLink.addEventListener("click", function(e) {
          post_default(window, editorUrl, {
            config,
            mode,
            renderer,
            spec: import_json_stringify_pretty_compact.default(spec)
          });
          e.preventDefault();
        });
        ctrl.append(editorLink);
      }
    }
    function finalize2() {
      if (documentClickHandler) {
        document.removeEventListener("click", documentClickHandler);
      }
      view.finalize();
    }
    return {view, spec, vgSpec, finalize: finalize2};
  });
}

// src/util/dom.ts
var import_glamor4 = __toModule(require_lib());

// src/types.ts
/*
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function isSurfaceInfo(drawable) {
  if (drawable.name != null) {
    return true;
  }
  return false;
}
function isSurface(drawable) {
  if (drawable.drawArea instanceof HTMLElement) {
    return true;
  }
  return false;
}

// node_modules/preact/dist/preact.esm.js
function VNode() {
}
var options = {};
var stack2 = [];
var EMPTY_CHILDREN = [];
function h2(nodeName, attributes) {
  var children4 = EMPTY_CHILDREN, lastSimple, child, simple, i;
  for (i = arguments.length; i-- > 2; ) {
    stack2.push(arguments[i]);
  }
  if (attributes && attributes.children != null) {
    if (!stack2.length)
      stack2.push(attributes.children);
    delete attributes.children;
  }
  while (stack2.length) {
    if ((child = stack2.pop()) && child.pop !== void 0) {
      for (i = child.length; i--; ) {
        stack2.push(child[i]);
      }
    } else {
      if (typeof child === "boolean")
        child = null;
      if (simple = typeof nodeName !== "function") {
        if (child == null)
          child = "";
        else if (typeof child === "number")
          child = String(child);
        else if (typeof child !== "string")
          simple = false;
      }
      if (simple && lastSimple) {
        children4[children4.length - 1] += child;
      } else if (children4 === EMPTY_CHILDREN) {
        children4 = [child];
      } else {
        children4.push(child);
      }
      lastSimple = simple;
    }
  }
  var p = new VNode();
  p.nodeName = nodeName;
  p.children = children4;
  p.attributes = attributes == null ? void 0 : attributes;
  p.key = attributes == null ? void 0 : attributes.key;
  if (options.vnode !== void 0)
    options.vnode(p);
  return p;
}
function extend3(obj, props) {
  for (var i in props) {
    obj[i] = props[i];
  }
  return obj;
}
var defer = typeof Promise == "function" ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;
var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
var items = [];
function enqueueRender(component) {
  if (!component._dirty && (component._dirty = true) && items.push(component) == 1) {
    (options.debounceRendering || defer)(rerender);
  }
}
function rerender() {
  var p, list = items;
  items = [];
  while (p = list.pop()) {
    if (p._dirty)
      renderComponent(p);
  }
}
function isSameNodeType(node, vnode, hydrating2) {
  if (typeof vnode === "string" || typeof vnode === "number") {
    return node.splitText !== void 0;
  }
  if (typeof vnode.nodeName === "string") {
    return !node._componentConstructor && isNamedNode(node, vnode.nodeName);
  }
  return hydrating2 || node._componentConstructor === vnode.nodeName;
}
function isNamedNode(node, nodeName) {
  return node.normalizedNodeName === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();
}
function getNodeProps(vnode) {
  var props = extend3({}, vnode.attributes);
  props.children = vnode.children;
  var defaultProps = vnode.nodeName.defaultProps;
  if (defaultProps !== void 0) {
    for (var i in defaultProps) {
      if (props[i] === void 0) {
        props[i] = defaultProps[i];
      }
    }
  }
  return props;
}
function createNode(nodeName, isSvg) {
  var node = isSvg ? document.createElementNS("http://www.w3.org/2000/svg", nodeName) : document.createElement(nodeName);
  node.normalizedNodeName = nodeName;
  return node;
}
function removeNode(node) {
  var parentNode = node.parentNode;
  if (parentNode)
    parentNode.removeChild(node);
}
function setAccessor(node, name4, old, value3, isSvg) {
  if (name4 === "className")
    name4 = "class";
  if (name4 === "key") {
  } else if (name4 === "ref") {
    if (old)
      old(null);
    if (value3)
      value3(node);
  } else if (name4 === "class" && !isSvg) {
    node.className = value3 || "";
  } else if (name4 === "style") {
    if (!value3 || typeof value3 === "string" || typeof old === "string") {
      node.style.cssText = value3 || "";
    }
    if (value3 && typeof value3 === "object") {
      if (typeof old !== "string") {
        for (var i in old) {
          if (!(i in value3))
            node.style[i] = "";
        }
      }
      for (var i in value3) {
        node.style[i] = typeof value3[i] === "number" && IS_NON_DIMENSIONAL.test(i) === false ? value3[i] + "px" : value3[i];
      }
    }
  } else if (name4 === "dangerouslySetInnerHTML") {
    if (value3)
      node.innerHTML = value3.__html || "";
  } else if (name4[0] == "o" && name4[1] == "n") {
    var useCapture = name4 !== (name4 = name4.replace(/Capture$/, ""));
    name4 = name4.toLowerCase().substring(2);
    if (value3) {
      if (!old)
        node.addEventListener(name4, eventProxy, useCapture);
    } else {
      node.removeEventListener(name4, eventProxy, useCapture);
    }
    (node._listeners || (node._listeners = {}))[name4] = value3;
  } else if (name4 !== "list" && name4 !== "type" && !isSvg && name4 in node) {
    setProperty(node, name4, value3 == null ? "" : value3);
    if (value3 == null || value3 === false)
      node.removeAttribute(name4);
  } else {
    var ns = isSvg && name4 !== (name4 = name4.replace(/^xlink:?/, ""));
    if (value3 == null || value3 === false) {
      if (ns)
        node.removeAttributeNS("http://www.w3.org/1999/xlink", name4.toLowerCase());
      else
        node.removeAttribute(name4);
    } else if (typeof value3 !== "function") {
      if (ns)
        node.setAttributeNS("http://www.w3.org/1999/xlink", name4.toLowerCase(), value3);
      else
        node.setAttribute(name4, value3);
    }
  }
}
function setProperty(node, name4, value3) {
  try {
    node[name4] = value3;
  } catch (e) {
  }
}
function eventProxy(e) {
  return this._listeners[e.type](options.event && options.event(e) || e);
}
var mounts = [];
var diffLevel = 0;
var isSvgMode = false;
var hydrating = false;
function flushMounts() {
  var c2;
  while (c2 = mounts.pop()) {
    if (options.afterMount)
      options.afterMount(c2);
    if (c2.componentDidMount)
      c2.componentDidMount();
  }
}
function diff(dom, vnode, context3, mountAll, parent, componentRoot) {
  if (!diffLevel++) {
    isSvgMode = parent != null && parent.ownerSVGElement !== void 0;
    hydrating = dom != null && !("__preactattr_" in dom);
  }
  var ret = idiff(dom, vnode, context3, mountAll, componentRoot);
  if (parent && ret.parentNode !== parent)
    parent.appendChild(ret);
  if (!--diffLevel) {
    hydrating = false;
    if (!componentRoot)
      flushMounts();
  }
  return ret;
}
function idiff(dom, vnode, context3, mountAll, componentRoot) {
  var out = dom, prevSvgMode = isSvgMode;
  if (vnode == null || typeof vnode === "boolean")
    vnode = "";
  if (typeof vnode === "string" || typeof vnode === "number") {
    if (dom && dom.splitText !== void 0 && dom.parentNode && (!dom._component || componentRoot)) {
      if (dom.nodeValue != vnode) {
        dom.nodeValue = vnode;
      }
    } else {
      out = document.createTextNode(vnode);
      if (dom) {
        if (dom.parentNode)
          dom.parentNode.replaceChild(out, dom);
        recollectNodeTree(dom, true);
      }
    }
    out["__preactattr_"] = true;
    return out;
  }
  var vnodeName = vnode.nodeName;
  if (typeof vnodeName === "function") {
    return buildComponentFromVNode(dom, vnode, context3, mountAll);
  }
  isSvgMode = vnodeName === "svg" ? true : vnodeName === "foreignObject" ? false : isSvgMode;
  vnodeName = String(vnodeName);
  if (!dom || !isNamedNode(dom, vnodeName)) {
    out = createNode(vnodeName, isSvgMode);
    if (dom) {
      while (dom.firstChild) {
        out.appendChild(dom.firstChild);
      }
      if (dom.parentNode)
        dom.parentNode.replaceChild(out, dom);
      recollectNodeTree(dom, true);
    }
  }
  var fc = out.firstChild, props = out["__preactattr_"], vchildren = vnode.children;
  if (props == null) {
    props = out["__preactattr_"] = {};
    for (var a2 = out.attributes, i = a2.length; i--; ) {
      props[a2[i].name] = a2[i].value;
    }
  }
  if (!hydrating && vchildren && vchildren.length === 1 && typeof vchildren[0] === "string" && fc != null && fc.splitText !== void 0 && fc.nextSibling == null) {
    if (fc.nodeValue != vchildren[0]) {
      fc.nodeValue = vchildren[0];
    }
  } else if (vchildren && vchildren.length || fc != null) {
    innerDiffNode(out, vchildren, context3, mountAll, hydrating || props.dangerouslySetInnerHTML != null);
  }
  diffAttributes(out, vnode.attributes, props);
  isSvgMode = prevSvgMode;
  return out;
}
function innerDiffNode(dom, vchildren, context3, mountAll, isHydrating) {
  var originalChildren = dom.childNodes, children4 = [], keyed = {}, keyedLen = 0, min4 = 0, len = originalChildren.length, childrenLen = 0, vlen = vchildren ? vchildren.length : 0, j, c2, f, vchild, child;
  if (len !== 0) {
    for (var i = 0; i < len; i++) {
      var _child = originalChildren[i], props = _child["__preactattr_"], key2 = vlen && props ? _child._component ? _child._component.__key : props.key : null;
      if (key2 != null) {
        keyedLen++;
        keyed[key2] = _child;
      } else if (props || (_child.splitText !== void 0 ? isHydrating ? _child.nodeValue.trim() : true : isHydrating)) {
        children4[childrenLen++] = _child;
      }
    }
  }
  if (vlen !== 0) {
    for (var i = 0; i < vlen; i++) {
      vchild = vchildren[i];
      child = null;
      var key2 = vchild.key;
      if (key2 != null) {
        if (keyedLen && keyed[key2] !== void 0) {
          child = keyed[key2];
          keyed[key2] = void 0;
          keyedLen--;
        }
      } else if (!child && min4 < childrenLen) {
        for (j = min4; j < childrenLen; j++) {
          if (children4[j] !== void 0 && isSameNodeType(c2 = children4[j], vchild, isHydrating)) {
            child = c2;
            children4[j] = void 0;
            if (j === childrenLen - 1)
              childrenLen--;
            if (j === min4)
              min4++;
            break;
          }
        }
      }
      child = idiff(child, vchild, context3, mountAll);
      f = originalChildren[i];
      if (child && child !== dom && child !== f) {
        if (f == null) {
          dom.appendChild(child);
        } else if (child === f.nextSibling) {
          removeNode(f);
        } else {
          dom.insertBefore(child, f);
        }
      }
    }
  }
  if (keyedLen) {
    for (var i in keyed) {
      if (keyed[i] !== void 0)
        recollectNodeTree(keyed[i], false);
    }
  }
  while (min4 <= childrenLen) {
    if ((child = children4[childrenLen--]) !== void 0)
      recollectNodeTree(child, false);
  }
}
function recollectNodeTree(node, unmountOnly) {
  var component = node._component;
  if (component) {
    unmountComponent(component);
  } else {
    if (node["__preactattr_"] != null && node["__preactattr_"].ref)
      node["__preactattr_"].ref(null);
    if (unmountOnly === false || node["__preactattr_"] == null) {
      removeNode(node);
    }
    removeChildren(node);
  }
}
function removeChildren(node) {
  node = node.lastChild;
  while (node) {
    var next = node.previousSibling;
    recollectNodeTree(node, true);
    node = next;
  }
}
function diffAttributes(dom, attrs, old) {
  var name4;
  for (name4 in old) {
    if (!(attrs && attrs[name4] != null) && old[name4] != null) {
      setAccessor(dom, name4, old[name4], old[name4] = void 0, isSvgMode);
    }
  }
  for (name4 in attrs) {
    if (name4 !== "children" && name4 !== "innerHTML" && (!(name4 in old) || attrs[name4] !== (name4 === "value" || name4 === "checked" ? dom[name4] : old[name4]))) {
      setAccessor(dom, name4, old[name4], old[name4] = attrs[name4], isSvgMode);
    }
  }
}
var components = {};
function collectComponent(component) {
  var name4 = component.constructor.name;
  (components[name4] || (components[name4] = [])).push(component);
}
function createComponent(Ctor, props, context3) {
  var list = components[Ctor.name], inst;
  if (Ctor.prototype && Ctor.prototype.render) {
    inst = new Ctor(props, context3);
    Component.call(inst, props, context3);
  } else {
    inst = new Component(props, context3);
    inst.constructor = Ctor;
    inst.render = doRender;
  }
  if (list) {
    for (var i = list.length; i--; ) {
      if (list[i].constructor === Ctor) {
        inst.nextBase = list[i].nextBase;
        list.splice(i, 1);
        break;
      }
    }
  }
  return inst;
}
function doRender(props, state, context3) {
  return this.constructor(props, context3);
}
function setComponentProps(component, props, opts, context3, mountAll) {
  if (component._disable)
    return;
  component._disable = true;
  if (component.__ref = props.ref)
    delete props.ref;
  if (component.__key = props.key)
    delete props.key;
  if (!component.base || mountAll) {
    if (component.componentWillMount)
      component.componentWillMount();
  } else if (component.componentWillReceiveProps) {
    component.componentWillReceiveProps(props, context3);
  }
  if (context3 && context3 !== component.context) {
    if (!component.prevContext)
      component.prevContext = component.context;
    component.context = context3;
  }
  if (!component.prevProps)
    component.prevProps = component.props;
  component.props = props;
  component._disable = false;
  if (opts !== 0) {
    if (opts === 1 || options.syncComponentUpdates !== false || !component.base) {
      renderComponent(component, 1, mountAll);
    } else {
      enqueueRender(component);
    }
  }
  if (component.__ref)
    component.__ref(component);
}
function renderComponent(component, opts, mountAll, isChild) {
  if (component._disable)
    return;
  var props = component.props, state = component.state, context3 = component.context, previousProps = component.prevProps || props, previousState = component.prevState || state, previousContext = component.prevContext || context3, isUpdate = component.base, nextBase = component.nextBase, initialBase = isUpdate || nextBase, initialChildComponent = component._component, skip = false, rendered, inst, cbase;
  if (isUpdate) {
    component.props = previousProps;
    component.state = previousState;
    component.context = previousContext;
    if (opts !== 2 && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context3) === false) {
      skip = true;
    } else if (component.componentWillUpdate) {
      component.componentWillUpdate(props, state, context3);
    }
    component.props = props;
    component.state = state;
    component.context = context3;
  }
  component.prevProps = component.prevState = component.prevContext = component.nextBase = null;
  component._dirty = false;
  if (!skip) {
    rendered = component.render(props, state, context3);
    if (component.getChildContext) {
      context3 = extend3(extend3({}, context3), component.getChildContext());
    }
    var childComponent = rendered && rendered.nodeName, toUnmount, base2;
    if (typeof childComponent === "function") {
      var childProps = getNodeProps(rendered);
      inst = initialChildComponent;
      if (inst && inst.constructor === childComponent && childProps.key == inst.__key) {
        setComponentProps(inst, childProps, 1, context3, false);
      } else {
        toUnmount = inst;
        component._component = inst = createComponent(childComponent, childProps, context3);
        inst.nextBase = inst.nextBase || nextBase;
        inst._parentComponent = component;
        setComponentProps(inst, childProps, 0, context3, false);
        renderComponent(inst, 1, mountAll, true);
      }
      base2 = inst.base;
    } else {
      cbase = initialBase;
      toUnmount = initialChildComponent;
      if (toUnmount) {
        cbase = component._component = null;
      }
      if (initialBase || opts === 1) {
        if (cbase)
          cbase._component = null;
        base2 = diff(cbase, rendered, context3, mountAll || !isUpdate, initialBase && initialBase.parentNode, true);
      }
    }
    if (initialBase && base2 !== initialBase && inst !== initialChildComponent) {
      var baseParent = initialBase.parentNode;
      if (baseParent && base2 !== baseParent) {
        baseParent.replaceChild(base2, initialBase);
        if (!toUnmount) {
          initialBase._component = null;
          recollectNodeTree(initialBase, false);
        }
      }
    }
    if (toUnmount) {
      unmountComponent(toUnmount);
    }
    component.base = base2;
    if (base2 && !isChild) {
      var componentRef = component, t = component;
      while (t = t._parentComponent) {
        (componentRef = t).base = base2;
      }
      base2._component = componentRef;
      base2._componentConstructor = componentRef.constructor;
    }
  }
  if (!isUpdate || mountAll) {
    mounts.unshift(component);
  } else if (!skip) {
    if (component.componentDidUpdate) {
      component.componentDidUpdate(previousProps, previousState, previousContext);
    }
    if (options.afterUpdate)
      options.afterUpdate(component);
  }
  if (component._renderCallbacks != null) {
    while (component._renderCallbacks.length) {
      component._renderCallbacks.pop().call(component);
    }
  }
  if (!diffLevel && !isChild)
    flushMounts();
}
function buildComponentFromVNode(dom, vnode, context3, mountAll) {
  var c2 = dom && dom._component, originalComponent = c2, oldDom = dom, isDirectOwner = c2 && dom._componentConstructor === vnode.nodeName, isOwner = isDirectOwner, props = getNodeProps(vnode);
  while (c2 && !isOwner && (c2 = c2._parentComponent)) {
    isOwner = c2.constructor === vnode.nodeName;
  }
  if (c2 && isOwner && (!mountAll || c2._component)) {
    setComponentProps(c2, props, 3, context3, mountAll);
    dom = c2.base;
  } else {
    if (originalComponent && !isDirectOwner) {
      unmountComponent(originalComponent);
      dom = oldDom = null;
    }
    c2 = createComponent(vnode.nodeName, props, context3);
    if (dom && !c2.nextBase) {
      c2.nextBase = dom;
      oldDom = null;
    }
    setComponentProps(c2, props, 1, context3, mountAll);
    dom = c2.base;
    if (oldDom && dom !== oldDom) {
      oldDom._component = null;
      recollectNodeTree(oldDom, false);
    }
  }
  return dom;
}
function unmountComponent(component) {
  if (options.beforeUnmount)
    options.beforeUnmount(component);
  var base2 = component.base;
  component._disable = true;
  if (component.componentWillUnmount)
    component.componentWillUnmount();
  component.base = null;
  var inner = component._component;
  if (inner) {
    unmountComponent(inner);
  } else if (base2) {
    if (base2["__preactattr_"] && base2["__preactattr_"].ref)
      base2["__preactattr_"].ref(null);
    component.nextBase = base2;
    removeNode(base2);
    collectComponent(component);
    removeChildren(base2);
  }
  if (component.__ref)
    component.__ref(null);
}
function Component(props, context3) {
  this._dirty = true;
  this.context = context3;
  this.props = props;
  this.state = this.state || {};
}
extend3(Component.prototype, {
  setState: function setState3(state, callback) {
    var s = this.state;
    if (!this.prevState)
      this.prevState = extend3({}, s);
    extend3(s, typeof state === "function" ? state(s, this.props) : state);
    if (callback)
      (this._renderCallbacks = this._renderCallbacks || []).push(callback);
    enqueueRender(this);
  },
  forceUpdate: function forceUpdate(callback) {
    if (callback)
      (this._renderCallbacks = this._renderCallbacks || []).push(callback);
    renderComponent(this, 2);
  },
  render: function render() {
  }
});
function render2(vnode, parent, merge6) {
  return diff(merge6, vnode, {}, false, parent, false);
}

// src/components/visor.tsx
var import_glamor3 = __toModule(require_lib());

// src/components/surface.tsx
var import_glamor = __toModule(require_lib());
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var SurfaceComponent2 = class extends Component {
  componentDidMount() {
    const {name: name4, tab} = this.props;
    this.props.registerSurface(name4, tab, this);
  }
  componentDidUpdate() {
    return false;
  }
  render() {
    const {name: name4, visible, styles: styles2} = this.props;
    const finalStyles = {
      ...SurfaceComponent2.defaultStyles,
      ...styles2
    };
    const {width: width2, height: height2} = finalStyles;
    let {maxHeight, maxWidth} = finalStyles;
    maxHeight = height2 === SurfaceComponent2.defaultStyles.height ? maxHeight : height2;
    maxWidth = width2 === SurfaceComponent2.defaultStyles.width ? maxWidth : width2;
    const surfaceStyle = import_glamor.css({
      display: visible ? "block" : "none",
      backgroundColor: "white",
      marginTop: "10px",
      marginBottom: "10px",
      boxShadow: "0 0 6px -3px #777",
      padding: "10px !important",
      height: height2,
      width: width2,
      maxHeight,
      maxWidth,
      overflow: "auto"
    });
    const labelStyle = import_glamor.css({
      backgroundColor: "white",
      boxSizing: "border-box",
      borderBottom: "1px solid #357EDD",
      lineHeight: "2em",
      marginBottom: "20px",
      fontWeight: "600",
      textAlign: "center"
    });
    const drawAreaStyle = import_glamor.css({
      boxSizing: "border-box"
    });
    return /* @__PURE__ */ h2("div", {
      className: `${surfaceStyle} tf-surface`,
      ref: (r2) => this.container = r2,
      "data-visible": visible
    }, /* @__PURE__ */ h2("div", {
      className: `${labelStyle} tf-label`,
      ref: (r2) => this.label = r2
    }, name4), /* @__PURE__ */ h2("div", {
      className: `${drawAreaStyle} tf-draw-area`,
      ref: (r2) => this.drawArea = r2
    }));
  }
};
var SurfaceComponent = SurfaceComponent2;
SurfaceComponent.defaultStyles = {
  maxWidth: "550px",
  maxHeight: "580px",
  height: "auto",
  width: "auto"
};

// src/components/tabs.tsx
var import_glamor2 = __toModule(require_lib());
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var Tabs = class extends Component {
  render() {
    const {tabNames, activeTab, handleClick} = this.props;
    const tabs = tabNames.length > 0 ? tabNames.map((name4) => /* @__PURE__ */ h2(Tab, {
      key: name4,
      id: name4,
      handleClick,
      isActive: name4 === activeTab
    }, name4)) : null;
    const tabStyle = import_glamor2.css({
      overflowX: "scroll",
      overflowY: "hidden",
      whiteSpace: "nowrap",
      borderBottomStyle: "solid",
      borderBottomWidth: "1px",
      borderColor: "#eee",
      paddingBottom: "1rem",
      marginTop: "1rem"
    });
    return /* @__PURE__ */ h2("div", {
      className: `${tabStyle} visor-tabs`
    }, tabs);
  }
};
var Tab = class extends Component {
  render() {
    const {children: children4, isActive, handleClick, id: id4} = this.props;
    const tabStyle = import_glamor2.css({
      borderBottomColor: isActive ? "#357EDD" : "#AAAAAA",
      borderBottomWidth: "1px",
      borderBottomStyle: "solid",
      cursor: "pointer",
      ":hover": {
        color: "#357EDD"
      },
      display: "inline-block",
      marginRight: "1rem",
      padding: ".5rem",
      fontSize: "1rem",
      fontWeight: "bold"
    });
    return /* @__PURE__ */ h2("a", {
      className: `${tabStyle} tf-tab`,
      "data-isactive": isActive,
      onClick: () => handleClick(id4)
    }, children4);
  }
};

// src/components/visor.tsx
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var VisorComponent = class extends Component {
  static render(parent, replaceNode, props) {
    return render2(/* @__PURE__ */ h2(VisorComponent, {
      ...props
    }), parent, replaceNode);
  }
  constructor(props) {
    super(props);
    this.surfaces = new Map();
    const startOpen = props.startOpen == null ? true : props.startOpen;
    this.state = {
      isOpen: startOpen,
      isFullscreen: false,
      activeTab: null,
      tabs: new Set()
    };
    this.keyHandler = this.keyHandler.bind(this);
  }
  close() {
    this.setState({isOpen: false});
  }
  open() {
    this.setState({isOpen: true});
  }
  toggle() {
    this.setState({isOpen: !this.state.isOpen});
  }
  toggleFullScreen() {
    this.setState({isFullscreen: !this.state.isFullscreen});
  }
  isOpen() {
    return this.state.isOpen;
  }
  isFullscreen() {
    return this.state.isFullscreen;
  }
  getSurface(label, tab) {
    const surfaceId = this.surfaceId(label, tab);
    let surface;
    if (this.surfaces.has(surfaceId)) {
      surface = this.surfaces.get(surfaceId);
    } else {
      throw Error(`Surface not found with id: ${surfaceId}`);
    }
    return {
      container: surface.container,
      label: surface.label,
      drawArea: surface.drawArea
    };
  }
  bindKeys() {
    document.addEventListener("keydown", this.keyHandler, false);
  }
  unbindKeys() {
    document.removeEventListener("keydown", this.keyHandler);
  }
  surfaceId(label, tab) {
    return label + tab;
  }
  setTabs(surfaceList) {
    const nextTabs = surfaceList.map((s) => s.tab);
    const tabs = this.state.tabs;
    let newActiveTab;
    for (const tab of nextTabs) {
      if (!tabs.has(tab)) {
        tabs.add(tab);
        newActiveTab = tab;
      }
    }
    if (newActiveTab != null) {
      this.setState({
        tabs,
        activeTab: newActiveTab
      });
    }
  }
  getTabs() {
    return this.state.tabs;
  }
  registerSurface(name4, tab, surface) {
    const surfaceId = this.surfaceId(name4, tab);
    this.surfaces.set(surfaceId, surface);
  }
  keyHandler(event2) {
    const BACKTICK_KEY = 192;
    if (event2.keyCode === BACKTICK_KEY) {
      if (event2.shiftKey) {
        this.toggleFullScreen();
      } else {
        this.toggle();
      }
    }
  }
  setActiveTab(tab) {
    this.setState({activeTab: tab});
  }
  componentDidMount() {
    this.bindKeys();
  }
  componentWillMount() {
    this.setTabs(this.props.surfaceList);
  }
  componentWillReceiveProps(nextProps) {
    this.setTabs(nextProps.surfaceList);
  }
  render() {
    const {isOpen, isFullscreen, activeTab} = this.state;
    const {surfaceList} = this.props;
    const tabNames = Array.from(this.getTabs().values());
    const SMALL_WIDTH = "550px";
    const LARGE_WIDTH = "90vw";
    const width2 = isFullscreen ? LARGE_WIDTH : SMALL_WIDTH;
    const defaultStyles = import_glamor3.css({
      width: width2,
      height: "100%",
      backgroundColor: "#fafafa",
      boxSizing: "border-box",
      padding: "10px",
      position: "fixed",
      top: "0px",
      transition: `right 0.5s cubic-bezier(0.645, 0.045, 0.355, 1), width 0.5s cubic-bezier(0.645, 0.045, 0.355, 1)`,
      boxShadow: "0 2px 5px rgba(0, 0, 0, 0.12), 0 2px 5px rgba(0, 0, 0, 0.24)",
      overflow: "auto",
      fontFamily: "sans-serif",
      fontSize: "14px",
      zIndex: 1e3
    });
    const openStyle = import_glamor3.css({right: "0"});
    const closedStyle = import_glamor3.css({right: `calc(-${width2} - 10px)`});
    const position2 = isOpen ? openStyle : closedStyle;
    const surfacesContainerStyle = import_glamor3.css({});
    return /* @__PURE__ */ h2("div", {
      className: `${defaultStyles} ${position2} visor`,
      "data-isopen": isOpen,
      "data-isfullscreen": isFullscreen
    }, /* @__PURE__ */ h2(VisorControls, {
      fullScreenHandler: this.toggleFullScreen.bind(this),
      closeHandler: this.close.bind(this),
      isFullScreen: isFullscreen
    }), /* @__PURE__ */ h2(Tabs, {
      tabNames,
      activeTab,
      handleClick: this.setActiveTab.bind(this)
    }), /* @__PURE__ */ h2("div", {
      className: `${surfacesContainerStyle} visor-surfaces`
    }, surfaceList.map((surfaceInfo) => /* @__PURE__ */ h2(SurfaceComponent, {
      key: surfaceInfo.name + surfaceInfo.tab,
      name: surfaceInfo.name,
      tab: surfaceInfo.tab,
      styles: surfaceInfo.styles,
      registerSurface: this.registerSurface.bind(this),
      visible: activeTab === surfaceInfo.tab
    }))));
  }
};
function VisorControls(props) {
  const {isFullScreen, fullScreenHandler, closeHandler} = props;
  const toolBarStyle = import_glamor3.css({
    display: "flex",
    backgroundColor: "white",
    border: "1px solid white",
    padding: "6px",
    paddingTop: "10px",
    marginBottom: "10px",
    borderRadius: "6px",
    marginTop: "-16px"
  });
  const controlsButtonClass = import_glamor3.css({
    fontSize: ".875rem",
    borderRadius: ".25rem",
    paddingLeft: "1rem",
    paddingRight: "1rem",
    paddingTop: ".5rem",
    paddingBottom: ".5rem",
    textDecoration: "none",
    transition: "color .15s ease-in",
    color: "#111"
  });
  const floatRight = import_glamor3.css({
    marginLeft: "auto"
  });
  return /* @__PURE__ */ h2("div", {
    className: `${toolBarStyle} visor-controls`
  }, /* @__PURE__ */ h2("button", {
    className: `${controlsButtonClass}`,
    onClick: fullScreenHandler
  }, isFullScreen ? "Minimize" : "Maximize"), /* @__PURE__ */ h2("button", {
    className: `${controlsButtonClass} ${floatRight}`,
    onClick: closeHandler
  }, "Hide"));
}

// src/visor.ts
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var visorSingleton;
var DEFAULT_TAB = "Visor";
var VISOR_CONTAINER_ID = "tfjs-visor-container";
function visor() {
  if (typeof document === "undefined") {
    throw new Error("No document defined. This library needs a browser/dom to work");
  }
  if (document.getElementById(VISOR_CONTAINER_ID) && visorSingleton != null) {
    return visorSingleton;
  }
  let visorEl = document.getElementById(VISOR_CONTAINER_ID);
  if (visorEl == null) {
    visorEl = document.createElement("div");
    visorEl.id = VISOR_CONTAINER_ID;
    document.body.appendChild(visorEl);
  }
  let renderRoot;
  function renderVisor(domNode, surfaceList2) {
    let visorInstance = null;
    renderRoot = VisorComponent.render(domNode, renderRoot, {
      ref: (r2) => visorInstance = r2,
      surfaceList: Array.from(surfaceList2.values())
    });
    return visorInstance;
  }
  const surfaceList = new Map();
  const visorComponentInstance = renderVisor(visorEl, surfaceList);
  visorSingleton = new Visor(visorComponentInstance, visorEl, surfaceList, renderVisor);
  return visorSingleton;
}
var Visor = class {
  constructor(visorComponent, visorEl, surfaceList, renderVisor) {
    this.visorComponent = visorComponent;
    this.el = visorEl;
    this.surfaceList = surfaceList;
    this.renderVisor = renderVisor;
  }
  surface(options2) {
    const {name: name4} = options2;
    const tab = options2.tab == null ? DEFAULT_TAB : options2.tab;
    if (name4 == null || !(typeof name4 === "string" || name4 instanceof String)) {
      throw new Error("You must pass a config object with a 'name' property to create or retrieve a surface");
    }
    const finalOptions = {
      ...options2,
      tab
    };
    const key2 = `${name4}-${tab}`;
    if (!this.surfaceList.has(key2)) {
      this.surfaceList.set(key2, finalOptions);
    }
    this.renderVisor(this.el, this.surfaceList);
    return this.visorComponent.getSurface(name4, tab);
  }
  isFullscreen() {
    return this.visorComponent.isFullscreen();
  }
  isOpen() {
    return this.visorComponent.isOpen();
  }
  close() {
    return this.visorComponent.close();
  }
  open() {
    return this.visorComponent.open();
  }
  toggle() {
    return this.visorComponent.toggle();
  }
  toggleFullScreen() {
    return this.visorComponent.toggleFullScreen();
  }
  bindKeys() {
    return this.visorComponent.bindKeys();
  }
  unbindKeys() {
    return this.visorComponent.unbindKeys();
  }
  setActiveTab(tabName) {
    const tabs = this.visorComponent.state.tabs;
    if (!tabs.has(tabName)) {
      throw new Error(`Tab '${tabName}' does not exist`);
    }
    this.visorComponent.setState({activeTab: tabName});
  }
};

// src/render/render_utils.ts
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function getDrawArea(drawable) {
  if (drawable instanceof HTMLElement) {
    return drawable;
  } else if (isSurface(drawable)) {
    return drawable.drawArea;
  } else if (isSurfaceInfo(drawable)) {
    const surface = visor().surface({name: drawable.name, tab: drawable.tab, styles: drawable.styles});
    return surface.drawArea;
  } else {
    throw new Error("Not a drawable");
  }
}
function shallowEquals(a2, b2) {
  const aProps = Object.getOwnPropertyNames(a2);
  const bProps = Object.getOwnPropertyNames(b2);
  if (aProps.length !== bProps.length) {
    return false;
  }
  for (let i = 0; i < aProps.length; i++) {
    const prop = aProps[i];
    if (a2[prop] !== b2[prop]) {
      return false;
    }
  }
  return true;
}
async function nextFrame() {
  await new Promise((r2) => requestAnimationFrame(r2));
}

// src/util/dom.ts
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var DEFAULT_SUBSURFACE_OPTS = {
  prepend: false
};
function subSurface(parent, name4, opts = {}) {
  const container = getDrawArea(parent);
  const style2 = import_glamor4.css({
    "& canvas": {
      display: "block"
    },
    marginTop: ".5rem",
    marginBottom: ".5rem"
  });
  const titleStyle = import_glamor4.css({
    backgroundColor: "white",
    display: "inline-block",
    boxSizing: "border-box",
    borderBottom: "1px solid #357EDD",
    lineHeight: "2em",
    padding: "0 10px 0 10px",
    marginBottom: "20px",
    fontWeight: "600",
    textAlign: "left"
  });
  const options2 = Object.assign({}, DEFAULT_SUBSURFACE_OPTS, opts);
  let sub = container.querySelector(`div[data-name=${name4}]`);
  if (!sub) {
    sub = document.createElement("div");
    sub.setAttribute("class", `${style2}`);
    sub.dataset.name = name4;
    if (options2.title) {
      const title2 = document.createElement("div");
      title2.setAttribute("class", `subsurface-title ${titleStyle}`);
      title2.innerText = options2.title;
      sub.appendChild(title2);
    }
    if (options2.prepend) {
      container.insertBefore(sub, container.firstChild);
    } else {
      container.appendChild(sub);
    }
  }
  return sub;
}
function getDefaultWidth(element3) {
  const DEFAULT_PADDING = 50;
  let padding3 = 0;
  let current2 = element3;
  while (current2 && current2.clientWidth === 0) {
    current2 = current2.parentElement;
    padding3 = DEFAULT_PADDING;
  }
  return current2.clientWidth - padding3;
}
function getDefaultHeight(element3) {
  if (element3.clientHeight === 0) {
    return 200;
  } else {
    return element3.clientHeight;
  }
}

// src/render/barchart.ts
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function barchart(container, data4, opts = {}) {
  const drawArea = getDrawArea(container);
  const values4 = data4;
  const options2 = Object.assign({}, defaultOpts, opts);
  if (instances.has(drawArea)) {
    const instanceInfo = instances.get(drawArea);
    if (shallowEquals(options2, instanceInfo.lastOptions)) {
      await nextFrame();
      const view = instanceInfo.view;
      const changes = view.changeset().remove(() => true).insert(values4);
      await view.change("values", changes).runAsync();
      return;
    }
  }
  const {xLabel, yLabel, xType, yType} = options2;
  let xAxis = null;
  if (xLabel != null) {
    xAxis = {title: xLabel};
  }
  let yAxis = null;
  if (yLabel != null) {
    yAxis = {title: yLabel};
  }
  const embedOpts = {
    actions: false,
    mode: "vega-lite",
    defaultStyle: false
  };
  let colorEncoding;
  if (options2.color != null) {
    if (Array.isArray(options2.color)) {
      colorEncoding = {
        field: "index",
        type: "nominal",
        scale: {
          range: options2.color
        }
      };
    } else {
      colorEncoding = {value: options2.color};
    }
  } else {
    colorEncoding = {value: "#4C78A0"};
  }
  const spec = {
    width: options2.width || getDefaultWidth(drawArea),
    height: options2.height || getDefaultHeight(drawArea),
    padding: 0,
    autosize: {
      type: "fit",
      contains: "padding",
      resize: true
    },
    config: {
      axis: {
        labelFontSize: options2.fontSize,
        titleFontSize: options2.fontSize
      },
      text: {fontSize: options2.fontSize},
      legend: {
        labelFontSize: options2.fontSize,
        titleFontSize: options2.fontSize
      }
    },
    data: {values: values4, name: "values"},
    mark: {
      type: "bar",
      tooltip: true
    },
    encoding: {
      x: {field: "index", type: xType, axis: xAxis},
      y: {field: "value", type: yType, axis: yAxis},
      color: colorEncoding
    }
  };
  await nextFrame();
  const embedRes = await embed(drawArea, spec, embedOpts);
  instances.set(drawArea, {
    view: embedRes.view,
    lastOptions: options2
  });
}
var defaultOpts = {
  xLabel: "",
  yLabel: "",
  xType: "ordinal",
  yType: "quantitative",
  fontSize: 11
};
var instances = new Map();

// src/render/confusion_matrix.ts
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function confusionMatrix(container, data4, opts = {}) {
  const options2 = Object.assign({}, defaultOpts2, opts);
  const drawArea = getDrawArea(container);
  const values4 = [];
  const inputArray = data4.values;
  const tickLabels = data4.tickLabels || [];
  const generateLabels = tickLabels.length === 0;
  let nonDiagonalIsAllZeroes = true;
  for (let i = 0; i < inputArray.length; i++) {
    const label = generateLabels ? `Class ${i}` : tickLabels[i];
    if (generateLabels) {
      tickLabels.push(label);
    }
    for (let j = 0; j < inputArray[i].length; j++) {
      const prediction = generateLabels ? `Class ${j}` : tickLabels[j];
      const count2 = inputArray[i][j];
      if (i === j && !options2.shadeDiagonal) {
        values4.push({
          label,
          prediction,
          count: count2,
          noFill: true
        });
      } else {
        values4.push({
          label,
          prediction,
          count: count2,
          scaleCount: count2
        });
        if (count2 !== 0) {
          nonDiagonalIsAllZeroes = false;
        }
      }
    }
  }
  if (!options2.shadeDiagonal && nonDiagonalIsAllZeroes) {
    for (const val of values4) {
      if (val.noFill === true) {
        val.noFill = false;
        val.scaleCount = val.count;
      }
    }
  }
  const embedOpts = {
    actions: false,
    mode: "vega-lite",
    defaultStyle: false
  };
  const spec = {
    width: options2.width || getDefaultWidth(drawArea),
    height: options2.height || getDefaultHeight(drawArea),
    padding: 0,
    autosize: {
      type: "fit",
      contains: "padding",
      resize: true
    },
    config: {
      axis: {
        labelFontSize: options2.fontSize,
        titleFontSize: options2.fontSize
      },
      text: {fontSize: options2.fontSize},
      legend: {
        labelFontSize: options2.fontSize,
        titleFontSize: options2.fontSize
      }
    },
    data: {values: values4},
    encoding: {
      x: {
        field: "prediction",
        type: "ordinal",
        title: options2.xLabel || "prediction",
        scale: {domain: tickLabels}
      },
      y: {
        field: "label",
        type: "ordinal",
        title: options2.yLabel || "label",
        scale: {domain: tickLabels}
      }
    },
    layer: [
      {
        transform: [
          {filter: "datum.noFill != true"}
        ],
        mark: {
          type: "rect"
        },
        encoding: {
          color: {
            field: "scaleCount",
            type: "quantitative",
            scale: {range: options2.colorMap}
          },
          tooltip: [
            {field: "label", type: "nominal"},
            {field: "prediction", type: "nominal"},
            {field: "count", type: "quantitative"}
          ]
        }
      }
    ]
  };
  if (options2.shadeDiagonal === false) {
    spec.layer.push({
      transform: [
        {filter: "datum.noFill == true"}
      ],
      mark: {
        type: "rect",
        fill: "white"
      },
      encoding: {
        tooltip: [
          {field: "label", type: "nominal"},
          {field: "prediction", type: "nominal"},
          {field: "count", type: "quantitative"}
        ]
      }
    });
  }
  if (options2.showTextOverlay) {
    spec.layer.push({
      mark: {type: "text", baseline: "middle"},
      encoding: {
        text: {
          field: "count",
          type: "nominal"
        }
      }
    });
  }
  const colorMap = typeof options2.colorMap === "string" ? {scheme: options2.colorMap} : options2.colorMap;
  spec.layer[0].encoding.color.scale.range = colorMap;
  await embed(drawArea, spec, embedOpts);
}
var defaultOpts2 = {
  xLabel: null,
  yLabel: null,
  xType: "nominal",
  yType: "nominal",
  shadeDiagonal: true,
  fontSize: 12,
  showTextOverlay: true,
  height: 400,
  colorMap: ["#f7fbff", "#4292c6"]
};

// src/render/heatmap.ts
import {
  Tensor,
  tensor2d,
  tidy
} from "@tensorflow/tfjs-core";

// src/util/utils.ts
/*
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function assert3(expr2, msg) {
  if (!expr2) {
    throw new Error(typeof msg === "string" ? msg : msg());
  }
}
function assertShapesMatch(shapeA, shapeB, errorMessagePrefix = "") {
  assert3(arraysEqual(shapeA, shapeB), errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);
}
function arraysEqual(n1, n2) {
  if (n1.length !== n2.length) {
    return false;
  }
  for (let i = 0; i < n1.length; i++) {
    if (n1[i] !== n2[i]) {
      return false;
    }
  }
  return true;
}

// src/render/heatmap.ts
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function heatmap(container, data4, opts = {}) {
  const options2 = Object.assign({}, defaultOpts3, opts);
  const drawArea = getDrawArea(container);
  let inputValues = data4.values;
  if (options2.rowMajor) {
    inputValues = await convertToRowMajor(data4.values);
  }
  const {xTickLabels, yTickLabels} = data4;
  if (xTickLabels != null) {
    const dimension = 0;
    assertLabelsMatchShape(inputValues, xTickLabels, dimension);
  }
  if (yTickLabels != null) {
    const dimension = 1;
    assertLabelsMatchShape(inputValues, yTickLabels, dimension);
  }
  const IDX_SEPARATOR = "@tfidx@";
  const values4 = [];
  if (inputValues instanceof Tensor) {
    assert3(inputValues.rank === 2, "Input to renderHeatmap must be a 2d array or Tensor2d");
    const inputArray = await inputValues.data();
    const [numRows, numCols] = inputValues.shape;
    for (let row = 0; row < numRows; row++) {
      const x5 = xTickLabels ? `${xTickLabels[row]}${IDX_SEPARATOR}${row}` : row;
      for (let col = 0; col < numCols; col++) {
        const y5 = yTickLabels ? `${yTickLabels[col]}${IDX_SEPARATOR}${col}` : col;
        const index4 = row * numCols + col;
        const value3 = inputArray[index4];
        values4.push({x: x5, y: y5, value: value3});
      }
    }
  } else {
    const inputArray = inputValues;
    for (let row = 0; row < inputArray.length; row++) {
      const x5 = xTickLabels ? `${xTickLabels[row]}${IDX_SEPARATOR}${row}` : row;
      for (let col = 0; col < inputArray[row].length; col++) {
        const y5 = yTickLabels ? `${yTickLabels[col]}${IDX_SEPARATOR}${col}` : col;
        const value3 = inputArray[row][col];
        values4.push({x: x5, y: y5, value: value3});
      }
    }
  }
  const embedOpts = {
    actions: false,
    mode: "vega-lite",
    defaultStyle: false
  };
  const spec = {
    width: options2.width || getDefaultWidth(drawArea),
    height: options2.height || getDefaultHeight(drawArea),
    padding: 0,
    autosize: {
      type: "fit",
      contains: "padding",
      resize: true
    },
    config: {
      axis: {
        labelFontSize: options2.fontSize,
        titleFontSize: options2.fontSize
      },
      text: {fontSize: options2.fontSize},
      legend: {
        labelFontSize: options2.fontSize,
        titleFontSize: options2.fontSize
      },
      scale: {bandPaddingInner: 0, bandPaddingOuter: 0}
    },
    data: {values: values4},
    mark: {type: "rect", tooltip: true},
    encoding: {
      x: {
        field: "x",
        type: options2.xType,
        title: options2.xLabel,
        sort: false
      },
      y: {
        field: "y",
        type: options2.yType,
        title: options2.yLabel,
        sort: false
      },
      fill: {
        field: "value",
        type: "quantitative"
      }
    }
  };
  const suffixPattern = `${IDX_SEPARATOR}\\d+$`;
  const suffixRegex = new RegExp(suffixPattern);
  if (xTickLabels) {
    spec.encoding.x.axis = {
      labelExpr: `replace(datum.value, regexp(/${suffixPattern}/), '')`
    };
  }
  if (yTickLabels) {
    spec.encoding.y.axis = {
      labelExpr: `replace(datum.value, regexp(/${suffixPattern}/), '')`
    };
  }
  if (xTickLabels || yTickLabels) {
    embedOpts.tooltip = {
      sanitize: (value3) => {
        const valueString = String(value3);
        return valueString.replace(suffixRegex, "");
      }
    };
  }
  let colorRange;
  switch (options2.colorMap) {
    case "blues":
      colorRange = ["#f7fbff", "#4292c6"];
      break;
    case "greyscale":
      colorRange = ["#000000", "#ffffff"];
      break;
    case "viridis":
    default:
      colorRange = "viridis";
      break;
  }
  if (colorRange !== "viridis") {
    const fill2 = spec.encoding.fill;
    fill2.scale = {range: colorRange};
  }
  if (options2.domain) {
    const fill2 = spec.encoding.fill;
    if (fill2.scale != null) {
      fill2.scale = Object.assign({}, fill2.scale, {domain: options2.domain});
    } else {
      fill2.scale = {domain: options2.domain};
    }
  }
  await embed(drawArea, spec, embedOpts);
}
async function convertToRowMajor(inputValues) {
  let originalShape;
  let transposed;
  if (inputValues instanceof Tensor) {
    originalShape = inputValues.shape;
    transposed = inputValues.transpose();
  } else {
    originalShape = [inputValues.length, inputValues[0].length];
    transposed = tidy(() => tensor2d(inputValues).transpose());
  }
  assert3(transposed.rank === 2, "Input to renderHeatmap must be a 2d array or Tensor2d");
  const transposedValues = await transposed.array();
  transposed.dispose();
  const transposedShape = [transposedValues.length, transposedValues[0].length];
  assert3(originalShape[0] === transposedShape[1] && originalShape[1] === transposedShape[0], `Unexpected transposed shape. Original ${originalShape} : Transposed ${transposedShape}`);
  return transposedValues;
}
function assertLabelsMatchShape(inputValues, labels3, dimension) {
  const shape2 = inputValues instanceof Tensor ? inputValues.shape : [inputValues.length, inputValues[0].length];
  if (dimension === 0) {
    assert3(shape2[0] === labels3.length, `Length of xTickLabels (${labels3.length}) must match number of rows (${shape2[0]})`);
  } else if (dimension === 1) {
    assert3(shape2[1] === labels3.length, `Length of yTickLabels (${labels3.length}) must match number of columns (${shape2[1]})`);
  }
}
var defaultOpts3 = {
  xLabel: null,
  yLabel: null,
  xType: "ordinal",
  yType: "ordinal",
  colorMap: "viridis",
  fontSize: 12,
  domain: null,
  rowMajor: false
};

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default3(x5, p) {
  if ((i = (x5 = p ? x5.toExponential(p - 1) : x5.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x5.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x5.slice(i + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default3(x5) {
  return x5 = formatDecimal_default3(Math.abs(x5)), x5 ? x5[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default3(grouping, thousands) {
  return function(value3, width2) {
    var i = value3.length, t = [], j = 0, g = grouping[0], length3 = 0;
    while (i > 0 && g > 0) {
      if (length3 + g + 1 > width2)
        g = Math.max(1, width2 - length3);
      t.push(value3.substring(i -= g, i + g));
      if ((length3 += g + 1) > width2)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default3(numerals) {
  return function(value3) {
    return value3.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re3 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier3(specifier) {
  return new FormatSpecifier3(specifier);
}
formatSpecifier3.prototype = FormatSpecifier3.prototype;
function FormatSpecifier3(specifier) {
  if (!(match3 = re3.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match3;
  this.fill = match3[1] || " ";
  this.align = match3[2] || ">";
  this.sign = match3[3] || "-";
  this.symbol = match3[4] || "";
  this.zero = !!match3[5];
  this.width = match3[6] && +match3[6];
  this.comma = !!match3[7];
  this.precision = match3[8] && +match3[8].slice(1);
  this.trim = !!match3[9];
  this.type = match3[10] || "";
}
FormatSpecifier3.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width == null ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default3(s) {
  out:
    for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (i0 > 0) {
            if (!+s[i])
              break out;
            i0 = 0;
          }
          break;
      }
    }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent3;
function formatPrefixAuto_default3(x5, p) {
  var d = formatDecimal_default3(x5, p);
  if (!d)
    return x5 + "";
  var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent3 = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimal_default3(x5, Math.max(0, p + i - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default3(x5, p) {
  var d = formatDecimal_default3(x5, p);
  if (!d)
    return x5 + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default3 = {
  "%": function(x5, p) {
    return (x5 * 100).toFixed(p);
  },
  b: function(x5) {
    return Math.round(x5).toString(2);
  },
  c: function(x5) {
    return x5 + "";
  },
  d: function(x5) {
    return Math.round(x5).toString(10);
  },
  e: function(x5, p) {
    return x5.toExponential(p);
  },
  f: function(x5, p) {
    return x5.toFixed(p);
  },
  g: function(x5, p) {
    return x5.toPrecision(p);
  },
  o: function(x5) {
    return Math.round(x5).toString(8);
  },
  p: function(x5, p) {
    return formatRounded_default3(x5 * 100, p);
  },
  r: formatRounded_default3,
  s: formatPrefixAuto_default3,
  X: function(x5) {
    return Math.round(x5).toString(16).toUpperCase();
  },
  x: function(x5) {
    return Math.round(x5).toString(16);
  }
};

// node_modules/d3-format/src/identity.js
function identity_default6(x5) {
  return x5;
}

// node_modules/d3-format/src/locale.js
var prefixes3 = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default3(locale6) {
  var group2 = locale6.grouping && locale6.thousands ? formatGroup_default3(locale6.grouping, locale6.thousands) : identity_default6, currency = locale6.currency, decimal = locale6.decimal, numerals = locale6.numerals ? formatNumerals_default3(locale6.numerals) : identity_default6, percent = locale6.percent || "%";
  function newFormat(specifier) {
    specifier = formatSpecifier3(specifier);
    var fill2 = specifier.fill, align2 = specifier.align, sign3 = specifier.sign, symbol2 = specifier.symbol, zero7 = specifier.zero, width2 = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;
    if (type2 === "n")
      comma = true, type2 = "g";
    else if (!formatTypes_default3[type2])
      precision == null && (precision = 12), trim = true, type2 = "g";
    if (zero7 || fill2 === "0" && align2 === "=")
      zero7 = true, fill2 = "0", align2 = "=";
    var prefix = symbol2 === "$" ? currency[0] : symbol2 === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol2 === "$" ? currency[1] : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes_default3[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision == null ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format8(value3) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c2;
      if (type2 === "c") {
        valueSuffix = formatType(value3) + valueSuffix;
        value3 = "";
      } else {
        value3 = +value3;
        var valueNegative = value3 < 0;
        value3 = formatType(Math.abs(value3), precision);
        if (trim)
          value3 = formatTrim_default3(value3);
        if (valueNegative && +value3 === 0)
          valueNegative = false;
        valuePrefix = (valueNegative ? sign3 === "(" ? sign3 : "-" : sign3 === "-" || sign3 === "(" ? "" : sign3) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes3[8 + prefixExponent3 / 3] : "") + valueSuffix + (valueNegative && sign3 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value3.length;
          while (++i < n) {
            if (c2 = value3.charCodeAt(i), 48 > c2 || c2 > 57) {
              valueSuffix = (c2 === 46 ? decimal + value3.slice(i + 1) : value3.slice(i)) + valueSuffix;
              value3 = value3.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero7)
        value3 = group2(value3, Infinity);
      var length3 = valuePrefix.length + value3.length + valueSuffix.length, padding3 = length3 < width2 ? new Array(width2 - length3 + 1).join(fill2) : "";
      if (comma && zero7)
        value3 = group2(padding3 + value3, padding3.length ? width2 - valueSuffix.length : Infinity), padding3 = "";
      switch (align2) {
        case "<":
          value3 = valuePrefix + value3 + valueSuffix + padding3;
          break;
        case "=":
          value3 = valuePrefix + padding3 + value3 + valueSuffix;
          break;
        case "^":
          value3 = padding3.slice(0, length3 = padding3.length >> 1) + valuePrefix + value3 + valueSuffix + padding3.slice(length3);
          break;
        default:
          value3 = padding3 + valuePrefix + value3 + valueSuffix;
          break;
      }
      return numerals(value3);
    }
    format8.toString = function() {
      return specifier + "";
    };
    return format8;
  }
  function formatPrefix4(specifier, value3) {
    var f = newFormat((specifier = formatSpecifier3(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default3(value3) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes3[8 + e / 3];
    return function(value4) {
      return f(k * value4) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix4
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale5;
var format7;
var formatPrefix3;
defaultLocale5({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale5(definition3) {
  locale5 = locale_default3(definition3);
  format7 = locale5.format;
  formatPrefix3 = locale5.formatPrefix;
  return locale5;
}

// src/util/math.ts
import {dispose, maximum, scalar, tidy as tidy2} from "@tensorflow/tfjs-core";
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function arrayStats(input) {
  if (!Array.isArray(input)) {
    throw new Error("input must be an array");
  }
  if (input.length === 0) {
    return {
      numVals: 0,
      numNans: 0,
      numZeros: 0,
      max: void 0,
      min: void 0
    };
  }
  const numVals = input.length;
  let max4 = -Infinity;
  let min4 = Infinity;
  let numZeros = 0;
  let numNans = 0;
  let numInfs = 0;
  for (let i = 0; i < numVals; i++) {
    const curr = input[i];
    if (curr > max4) {
      max4 = curr;
    }
    if (curr < min4) {
      min4 = curr;
    }
    if (curr === 0) {
      numZeros += 1;
    }
    if (isNaN(curr)) {
      numNans += 1;
    } else if (!isFinite(curr)) {
      numInfs += 1;
    }
  }
  const result = {
    numVals,
    numZeros,
    numNans,
    max: max4,
    min: min4,
    numInfs
  };
  if (result.max === -Infinity) {
    result.max = NaN;
  }
  if (result.min === Infinity) {
    result.min = NaN;
  }
  return result;
}
async function tensorStats(input) {
  const [min4, max4, numZeros] = tidy2(() => {
    const zero7 = scalar(0, input.dtype);
    const min5 = input.min();
    const max5 = input.max();
    const numZeros2 = input.equal(zero7).sum();
    return [min5, max5, numZeros2];
  });
  return Promise.all([input.data(), min4.data(), max4.data(), numZeros.data()]).then(([tensorVal, minVal, maxVal, numZerosVal]) => {
    const numVals = tensorVal.length;
    let numNans = 0;
    let numInfs = 0;
    for (let i = 0; i < numVals; i++) {
      const curr = tensorVal[i];
      if (isNaN(curr)) {
        numNans += 1;
      } else if (!isFinite(curr)) {
        numInfs += 1;
      }
    }
    let trueMin = minVal[0];
    let trueMax = maxVal[0];
    if (numNans === numVals) {
      trueMin = NaN;
      trueMax = NaN;
    }
    const stats = {
      numVals,
      numZeros: numZerosVal[0],
      numNans,
      min: trueMin,
      max: trueMax,
      numInfs
    };
    return stats;
  });
}
async function confusionMatrix2(labels3, predictions, numClasses, weights) {
  assert3(labels3.rank === 1, "labels must be a 1D tensor");
  assert3(predictions.rank === 1, "predictions must be a 1D tensor");
  assert3(labels3.size === predictions.size, "labels and predictions must be the same length");
  if (weights != null) {
    assert3(weights.size === predictions.size, "labels and predictions must be the same length");
  }
  const labelsInt = labels3.cast("int32");
  const predictionsInt = predictions.cast("int32");
  if (numClasses == null) {
    numClasses = tidy2(() => {
      const max4 = maximum(labelsInt.max(), predictionsInt.max()).cast("int32");
      return max4.dataSync()[0] + 1;
    });
  }
  let weightsPromise = Promise.resolve(null);
  if (weights != null) {
    weightsPromise = weights.data();
  }
  return Promise.all([labelsInt.data(), predictionsInt.data(), weightsPromise]).then(([labelsArray, predsArray, weightsArray]) => {
    const result = Array(numClasses).fill(0);
    for (let i = 0; i < numClasses; i++) {
      result[i] = Array(numClasses).fill(0);
    }
    for (let i = 0; i < labelsArray.length; i++) {
      const label = labelsArray[i];
      const pred = predsArray[i];
      if (weightsArray != null) {
        result[label][pred] += weightsArray[i];
      } else {
        result[label][pred] += 1;
      }
    }
    return result;
  });
}
async function accuracy(labels3, predictions) {
  assertShapesMatch(labels3.shape, predictions.shape, "Error computing accuracy.");
  const eq = labels3.equal(predictions);
  const mean2 = eq.mean();
  const acc = (await mean2.data())[0];
  dispose([eq, mean2]);
  return acc;
}
async function perClassAccuracy(labels3, predictions, numClasses) {
  assert3(labels3.rank === 1, "labels must be a 1D tensor");
  assert3(predictions.rank === 1, "predictions must be a 1D tensor");
  assert3(labels3.size === predictions.size, "labels and predictions must be the same length");
  if (numClasses == null) {
    numClasses = tidy2(() => {
      return maximum(labels3.max(), predictions.max()).dataSync()[0] + 1;
    });
  }
  return Promise.all([labels3.data(), predictions.data()]).then(([labelsArray, predsArray]) => {
    const counts = Array(numClasses).fill(0);
    const accuracy2 = Array(numClasses).fill(0);
    for (let i = 0; i < labelsArray.length; i++) {
      const label = labelsArray[i];
      const pred = predsArray[i];
      counts[label] += 1;
      if (label === pred) {
        accuracy2[label] += 1;
      }
    }
    const results = [];
    for (let i = 0; i < counts.length; i++) {
      results.push({
        count: counts[i],
        accuracy: counts[i] === 0 ? 0 : accuracy2[i] / counts[i]
      });
    }
    return results;
  });
}

// node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces_default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/d3-selection/src/namespace.js
function namespace_default(name4) {
  var prefix = name4 += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name4.slice(0, i)) !== "xmlns")
    name4 = name4.slice(i + 1);
  return namespaces_default.hasOwnProperty(prefix) ? {space: namespaces_default[prefix], local: name4} : name4;
}

// node_modules/d3-selection/src/creator.js
function creatorInherit(name4) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name4) : document2.createElementNS(uri, name4);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name4) {
  var fullname = namespace_default(name4);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

// node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

// node_modules/d3-selection/src/selection/select.js
function select_default(select2) {
  if (typeof select2 !== "function")
    select2 = selector_default(select2);
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
    for (var group2 = groups[j], n = group2.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group2[i]) && (subnode = select2.call(node, node.__data__, i, group2))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/selectorAll.js
function empty2() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty2 : function() {
    return this.querySelectorAll(selector);
  };
}

// node_modules/d3-selection/src/selection/selectAll.js
function selectAll_default(select2) {
  if (typeof select2 !== "function")
    select2 = selectorAll_default(select2);
  for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j = 0; j < m2; ++j) {
    for (var group2 = groups[j], n = group2.length, node, i = 0; i < n; ++i) {
      if (node = group2[i]) {
        subgroups.push(select2.call(node, node.__data__, i, group2));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}

// node_modules/d3-selection/src/matcher.js
var matcher = function(selector) {
  return function() {
    return this.matches(selector);
  };
};
if (typeof document !== "undefined") {
  element3 = document.documentElement;
  if (!element3.matches) {
    vendorMatches = element3.webkitMatchesSelector || element3.msMatchesSelector || element3.mozMatchesSelector || element3.oMatchesSelector;
    matcher = function(selector) {
      return function() {
        return vendorMatches.call(this, selector);
      };
    };
  }
}
var element3;
var vendorMatches;
var matcher_default = matcher;

// node_modules/d3-selection/src/selection/filter.js
function filter_default(match3) {
  if (typeof match3 !== "function")
    match3 = matcher_default(match3);
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
    for (var group2 = groups[j], n = group2.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group2[i]) && match3.call(node, node.__data__, i, group2)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update3) {
  return new Array(update3.length);
}

// node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum3) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum3;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

// node_modules/d3-selection/src/constant.js
function constant_default6(x5) {
  return function() {
    return x5;
  };
}

// node_modules/d3-selection/src/selection/data.js
var keyPrefix = "$";
function bindIndex(parent, group2, enter, update3, exit, data4) {
  var i = 0, node, groupLength = group2.length, dataLength = data4.length;
  for (; i < dataLength; ++i) {
    if (node = group2[i]) {
      node.__data__ = data4[i];
      update3[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data4[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group2[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group2, enter, update3, exit, data4, key2) {
  var i, node, nodeByKeyValue = {}, groupLength = group2.length, dataLength = data4.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group2[i]) {
      keyValues[i] = keyValue = keyPrefix + key2.call(node, node.__data__, i, group2);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key2.call(parent, data4[i], i, data4);
    if (node = nodeByKeyValue[keyValue]) {
      update3[i] = node;
      node.__data__ = data4[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data4[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group2[i]) && nodeByKeyValue[keyValues[i]] === node) {
      exit[i] = node;
    }
  }
}
function data_default2(value3, key2) {
  if (!value3) {
    data4 = new Array(this.size()), j = -1;
    this.each(function(d) {
      data4[++j] = d;
    });
    return data4;
  }
  var bind3 = key2 ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value3 !== "function")
    value3 = constant_default6(value3);
  for (var m2 = groups.length, update3 = new Array(m2), enter = new Array(m2), exit = new Array(m2), j = 0; j < m2; ++j) {
    var parent = parents[j], group2 = groups[j], groupLength = group2.length, data4 = value3.call(parent, parent && parent.__data__, j, parents), dataLength = data4.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update3[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind3(parent, group2, enterGroup, updateGroup, exitGroup, data4, key2);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update3 = new Selection(update3, parents);
  update3._enter = enter;
  update3._exit = exit;
  return update3;
}

// node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}

// node_modules/d3-selection/src/selection/merge.js
function merge_default3(selection2) {
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m2; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge6 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge6[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection(merges, this._parents);
}

// node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups = this._groups, j = -1, m2 = groups.length; ++j < m2; ) {
    for (var group2 = groups[j], i = group2.length - 1, next = group2[i], node; --i >= 0; ) {
      if (node = group2[i]) {
        if (next && next !== node.nextSibling)
          next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/sort.js
function sort_default2(compare4) {
  if (!compare4)
    compare4 = ascending4;
  function compareNode(a2, b2) {
    return a2 && b2 ? compare4(a2.__data__, b2.__data__) : !a2 - !b2;
  }
  for (var groups = this._groups, m2 = groups.length, sortgroups = new Array(m2), j = 0; j < m2; ++j) {
    for (var group2 = groups[j], n = group2.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group2[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending4(a2, b2) {
  return a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
}

// node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

// node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() {
    nodes[++i] = this;
  });
  return nodes;
}

// node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j) {
    for (var group2 = groups[j], i = 0, n = group2.length; i < n; ++i) {
      var node = group2[i];
      if (node)
        return node;
    }
  }
  return null;
}

// node_modules/d3-selection/src/selection/size.js
function size_default2() {
  var size = 0;
  this.each(function() {
    ++size;
  });
  return size;
}

// node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}

// node_modules/d3-selection/src/selection/each.js
function each_default2(callback) {
  for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j) {
    for (var group2 = groups[j], i = 0, n = group2.length, node; i < n; ++i) {
      if (node = group2[i])
        callback.call(node, node.__data__, i, group2);
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/attr.js
function attrRemove(name4) {
  return function() {
    this.removeAttribute(name4);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name4, value3) {
  return function() {
    this.setAttribute(name4, value3);
  };
}
function attrConstantNS(fullname, value3) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value3);
  };
}
function attrFunction(name4, value3) {
  return function() {
    var v = value3.apply(this, arguments);
    if (v == null)
      this.removeAttribute(name4);
    else
      this.setAttribute(name4, v);
  };
}
function attrFunctionNS(fullname, value3) {
  return function() {
    var v = value3.apply(this, arguments);
    if (v == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function attr_default(name4, value3) {
  var fullname = namespace_default(name4);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value3 == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value3 === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value3));
}

// node_modules/d3-selection/src/window.js
function window_default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}

// node_modules/d3-selection/src/selection/style.js
function styleRemove(name4) {
  return function() {
    this.style.removeProperty(name4);
  };
}
function styleConstant(name4, value3, priority) {
  return function() {
    this.style.setProperty(name4, value3, priority);
  };
}
function styleFunction(name4, value3, priority) {
  return function() {
    var v = value3.apply(this, arguments);
    if (v == null)
      this.style.removeProperty(name4);
    else
      this.style.setProperty(name4, v, priority);
  };
}
function style_default3(name4, value3, priority) {
  return arguments.length > 1 ? this.each((value3 == null ? styleRemove : typeof value3 === "function" ? styleFunction : styleConstant)(name4, value3, priority == null ? "" : priority)) : styleValue(this.node(), name4);
}
function styleValue(node, name4) {
  return node.style.getPropertyValue(name4) || window_default(node).getComputedStyle(node, null).getPropertyValue(name4);
}

// node_modules/d3-selection/src/selection/property.js
function propertyRemove(name4) {
  return function() {
    delete this[name4];
  };
}
function propertyConstant(name4, value3) {
  return function() {
    this[name4] = value3;
  };
}
function propertyFunction(name4, value3) {
  return function() {
    var v = value3.apply(this, arguments);
    if (v == null)
      delete this[name4];
    else
      this[name4] = v;
  };
}
function property_default(name4, value3) {
  return arguments.length > 1 ? this.each((value3 == null ? propertyRemove : typeof value3 === "function" ? propertyFunction : propertyConstant)(name4, value3)) : this.node()[name4];
}

// node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name4) {
    var i = this._names.indexOf(name4);
    if (i < 0) {
      this._names.push(name4);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name4) {
    var i = this._names.indexOf(name4);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name4) {
    return this._names.indexOf(name4) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n)
    list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n)
    list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value3) {
  return function() {
    (value3.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function classed_default(name4, value3) {
  var names = classArray(name4 + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n)
      if (!list.contains(names[i]))
        return false;
    return true;
  }
  return this.each((typeof value3 === "function" ? classedFunction : value3 ? classedTrue : classedFalse)(names, value3));
}

// node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value3) {
  return function() {
    this.textContent = value3;
  };
}
function textFunction(value3) {
  return function() {
    var v = value3.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function text_default(value3) {
  return arguments.length ? this.each(value3 == null ? textRemove : (typeof value3 === "function" ? textFunction : textConstant)(value3)) : this.node().textContent;
}

// node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value3) {
  return function() {
    this.innerHTML = value3;
  };
}
function htmlFunction(value3) {
  return function() {
    var v = value3.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function html_default(value3) {
  return arguments.length ? this.each(value3 == null ? htmlRemove : (typeof value3 === "function" ? htmlFunction : htmlConstant)(value3)) : this.node().innerHTML;
}

// node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}

// node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower);
}

// node_modules/d3-selection/src/selection/append.js
function append_default(name4) {
  var create4 = typeof name4 === "function" ? name4 : creator_default(name4);
  return this.select(function() {
    return this.appendChild(create4.apply(this, arguments));
  });
}

// node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name4, before) {
  var create4 = typeof name4 === "function" ? name4 : creator_default(name4), select2 = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
  return this.select(function() {
    return this.insertBefore(create4.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}

// node_modules/d3-selection/src/selection/remove.js
function remove2() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function remove_default2() {
  return this.each(remove2);
}

// node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
}
function selection_cloneDeep() {
  return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

// node_modules/d3-selection/src/selection/datum.js
function datum_default(value3) {
  return arguments.length ? this.property("__data__", value3) : this.node().__data__;
}

// node_modules/d3-selection/src/selection/on.js
var filterEvents = {};
var event = null;
if (typeof document !== "undefined") {
  element3 = document.documentElement;
  if (!("onmouseenter" in element3)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}
var element3;
function filterContextListener(listener2, index4, group2) {
  listener2 = contextListener(listener2, index4, group2);
  return function(event2) {
    var related = event2.relatedTarget;
    if (!related || related !== this && !(related.compareDocumentPosition(this) & 8)) {
      listener2.call(this, event2);
    }
  };
}
function contextListener(listener2, index4, group2) {
  return function(event1) {
    var event0 = event;
    event = event1;
    try {
      listener2.call(this, this.__data__, index4, group2);
    } finally {
      event = event0;
    }
  };
}
function parseTypenames2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name4 = "", i = t.indexOf(".");
    if (i >= 0)
      name4 = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name4};
  });
}
function onRemove(typename) {
  return function() {
    var on2 = this.__on;
    if (!on2)
      return;
    for (var j = 0, i = -1, m2 = on2.length, o; j < m2; ++j) {
      if (o = on2[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on2[++i] = o;
      }
    }
    if (++i)
      on2.length = i;
    else
      delete this.__on;
  };
}
function onAdd(typename, value3, capture) {
  var wrap3 = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group2) {
    var on2 = this.__on, o, listener2 = wrap3(value3, i, group2);
    if (on2)
      for (var j = 0, m2 = on2.length; j < m2; ++j) {
        if ((o = on2[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
          this.addEventListener(o.type, o.listener = listener2, o.capture = capture);
          o.value = value3;
          return;
        }
      }
    this.addEventListener(typename.type, listener2, capture);
    o = {type: typename.type, name: typename.name, value: value3, listener: listener2, capture};
    if (!on2)
      this.__on = [o];
    else
      on2.push(o);
  };
}
function on_default(typename, value3, capture) {
  var typenames = parseTypenames2(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on2 = this.node().__on;
    if (on2)
      for (var j = 0, m2 = on2.length, o; j < m2; ++j) {
        for (i = 0, o = on2[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
    return;
  }
  on2 = value3 ? onAdd : onRemove;
  if (capture == null)
    capture = false;
  for (i = 0; i < n; ++i)
    this.each(on2(typenames[i], value3, capture));
  return this;
}

// node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type2, params2) {
  var window2 = window_default(node), event2 = window2.CustomEvent;
  if (typeof event2 === "function") {
    event2 = new event2(type2, params2);
  } else {
    event2 = window2.document.createEvent("Event");
    if (params2)
      event2.initEvent(type2, params2.bubbles, params2.cancelable), event2.detail = params2.detail;
    else
      event2.initEvent(type2, false, false);
  }
  node.dispatchEvent(event2);
}
function dispatchConstant(type2, params2) {
  return function() {
    return dispatchEvent(this, type2, params2);
  };
}
function dispatchFunction(type2, params2) {
  return function() {
    return dispatchEvent(this, type2, params2.apply(this, arguments));
  };
}
function dispatch_default2(type2, params2) {
  return this.each((typeof params2 === "function" ? dispatchFunction : dispatchConstant)(type2, params2));
}

// node_modules/d3-selection/src/selection/index.js
var root = [null];
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root);
}
Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: select_default,
  selectAll: selectAll_default,
  filter: filter_default,
  data: data_default2,
  enter: enter_default,
  exit: exit_default,
  merge: merge_default3,
  order: order_default,
  sort: sort_default2,
  call: call_default,
  nodes: nodes_default,
  node: node_default,
  size: size_default2,
  empty: empty_default,
  each: each_default2,
  attr: attr_default,
  style: style_default3,
  property: property_default,
  classed: classed_default,
  text: text_default,
  html: html_default,
  raise: raise_default,
  lower: lower_default,
  append: append_default,
  insert: insert_default,
  remove: remove_default2,
  clone: clone_default,
  datum: datum_default,
  on: on_default,
  dispatch: dispatch_default2
};

// node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
}

// node_modules/d3-selection/src/local.js
var nextId = 0;
function local() {
  return new Local();
}
function Local() {
  this._ = "@" + (++nextId).toString(36);
}
Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id4 = this._;
    while (!(id4 in node))
      if (!(node = node.parentNode))
        return;
    return node[id4];
  },
  set: function(node, value3) {
    return node[this._] = value3;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

// src/render/table.ts
var import_glamor5 = __toModule(require_lib());
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function table(container, data4, opts = {}) {
  if (data4 && data4.headers == null) {
    throw new Error('Data to render must have a "headers" property');
  }
  if (data4 && data4.values == null) {
    throw new Error('Data to render must have a "values" property');
  }
  const drawArea = getDrawArea(container);
  const options2 = Object.assign({}, defaultOpts4, opts);
  let table2 = select_default2(drawArea).select("table.tf-table");
  const tableStyle = import_glamor5.css({
    fontSize: options2.fontSize || ".875rem",
    width: "100%",
    maxWidth: "64rem",
    marginRight: "auto",
    marginLeft: "auto"
  });
  if (table2.size() === 0) {
    table2 = select_default2(drawArea).append("table");
    table2.attr("class", ` ${tableStyle} tf-table`);
    table2.append("thead").append("tr");
    table2.append("tbody");
  }
  if (table2.size() !== 1) {
    throw new Error("Error inserting table");
  }
  const headerRowStyle = import_glamor5.css({
    fontWeight: "600",
    borderBottomStyle: "solid",
    borderBottomWidth: "1px",
    borderColor: "rgba( 0, 0, 0, .2 )",
    textAlign: "left",
    paddingBottom: "1rem",
    paddingRight: "1rem",
    backgroundColor: "#fff"
  });
  const headers = table2.select("thead").select("tr").selectAll("th").data(data4.headers);
  const headersEnter = headers.enter().append("th").attr("class", `${headerRowStyle}`);
  headers.merge(headersEnter).html((d) => d);
  headers.exit().remove();
  const format8 = format7(",.4~f");
  const rows = table2.select("tbody").selectAll("tr").data(data4.values);
  const rowsEnter = rows.enter().append("tr");
  const cellStyle = import_glamor5.css({
    padding: "0.25rem",
    borderBottomStyle: "solid",
    borderBottomWidth: "1px",
    borderColor: "rgba( 0, 0, 0, .2 )"
  });
  const cells = rows.merge(rowsEnter).selectAll("td").data((d) => d);
  const cellsEnter = cells.enter().append("td").attr("class", `${cellStyle}`);
  cells.merge(cellsEnter).html((d) => typeof d === "number" ? format8(d) : d);
  cells.exit().remove();
  rows.exit().remove();
}
var defaultOpts4 = {
  fontSize: 14
};

// src/render/histogram.ts
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var defaultOpts5 = {
  maxBins: 12,
  fontSize: 11
};
async function histogram(container, data4, opts = {}) {
  const values4 = prepareData(data4);
  const options2 = Object.assign({}, defaultOpts5, opts);
  const embedOpts = {
    actions: false,
    mode: "vega-lite",
    defaultStyle: false
  };
  const histogramContainer = subSurface(container, "histogram");
  if (opts.stats !== false) {
    const statsContainer = subSurface(container, "stats", {
      prepend: true
    });
    let stats;
    if (opts.stats) {
      stats = opts.stats;
    } else {
      stats = arrayStats(values4.map((x5) => x5.value));
    }
    renderStats(stats, statsContainer, {fontSize: options2.fontSize});
  }
  if (values4.length === 0) {
    return void 0;
  }
  const filtered = [];
  for (let i = 0; i < values4.length; i++) {
    const val = values4[i].value;
    if (val != null && isFinite(val)) {
      filtered.push(values4[i]);
    }
  }
  const histogramSpec = {
    width: options2.width || getDefaultWidth(histogramContainer),
    height: options2.height || getDefaultHeight(histogramContainer),
    padding: 0,
    autosize: {
      type: "fit",
      contains: "padding",
      resize: true
    },
    data: {values: filtered},
    mark: {
      type: "bar",
      tooltip: true
    },
    config: {
      axis: {
        labelFontSize: options2.fontSize,
        titleFontSize: options2.fontSize
      },
      text: {fontSize: options2.fontSize},
      legend: {
        labelFontSize: options2.fontSize,
        titleFontSize: options2.fontSize
      }
    },
    encoding: {
      x: {
        bin: {maxbins: options2.maxBins},
        field: "value",
        type: "quantitative"
      },
      y: {
        aggregate: "count",
        type: "quantitative"
      },
      color: {
        value: options2.color || "#001B44"
      }
    }
  };
  return embed(histogramContainer, histogramSpec, embedOpts);
}
function renderStats(stats, container, opts) {
  const format8 = format7(",.4~f");
  const pctFormat = format7(".4~p");
  const headers = [];
  const vals2 = [];
  if (stats.numVals != null) {
    headers.push("Num Vals");
    vals2.push(format8(stats.numVals));
  }
  if (stats.min != null) {
    headers.push("Min");
    vals2.push(format8(stats.min));
  }
  if (stats.max != null) {
    headers.push("Max");
    vals2.push(format8(stats.max));
  }
  if (stats.numZeros != null) {
    headers.push("# Zeros");
    let zeroPct = "";
    if (stats.numVals) {
      zeroPct = stats.numZeros > 0 ? `(${pctFormat(stats.numZeros / stats.numVals)})` : "";
    }
    vals2.push(`${format8(stats.numZeros)} ${zeroPct}`);
  }
  if (stats.numNans != null) {
    headers.push("# NaNs");
    let nanPct = "";
    if (stats.numVals) {
      nanPct = stats.numNans > 0 ? `(${pctFormat(stats.numNans / stats.numVals)})` : "";
    }
    vals2.push(`${format8(stats.numNans)} ${nanPct}`);
  }
  if (stats.numInfs != null) {
    headers.push("# Infinity");
    let infPct = "";
    if (stats.numVals) {
      infPct = stats.numInfs > 0 ? `(${pctFormat(stats.numInfs / stats.numVals)})` : "";
    }
    vals2.push(`${format8(stats.numInfs)} ${infPct}`);
  }
  table(container, {headers, values: [vals2]}, opts);
}
function prepareData(data4) {
  if (data4.length == null) {
    throw new Error("input data must be an array");
  }
  if (data4.length === 0) {
    return [];
  } else if (typeof data4[0] === "object") {
    if (data4[0].value == null) {
      throw new Error("input data must have a value field");
    } else {
      return data4;
    }
  } else {
    const ret = Array(data4.length);
    for (let i = 0; i < data4.length; i++) {
      ret[i] = {value: data4[i]};
    }
    return ret;
  }
}

// src/render/linechart.ts
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function linechart(container, data4, opts = {}) {
  const _data = Array.isArray(data4.values[0]) ? data4.values : [data4.values];
  const numValues = _data[0].length;
  const _series = data4.series ? data4.series : _data.map((_, i) => `Series ${i + 1}`);
  assert3(_series.length === _data.length, "Must have an equal number of series labels as there are data series");
  if (opts.seriesColors != null) {
    assert3(opts.seriesColors.length === _data.length, "Must have an equal number of series colors as there are data series");
  }
  const vlChartValues = [];
  for (let valueIdx = 0; valueIdx < numValues; valueIdx++) {
    const v = {
      x: valueIdx
    };
    _series.forEach((seriesName, seriesIdx) => {
      const seriesValue = _data[seriesIdx][valueIdx].y;
      v[seriesName] = seriesValue;
      v[`${seriesName}-name`] = seriesName;
    });
    vlChartValues.push(v);
  }
  const options2 = Object.assign({}, defaultOpts6, opts);
  const yScale = () => {
    if (options2.zoomToFit) {
      return {zero: false};
    } else if (options2.yAxisDomain != null) {
      return {domain: options2.yAxisDomain};
    }
    return void 0;
  };
  const sharedEncoding = {
    x: {
      field: "x",
      type: options2.xType,
      title: options2.xLabel
    },
    tooltip: [
      {field: "x", type: "quantitative"},
      ..._series.map((seriesName) => {
        return {
          field: seriesName,
          type: "quantitative"
        };
      })
    ]
  };
  const lineLayers = _series.map((seriesName) => {
    return {
      data: void 0,
      mark: {type: "line", clip: true},
      encoding: {
        y: {
          field: seriesName,
          type: options2.yType,
          title: options2.yLabel,
          scale: yScale()
        },
        color: {
          field: `${seriesName}-name`,
          type: "nominal",
          legend: {values: _series, title: null},
          scale: {
            range: options2.seriesColors
          }
        }
      }
    };
  });
  const tooltipLayer = {
    mark: "rule",
    selection: {
      hover: {
        type: "single",
        on: "mouseover",
        nearest: true,
        clear: "mouseout"
      }
    },
    encoding: {
      color: {
        value: "grey",
        condition: {
          selection: {not: "hover"},
          value: "transparent"
        }
      }
    }
  };
  const drawArea = getDrawArea(container);
  const spec = {
    width: options2.width || getDefaultWidth(drawArea),
    height: options2.height || getDefaultHeight(drawArea),
    padding: 0,
    autosize: {
      type: "fit",
      contains: "padding",
      resize: true
    },
    config: {
      axis: {
        labelFontSize: options2.fontSize,
        titleFontSize: options2.fontSize
      },
      text: {fontSize: options2.fontSize},
      legend: {
        labelFontSize: options2.fontSize,
        titleFontSize: options2.fontSize
      }
    },
    data: {values: vlChartValues},
    encoding: sharedEncoding,
    layer: [
      ...lineLayers,
      tooltipLayer
    ]
  };
  const embedOpts = {
    actions: false,
    mode: "vega-lite",
    defaultStyle: false
  };
  await embed(drawArea, spec, embedOpts);
  return Promise.resolve();
}
var defaultOpts6 = {
  xLabel: "x",
  yLabel: "y",
  xType: "quantitative",
  yType: "quantitative",
  zoomToFit: false,
  fontSize: 11
};

// src/render/scatterplot.ts
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function scatterplot(container, data4, opts = {}) {
  let _values = data4.values;
  const _series = data4.series == null ? [] : data4.series;
  _values = Array.isArray(_values[0]) ? _values : [_values];
  const values4 = [];
  _values.forEach((seriesData, i) => {
    const seriesName = _series[i] != null ? _series[i] : `Series ${i + 1}`;
    const seriesVals = seriesData.map((v) => Object.assign({}, v, {series: seriesName}));
    values4.push(...seriesVals);
  });
  if (opts.seriesColors != null) {
    assert3(opts.seriesColors.length === _values.length, "Must have an equal number of series colors as there are data series");
  }
  const drawArea = getDrawArea(container);
  const options2 = Object.assign({}, defaultOpts7, opts);
  const embedOpts = {
    actions: false,
    mode: "vega-lite",
    defaultStyle: false
  };
  const xDomain = () => {
    if (options2.zoomToFit) {
      return {zero: false};
    } else if (options2.xAxisDomain != null) {
      return {domain: options2.xAxisDomain};
    }
    return void 0;
  };
  const yDomain = () => {
    if (options2.zoomToFit) {
      return {zero: false};
    } else if (options2.yAxisDomain != null) {
      return {domain: options2.yAxisDomain};
    }
    return void 0;
  };
  const spec = {
    width: options2.width || getDefaultWidth(drawArea),
    height: options2.height || getDefaultHeight(drawArea),
    padding: 0,
    autosize: {
      type: "fit",
      contains: "padding",
      resize: true
    },
    config: {
      axis: {
        labelFontSize: options2.fontSize,
        titleFontSize: options2.fontSize
      },
      text: {fontSize: options2.fontSize},
      legend: {
        labelFontSize: options2.fontSize,
        titleFontSize: options2.fontSize
      }
    },
    data: {
      values: values4
    },
    mark: {
      type: "point",
      clip: true,
      tooltip: {content: "data"}
    },
    encoding: {
      x: {
        field: "x",
        type: options2.xType,
        title: options2.xLabel,
        scale: xDomain()
      },
      y: {
        field: "y",
        type: options2.yType,
        title: options2.yLabel,
        scale: yDomain()
      },
      color: {
        field: "series",
        type: "nominal",
        scale: {
          range: options2.seriesColors
        }
      },
      shape: {
        field: "series",
        type: "nominal"
      }
    }
  };
  await embed(drawArea, spec, embedOpts);
  return Promise.resolve();
}
var defaultOpts7 = {
  xLabel: "x",
  yLabel: "y",
  xType: "quantitative",
  yType: "quantitative",
  zoomToFit: false,
  fontSize: 11
};

// src/show/history.ts
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function history(container, history2, metrics2, opts = {}) {
  const drawArea = getDrawArea(container);
  const plots = {};
  for (const metric of metrics2) {
    if (!/val_/.test(metric)) {
      const values4 = getValues(history2, metric, metrics2.indexOf(metric));
      initPlot(plots, metric);
      plots[metric].series.push(metric);
      plots[metric].values.push(values4);
    } else {
      const nonValidationMetric = metric.replace("val_", "");
      initPlot(plots, nonValidationMetric);
      const values4 = getValues(history2, metric, metrics2.indexOf(metric));
      plots[nonValidationMetric].series.push(metric);
      plots[nonValidationMetric].values.push(values4);
    }
  }
  const plotNames = Object.keys(plots);
  const options2 = Object.assign({}, {xLabel: "Iteration", yLabel: "Value"}, opts);
  const renderPromises = [];
  for (const name4 of plotNames) {
    const subContainer = subSurface(drawArea, name4);
    const series = plots[name4].series;
    const values4 = plots[name4].values;
    if (series.every((seriesName) => Boolean(seriesName.match("acc")))) {
      if (options2.zoomToFitAccuracy) {
        options2.zoomToFit = true;
      } else {
        options2.yAxisDomain = [0, 1];
        delete options2.zoomToFit;
      }
    }
    const done = linechart(subContainer, {values: values4, series}, options2);
    renderPromises.push(done);
  }
  await Promise.all(renderPromises);
}
function initPlot(plot, name4) {
  if (plot[name4] == null) {
    plot[name4] = {series: [], values: []};
  }
}
function getValues(history2, metric, metricIndex) {
  if (Array.isArray(history2)) {
    const metricHistory = Array.isArray(history2[0]) ? history2[metricIndex] : history2;
    const points2 = [];
    for (let i = 0; i < metricHistory.length; i++) {
      const log50 = metricHistory[i];
      points2.push({x: i, y: log50[metric]});
    }
    return points2;
  } else {
    return history2.history[metric].map((y5, x5) => ({x: x5, y: y5}));
  }
}
function fitCallbacks(container, metrics2, opts = {}) {
  const accumulators = {};
  const callbackNames = opts.callbacks || ["onEpochEnd", "onBatchEnd"];
  const drawArea = getDrawArea(container);
  const historyOpts = Object.assign({}, opts);
  delete historyOpts.callbacks;
  function makeCallbackFor(callbackName) {
    return async (_, log50) => {
      if (/batch/i.test(callbackName)) {
        historyOpts.xLabel = "Batch";
      } else if (/epoch/i.test(callbackName)) {
        historyOpts.xLabel = "Epoch";
      }
      const metricLogs = [];
      const presentMetrics = [];
      for (const metric of metrics2) {
        if (log50[metric] != null) {
          presentMetrics.push(metric);
          const accumulator = getAccumulator(accumulators, callbackName, metric);
          accumulator.push({[metric]: log50[metric]});
          metricLogs.push(accumulator);
        }
      }
      const subContainer = subSurface(drawArea, callbackName, {title: callbackName});
      history(subContainer, metricLogs, presentMetrics, historyOpts);
      await nextFrame();
    };
  }
  const callbacks = {};
  callbackNames.forEach((name4) => {
    callbacks[name4] = makeCallbackFor(name4);
  });
  return callbacks;
}
function getAccumulator(accumulators, callback, metric) {
  if (accumulators[callback] == null) {
    accumulators[callback] = {};
  }
  if (accumulators[callback][metric] == null) {
    accumulators[callback][metric] = [];
  }
  return accumulators[callback][metric];
}

// src/show/model.ts
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function modelSummary(container, model) {
  const drawArea = getDrawArea(container);
  const summary = getModelSummary(model);
  const headers = [
    "Layer Name",
    "Output Shape",
    "# Of Params",
    "Trainable"
  ];
  const values4 = summary.layers.map((l) => [
    l.name,
    l.outputShape,
    l.parameters,
    l.trainable
  ]);
  table(drawArea, {headers, values: values4});
}
async function layer(container, layer2) {
  const drawArea = getDrawArea(container);
  const details = await getLayerDetails(layer2);
  const headers = [
    "Weight Name",
    "Shape",
    "Min",
    "Max",
    "# Params",
    "# Zeros",
    "# NaNs",
    "# Infinity"
  ];
  const weightsInfoSurface = subSurface(drawArea, "layer-weights-info");
  const detailValues = details.map((l) => [
    l.name,
    l.shape,
    l.stats.min,
    l.stats.max,
    l.weight.size,
    l.stats.numZeros,
    l.stats.numNans,
    l.stats.numInfs
  ]);
  table(weightsInfoSurface, {headers, values: detailValues});
  const histogramSelectorSurface = subSurface(drawArea, "select-layer");
  const layerValuesHistogram = subSurface(drawArea, "param-distribution");
  const handleSelection = async (layerName) => {
    const layer3 = details.filter((d) => d.name === layerName)[0];
    const weights = await layer3.weight.data();
    histogram(layerValuesHistogram, weights, {height: 150, width: 460, stats: false});
  };
  addHistogramSelector(details.map((d) => d.name), histogramSelectorSurface, handleSelection);
}
function getModelSummary(model) {
  return {
    layers: model.layers.map(getLayerSummary)
  };
}
function getLayerSummary(layer2) {
  let outputShape;
  if (Array.isArray(layer2.outputShape[0])) {
    const shapes = layer2.outputShape.map((s) => formatShape(s));
    outputShape = `[${shapes.join(", ")}]`;
  } else {
    outputShape = formatShape(layer2.outputShape);
  }
  return {
    name: layer2.name,
    trainable: layer2.trainable,
    parameters: layer2.countParams(),
    outputShape
  };
}
async function getLayerDetails(layer2) {
  const weights = layer2.getWeights();
  const layerVariables = layer2.weights;
  const statsPromises = weights.map(tensorStats);
  const stats = await Promise.all(statsPromises);
  const shapes = weights.map((w3) => w3.shape);
  return weights.map((weight, i) => ({
    name: layerVariables[i].name,
    stats: stats[i],
    shape: formatShape(shapes[i]),
    weight
  }));
}
function formatShape(shape2) {
  const oShape = shape2.slice();
  if (oShape.length === 0) {
    return "Scalar";
  }
  if (oShape[0] === null) {
    oShape[0] = "batch";
  }
  return `[${oShape.join(",")}]`;
}
function addHistogramSelector(items2, parent, selectionHandler) {
  const select2 = `
    <select>
      ${items2.map((i) => `<option value=${i}>${i}</option>`)}
    </select>
  `;
  const button = `<button>Show Values Distribution for:</button>`;
  const content2 = `<div>${button}${select2}</div>`;
  parent.innerHTML = content2;
  const buttonEl = parent.querySelector("button");
  const selectEl = parent.querySelector("select");
  buttonEl.addEventListener("click", () => {
    selectionHandler(selectEl.selectedOptions[0].label);
  });
}

// src/show/quality.ts
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function perClassAccuracy2(container, classAccuracy, classLabels) {
  const drawArea = getDrawArea(container);
  const headers = [
    "Class",
    "Accuracy",
    "# Samples"
  ];
  const values4 = [];
  for (let i = 0; i < classAccuracy.length; i++) {
    const label = classLabels ? classLabels[i] : i.toString();
    const classAcc = classAccuracy[i];
    values4.push([label, classAcc.accuracy, classAcc.count]);
  }
  return table(drawArea, {headers, values: values4});
}

// src/show/tensor.ts
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function valuesDistribution(container, tensor) {
  const drawArea = getDrawArea(container);
  const stats = await tensorStats(tensor);
  const values4 = await tensor.data();
  histogram(drawArea, values4, {height: 150, stats});
}

// src/version.ts
/** @license See the LICENSE file. */
var version7 = "1.4.0";

// src/index.ts
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var render3 = {
  barchart,
  table,
  histogram,
  linechart,
  scatterplot,
  confusionMatrix,
  heatmap
};
var metrics = {
  accuracy,
  perClassAccuracy,
  confusionMatrix: confusionMatrix2
};
var show = {
  history,
  fitCallbacks,
  perClassAccuracy: perClassAccuracy2,
  valuesDistribution,
  layer,
  modelSummary
};
export {
  isSurface,
  isSurfaceInfo,
  metrics,
  render3 as render,
  show,
  version7 as version_vis,
  visor
};
