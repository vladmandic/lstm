
  /*
  LTSM
  homepage: <https://github.com/vladmandic/ltsm>
  author: <https://github.com/vladmandic>'
  */

var __create=Object.create,__defProp=Object.defineProperty,__getProtoOf=Object.getPrototypeOf,__hasOwnProp=Object.prototype.hasOwnProperty,__getOwnPropNames=Object.getOwnPropertyNames,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__markAsModule=target=>__defProp(target,"__esModule",{value:!0}),__commonJS=(callback,module)=>()=>(module||(module={exports:{}},callback(module.exports,module)),module.exports),__export=(target,all5)=>{__markAsModule(target);for(var name in all5)__defProp(target,name,{get:all5[name],enumerable:!0})},__exportStar=(target,module,desc)=>{if(__markAsModule(target),module&&typeof module=="object"||typeof module=="function")for(let key of __getOwnPropNames(module))!__hasOwnProp.call(target,key)&&key!=="default"&&__defProp(target,key,{get:()=>module[key],enumerable:!(desc=__getOwnPropDesc(module,key))||desc.enumerable});return target},__toModule=module=>module&&module.__esModule?module:__exportStar(__defProp(module!=null?__create(__getProtoOf(module)):{},"default",{value:module,enumerable:!0}),module),require_browser=__commonJS(()=>{}),require_alea=__commonJS((exports3,module)=>{(function(global2,module2,define2){function Alea(seed){var me=this,mash=Mash();me.next=function(){var t=2091639*me.s0+me.c*23283064365386963e-26;return me.s0=me.s1,me.s1=me.s2,me.s2=t-(me.c=t|0)},me.c=1,me.s0=mash(" "),me.s1=mash(" "),me.s2=mash(" "),me.s0-=mash(seed),me.s0<0&&(me.s0+=1),me.s1-=mash(seed),me.s1<0&&(me.s1+=1),me.s2-=mash(seed),me.s2<0&&(me.s2+=1),mash=null}function copy(f,t){return t.c=f.c,t.s0=f.s0,t.s1=f.s1,t.s2=f.s2,t}function impl(seed,opts){var xg=new Alea(seed),state6=opts&&opts.state,prng=xg.next;return prng.int32=function(){return xg.next()*4294967296|0},prng.double=function(){return prng()+(prng()*2097152|0)*11102230246251565e-32},prng.quick=prng,state6&&(typeof state6=="object"&&copy(state6,xg),prng.state=function(){return copy(xg,{})}),prng}function Mash(){var n=4022871197,mash=function(data){data=data.toString();for(var i=0;i<data.length;i++){n+=data.charCodeAt(i);var h=.02519603282416938*n;n=h>>>0,h-=n,h*=n,n=h>>>0,h-=n,n+=h*4294967296}return(n>>>0)*23283064365386963e-26};return mash}module2&&module2.exports?module2.exports=impl:define2&&define2.amd?define2(function(){return impl}):this.alea=impl})(exports3,typeof module=="object"&&module,typeof define=="function"&&define)}),require_xor128=__commonJS((exports3,module)=>{(function(global2,module2,define2){function XorGen(seed){var me=this,strseed="";me.x=0,me.y=0,me.z=0,me.w=0,me.next=function(){var t=me.x^me.x<<11;return me.x=me.y,me.y=me.z,me.z=me.w,me.w^=me.w>>>19^t^t>>>8},seed===(seed|0)?me.x=seed:strseed+=seed;for(var k=0;k<strseed.length+64;k++)me.x^=strseed.charCodeAt(k)|0,me.next()}function copy(f,t){return t.x=f.x,t.y=f.y,t.z=f.z,t.w=f.w,t}function impl(seed,opts){var xg=new XorGen(seed),state6=opts&&opts.state,prng=function(){return(xg.next()>>>0)/4294967296};return prng.double=function(){do var top=xg.next()>>>11,bot=(xg.next()>>>0)/4294967296,result=(top+bot)/(1<<21);while(result===0);return result},prng.int32=xg.next,prng.quick=prng,state6&&(typeof state6=="object"&&copy(state6,xg),prng.state=function(){return copy(xg,{})}),prng}module2&&module2.exports?module2.exports=impl:define2&&define2.amd?define2(function(){return impl}):this.xor128=impl})(exports3,typeof module=="object"&&module,typeof define=="function"&&define)}),require_xorwow=__commonJS((exports3,module)=>{(function(global2,module2,define2){function XorGen(seed){var me=this,strseed="";me.next=function(){var t=me.x^me.x>>>2;return me.x=me.y,me.y=me.z,me.z=me.w,me.w=me.v,(me.d=me.d+362437|0)+(me.v=me.v^me.v<<4^(t^t<<1))|0},me.x=0,me.y=0,me.z=0,me.w=0,me.v=0,seed===(seed|0)?me.x=seed:strseed+=seed;for(var k=0;k<strseed.length+64;k++)me.x^=strseed.charCodeAt(k)|0,k==strseed.length&&(me.d=me.x<<10^me.x>>>4),me.next()}function copy(f,t){return t.x=f.x,t.y=f.y,t.z=f.z,t.w=f.w,t.v=f.v,t.d=f.d,t}function impl(seed,opts){var xg=new XorGen(seed),state6=opts&&opts.state,prng=function(){return(xg.next()>>>0)/4294967296};return prng.double=function(){do var top=xg.next()>>>11,bot=(xg.next()>>>0)/4294967296,result=(top+bot)/(1<<21);while(result===0);return result},prng.int32=xg.next,prng.quick=prng,state6&&(typeof state6=="object"&&copy(state6,xg),prng.state=function(){return copy(xg,{})}),prng}module2&&module2.exports?module2.exports=impl:define2&&define2.amd?define2(function(){return impl}):this.xorwow=impl})(exports3,typeof module=="object"&&module,typeof define=="function"&&define)}),require_xorshift7=__commonJS((exports3,module)=>{(function(global2,module2,define2){function XorGen(seed){var me=this;me.next=function(){var X=me.x,i=me.i,t,v,w;return t=X[i],t^=t>>>7,v=t^t<<24,t=X[i+1&7],v^=t^t>>>10,t=X[i+3&7],v^=t^t>>>3,t=X[i+4&7],v^=t^t<<7,t=X[i+7&7],t=t^t<<13,v^=t^t<<9,X[i]=v,me.i=i+1&7,v};function init(me2,seed2){var j,w,X=[];if(seed2===(seed2|0))w=X[0]=seed2;else for(seed2=""+seed2,j=0;j<seed2.length;++j)X[j&7]=X[j&7]<<15^seed2.charCodeAt(j)+X[j+1&7]<<13;for(;X.length<8;)X.push(0);for(j=0;j<8&&X[j]===0;++j);for(j==8?w=X[7]=-1:w=X[j],me2.x=X,me2.i=0,j=256;j>0;--j)me2.next()}init(me,seed)}function copy(f,t){return t.x=f.x.slice(),t.i=f.i,t}function impl(seed,opts){seed==null&&(seed=+new Date);var xg=new XorGen(seed),state6=opts&&opts.state,prng=function(){return(xg.next()>>>0)/4294967296};return prng.double=function(){do var top=xg.next()>>>11,bot=(xg.next()>>>0)/4294967296,result=(top+bot)/(1<<21);while(result===0);return result},prng.int32=xg.next,prng.quick=prng,state6&&(state6.x&&copy(state6,xg),prng.state=function(){return copy(xg,{})}),prng}module2&&module2.exports?module2.exports=impl:define2&&define2.amd?define2(function(){return impl}):this.xorshift7=impl})(exports3,typeof module=="object"&&module,typeof define=="function"&&define)}),require_xor4096=__commonJS((exports3,module)=>{(function(global2,module2,define2){function XorGen(seed){var me=this;me.next=function(){var w=me.w,X=me.X,i=me.i,t,v;return me.w=w=w+1640531527|0,v=X[i+34&127],t=X[i=i+1&127],v^=v<<13,t^=t<<17,v^=v>>>15,t^=t>>>12,v=X[i]=v^t,me.i=i,v+(w^w>>>16)|0};function init(me2,seed2){var t,v,i,j,w,X=[],limit=128;for(seed2===(seed2|0)?(v=seed2,seed2=null):(seed2=seed2+"\0",v=0,limit=Math.max(limit,seed2.length)),i=0,j=-32;j<limit;++j)seed2&&(v^=seed2.charCodeAt((j+32)%seed2.length)),j===0&&(w=v),v^=v<<10,v^=v>>>15,v^=v<<4,v^=v>>>13,j>=0&&(w=w+1640531527|0,t=X[j&127]^=v+w,i=t==0?i+1:0);for(i>=128&&(X[(seed2&&seed2.length||0)&127]=-1),i=127,j=4*128;j>0;--j)v=X[i+34&127],t=X[i=i+1&127],v^=v<<13,t^=t<<17,v^=v>>>15,t^=t>>>12,X[i]=v^t;me2.w=w,me2.X=X,me2.i=i}init(me,seed)}function copy(f,t){return t.i=f.i,t.w=f.w,t.X=f.X.slice(),t}function impl(seed,opts){seed==null&&(seed=+new Date);var xg=new XorGen(seed),state6=opts&&opts.state,prng=function(){return(xg.next()>>>0)/4294967296};return prng.double=function(){do var top=xg.next()>>>11,bot=(xg.next()>>>0)/4294967296,result=(top+bot)/(1<<21);while(result===0);return result},prng.int32=xg.next,prng.quick=prng,state6&&(state6.X&&copy(state6,xg),prng.state=function(){return copy(xg,{})}),prng}module2&&module2.exports?module2.exports=impl:define2&&define2.amd?define2(function(){return impl}):this.xor4096=impl})(exports3,typeof module=="object"&&module,typeof define=="function"&&define)}),require_tychei=__commonJS((exports3,module)=>{(function(global2,module2,define2){function XorGen(seed){var me=this,strseed="";me.next=function(){var b=me.b,c=me.c,d=me.d,a=me.a;return b=b<<25^b>>>7^c,c=c-d|0,d=d<<24^d>>>8^a,a=a-b|0,me.b=b=b<<20^b>>>12^c,me.c=c=c-d|0,me.d=d<<16^c>>>16^a,me.a=a-b|0},me.a=0,me.b=0,me.c=2654435769|0,me.d=1367130551,seed===Math.floor(seed)?(me.a=seed/4294967296|0,me.b=seed|0):strseed+=seed;for(var k=0;k<strseed.length+20;k++)me.b^=strseed.charCodeAt(k)|0,me.next()}function copy(f,t){return t.a=f.a,t.b=f.b,t.c=f.c,t.d=f.d,t}function impl(seed,opts){var xg=new XorGen(seed),state6=opts&&opts.state,prng=function(){return(xg.next()>>>0)/4294967296};return prng.double=function(){do var top=xg.next()>>>11,bot=(xg.next()>>>0)/4294967296,result=(top+bot)/(1<<21);while(result===0);return result},prng.int32=xg.next,prng.quick=prng,state6&&(typeof state6=="object"&&copy(state6,xg),prng.state=function(){return copy(xg,{})}),prng}module2&&module2.exports?module2.exports=impl:define2&&define2.amd?define2(function(){return impl}):this.tychei=impl})(exports3,typeof module=="object"&&module,typeof define=="function"&&define)}),require_crypto=__commonJS(()=>{}),require_seedrandom=__commonJS((exports3,module)=>{(function(pool6,math){var global2=this,width=256,chunks=6,digits=52,rngname="random",startdenom=math.pow(width,chunks),significance=math.pow(2,digits),overflow=significance*2,mask=width-1,nodecrypto;function seedrandom5(seed,options,callback){var key=[];options=options==!0?{entropy:!0}:options||{};var shortseed=mixkey(flatten4(options.entropy?[seed,tostring(pool6)]:seed==null?autoseed():seed,3),key),arc4=new ARC4(key),prng=function(){for(var n=arc4.g(chunks),d=startdenom,x=0;n<significance;)n=(n+x)*width,d*=width,x=arc4.g(1);for(;n>=overflow;)n/=2,d/=2,x>>>=1;return(n+x)/d};return prng.int32=function(){return arc4.g(4)|0},prng.quick=function(){return arc4.g(4)/4294967296},prng.double=prng,mixkey(tostring(arc4.S),pool6),(options.pass||callback||function(prng2,seed2,is_math_call,state6){return state6&&(state6.S&&copy(state6,arc4),prng2.state=function(){return copy(arc4,{})}),is_math_call?(math[rngname]=prng2,seed2):prng2})(prng,shortseed,"global"in options?options.global:this==math,options.state)}math["seed"+rngname]=seedrandom5;function ARC4(key){var t,keylen=key.length,me=this,i=0,j=me.i=me.j=0,s=me.S=[];for(keylen||(key=[keylen++]);i<width;)s[i]=i++;for(i=0;i<width;i++)s[i]=s[j=mask&j+key[i%keylen]+(t=s[i])],s[j]=t;(me.g=function(count2){for(var t2,r=0,i2=me.i,j2=me.j,s2=me.S;count2--;)t2=s2[i2=mask&i2+1],r=r*width+s2[mask&(s2[i2]=s2[j2=mask&j2+t2])+(s2[j2]=t2)];return me.i=i2,me.j=j2,r})(width)}function copy(f,t){return t.i=f.i,t.j=f.j,t.S=f.S.slice(),t}function flatten4(obj,depth){var result=[],typ=typeof obj,prop;if(depth&&typ=="object")for(prop in obj)try{result.push(flatten4(obj[prop],depth-1))}catch(e){}return result.length?result:typ=="string"?obj:obj+"\0"}function mixkey(seed,key){for(var stringseed=seed+"",smear,j=0;j<stringseed.length;)key[mask&j]=mask&(smear^=key[mask&j]*19)+stringseed.charCodeAt(j++);return tostring(key)}function autoseed(){try{var out;return nodecrypto&&(out=nodecrypto.randomBytes)?out=out(width):(out=new Uint8Array(width),(global2.crypto||global2.msCrypto).getRandomValues(out)),tostring(out)}catch(e){var browser=global2.navigator,plugins=browser&&browser.plugins;return[+new Date,global2,plugins,global2.screen,tostring(pool6)]}}function tostring(a){return String.fromCharCode.apply(0,a)}if(mixkey(math.random(),pool6),typeof module=="object"&&module.exports){module.exports=seedrandom5;try{nodecrypto=require_crypto()}catch(ex){}}else typeof define=="function"&&define.amd&&define(function(){return seedrandom5})})([],Math)}),require_seedrandom2=__commonJS((exports3,module)=>{var alea5=require_alea(),xor128=require_xor128(),xorwow=require_xorwow(),xorshift7=require_xorshift7(),xor4096=require_xor4096(),tychei=require_tychei(),sr=require_seedrandom();sr.alea=alea5;sr.xor128=xor128;sr.xorwow=xorwow;sr.xorshift7=xorshift7;sr.xor4096=xor4096;sr.tychei=tychei;module.exports=sr}),require_alea2=__commonJS((exports3,module)=>{(function(global2,module2,define2){function Alea(seed){var me=this,mash=Mash();me.next=function(){var t=2091639*me.s0+me.c*23283064365386963e-26;return me.s0=me.s1,me.s1=me.s2,me.s2=t-(me.c=t|0)},me.c=1,me.s0=mash(" "),me.s1=mash(" "),me.s2=mash(" "),me.s0-=mash(seed),me.s0<0&&(me.s0+=1),me.s1-=mash(seed),me.s1<0&&(me.s1+=1),me.s2-=mash(seed),me.s2<0&&(me.s2+=1),mash=null}function copy(f,t){return t.c=f.c,t.s0=f.s0,t.s1=f.s1,t.s2=f.s2,t}function impl(seed,opts){var xg=new Alea(seed),state6=opts&&opts.state,prng=xg.next;return prng.int32=function(){return xg.next()*4294967296|0},prng.double=function(){return prng()+(prng()*2097152|0)*11102230246251565e-32},prng.quick=prng,state6&&(typeof state6=="object"&&copy(state6,xg),prng.state=function(){return copy(xg,{})}),prng}function Mash(){var n=4022871197,mash=function(data){data=String(data);for(var i=0;i<data.length;i++){n+=data.charCodeAt(i);var h=.02519603282416938*n;n=h>>>0,h-=n,h*=n,n=h>>>0,h-=n,n+=h*4294967296}return(n>>>0)*23283064365386963e-26};return mash}module2&&module2.exports?module2.exports=impl:define2&&define2.amd?define2(function(){return impl}):this.alea=impl})(exports3,typeof module=="object"&&module,typeof define=="function"&&define)}),require_xor1282=__commonJS((exports3,module)=>{(function(global2,module2,define2){function XorGen(seed){var me=this,strseed="";me.x=0,me.y=0,me.z=0,me.w=0,me.next=function(){var t=me.x^me.x<<11;return me.x=me.y,me.y=me.z,me.z=me.w,me.w^=me.w>>>19^t^t>>>8},seed===(seed|0)?me.x=seed:strseed+=seed;for(var k=0;k<strseed.length+64;k++)me.x^=strseed.charCodeAt(k)|0,me.next()}function copy(f,t){return t.x=f.x,t.y=f.y,t.z=f.z,t.w=f.w,t}function impl(seed,opts){var xg=new XorGen(seed),state6=opts&&opts.state,prng=function(){return(xg.next()>>>0)/4294967296};return prng.double=function(){do var top=xg.next()>>>11,bot=(xg.next()>>>0)/4294967296,result=(top+bot)/(1<<21);while(result===0);return result},prng.int32=xg.next,prng.quick=prng,state6&&(typeof state6=="object"&&copy(state6,xg),prng.state=function(){return copy(xg,{})}),prng}module2&&module2.exports?module2.exports=impl:define2&&define2.amd?define2(function(){return impl}):this.xor128=impl})(exports3,typeof module=="object"&&module,typeof define=="function"&&define)}),require_xorwow2=__commonJS((exports3,module)=>{(function(global2,module2,define2){function XorGen(seed){var me=this,strseed="";me.next=function(){var t=me.x^me.x>>>2;return me.x=me.y,me.y=me.z,me.z=me.w,me.w=me.v,(me.d=me.d+362437|0)+(me.v=me.v^me.v<<4^(t^t<<1))|0},me.x=0,me.y=0,me.z=0,me.w=0,me.v=0,seed===(seed|0)?me.x=seed:strseed+=seed;for(var k=0;k<strseed.length+64;k++)me.x^=strseed.charCodeAt(k)|0,k==strseed.length&&(me.d=me.x<<10^me.x>>>4),me.next()}function copy(f,t){return t.x=f.x,t.y=f.y,t.z=f.z,t.w=f.w,t.v=f.v,t.d=f.d,t}function impl(seed,opts){var xg=new XorGen(seed),state6=opts&&opts.state,prng=function(){return(xg.next()>>>0)/4294967296};return prng.double=function(){do var top=xg.next()>>>11,bot=(xg.next()>>>0)/4294967296,result=(top+bot)/(1<<21);while(result===0);return result},prng.int32=xg.next,prng.quick=prng,state6&&(typeof state6=="object"&&copy(state6,xg),prng.state=function(){return copy(xg,{})}),prng}module2&&module2.exports?module2.exports=impl:define2&&define2.amd?define2(function(){return impl}):this.xorwow=impl})(exports3,typeof module=="object"&&module,typeof define=="function"&&define)}),require_xorshift72=__commonJS((exports3,module)=>{(function(global2,module2,define2){function XorGen(seed){var me=this;me.next=function(){var X=me.x,i=me.i,t,v,w;return t=X[i],t^=t>>>7,v=t^t<<24,t=X[i+1&7],v^=t^t>>>10,t=X[i+3&7],v^=t^t>>>3,t=X[i+4&7],v^=t^t<<7,t=X[i+7&7],t=t^t<<13,v^=t^t<<9,X[i]=v,me.i=i+1&7,v};function init(me2,seed2){var j,w,X=[];if(seed2===(seed2|0))w=X[0]=seed2;else for(seed2=""+seed2,j=0;j<seed2.length;++j)X[j&7]=X[j&7]<<15^seed2.charCodeAt(j)+X[j+1&7]<<13;for(;X.length<8;)X.push(0);for(j=0;j<8&&X[j]===0;++j);for(j==8?w=X[7]=-1:w=X[j],me2.x=X,me2.i=0,j=256;j>0;--j)me2.next()}init(me,seed)}function copy(f,t){return t.x=f.x.slice(),t.i=f.i,t}function impl(seed,opts){seed==null&&(seed=+new Date);var xg=new XorGen(seed),state6=opts&&opts.state,prng=function(){return(xg.next()>>>0)/4294967296};return prng.double=function(){do var top=xg.next()>>>11,bot=(xg.next()>>>0)/4294967296,result=(top+bot)/(1<<21);while(result===0);return result},prng.int32=xg.next,prng.quick=prng,state6&&(state6.x&&copy(state6,xg),prng.state=function(){return copy(xg,{})}),prng}module2&&module2.exports?module2.exports=impl:define2&&define2.amd?define2(function(){return impl}):this.xorshift7=impl})(exports3,typeof module=="object"&&module,typeof define=="function"&&define)}),require_xor40962=__commonJS((exports3,module)=>{(function(global2,module2,define2){function XorGen(seed){var me=this;me.next=function(){var w=me.w,X=me.X,i=me.i,t,v;return me.w=w=w+1640531527|0,v=X[i+34&127],t=X[i=i+1&127],v^=v<<13,t^=t<<17,v^=v>>>15,t^=t>>>12,v=X[i]=v^t,me.i=i,v+(w^w>>>16)|0};function init(me2,seed2){var t,v,i,j,w,X=[],limit=128;for(seed2===(seed2|0)?(v=seed2,seed2=null):(seed2=seed2+"\0",v=0,limit=Math.max(limit,seed2.length)),i=0,j=-32;j<limit;++j)seed2&&(v^=seed2.charCodeAt((j+32)%seed2.length)),j===0&&(w=v),v^=v<<10,v^=v>>>15,v^=v<<4,v^=v>>>13,j>=0&&(w=w+1640531527|0,t=X[j&127]^=v+w,i=t==0?i+1:0);for(i>=128&&(X[(seed2&&seed2.length||0)&127]=-1),i=127,j=4*128;j>0;--j)v=X[i+34&127],t=X[i=i+1&127],v^=v<<13,t^=t<<17,v^=v>>>15,t^=t>>>12,X[i]=v^t;me2.w=w,me2.X=X,me2.i=i}init(me,seed)}function copy(f,t){return t.i=f.i,t.w=f.w,t.X=f.X.slice(),t}function impl(seed,opts){seed==null&&(seed=+new Date);var xg=new XorGen(seed),state6=opts&&opts.state,prng=function(){return(xg.next()>>>0)/4294967296};return prng.double=function(){do var top=xg.next()>>>11,bot=(xg.next()>>>0)/4294967296,result=(top+bot)/(1<<21);while(result===0);return result},prng.int32=xg.next,prng.quick=prng,state6&&(state6.X&&copy(state6,xg),prng.state=function(){return copy(xg,{})}),prng}module2&&module2.exports?module2.exports=impl:define2&&define2.amd?define2(function(){return impl}):this.xor4096=impl})(exports3,typeof module=="object"&&module,typeof define=="function"&&define)}),require_tychei2=__commonJS((exports3,module)=>{(function(global2,module2,define2){function XorGen(seed){var me=this,strseed="";me.next=function(){var b=me.b,c=me.c,d=me.d,a=me.a;return b=b<<25^b>>>7^c,c=c-d|0,d=d<<24^d>>>8^a,a=a-b|0,me.b=b=b<<20^b>>>12^c,me.c=c=c-d|0,me.d=d<<16^c>>>16^a,me.a=a-b|0},me.a=0,me.b=0,me.c=2654435769|0,me.d=1367130551,seed===Math.floor(seed)?(me.a=seed/4294967296|0,me.b=seed|0):strseed+=seed;for(var k=0;k<strseed.length+20;k++)me.b^=strseed.charCodeAt(k)|0,me.next()}function copy(f,t){return t.a=f.a,t.b=f.b,t.c=f.c,t.d=f.d,t}function impl(seed,opts){var xg=new XorGen(seed),state6=opts&&opts.state,prng=function(){return(xg.next()>>>0)/4294967296};return prng.double=function(){do var top=xg.next()>>>11,bot=(xg.next()>>>0)/4294967296,result=(top+bot)/(1<<21);while(result===0);return result},prng.int32=xg.next,prng.quick=prng,state6&&(typeof state6=="object"&&copy(state6,xg),prng.state=function(){return copy(xg,{})}),prng}module2&&module2.exports?module2.exports=impl:define2&&define2.amd?define2(function(){return impl}):this.tychei=impl})(exports3,typeof module=="object"&&module,typeof define=="function"&&define)}),require_seedrandom3=__commonJS((exports3,module)=>{(function(global2,pool6,math){var width=256,chunks=6,digits=52,rngname="random",startdenom=math.pow(width,chunks),significance=math.pow(2,digits),overflow=significance*2,mask=width-1,nodecrypto;function seedrandom5(seed,options,callback){var key=[];options=options==!0?{entropy:!0}:options||{};var shortseed=mixkey(flatten4(options.entropy?[seed,tostring(pool6)]:seed==null?autoseed():seed,3),key),arc4=new ARC4(key),prng=function(){for(var n=arc4.g(chunks),d=startdenom,x=0;n<significance;)n=(n+x)*width,d*=width,x=arc4.g(1);for(;n>=overflow;)n/=2,d/=2,x>>>=1;return(n+x)/d};return prng.int32=function(){return arc4.g(4)|0},prng.quick=function(){return arc4.g(4)/4294967296},prng.double=prng,mixkey(tostring(arc4.S),pool6),(options.pass||callback||function(prng2,seed2,is_math_call,state6){return state6&&(state6.S&&copy(state6,arc4),prng2.state=function(){return copy(arc4,{})}),is_math_call?(math[rngname]=prng2,seed2):prng2})(prng,shortseed,"global"in options?options.global:this==math,options.state)}function ARC4(key){var t,keylen=key.length,me=this,i=0,j=me.i=me.j=0,s=me.S=[];for(keylen||(key=[keylen++]);i<width;)s[i]=i++;for(i=0;i<width;i++)s[i]=s[j=mask&j+key[i%keylen]+(t=s[i])],s[j]=t;(me.g=function(count2){for(var t2,r=0,i2=me.i,j2=me.j,s2=me.S;count2--;)t2=s2[i2=mask&i2+1],r=r*width+s2[mask&(s2[i2]=s2[j2=mask&j2+t2])+(s2[j2]=t2)];return me.i=i2,me.j=j2,r})(width)}function copy(f,t){return t.i=f.i,t.j=f.j,t.S=f.S.slice(),t}function flatten4(obj,depth){var result=[],typ=typeof obj,prop;if(depth&&typ=="object")for(prop in obj)try{result.push(flatten4(obj[prop],depth-1))}catch(e){}return result.length?result:typ=="string"?obj:obj+"\0"}function mixkey(seed,key){for(var stringseed=seed+"",smear,j=0;j<stringseed.length;)key[mask&j]=mask&(smear^=key[mask&j]*19)+stringseed.charCodeAt(j++);return tostring(key)}function autoseed(){try{var out;return nodecrypto&&(out=nodecrypto.randomBytes)?out=out(width):(out=new Uint8Array(width),(global2.crypto||global2.msCrypto).getRandomValues(out)),tostring(out)}catch(e){var browser=global2.navigator,plugins=browser&&browser.plugins;return[+new Date,global2,plugins,global2.screen,tostring(pool6)]}}function tostring(a){return String.fromCharCode.apply(0,a)}if(mixkey(math.random(),pool6),typeof module=="object"&&module.exports){module.exports=seedrandom5;try{nodecrypto=require_crypto()}catch(ex){}}else typeof define=="function"&&define.amd?define(function(){return seedrandom5}):math["seed"+rngname]=seedrandom5})(typeof self!="undefined"?self:exports3,[],Math)}),require_seedrandom4=__commonJS((exports3,module)=>{var alea5=require_alea2(),xor128=require_xor1282(),xorwow=require_xorwow2(),xorshift7=require_xorshift72(),xor4096=require_xor40962(),tychei=require_tychei2(),sr=require_seedrandom3();sr.alea=alea5;sr.xor128=xor128;sr.xorwow=xorwow;sr.xorshift7=xorshift7;sr.xor4096=xor4096;sr.tychei=tychei;module.exports=sr}),require_string_decoder=__commonJS(()=>{}),require_alea3=__commonJS((exports3,module)=>{(function(global2,module2,define2){function Alea(seed){var me=this,mash=Mash();me.next=function(){var t=2091639*me.s0+me.c*23283064365386963e-26;return me.s0=me.s1,me.s1=me.s2,me.s2=t-(me.c=t|0)},me.c=1,me.s0=mash(" "),me.s1=mash(" "),me.s2=mash(" "),me.s0-=mash(seed),me.s0<0&&(me.s0+=1),me.s1-=mash(seed),me.s1<0&&(me.s1+=1),me.s2-=mash(seed),me.s2<0&&(me.s2+=1),mash=null}function copy(f,t){return t.c=f.c,t.s0=f.s0,t.s1=f.s1,t.s2=f.s2,t}function impl(seed,opts){var xg=new Alea(seed),state6=opts&&opts.state,prng=xg.next;return prng.int32=function(){return xg.next()*4294967296|0},prng.double=function(){return prng()+(prng()*2097152|0)*11102230246251565e-32},prng.quick=prng,state6&&(typeof state6=="object"&&copy(state6,xg),prng.state=function(){return copy(xg,{})}),prng}function Mash(){var n=4022871197,mash=function(data){data=data.toString();for(var i=0;i<data.length;i++){n+=data.charCodeAt(i);var h=.02519603282416938*n;n=h>>>0,h-=n,h*=n,n=h>>>0,h-=n,n+=h*4294967296}return(n>>>0)*23283064365386963e-26};return mash}module2&&module2.exports?module2.exports=impl:define2&&define2.amd?define2(function(){return impl}):this.alea=impl})(exports3,typeof module=="object"&&module,typeof define=="function"&&define)}),require_xor1283=__commonJS((exports3,module)=>{(function(global2,module2,define2){function XorGen(seed){var me=this,strseed="";me.x=0,me.y=0,me.z=0,me.w=0,me.next=function(){var t=me.x^me.x<<11;return me.x=me.y,me.y=me.z,me.z=me.w,me.w^=me.w>>>19^t^t>>>8},seed===(seed|0)?me.x=seed:strseed+=seed;for(var k=0;k<strseed.length+64;k++)me.x^=strseed.charCodeAt(k)|0,me.next()}function copy(f,t){return t.x=f.x,t.y=f.y,t.z=f.z,t.w=f.w,t}function impl(seed,opts){var xg=new XorGen(seed),state6=opts&&opts.state,prng=function(){return(xg.next()>>>0)/4294967296};return prng.double=function(){do var top=xg.next()>>>11,bot=(xg.next()>>>0)/4294967296,result=(top+bot)/(1<<21);while(result===0);return result},prng.int32=xg.next,prng.quick=prng,state6&&(typeof state6=="object"&&copy(state6,xg),prng.state=function(){return copy(xg,{})}),prng}module2&&module2.exports?module2.exports=impl:define2&&define2.amd?define2(function(){return impl}):this.xor128=impl})(exports3,typeof module=="object"&&module,typeof define=="function"&&define)}),require_xorwow3=__commonJS((exports3,module)=>{(function(global2,module2,define2){function XorGen(seed){var me=this,strseed="";me.next=function(){var t=me.x^me.x>>>2;return me.x=me.y,me.y=me.z,me.z=me.w,me.w=me.v,(me.d=me.d+362437|0)+(me.v=me.v^me.v<<4^(t^t<<1))|0},me.x=0,me.y=0,me.z=0,me.w=0,me.v=0,seed===(seed|0)?me.x=seed:strseed+=seed;for(var k=0;k<strseed.length+64;k++)me.x^=strseed.charCodeAt(k)|0,k==strseed.length&&(me.d=me.x<<10^me.x>>>4),me.next()}function copy(f,t){return t.x=f.x,t.y=f.y,t.z=f.z,t.w=f.w,t.v=f.v,t.d=f.d,t}function impl(seed,opts){var xg=new XorGen(seed),state6=opts&&opts.state,prng=function(){return(xg.next()>>>0)/4294967296};return prng.double=function(){do var top=xg.next()>>>11,bot=(xg.next()>>>0)/4294967296,result=(top+bot)/(1<<21);while(result===0);return result},prng.int32=xg.next,prng.quick=prng,state6&&(typeof state6=="object"&&copy(state6,xg),prng.state=function(){return copy(xg,{})}),prng}module2&&module2.exports?module2.exports=impl:define2&&define2.amd?define2(function(){return impl}):this.xorwow=impl})(exports3,typeof module=="object"&&module,typeof define=="function"&&define)}),require_xorshift73=__commonJS((exports3,module)=>{(function(global2,module2,define2){function XorGen(seed){var me=this;me.next=function(){var X=me.x,i=me.i,t,v,w;return t=X[i],t^=t>>>7,v=t^t<<24,t=X[i+1&7],v^=t^t>>>10,t=X[i+3&7],v^=t^t>>>3,t=X[i+4&7],v^=t^t<<7,t=X[i+7&7],t=t^t<<13,v^=t^t<<9,X[i]=v,me.i=i+1&7,v};function init(me2,seed2){var j,w,X=[];if(seed2===(seed2|0))w=X[0]=seed2;else for(seed2=""+seed2,j=0;j<seed2.length;++j)X[j&7]=X[j&7]<<15^seed2.charCodeAt(j)+X[j+1&7]<<13;for(;X.length<8;)X.push(0);for(j=0;j<8&&X[j]===0;++j);for(j==8?w=X[7]=-1:w=X[j],me2.x=X,me2.i=0,j=256;j>0;--j)me2.next()}init(me,seed)}function copy(f,t){return t.x=f.x.slice(),t.i=f.i,t}function impl(seed,opts){seed==null&&(seed=+new Date);var xg=new XorGen(seed),state6=opts&&opts.state,prng=function(){return(xg.next()>>>0)/4294967296};return prng.double=function(){do var top=xg.next()>>>11,bot=(xg.next()>>>0)/4294967296,result=(top+bot)/(1<<21);while(result===0);return result},prng.int32=xg.next,prng.quick=prng,state6&&(state6.x&&copy(state6,xg),prng.state=function(){return copy(xg,{})}),prng}module2&&module2.exports?module2.exports=impl:define2&&define2.amd?define2(function(){return impl}):this.xorshift7=impl})(exports3,typeof module=="object"&&module,typeof define=="function"&&define)}),require_xor40963=__commonJS((exports3,module)=>{(function(global2,module2,define2){function XorGen(seed){var me=this;me.next=function(){var w=me.w,X=me.X,i=me.i,t,v;return me.w=w=w+1640531527|0,v=X[i+34&127],t=X[i=i+1&127],v^=v<<13,t^=t<<17,v^=v>>>15,t^=t>>>12,v=X[i]=v^t,me.i=i,v+(w^w>>>16)|0};function init(me2,seed2){var t,v,i,j,w,X=[],limit=128;for(seed2===(seed2|0)?(v=seed2,seed2=null):(seed2=seed2+"\0",v=0,limit=Math.max(limit,seed2.length)),i=0,j=-32;j<limit;++j)seed2&&(v^=seed2.charCodeAt((j+32)%seed2.length)),j===0&&(w=v),v^=v<<10,v^=v>>>15,v^=v<<4,v^=v>>>13,j>=0&&(w=w+1640531527|0,t=X[j&127]^=v+w,i=t==0?i+1:0);for(i>=128&&(X[(seed2&&seed2.length||0)&127]=-1),i=127,j=4*128;j>0;--j)v=X[i+34&127],t=X[i=i+1&127],v^=v<<13,t^=t<<17,v^=v>>>15,t^=t>>>12,X[i]=v^t;me2.w=w,me2.X=X,me2.i=i}init(me,seed)}function copy(f,t){return t.i=f.i,t.w=f.w,t.X=f.X.slice(),t}function impl(seed,opts){seed==null&&(seed=+new Date);var xg=new XorGen(seed),state6=opts&&opts.state,prng=function(){return(xg.next()>>>0)/4294967296};return prng.double=function(){do var top=xg.next()>>>11,bot=(xg.next()>>>0)/4294967296,result=(top+bot)/(1<<21);while(result===0);return result},prng.int32=xg.next,prng.quick=prng,state6&&(state6.X&&copy(state6,xg),prng.state=function(){return copy(xg,{})}),prng}module2&&module2.exports?module2.exports=impl:define2&&define2.amd?define2(function(){return impl}):this.xor4096=impl})(exports3,typeof module=="object"&&module,typeof define=="function"&&define)}),require_tychei3=__commonJS((exports3,module)=>{(function(global2,module2,define2){function XorGen(seed){var me=this,strseed="";me.next=function(){var b=me.b,c=me.c,d=me.d,a=me.a;return b=b<<25^b>>>7^c,c=c-d|0,d=d<<24^d>>>8^a,a=a-b|0,me.b=b=b<<20^b>>>12^c,me.c=c=c-d|0,me.d=d<<16^c>>>16^a,me.a=a-b|0},me.a=0,me.b=0,me.c=2654435769|0,me.d=1367130551,seed===Math.floor(seed)?(me.a=seed/4294967296|0,me.b=seed|0):strseed+=seed;for(var k=0;k<strseed.length+20;k++)me.b^=strseed.charCodeAt(k)|0,me.next()}function copy(f,t){return t.a=f.a,t.b=f.b,t.c=f.c,t.d=f.d,t}function impl(seed,opts){var xg=new XorGen(seed),state6=opts&&opts.state,prng=function(){return(xg.next()>>>0)/4294967296};return prng.double=function(){do var top=xg.next()>>>11,bot=(xg.next()>>>0)/4294967296,result=(top+bot)/(1<<21);while(result===0);return result},prng.int32=xg.next,prng.quick=prng,state6&&(typeof state6=="object"&&copy(state6,xg),prng.state=function(){return copy(xg,{})}),prng}module2&&module2.exports?module2.exports=impl:define2&&define2.amd?define2(function(){return impl}):this.tychei=impl})(exports3,typeof module=="object"&&module,typeof define=="function"&&define)}),require_seedrandom5=__commonJS((exports3,module)=>{(function(pool6,math){var global2=this,width=256,chunks=6,digits=52,rngname="random",startdenom=math.pow(width,chunks),significance=math.pow(2,digits),overflow=significance*2,mask=width-1,nodecrypto;function seedrandom5(seed,options,callback){var key=[];options=options==!0?{entropy:!0}:options||{};var shortseed=mixkey(flatten4(options.entropy?[seed,tostring(pool6)]:seed==null?autoseed():seed,3),key),arc4=new ARC4(key),prng=function(){for(var n=arc4.g(chunks),d=startdenom,x=0;n<significance;)n=(n+x)*width,d*=width,x=arc4.g(1);for(;n>=overflow;)n/=2,d/=2,x>>>=1;return(n+x)/d};return prng.int32=function(){return arc4.g(4)|0},prng.quick=function(){return arc4.g(4)/4294967296},prng.double=prng,mixkey(tostring(arc4.S),pool6),(options.pass||callback||function(prng2,seed2,is_math_call,state6){return state6&&(state6.S&&copy(state6,arc4),prng2.state=function(){return copy(arc4,{})}),is_math_call?(math[rngname]=prng2,seed2):prng2})(prng,shortseed,"global"in options?options.global:this==math,options.state)}math["seed"+rngname]=seedrandom5;function ARC4(key){var t,keylen=key.length,me=this,i=0,j=me.i=me.j=0,s=me.S=[];for(keylen||(key=[keylen++]);i<width;)s[i]=i++;for(i=0;i<width;i++)s[i]=s[j=mask&j+key[i%keylen]+(t=s[i])],s[j]=t;(me.g=function(count2){for(var t2,r=0,i2=me.i,j2=me.j,s2=me.S;count2--;)t2=s2[i2=mask&i2+1],r=r*width+s2[mask&(s2[i2]=s2[j2=mask&j2+t2])+(s2[j2]=t2)];return me.i=i2,me.j=j2,r})(width)}function copy(f,t){return t.i=f.i,t.j=f.j,t.S=f.S.slice(),t}function flatten4(obj,depth){var result=[],typ=typeof obj,prop;if(depth&&typ=="object")for(prop in obj)try{result.push(flatten4(obj[prop],depth-1))}catch(e){}return result.length?result:typ=="string"?obj:obj+"\0"}function mixkey(seed,key){for(var stringseed=seed+"",smear,j=0;j<stringseed.length;)key[mask&j]=mask&(smear^=key[mask&j]*19)+stringseed.charCodeAt(j++);return tostring(key)}function autoseed(){try{var out;return nodecrypto&&(out=nodecrypto.randomBytes)?out=out(width):(out=new Uint8Array(width),(global2.crypto||global2.msCrypto).getRandomValues(out)),tostring(out)}catch(e){var browser=global2.navigator,plugins=browser&&browser.plugins;return[+new Date,global2,plugins,global2.screen,tostring(pool6)]}}function tostring(a){return String.fromCharCode.apply(0,a)}if(mixkey(math.random(),pool6),typeof module=="object"&&module.exports){module.exports=seedrandom5;try{nodecrypto=require_crypto()}catch(ex){}}else typeof define=="function"&&define.amd&&define(function(){return seedrandom5})})([],Math)}),require_seedrandom6=__commonJS((exports3,module)=>{var alea5=require_alea3(),xor128=require_xor1283(),xorwow=require_xorwow3(),xorshift7=require_xorshift73(),xor4096=require_xor40963(),tychei=require_tychei3(),sr=require_seedrandom5();sr.alea=alea5;sr.xor128=xor128;sr.xorwow=xorwow;sr.xorshift7=xorshift7;sr.xor4096=xor4096;sr.tychei=tychei;module.exports=sr});var EPSILON_FLOAT32=1e-7,EPSILON_FLOAT16=1e-4,DataStorage=class{constructor(backend3,dataMover){this.backend=backend3,this.dataMover=dataMover,this.data=new WeakMap,this.dataIdsCount=0}get(dataId){return this.data.has(dataId)||this.dataMover.moveData(this.backend,dataId),this.data.get(dataId)}set(dataId,value){this.dataIdsCount++,this.data.set(dataId,value)}has(dataId){return this.data.has(dataId)}delete(dataId){return this.dataIdsCount--,this.data.delete(dataId)}numDataIds(){return this.dataIdsCount}},KernelBackend=class{time(f){return notYetImplemented("time")}read(dataId){return notYetImplemented("read")}readSync(dataId){return notYetImplemented("readSync")}numDataIds(){return notYetImplemented("numDataIds")}disposeData(dataId){return notYetImplemented("disposeData")}write(values,shape,dtype){return notYetImplemented("write")}move(dataId,values,shape,dtype){return notYetImplemented("move")}memory(){return notYetImplemented("memory")}floatPrecision(){return notYetImplemented("floatPrecision")}epsilon(){return this.floatPrecision()===32?EPSILON_FLOAT32:EPSILON_FLOAT16}batchMatMul(a,b,transposeA,transposeB){return notYetImplemented("batchMatMul")}fusedBatchMatMul({a,b,transposeA,transposeB,bias,activation,preluActivationWeights}){return notYetImplemented("fusedBatchMatMul")}slice(x,begin,size){return notYetImplemented("slice")}stridedSlice(x,begin,end,strides){return notYetImplemented("stridedSlice")}unstack(x,axis){return notYetImplemented("unstack")}reverse(a,axis){return notYetImplemented("reverse")}concat(tensors,axis){return notYetImplemented("concat")}neg(a){return notYetImplemented("neg")}add(a,b){return notYetImplemented("add")}addN(tensors){return notYetImplemented("addN")}subtract(a,b){return notYetImplemented("subtract")}multiply(a,b){return notYetImplemented("multiply")}realDivide(a,b){return notYetImplemented("realDivide")}floorDiv(a,b){return notYetImplemented("floorDiv")}sum(x,axes){return notYetImplemented("sum")}prod(x,axes){return notYetImplemented("prod")}unsortedSegmentSum(x,segmentIds,numSegments){return notYetImplemented("unsortedSegmentSum")}argMin(x,axis){return notYetImplemented("argMin")}argMax(x,axis){return notYetImplemented("argMax")}equal(a,b){return notYetImplemented("equal")}notEqual(a,b){return notYetImplemented("notEqual")}less(a,b){return notYetImplemented("less")}lessEqual(a,b){return notYetImplemented("lessEqual")}greater(a,b){return notYetImplemented("greater")}greaterEqual(a,b){return notYetImplemented("greaterEqual")}logicalNot(a){return notYetImplemented("logicalNot")}logicalAnd(a,b){return notYetImplemented("logicalAnd")}logicalOr(a,b){return notYetImplemented("logicalOr")}where(condition){return notYetImplemented("where")}select(condition,a,b){return notYetImplemented("select")}topk(x,k,sorted){return notYetImplemented("topk")}min(x,axes){return notYetImplemented("min")}minimum(a,b){return notYetImplemented("minimum")}mod(a,b){return notYetImplemented("mod")}max(x,axes){return notYetImplemented("max")}maximum(a,b){return notYetImplemented("maximum")}all(x,axes){return notYetImplemented("all")}any(x,axes){return notYetImplemented("any")}squaredDifference(a,b){return notYetImplemented("squaredDifference")}ceil(x){return notYetImplemented("ceil")}floor(x){return notYetImplemented("floor")}round(x){return notYetImplemented("round")}sign(x){return notYetImplemented("sign")}isNaN(x){return notYetImplemented("isNaN")}isInf(x){return notYetImplemented("isInf")}isFinite(x){return notYetImplemented("isFinite")}pow(a,b){return notYetImplemented("pow")}exp(x){return notYetImplemented("exp")}expm1(x){return notYetImplemented("expm1")}softmax(x,dim){return notYetImplemented("softmax")}log(x){return notYetImplemented("log")}log1p(x){return notYetImplemented("log1p")}sqrt(x){return notYetImplemented("sqrt")}rsqrt(x){return notYetImplemented("rsqrt")}square(x){return notYetImplemented("square")}reciprocal(x){return notYetImplemented("reciprocal")}relu(x){return notYetImplemented("relu")}relu6(x){return notYetImplemented("relu6")}prelu(x,a){return notYetImplemented("prelu")}elu(x){return notYetImplemented("elu")}eluDer(dy,y){return notYetImplemented("eluDer")}selu(x){return notYetImplemented("selu")}int(x){return notYetImplemented("int")}clip(x,min7,max9){return notYetImplemented("clip")}abs(x){return notYetImplemented("abs")}complexAbs(x){return notYetImplemented("complexAbs")}sigmoid(x){return notYetImplemented("sigmoid")}softplus(x){return notYetImplemented("softplus")}sin(x){return notYetImplemented("sin")}cos(x){return notYetImplemented("cos")}tan(x){return notYetImplemented("tan")}asin(x){return notYetImplemented("asin")}acos(x){return notYetImplemented("acos")}atan(x){return notYetImplemented("atan")}atan2(a,b){return notYetImplemented("atan2")}sinh(x){return notYetImplemented("sinh")}cosh(x){return notYetImplemented("cosh")}tanh(x){return notYetImplemented("tanh")}asinh(x){return notYetImplemented("asinh")}acosh(x){return notYetImplemented("acosh")}atanh(x){return notYetImplemented("atanh")}erf(x){return notYetImplemented("erf")}step(x,alpha){return notYetImplemented("step")}fusedConv2d({input:input2,filter,convInfo,bias,activation,preluActivationWeights}){return notYetImplemented("fusedConv2d")}conv2d(x,filter,convInfo){return notYetImplemented("conv2d")}conv2dDerInput(dy,filter,convInfo){return notYetImplemented("conv2dDerInput")}conv2dDerFilter(x,dY,convInfo){return notYetImplemented("conv2dDerFilter")}fusedDepthwiseConv2D({input:input2,filter,convInfo,bias,activation,preluActivationWeights}){return notYetImplemented("fusedDepthwiseConv2D")}depthwiseConv2D(input2,filter,convInfo){return notYetImplemented("depthwiseConv2D")}depthwiseConv2DDerInput(dy,filter,convInfo){return notYetImplemented("depthwiseConv2DDerInput")}depthwiseConv2DDerFilter(x,dY,convInfo){return notYetImplemented("depthwiseConv2DDerFilter")}conv3d(x,filter,convInfo){return notYetImplemented("conv3d")}conv3dDerInput(dy,filter,convInfo){return notYetImplemented("conv3dDerInput")}conv3dDerFilter(x,dY,convInfo){return notYetImplemented("conv3dDerFilter")}maxPool(x,convInfo){return notYetImplemented("maxPool")}maxPoolBackprop(dy,x,y,convInfo){return notYetImplemented("maxPoolBackprop")}avgPool(x,convInfo){return notYetImplemented("avgPool")}avgPoolBackprop(dy,x,convInfo){return notYetImplemented("avgPoolBackprop")}avgPool3d(x,convInfo){return notYetImplemented("avgPool3d")}avgPool3dBackprop(dy,x,convInfo){return notYetImplemented("avgPool3dBackprop")}maxPool3d(x,convInfo){return notYetImplemented("maxPool3d")}maxPool3dBackprop(dy,x,y,convInfo){return notYetImplemented("maxPool3dBackprop")}reshape(x,shape){return notYetImplemented("reshape")}cast(x,dtype){return notYetImplemented("cast")}tile(x,reps){return notYetImplemented("tile")}pad(x,paddings,constantValue){return notYetImplemented("pad")}transpose(x,perm){return notYetImplemented("transpose")}gather(x,indices,axis){return notYetImplemented("gather")}gatherND(x,indices){return notYetImplemented("gatherND")}scatterND(indices,updates,shape){return notYetImplemented("scatterND")}batchToSpaceND(x,blockShape,crops){return notYetImplemented("batchToSpaceND")}spaceToBatchND(x,blockShape,paddings){return notYetImplemented("spaceToBatchND")}resizeBilinear(x,newHeight,newWidth,alignCorners){return notYetImplemented("resizeBilinear")}resizeBilinearBackprop(dy,x,alignCorners){return notYetImplemented("resizeBilinearBackprop")}resizeNearestNeighbor(x,newHEight,newWidth,alignCorners){return notYetImplemented("resizeNearestNeighbor")}resizeNearestNeighborBackprop(dy,x,alignCorners){return notYetImplemented("resizeNearestNeighborBackprop")}batchNorm(x,mean7,variance,offset,scale2,varianceEpsilon){return notYetImplemented("batchNorm")}localResponseNormalization4D(x,radius,bias,alpha,beta){return notYetImplemented("localResponseNormalization4D")}LRNGrad(dy,inputImage,outputImage,radius,bias,alpha,beta){return notYetImplemented("LRNGrad")}multinomial(logits,normalized,numSamples,seed){return notYetImplemented("multinomial")}oneHot(indices,depth,onValue,offValue){return notYetImplemented("oneHot")}cumsum(x,axis,exclusive,reverse7){return notYetImplemented("cumsum")}nonMaxSuppression(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold){return notYetImplemented("nonMaxSuppression")}fft(x){return notYetImplemented("fft")}ifft(x){return notYetImplemented("ifft")}complex(real8,imag8){return notYetImplemented("complex")}real(input2){return notYetImplemented("real")}imag(input2){return notYetImplemented("imag")}cropAndResize(image3,boxes,boxIndex,cropSize,method,extrapolationValue){return notYetImplemented("cropAndResize")}depthToSpace(x,blockSize,dataFormat){return notYetImplemented("depthToSpace")}split(value,sizeSplits,axis){return notYetImplemented("split")}sparseToDense(sparseIndices,sparseValues,outputShape,defaultValue){return notYetImplemented("sparseToDense")}diag(x){return notYetImplemented("diag")}fill(shape,value,dtype){return notYetImplemented("fill")}onesLike(x){return notYetImplemented("onesLike")}zerosLike(x){return notYetImplemented("zerosLike")}linspace(start,stop,num){return notYetImplemented("linspace")}dispose(){return notYetImplemented("dispose")}};function notYetImplemented(kernelName){throw new Error(`'${kernelName}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function shuffle(array2){let counter=array2.length,temp=0,index=0;for(;counter>0;)index=Math.random()*counter|0,counter--,temp=array2[counter],array2[counter]=array2[index],array2[index]=temp}function clamp(min7,x,max9){return Math.max(min7,Math.min(x,max9))}function nearestLargerEven(val){return val%2===0?val:val+1}function sum(arr){let sum28=0;for(let i=0;i<arr.length;i++)sum28+=arr[i];return sum28}function randUniform(a,b){let r=Math.random();return b*r+(1-r)*a}function distSquared(a,b){let result=0;for(let i=0;i<a.length;i++){let diff=Number(a[i])-Number(b[i]);result+=diff*diff}return result}function assert(expr,msg){if(!expr)throw new Error(typeof msg=="string"?msg:msg())}function assertShapesMatch(shapeA,shapeB,errorMessagePrefix=""){assert(arraysEqual(shapeA,shapeB),()=>errorMessagePrefix+` Shapes ${shapeA} and ${shapeB} must match`)}function assertNonNull(a){assert(a!=null,()=>"The input to the tensor constructor must be a non-null value.")}function flatten(arr,result=[],skipTypedArray=!1){if(result==null&&(result=[]),Array.isArray(arr)||isTypedArray(arr)&&!skipTypedArray)for(let i=0;i<arr.length;++i)flatten(arr[i],result,skipTypedArray);else result.push(arr);return result}function sizeFromShape(shape){if(shape.length===0)return 1;let size=shape[0];for(let i=1;i<shape.length;i++)size*=shape[i];return size}function isScalarShape(shape){return shape.length===0}function arraysEqual(n1,n2){if(n1===n2)return!0;if(n1==null||n2==null)return!1;if(n1.length!==n2.length)return!1;for(let i=0;i<n1.length;i++)if(n1[i]!==n2[i])return!1;return!0}function isInt(a){return a%1===0}function tanh(x){if(Math.tanh!=null)return Math.tanh(x);if(x===Infinity)return 1;if(x===-Infinity)return-1;{let e2x=Math.exp(2*x);return(e2x-1)/(e2x+1)}}function sizeToSquarishShape(size){let width=Math.ceil(Math.sqrt(size));return[width,Math.ceil(size/width)]}function createShuffledIndices(n){let shuffledIndices=new Uint32Array(n);for(let i=0;i<n;++i)shuffledIndices[i]=i;return shuffle(shuffledIndices),shuffledIndices}function rightPad(a,size){return size<=a.length?a:a+" ".repeat(size-a.length)}function repeatedTry(checkFn,delayFn=counter=>0,maxCounter){return new Promise((resolve,reject)=>{let tryCount=0,tryFn=()=>{if(checkFn()){resolve();return}tryCount++;let nextBackoff=delayFn(tryCount);if(maxCounter!=null&&tryCount>=maxCounter){reject();return}setTimeout(tryFn,nextBackoff)};tryFn()})}function inferFromImplicitShape(shape,size){let shapeProd=1,implicitIdx=-1;for(let i=0;i<shape.length;++i)if(shape[i]>=0)shapeProd*=shape[i];else if(shape[i]===-1){if(implicitIdx!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${implicitIdx} and dim ${i}`);implicitIdx=i}else if(shape[i]<0)throw Error(`Shapes can not be < 0. Found ${shape[i]} at dim ${i}`);if(implicitIdx===-1){if(size>0&&size!==shapeProd)throw Error(`Size(${size}) must match the product of shape ${shape}`);return shape}if(shapeProd===0)throw Error(`Cannot infer the missing size in [${shape}] when there are 0 elements`);if(size%shapeProd!==0)throw Error(`The implicit shape can't be a fractional number. Got ${size} / ${shapeProd}`);let newShape=shape.slice();return newShape[implicitIdx]=size/shapeProd,newShape}function parseAxisParam(axis,shape){let rank=shape.length;return axis=axis==null?shape.map((s,i)=>i):[].concat(axis),assert(axis.every(ax=>ax>=-rank&&ax<rank),()=>`All values in axis param must be in range [-${rank}, ${rank}) but got axis ${axis}`),assert(axis.every(ax=>isInt(ax)),()=>`All values in axis param must be integers but got axis ${axis}`),axis.map(a=>a<0?rank+a:a)}function squeezeShape(shape,axis){let newShape=[],keptDims=[],isEmptyArray=axis!=null&&Array.isArray(axis)&&axis.length===0,axes=axis==null||isEmptyArray?null:parseAxisParam(axis,shape).sort(),j=0;for(let i=0;i<shape.length;++i){if(axes!=null){if(axes[j]===i&&shape[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${shape[i]}' is not 1`);(axes[j]==null||axes[j]>i)&&shape[i]===1&&(newShape.push(shape[i]),keptDims.push(i)),axes[j]<=i&&j++}shape[i]!==1&&(newShape.push(shape[i]),keptDims.push(i))}return{newShape,keptDims}}function getTypedArrayFromDType(dtype,size){let values=null;if(dtype==null||dtype==="float32")values=new Float32Array(size);else if(dtype==="int32")values=new Int32Array(size);else if(dtype==="bool")values=new Uint8Array(size);else throw new Error(`Unknown data type ${dtype}`);return values}function getArrayFromDType(dtype,size){let values=null;if(dtype==null||dtype==="float32")values=new Float32Array(size);else if(dtype==="int32")values=new Int32Array(size);else if(dtype==="bool")values=new Uint8Array(size);else if(dtype==="string")values=new Array(size);else throw new Error(`Unknown data type ${dtype}`);return values}function checkConversionForErrors(vals,dtype){for(let i=0;i<vals.length;i++){let num=vals[i];if(isNaN(num)||!isFinite(num))throw Error(`A tensor of type ${dtype} being uploaded contains ${num}.`)}}function isValidDtype(dtype){return dtype==="bool"||dtype==="complex64"||dtype==="float32"||dtype==="int32"||dtype==="string"}function hasEncodingLoss(oldType,newType){return newType==="complex64"||(newType==="float32"&&oldType!=="complex64"||newType==="int32"&&oldType!=="float32"&&oldType!=="complex64")?!1:!(newType==="bool"&&oldType==="bool")}function isTypedArray(a){return a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array}function bytesPerElement(dtype){if(dtype==="float32"||dtype==="int32")return 4;if(dtype==="complex64")return 8;if(dtype==="bool")return 1;throw new Error(`Unknown dtype ${dtype}`)}function bytesFromStringArray(arr){if(arr==null)return 0;let bytes=0;return arr.forEach(x=>bytes+=x.length),bytes}function isString(value){return typeof value=="string"||value instanceof String}function isBoolean(value){return typeof value=="boolean"}function isNumber(value){return typeof value=="number"}function inferDtype(values){return Array.isArray(values)?inferDtype(values[0]):values instanceof Float32Array?"float32":values instanceof Int32Array||values instanceof Uint8Array?"int32":isNumber(values)?"float32":isString(values)?"string":isBoolean(values)?"bool":"float32"}function isFunction(f){return!!(f&&f.constructor&&f.call&&f.apply)}function nearestDivisor(size,start){for(let i=start;i<size;++i)if(size%i===0)return i;return size}function computeStrides(shape){let rank=shape.length;if(rank<2)return[];let strides=new Array(rank-1);strides[rank-2]=shape[rank-1];for(let i=rank-3;i>=0;--i)strides[i]=strides[i+1]*shape[i+1];return strides}function createNestedArray(offset,shape,a){let ret=new Array;if(shape.length===1){let d=shape[0];for(let i=0;i<d;i++)ret[i]=a[offset+i]}else{let d=shape[0],rest=shape.slice(1),len=rest.reduce((acc,c)=>acc*c);for(let i=0;i<d;i++)ret[i]=createNestedArray(offset+i*len,rest,a)}return ret}function toNestedArray(shape,a){if(shape.length===0)return a[0];let size=shape.reduce((acc,c)=>acc*c);if(size===0)return[];if(size!==a.length)throw new Error(`[${shape}] does not match the input size ${a.length}.`);return createNestedArray(0,shape,a)}function makeOnesTypedArray(size,dtype){let array2=makeZerosTypedArray(size,dtype);for(let i=0;i<array2.length;i++)array2[i]=1;return array2}function makeZerosTypedArray(size,dtype){if(dtype==null||dtype==="float32"||dtype==="complex64")return new Float32Array(size);if(dtype==="int32")return new Int32Array(size);if(dtype==="bool")return new Uint8Array(size);throw new Error(`Unknown data type ${dtype}`)}function makeZerosNestedTypedArray(shape,dtype){let size=shape.reduce((prev,curr)=>prev*curr,1);if(dtype==null||dtype==="float32")return toNestedArray(shape,new Float32Array(size));if(dtype==="int32")return toNestedArray(shape,new Int32Array(size));if(dtype==="bool")return toNestedArray(shape,new Uint8Array(size));throw new Error(`Unknown data type ${dtype}`)}function assertNonNegativeIntegerDimensions(shape){shape.forEach(dimSize=>{assert(Number.isInteger(dimSize)&&dimSize>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${shape}].`)})}function locToIndex(locs,rank,strides){if(rank===0)return 0;if(rank===1)return locs[0];let index=locs[locs.length-1];for(let i=0;i<locs.length-1;++i)index+=strides[i]*locs[i];return index}function indexToLoc(index,rank,strides){if(rank===0)return[];if(rank===1)return[index];let locs=new Array(rank);for(let i=0;i<locs.length-1;++i)locs[i]=Math.floor(index/strides[i]),index-=locs[i]*strides[i];return locs[locs.length-1]=index,locs}function isPromise(object){return object&&object.then&&typeof object.then=="function"}var TENSORFLOWJS_FLAGS_PREFIX="tfjsflags",Environment=class{constructor(global2){this.global=global2,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}setPlatform(platformName,platform){this.platform!=null&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${platform}.`),this.platformName=platformName,this.platform=platform}registerFlag(flagName,evaluationFn,setHook){if(this.flagRegistry[flagName]={evaluationFn,setHook},this.urlFlags[flagName]!=null){let flagValue=this.urlFlags[flagName];console.warn(`Setting feature override from URL ${flagName}: ${flagValue}.`),this.set(flagName,flagValue)}}async getAsync(flagName){return flagName in this.flags?this.flags[flagName]:(this.flags[flagName]=await this.evaluateFlag(flagName),this.flags[flagName])}get(flagName){if(flagName in this.flags)return this.flags[flagName];let flagValue=this.evaluateFlag(flagName);if(isPromise(flagValue))throw new Error(`Flag ${flagName} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[flagName]=flagValue,this.flags[flagName]}getNumber(flagName){return this.get(flagName)}getBool(flagName){return this.get(flagName)}getFlags(){return this.flags}get features(){return this.flags}set(flagName,value){if(this.flagRegistry[flagName]==null)throw new Error(`Cannot set flag ${flagName} as it has not been registered.`);this.flags[flagName]=value,this.flagRegistry[flagName].setHook!=null&&this.flagRegistry[flagName].setHook(value)}evaluateFlag(flagName){if(this.flagRegistry[flagName]==null)throw new Error(`Cannot evaluate flag '${flagName}': no evaluation function found.`);return this.flagRegistry[flagName].evaluationFn()}setFlags(flags6){this.flags=Object.assign({},flags6)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;let urlParams=getQueryParams(this.global.location.search);if(TENSORFLOWJS_FLAGS_PREFIX in urlParams){let keyValues=urlParams[TENSORFLOWJS_FLAGS_PREFIX].split(",");keyValues.forEach(keyValue=>{let[key,value]=keyValue.split(":");this.urlFlags[key]=parseValue(key,value)})}}};function getQueryParams(queryString){let params={};return queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(s,...t)=>(decodeParam(params,t[0],t[1]),t.join("="))),params}function decodeParam(params,name,value){params[decodeURIComponent(name)]=decodeURIComponent(value||"")}function parseValue(flagName,value){if(value=value.toLowerCase(),value==="true"||value==="false")return value==="true";if(`${+value}`===value)return+value;throw new Error(`Could not parse value flag value ${value} for flag ${flagName}.`)}function env(){return ENV}var ENV=null;function setEnvironmentGlobal(environment15){ENV=environment15}var globalNameSpace;function getGlobalNamespace(){if(globalNameSpace==null){let ns;if(typeof window!="undefined")ns=window;else if(typeof global!="undefined")ns=global;else if(typeof process!="undefined")ns=process;else if(typeof self!="undefined")ns=self;else throw new Error("Could not find a global object");globalNameSpace=ns}return globalNameSpace}function getGlobalMap(){let ns=getGlobalNamespace();return ns._tfGlobals==null&&(ns._tfGlobals=new Map),ns._tfGlobals}function getGlobal(key,init){let globalMap=getGlobalMap();if(globalMap.has(key))return globalMap.get(key);{let singleton=init();return globalMap.set(key,singleton),globalMap.get(key)}}var Abs="Abs",Acos="Acos",Acosh="Acosh",Add="Add",AddN="AddN",All="All",Any="Any",ArgMax="ArgMax",ArgMin="ArgMin",Asin="Asin",Asinh="Asinh",Atan="Atan",Atanh="Atanh",Atan2="Atan2",AvgPool="AvgPool",AvgPoolBackprop="AvgPoolBackprop",AvgPool3D="AvgPool3D",AvgPool3DBackprop="AvgPool3DBackprop",BatchMatMul="BatchMatMul",BatchToSpaceND="BatchToSpaceND",BroadcastTo="BroadcastTo",Cast="Cast",Ceil="Ceil",ClipByValue="ClipByValue",Complex="Complex",Concat="Concat",Conv2D="Conv2D",Conv2DBackpropFilter="Conv2DBackpropFilter",Conv2DBackpropInput="Conv2DBackpropInput",Conv3D="Conv3D",Conv3DBackpropFilterV2="Conv3DBackpropFilterV2",Conv3DBackpropInputV2="Conv3DBackpropInputV2",Cos="Cos",Cosh="Cosh",Cumsum="Cumsum",CropAndResize="CropAndResize",DepthToSpace="DepthToSpace",DepthwiseConv2dNative="DepthwiseConv2dNative",DepthwiseConv2dNativeBackpropFilter="DepthwiseConv2dNativeBackpropFilter",DepthwiseConv2dNativeBackpropInput="DepthwiseConv2dNativeBackpropInput",Dilation2D="Dilation2D",Dilation2DBackpropInput="Dilation2DBackpropInput",Dilation2DBackpropFilter="Dilation2DBackpropFilter",Div="Div",Elu="Elu",EluGrad="EluGrad",Erf="Erf",Equal="Equal",Exp="Exp",Expm1="Expm1",FFT="FFT",Fill="Fill",FlipLeftRight="FlipLeftRight",Floor="Floor",FloorDiv="FloorDiv",FusedBatchNorm="FusedBatchNorm",GatherV2="GatherV2",Greater="Greater",GreaterEqual="GreaterEqual",Identity="Identity",IFFT="IFFT",Imag="Imag",IsFinite="IsFinite",IsInf="IsInf",IsNan="IsNan",Less="Less",LessEqual="LessEqual",Log="Log",Log1p="Log1p",LogicalAnd="LogicalAnd",LogicalNot="LogicalNot",LogicalOr="LogicalOr",LogSoftmax="LogSoftmax",LRN="LRN",LRNBackprop="LRNBackprop",Max="Max",Maximum="Maximum",MaxPool="MaxPool",MaxPoolBackprop="MaxPoolBackprop",MaxPool3D="MaxPool3D",MaxPool3DBackprop="MaxPool3DBackprop",MaxPoolWithArgmax="MaxPoolWithArgmax",Mean="Mean",Min="Min",Minimum="Minimum",MirrorPad="MirrorPad",Mod="Mod",Multiply="Multiply",Negate="Negate",NotEqual="NotEqual",NonMaxSuppressionV3="NonMaxSuppressionV3",NonMaxSuppressionV4="NonMaxSuppressionV4",NonMaxSuppressionV5="NonMaxSuppressionV5",OnesLike="OnesLike",OneHot="OneHot",PadV2="PadV2",Pow="Pow",Prelu="Prelu",Prod="Prod",Range="Range",Real="Real",Reciprocal="Reciprocal",Relu="Relu",Reshape="Reshape",ResizeNearestNeighbor="ResizeNearestNeighbor",ResizeNearestNeighborGrad="ResizeNearestNeighborGrad",ResizeBilinear="ResizeBilinear",ResizeBilinearGrad="ResizeBilinearGrad",Relu6="Relu6",Reverse="Reverse",Round="Round",Rsqrt="Rsqrt",SelectV2="SelectV2",Selu="Selu",Slice="Slice",Sin="Sin",Sinh="Sinh",Sign="Sign",Sigmoid="Sigmoid",Softplus="Softplus",Sqrt="Sqrt",Sum="Sum",SpaceToBatchND="SpaceToBatchND",SplitV="SplitV",Softmax="Softmax",SquaredDifference="SquaredDifference",Square="Square",Sub="Sub",StridedSlice="StridedSlice",Tan="Tan",Tanh="Tanh",Tile="Tile",TopK="TopK",Transpose="Transpose",Unique="Unique",Unpack="Unpack",UnsortedSegmentSum="UnsortedSegmentSum",ZerosLike="ZerosLike",Step="Step",FromPixels="FromPixels",RotateWithOffset="RotateWithOffset",_FusedMatMul="_FusedMatMul",FusedConv2D="FusedConv2D",FusedDepthwiseConv2D="FusedDepthwiseConv2D";var kernelRegistry=getGlobal("kernelRegistry",()=>new Map),gradRegistry=getGlobal("gradRegistry",()=>new Map);function getKernel(kernelName,backendName){let key=makeKey(kernelName,backendName);return kernelRegistry.get(key)}function getGradient(kernelName){return gradRegistry.get(kernelName)}function getKernelsForBackend(backendName){let it=kernelRegistry.entries(),result=[];for(;;){let{done,value}=it.next();if(done)break;let[key,config]=value,[backend3]=key.split("_");backend3===backendName&&result.push(config)}return result}function registerKernel(config){let{kernelName,backendName}=config,key=makeKey(kernelName,backendName);kernelRegistry.has(key)&&console.warn(`The kernel '${kernelName}' for backend '${backendName}' is already registered`),kernelRegistry.set(key,config)}function registerGradient(config){let{kernelName}=config;gradRegistry.has(kernelName)&&(env().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${kernelName}'`)),gradRegistry.set(kernelName,config)}function makeKey(kernelName,backendName){return`${backendName}_${kernelName}`}var util_exports={};__export(util_exports,{arraysEqual:()=>arraysEqual,assert:()=>assert,assertNonNegativeIntegerDimensions:()=>assertNonNegativeIntegerDimensions,assertNonNull:()=>assertNonNull,assertShapesMatch:()=>assertShapesMatch,bytesFromStringArray:()=>bytesFromStringArray,bytesPerElement:()=>bytesPerElement,checkConversionForErrors:()=>checkConversionForErrors,clamp:()=>clamp,computeStrides:()=>computeStrides,createScalarValue:()=>createScalarValue,createShuffledIndices:()=>createShuffledIndices,decodeString:()=>decodeString,distSquared:()=>distSquared,encodeString:()=>encodeString,fetch:()=>fetch2,flatten:()=>flatten,getArrayFromDType:()=>getArrayFromDType,getTypedArrayFromDType:()=>getTypedArrayFromDType,hasEncodingLoss:()=>hasEncodingLoss,indexToLoc:()=>indexToLoc,inferDtype:()=>inferDtype,inferFromImplicitShape:()=>inferFromImplicitShape,isBoolean:()=>isBoolean,isFunction:()=>isFunction,isInt:()=>isInt,isNumber:()=>isNumber,isPromise:()=>isPromise,isScalarShape:()=>isScalarShape,isString:()=>isString,isTypedArray:()=>isTypedArray,isValidDtype:()=>isValidDtype,locToIndex:()=>locToIndex,makeOnesTypedArray:()=>makeOnesTypedArray,makeZerosNestedTypedArray:()=>makeZerosNestedTypedArray,makeZerosTypedArray:()=>makeZerosTypedArray,nearestDivisor:()=>nearestDivisor,nearestLargerEven:()=>nearestLargerEven,now:()=>now,parseAxisParam:()=>parseAxisParam,randUniform:()=>randUniform,repeatedTry:()=>repeatedTry,rightPad:()=>rightPad,shuffle:()=>shuffle,sizeFromShape:()=>sizeFromShape,sizeToSquarishShape:()=>sizeToSquarishShape,squeezeShape:()=>squeezeShape,sum:()=>sum,tanh:()=>tanh,toNestedArray:()=>toNestedArray,toTypedArray:()=>toTypedArray});function createScalarValue(value,dtype){return dtype==="string"?encodeString(value):toTypedArray([value],dtype)}function noConversionNeeded(a,dtype){return a instanceof Float32Array&&dtype==="float32"||a instanceof Int32Array&&dtype==="int32"||a instanceof Uint8Array&&dtype==="bool"}function toTypedArray(a,dtype){if(dtype==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(a)&&(a=flatten(a)),env().getBool("DEBUG")&&checkConversionForErrors(a,dtype),noConversionNeeded(a,dtype))return a;if(dtype==null||dtype==="float32"||dtype==="complex64")return new Float32Array(a);if(dtype==="int32")return new Int32Array(a);if(dtype==="bool"){let bool=new Uint8Array(a.length);for(let i=0;i<bool.length;++i)Math.round(a[i])!==0&&(bool[i]=1);return bool}else throw new Error(`Unknown data type ${dtype}`)}function now(){return env().platform.now()}function fetch2(path,requestInits){return env().platform.fetch(path,requestInits)}function encodeString(s,encoding="utf-8"){return encoding=encoding||"utf-8",env().platform.encode(s,encoding)}function decodeString(bytes,encoding="utf-8"){return encoding=encoding||"utf-8",env().platform.decode(bytes,encoding)}var Profiler=class{constructor(backendTimer,logger){this.backendTimer=backendTimer,this.logger=logger,logger==null&&(this.logger=new Logger)}profileKernel(kernelName,inputs,f){let outputs,holdResultWrapperFn=()=>{outputs=f()},timer=this.backendTimer.time(holdResultWrapperFn);for(let i=0;i<outputs.length;i++){let output=outputs[i];output.data().then(tensorVals=>{checkComputationForErrors(tensorVals,output.dtype,kernelName)})}let kernelProfile={kernelName,outputs,inputs,timeMs:timer.then(timing=>timing.kernelMs),extraInfo:timer.then(timing=>timing.getExtraProfileInfo!=null?timing.getExtraProfileInfo():"")};return kernelProfile}logKernelProfile(kernelProfile){let{kernelName,outputs,timeMs,inputs,extraInfo}=kernelProfile;outputs.forEach(result=>{Promise.all([result.data(),timeMs,extraInfo]).then(valueContainer=>{this.logger.logKernelProfile(kernelName,result,valueContainer[0],valueContainer[1],inputs,valueContainer[2])})})}};function checkComputationForErrors(vals,dtype,kernelName){if(dtype!=="float32")return!1;for(let i=0;i<vals.length;i++){let num=vals[i];if(isNaN(num)||!isFinite(num))return console.warn(`Found ${num} in the result of '${kernelName}'`),!0}return!1}var Logger=class{logKernelProfile(name,result,vals,timeMs,inputs,extraInfo){let time=typeof timeMs=="number"?rightPad(`${timeMs}ms`,9):timeMs.error,paddedName=rightPad(name,25),rank=result.rank,size=result.size,shape=rightPad(result.shape.toString(),14),inputShapesDescription="";for(let name2 in inputs){let input2=inputs[name2];if(input2!=null){let inputShape=input2.shape||result.shape,inputRank=inputShape.length;inputShapesDescription+=`${name2}: ${inputRank}D ${inputRank>0?inputShape:""} `}}console.log(`%c${paddedName}	%c${time}	%c${rank}D ${shape}	%c${size}	%c${inputShapesDescription}	%c${extraInfo}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function getFilteredNodesXToY(tape2,xs,y){let tensorsFromX={},nodesFromX={};for(let i=0;i<xs.length;i++)tensorsFromX[xs[i].id]=!0;for(let i=0;i<tape2.length;i++){let node=tape2[i],nodeInputs=node.inputs;for(let inputName in nodeInputs){let input2=nodeInputs[inputName],anyInputFromX=!1;for(let j=0;j<xs.length;j++)if(tensorsFromX[input2.id]){node.outputs.forEach(output=>tensorsFromX[output.id]=!0),anyInputFromX=!0,nodesFromX[node.id]=!0;break}if(anyInputFromX)break}}let tensorsLeadToY={};tensorsLeadToY[y.id]=!0;let nodesToY={};for(let i=tape2.length-1;i>=0;i--){let node=tape2[i],nodeInputs=node.inputs;for(let j=0;j<node.outputs.length;j++)if(tensorsLeadToY[node.outputs[j].id]){for(let inputName in nodeInputs)tensorsLeadToY[nodeInputs[inputName].id]=!0,nodesToY[node.id]=!0;break}}let filteredTape=[];for(let i=0;i<tape2.length;i++){let node=tape2[i];if(nodesFromX[node.id]&&nodesToY[node.id]){let prunedInputs={};for(let inputName in node.inputs){let nodeInput=node.inputs[inputName];tensorsFromX[nodeInput.id]&&(prunedInputs[inputName]=nodeInput)}let prunedNode=Object.assign({},node);prunedNode.inputs=prunedInputs,prunedNode.outputs=node.outputs,filteredTape.push(prunedNode)}}return filteredTape}function backpropagateGradients(tensorAccumulatedGradientMap,filteredTape,tidy2,add30){for(let i=filteredTape.length-1;i>=0;i--){let node=filteredTape[i],dys=[];if(node.outputs.forEach(o=>{let gradTensor=tensorAccumulatedGradientMap[o.id];gradTensor!=null?dys.push(gradTensor):dys.push(null)}),node.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${node.kernelName}.`);let inputGradients=node.gradient(dys);for(let inputName in node.inputs){if(!(inputName in inputGradients))throw new Error(`Cannot backprop through input ${inputName}. Available gradients found: ${Object.keys(inputGradients)}.`);let dx=tidy2(()=>inputGradients[inputName]());if(dx.dtype!=="float32")throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input ${inputName} must have 'float32' dtype, but has '${dx.dtype}'`);let x=node.inputs[inputName];if(!arraysEqual(dx.shape,x.shape))throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input '${inputName}' has shape '${dx.shape}', which does not match the shape of the input '${x.shape}'`);if(tensorAccumulatedGradientMap[x.id]==null)tensorAccumulatedGradientMap[x.id]=dx;else{let curGradient=tensorAccumulatedGradientMap[x.id];tensorAccumulatedGradientMap[x.id]=add30(curGradient,dx),curGradient.dispose()}}}}var FORMAT_LIMIT_NUM_VALS=20,FORMAT_NUM_FIRST_LAST_VALS=3,FORMAT_NUM_SIG_DIGITS=7;function tensorToString(vals,shape,dtype,verbose){let strides=computeStrides(shape),padPerCol=computeMaxSizePerColumn(vals,shape,dtype,strides),rank=shape.length,valsLines=subTensorToString(vals,shape,dtype,strides,padPerCol),lines=["Tensor"];return verbose&&(lines.push(`  dtype: ${dtype}`),lines.push(`  rank: ${rank}`),lines.push(`  shape: [${shape}]`),lines.push("  values:")),lines.push(valsLines.map(l=>"    "+l).join(`
`)),lines.join(`
`)}function computeMaxSizePerColumn(vals,shape,dtype,strides){let n=sizeFromShape(shape),numCols=strides[strides.length-1],padPerCol=new Array(numCols).fill(0),rank=shape.length,valuesOrTuples=dtype==="complex64"?createComplexTuples(vals):vals;if(rank>1)for(let row=0;row<n/numCols;row++){let offset=row*numCols;for(let j=0;j<numCols;j++)padPerCol[j]=Math.max(padPerCol[j],valToString(valuesOrTuples[offset+j],0,dtype).length)}return padPerCol}function valToString(val,pad6,dtype){let valStr;return Array.isArray(val)?valStr=`${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`:isString(val)?valStr=`'${val}'`:dtype==="bool"?valStr=boolNumToString(val):valStr=parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString(),rightPad(valStr,pad6)}function boolNumToString(v){return v===0?"false":"true"}function subTensorToString(vals,shape,dtype,strides,padPerCol,isLast=!0){let storagePerElement=dtype==="complex64"?2:1,size=shape[0],rank=shape.length;if(rank===0){if(dtype==="complex64"){let complexTuple=createComplexTuples(vals);return[valToString(complexTuple[0],0,dtype)]}return dtype==="bool"?[boolNumToString(vals[0])]:[vals[0].toString()]}if(rank===1){if(size>FORMAT_LIMIT_NUM_VALS){let firstValsSize=FORMAT_NUM_FIRST_LAST_VALS*storagePerElement,firstVals=Array.from(vals.slice(0,firstValsSize)),lastVals=Array.from(vals.slice((size-FORMAT_NUM_FIRST_LAST_VALS)*storagePerElement,size*storagePerElement));return dtype==="complex64"&&(firstVals=createComplexTuples(firstVals),lastVals=createComplexTuples(lastVals)),["["+firstVals.map((x,i)=>valToString(x,padPerCol[i],dtype)).join(", ")+", ..., "+lastVals.map((x,i)=>valToString(x,padPerCol[size-FORMAT_NUM_FIRST_LAST_VALS+i],dtype)).join(", ")+"]"]}let displayVals=dtype==="complex64"?createComplexTuples(vals):Array.from(vals);return["["+displayVals.map((x,i)=>valToString(x,padPerCol[i],dtype)).join(", ")+"]"]}let subshape=shape.slice(1),substrides=strides.slice(1),stride=strides[0]*storagePerElement,lines=[];if(size>FORMAT_LIMIT_NUM_VALS){for(let i=0;i<FORMAT_NUM_FIRST_LAST_VALS;i++){let start=i*stride,end=start+stride;lines.push(...subTensorToString(vals.slice(start,end),subshape,dtype,substrides,padPerCol,!1))}lines.push("...");for(let i=size-FORMAT_NUM_FIRST_LAST_VALS;i<size;i++){let start=i*stride,end=start+stride;lines.push(...subTensorToString(vals.slice(start,end),subshape,dtype,substrides,padPerCol,i===size-1))}}else for(let i=0;i<size;i++){let start=i*stride,end=start+stride;lines.push(...subTensorToString(vals.slice(start,end),subshape,dtype,substrides,padPerCol,i===size-1))}let sep=rank===2?",":"";lines[0]="["+lines[0]+sep;for(let i=1;i<lines.length-1;i++)lines[i]=" "+lines[i]+sep;let newLineSep=`,
`;for(let i=2;i<rank;i++)newLineSep+=`
`;return lines[lines.length-1]=" "+lines[lines.length-1]+"]"+(isLast?"":newLineSep),lines}function createComplexTuples(vals){let complexTuples=[];for(let i=0;i<vals.length;i+=2)complexTuples.push([vals[i],vals[i+1]]);return complexTuples}var TensorBuffer=class{constructor(shape,dtype,values){if(this.dtype=dtype,this.shape=shape.slice(),this.size=sizeFromShape(shape),values!=null){let n=values.length;assert(n===this.size,()=>`Length of values '${n}' does not match the size inferred by the shape '${this.size}'.`)}if(dtype==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=values||getArrayFromDType(dtype,this.size),this.strides=computeStrides(shape)}set(value,...locs){locs.length===0&&(locs=[0]),assert(locs.length===this.rank,()=>`The number of provided coordinates (${locs.length}) must match the rank (${this.rank})`);let index=this.locToIndex(locs);this.values[index]=value}get(...locs){locs.length===0&&(locs=[0]);let i=0;for(let loc of locs){if(loc<0||loc>=this.shape[i]){let msg=`Requested out of range element at ${locs}.   Buffer shape=${this.shape}`;throw new Error(msg)}i++}let index=locs[locs.length-1];for(let i2=0;i2<locs.length-1;++i2)index+=this.strides[i2]*locs[i2];return this.values[index]}locToIndex(locs){if(this.rank===0)return 0;if(this.rank===1)return locs[0];let index=locs[locs.length-1];for(let i=0;i<locs.length-1;++i)index+=this.strides[i]*locs[i];return index}indexToLoc(index){if(this.rank===0)return[];if(this.rank===1)return[index];let locs=new Array(this.shape.length);for(let i=0;i<locs.length-1;++i)locs[i]=Math.floor(index/this.strides[i]),index-=locs[i]*this.strides[i];return locs[locs.length-1]=index,locs}get rank(){return this.shape.length}toTensor(){return trackerFn().makeTensor(this.values,this.shape,this.dtype)}},trackerFn=null,opHandler=null,deprecationWarningFn=null;function setTensorTracker(fn){trackerFn=fn}function setOpHandler(handler){opHandler=handler}function setDeprecationWarningFn(fn){deprecationWarningFn=fn}var Tensor=class{constructor(shape,dtype,dataId,id){this.kept=!1,this.isDisposedInternal=!1,this.shape=shape.slice(),this.dtype=dtype||"float32",this.size=sizeFromShape(shape),this.strides=computeStrides(shape),this.dataId=dataId,this.id=id,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let vals=await this.data();return opHandler.buffer(this.shape,this.dtype,vals)}bufferSync(){return opHandler.buffer(this.shape,this.dtype,this.dataSync())}async array(){let vals=await this.data();return toNestedArray(this.shape,vals)}arraySync(){return toNestedArray(this.shape,this.dataSync())}async data(){this.throwIfDisposed();let data=trackerFn().read(this.dataId);if(this.dtype==="string"){let bytes=await data;try{return bytes.map(b=>decodeString(b))}catch(_a){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return data}dataSync(){this.throwIfDisposed();let data=trackerFn().readSync(this.dataId);if(this.dtype==="string")try{return data.map(b=>decodeString(b))}catch(_a){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return data}async bytes(){this.throwIfDisposed();let data=await trackerFn().read(this.dataId);return this.dtype==="string"?data:new Uint8Array(data.buffer)}dispose(){if(this.isDisposed)return;trackerFn().disposeTensor(this),this.isDisposedInternal=!0}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(verbose=!1){return opHandler.print(this,verbose)}clone(){return this.throwIfDisposed(),opHandler.clone(this)}toString(verbose=!1){let vals=this.dataSync();return tensorToString(vals,this.shape,this.dtype,verbose)}cast(dtype){return this.throwIfDisposed(),opHandler.cast(this,dtype)}variable(trainable=!0,name,dtype){return this.throwIfDisposed(),trackerFn().makeVariable(this,trainable,name,dtype)}};Object.defineProperty(Tensor,Symbol.hasInstance,{value:instance=>!!instance&&instance.data!=null&&instance.dataSync!=null&&instance.throwIfDisposed!=null});var Variable=class extends Tensor{constructor(initialValue,trainable,name,tensorId){super(initialValue.shape,initialValue.dtype,initialValue.dataId,tensorId);this.trainable=trainable,this.name=name}assign(newValue){if(newValue.dtype!==this.dtype)throw new Error(`dtype of the new value (${newValue.dtype}) and previous value (${this.dtype}) must match`);if(!arraysEqual(newValue.shape,this.shape))throw new Error(`shape of the new value (${newValue.shape}) and previous value (${this.shape}) must match`);trackerFn().disposeTensor(this),this.dataId=newValue.dataId,trackerFn().incRef(this,null)}dispose(){trackerFn().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Variable,Symbol.hasInstance,{value:instance=>instance instanceof Tensor&&instance.assign!=null&&instance.assign instanceof Function});var tensor_util_exports={};__export(tensor_util_exports,{assertTypesMatch:()=>assertTypesMatch,getTensorsInContainer:()=>getTensorsInContainer,isTensorInList:()=>isTensorInList,makeTypesMatch:()=>makeTypesMatch});var Rank;(function(Rank2){Rank2.R0="R0",Rank2.R1="R1",Rank2.R2="R2",Rank2.R3="R3",Rank2.R4="R4",Rank2.R5="R5",Rank2.R6="R6"})(Rank||(Rank={}));var UpcastInt32AndMap;(function(UpcastInt32AndMap2){UpcastInt32AndMap2.float32="float32",UpcastInt32AndMap2.int32="int32",UpcastInt32AndMap2.bool="int32",UpcastInt32AndMap2.complex64="complex64"})(UpcastInt32AndMap||(UpcastInt32AndMap={}));var UpcastBoolAndMap;(function(UpcastBoolAndMap2){UpcastBoolAndMap2.float32="float32",UpcastBoolAndMap2.int32="int32",UpcastBoolAndMap2.bool="bool",UpcastBoolAndMap2.complex64="complex64"})(UpcastBoolAndMap||(UpcastBoolAndMap={}));var UpcastFloat32AndMap;(function(UpcastFloat32AndMap2){UpcastFloat32AndMap2.float32="float32",UpcastFloat32AndMap2.int32="float32",UpcastFloat32AndMap2.bool="float32",UpcastFloat32AndMap2.complex64="complex64"})(UpcastFloat32AndMap||(UpcastFloat32AndMap={}));var UpcastComplex64AndMap;(function(UpcastComplex64AndMap2){UpcastComplex64AndMap2.float32="complex64",UpcastComplex64AndMap2.int32="complex64",UpcastComplex64AndMap2.bool="complex64",UpcastComplex64AndMap2.complex64="complex64"})(UpcastComplex64AndMap||(UpcastComplex64AndMap={}));var upcastTypeMap={float32:UpcastFloat32AndMap,int32:UpcastInt32AndMap,bool:UpcastBoolAndMap,complex64:UpcastComplex64AndMap};function upcastType(typeA,typeB){if(typeA==="string"||typeB==="string"){if(typeA==="string"&&typeB==="string")return"string";throw new Error(`Can not upcast ${typeA} with ${typeB}`)}return upcastTypeMap[typeA][typeB]}function sumOutType(type){return upcastType(type,"int32")}function makeTypesMatch(a,b){if(a.dtype===b.dtype)return[a,b];let dtype=upcastType(a.dtype,b.dtype);return[a.cast(dtype),b.cast(dtype)]}function assertTypesMatch(a,b){assert(a.dtype===b.dtype,()=>`The dtypes of the first(${a.dtype}) and second(${b.dtype}) input must match`)}function isTensorInList(tensor166,tensorList){return tensorList.some(x=>x.id===tensor166.id)}function getTensorsInContainer(result){let list=[],seen=new Set;return walkTensorContainer(result,list,seen),list}function walkTensorContainer(container2,list,seen){if(container2==null)return;if(container2 instanceof Tensor){list.push(container2);return}if(!isIterable(container2))return;let iterable=container2;for(let k in iterable){let val=iterable[k];seen.has(val)||(seen.add(val),walkTensorContainer(val,list,seen))}}function isIterable(obj){return Array.isArray(obj)||typeof obj=="object"}var EngineState=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null}}dispose(){for(let variableName in this.registeredVariables)this.registeredVariables[variableName].dispose()}},Engine=class{constructor(ENV4){this.ENV=ENV4,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new EngineState}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let sortedBackends=this.getSortedBackends();for(let i=0;i<sortedBackends.length;i++){let backendName=sortedBackends[i],success=await this.initializeBackend(backendName).success;if(success){await this.setBackend(backendName);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name,asyncInit}=this.initializeBackendsAndReturnBest();if(asyncInit)throw new Error(`The highest priority backend '${name}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(name)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(backendName){if(!(backendName in this.registry))if(backendName in this.registryFactory){let{asyncInit}=this.initializeBackend(backendName);if(asyncInit)return null}else return null;return this.registry[backendName]}findBackendFactory(backendName){return backendName in this.registryFactory?this.registryFactory[backendName].factory:null}registerBackend(backendName,factory,priority=1){return backendName in this.registryFactory?(console.warn(`${backendName} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[backendName]={factory,priority},!0)}async setBackend(backendName){if(this.registryFactory[backendName]==null)throw new Error(`Backend name '${backendName}' not found in registry`);if(this.backendName=backendName,this.registry[backendName]==null){this.backendInstance=null;let{success,asyncInit}=this.initializeBackend(backendName),result=asyncInit?await success:success;if(!result)return!1}return this.backendInstance=this.registry[backendName],this.setupRegisteredKernels(),this.profiler=new Profiler(this.backendInstance),!0}setupRegisteredKernels(){let kernels=getKernelsForBackend(this.backendName);kernels.forEach(kernel=>{kernel.setupFunc!=null&&kernel.setupFunc(this.backendInstance)})}disposeRegisteredKernels(backendName){let kernels=getKernelsForBackend(backendName);kernels.forEach(kernel=>{kernel.disposeFunc!=null&&kernel.disposeFunc(this.registry[backendName])})}initializeBackend(backendName){let registryFactoryEntry=this.registryFactory[backendName];if(registryFactoryEntry==null)throw new Error(`Cannot initialize backend ${backendName}, no registration found.`);try{let backend3=registryFactoryEntry.factory();if(backend3&&!(backend3 instanceof KernelBackend)&&typeof backend3.then=="function"){let promiseId=++this.pendingBackendInitId,success=backend3.then(backendInstance=>promiseId<this.pendingBackendInitId?!1:(this.registry[backendName]=backendInstance,this.pendingBackendInit=null,!0)).catch(err=>(promiseId<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${backendName} failed`),console.warn(err.stack||err.message)),!1));return this.pendingBackendInit=success,{success,asyncInit:!0}}else return this.registry[backendName]=backend3,{success:!0,asyncInit:!1}}catch(err){return console.warn(`Initialization of backend ${backendName} failed`),console.warn(err.stack||err.message),{success:!1,asyncInit:!1}}}removeBackend(backendName){if(!(backendName in this.registryFactory))throw new Error(`${backendName} backend not found in registry`);this.backendName===backendName&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,backendName in this.registry&&(this.disposeRegisteredKernels(backendName),this.registry[backendName].dispose(),delete this.registry[backendName]),delete this.registryFactory[backendName],this.backendName===backendName&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((a,b)=>this.registryFactory[b].priority-this.registryFactory[a].priority)}initializeBackendsAndReturnBest(){let sortedBackends=this.getSortedBackends();for(let i=0;i<sortedBackends.length;i++){let backendName=sortedBackends[i],{success,asyncInit}=this.initializeBackend(backendName);if(asyncInit||success)return{name:backendName,asyncInit}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(backend3,dataId){let info=this.state.tensorInfo.get(dataId),srcBackend=info.backend,values=this.readSync(dataId);srcBackend.disposeData(dataId),info.backend=backend3,backend3.move(dataId,values,info.shape,info.dtype),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(nameOrFn,fn){let name=null;if(fn==null){if(typeof nameOrFn!="function")throw new Error("Please provide a function to tidy()");fn=nameOrFn}else{if(typeof nameOrFn!="string"&&!(nameOrFn instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof fn!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");name=nameOrFn}let result;return this.scopedRun(()=>this.startScope(name),()=>this.endScope(result),()=>(result=fn(),result instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),result))}scopedRun(start,end,f){start();try{let res=f();return end(),res}catch(ex){throw end(),ex}}nextTensorId(){return Engine.nextTensorId++}nextVariableId(){return Engine.nextVariableId++}clone(x){let y=this.makeTensorFromDataId(x.dataId,x.shape,x.dtype),inputs={x},grad=dy=>({x:()=>{let dtype="float32",gradInputs={x:dy},attrs={dtype};return ENGINE.runKernelFunc(backend3=>backend3.cast(dy,dtype),gradInputs,null,Cast,attrs)}}),saved=[];return this.addTapeNode(this.state.activeScope.name,inputs,[y],grad,saved,{}),y}runKernel(kernelName,inputs,attrs,inputsToSave,outputsToSave){let forwardFunc=null,backwardsFunc=null;return this.runKernelFunc(forwardFunc,inputs,backwardsFunc,kernelName,attrs,inputsToSave,outputsToSave)}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(kernelName,numDataIdsBefore,outInfos){let numDataIdsAfter=this.backend.numDataIds(),numOutputDataIds=0;outInfos.forEach(info=>{numOutputDataIds+=info.dtype==="complex64"?3:1});let numMoves=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],dataIdsLeaked=numDataIdsAfter-numDataIdsBefore-numOutputDataIds-numMoves;if(dataIdsLeaked>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${dataIdsLeaked} data ids) after running '${kernelName}'`)}runKernelFunc(forwardFunc,inputs,backwardsFunc,kernelName,attrs,inputsToSave,outputsToSave){let outputs,saved=[],isTapeOn=this.isTapeOn();kernelName==null&&(kernelName=this.state.activeScope!=null?this.state.activeScope.name:"");let startingBytecount=this.state.numBytes,startingNumTensors=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let kernelFunc,kernel=getKernel(kernelName,this.backendName),out;if(kernel!=null)kernelFunc=()=>{let numDataIdsBefore=this.backend.numDataIds();out=kernel.kernelFunc({inputs,attrs,backend:this.backend});let outInfos=Array.isArray(out)?out:[out];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(kernelName,numDataIdsBefore,outInfos);let outTensors=outInfos.map(({dataId,shape,dtype})=>this.makeTensorFromDataId(dataId,shape,dtype));if(isTapeOn){let tensorsToSave=this.getTensorsForGradient(kernelName,inputs,outTensors);if(tensorsToSave==null){outputsToSave==null&&(outputsToSave=[]);let outsToSave=outTensors.filter((_,i)=>outputsToSave[i]);tensorsToSave=(inputsToSave||[]).slice().concat(outsToSave)}saved=this.saveTensorsForBackwardMode(tensorsToSave)}return outTensors};else{let saveFunc=tensors=>{if(!isTapeOn)return;saved=tensors.map(tensor166=>this.keep(this.clone(tensor166)))};kernelFunc=()=>{let numDataIdsBefore=this.backend.numDataIds();out=this.tidy(()=>forwardFunc(this.backend,saveFunc));let outs=Array.isArray(out)?out:[out];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(kernelName,numDataIdsBefore,outs),outs}}let kernelProfile;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?outputs=kernelFunc():(kernelProfile=this.profiler.profileKernel(kernelName,inputs,()=>kernelFunc()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(kernelProfile),outputs=kernelProfile.outputs)}),isTapeOn&&this.addTapeNode(kernelName,inputs,outputs,backwardsFunc,saved,attrs),this.state.profiling&&this.state.activeProfile.kernels.push({name:kernelName,bytesAdded:this.state.numBytes-startingBytecount,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-startingNumTensors,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(inputs).map(key=>inputs[key]!=null?inputs[key].shape:null),outputShapes:outputs.map(item=>item.shape),kernelTimeMs:kernelProfile.timeMs,extraInfo:kernelProfile.extraInfo}),Array.isArray(out)?outputs:outputs[0]}saveTensorsForBackwardMode(tensors){let saved=tensors.map(tensor166=>this.keep(this.clone(tensor166)));return saved}getTensorsForGradient(kernelName,inputs,outputs){let gradConfig=getGradient(kernelName);if(gradConfig!=null){let inputsToSave=gradConfig.inputsToSave||[],outputsToSave=gradConfig.outputsToSave||[],inputTensorsToSave;gradConfig.saveAllInputs?(assert(Array.isArray(inputs),()=>"saveAllInputs is true, expected inputs to be an array."),inputTensorsToSave=Object.keys(inputs).map(key=>inputs[key])):inputTensorsToSave=inputsToSave.map(inputName=>inputs[inputName]);let outputTensorsToSave=outputs.filter((_,i)=>outputsToSave[i]);return inputTensorsToSave.concat(outputTensorsToSave)}return null}makeTensor(values,shape,dtype,backend3){if(values==null)throw new Error("Values passed to engine.makeTensor() are null");dtype=dtype||"float32",backend3=backend3||this.backend;let backendVals=values;dtype==="string"&&isString(values[0])&&(backendVals=values.map(d=>encodeString(d)));let dataId=backend3.write(backendVals,shape,dtype),t=new Tensor(shape,dtype,dataId,this.nextTensorId());if(this.incRef(t,backend3),dtype==="string"){let info=this.state.tensorInfo.get(dataId),newBytes=bytesFromStringArray(backendVals);this.state.numBytes+=newBytes-info.bytes,info.bytes=newBytes}return t}makeTensorFromDataId(dataId,shape,dtype,backend3){dtype=dtype||"float32";let t=new Tensor(shape,dtype,dataId,this.nextTensorId());return this.incRef(t,backend3),t}makeVariable(initialValue,trainable=!0,name,dtype){name=name||this.nextVariableId().toString(),dtype!=null&&dtype!==initialValue.dtype&&(initialValue=initialValue.cast(dtype));let v=new Variable(initialValue,trainable,name,this.nextTensorId());if(this.state.registeredVariables[v.name]!=null)throw new Error(`Variable with name ${v.name} was already registered`);return this.state.registeredVariables[v.name]=v,this.incRef(v,this.backend),v}incRef(a,backend3){let refCount=this.state.tensorInfo.has(a.dataId)?this.state.tensorInfo.get(a.dataId).refCount:0;if(this.state.numTensors++,a.dtype==="string"&&this.state.numStringTensors++,refCount===0){this.state.numDataBuffers++;let bytes=0;a.dtype!=="complex64"&&a.dtype!=="string"&&(bytes=a.size*bytesPerElement(a.dtype)),this.state.tensorInfo.set(a.dataId,{backend:backend3||this.backend,dtype:a.dtype,shape:a.shape,bytes,refCount:0}),this.state.numBytes+=bytes}this.state.tensorInfo.get(a.dataId).refCount++,a instanceof Variable||this.track(a)}disposeTensor(a){if(!this.state.tensorInfo.has(a.dataId))return;this.state.numTensors--,a.dtype==="string"&&this.state.numStringTensors--;let info=this.state.tensorInfo.get(a.dataId),refCount=info.refCount;refCount<=1?(a.dtype!=="complex64"&&(this.state.numBytes-=info.bytes),this.state.numDataBuffers--,info.backend.disposeData(a.dataId),this.state.tensorInfo.delete(a.dataId)):this.state.tensorInfo.get(a.dataId).refCount--}disposeVariables(){for(let varName in this.state.registeredVariables){let v=this.state.registeredVariables[varName];this.disposeVariable(v)}}disposeVariable(v){this.disposeTensor(v),this.state.registeredVariables[v.name]!=null&&delete this.state.registeredVariables[v.name]}memory(){let info=this.backend.memory();return info.numTensors=this.state.numTensors,info.numDataBuffers=this.state.numDataBuffers,info.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(info.unreliable=!0,info.reasons==null&&(info.reasons=[]),info.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),info}async profile(query){this.state.profiling=!0;let startBytes=this.state.numBytes,startNumTensors=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await query(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(d=>d.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-startBytes,this.state.activeProfile.newTensors=this.state.numTensors-startNumTensors;for(let kernel of this.state.activeProfile.kernels)kernel.kernelTimeMs=await kernel.kernelTimeMs,kernel.extraInfo=await kernel.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(kernelName,inputs,outputs,gradientsFunc,saved,attrs){let tapeNode={id:this.state.nextTapeNodeId++,kernelName,inputs,outputs,saved},gradConfig=getGradient(kernelName);gradConfig!=null&&(gradientsFunc=gradConfig.gradFunc),gradientsFunc!=null&&(tapeNode.gradient=dys=>(dys=dys.map((dy,i)=>{if(dy==null){let output=outputs[i],vals=makeZerosTypedArray(output.size,output.dtype);return this.makeTensor(vals,output.shape,output.dtype)}return dy}),gradientsFunc(dys.length>1?dys:dys[0],saved,attrs))),this.state.activeTape.push(tapeNode)}keep(result){return result.kept=!0,result}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(name){let scopeInfo={track:[],name:"unnamed scope",id:this.state.nextScopeId++};name&&(scopeInfo.name=name),this.state.scopeStack.push(scopeInfo),this.state.activeScope=scopeInfo}endScope(result){let tensorsToTrackInParent=getTensorsInContainer(result),tensorsToTrackInParentSet=new Set(tensorsToTrackInParent.map(t=>t.id));for(let i=0;i<this.state.activeScope.track.length;i++){let tensor166=this.state.activeScope.track[i];!tensor166.kept&&!tensorsToTrackInParentSet.has(tensor166.id)&&tensor166.dispose()}let oldScope=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],tensorsToTrackInParent.forEach(tensor166=>{!tensor166.kept&&tensor166.scopeId===oldScope.id&&this.track(tensor166)})}gradients(f,xs,dy,allowNoGradients=!1){if(assert(xs.length>0,()=>"gradients() received an empty list of xs."),dy!=null&&dy.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${dy.dtype}'`);let y=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",f));assert(y instanceof Tensor,()=>"The result y returned by f() must be a tensor.");let filteredTape=getFilteredNodesXToY(this.state.activeTape,xs,y);if(!allowNoGradients&&filteredTape.length===0&&xs.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let accumulatedGradientMap={};accumulatedGradientMap[y.id]=dy==null?ones(y.shape):dy,backpropagateGradients(accumulatedGradientMap,filteredTape,f2=>this.tidy(f2),add);let grads=xs.map(x=>accumulatedGradientMap[x.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(node=>{for(let tensor166 of node.saved)tensor166.dispose()}),this.state.activeTape=null),{value:y,grads}})}customGrad(f){return assert(isFunction(f),()=>"The f passed in customGrad(f) must be a function."),(...inputs)=>{assert(inputs.every(t=>t instanceof Tensor),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let res,inputMap={};return inputs.forEach((input2,i)=>{inputMap[i]=input2}),this.runKernelFunc((_,save)=>(res=f(...inputs,save),assert(res.value instanceof Tensor,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),assert(isFunction(res.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),res.value),inputMap,(dy,saved)=>{let gradRes=res.gradFunc(dy,saved),grads=Array.isArray(gradRes)?gradRes:[gradRes];assert(grads.length===inputs.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),assert(grads.every(t=>t instanceof Tensor),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let gradMap={};return grads.forEach((grad,i)=>{gradMap[i]=()=>grad}),gradMap})}}readSync(dataId){let info=this.state.tensorInfo.get(dataId);return info.backend.readSync(dataId)}read(dataId){let info=this.state.tensorInfo.get(dataId);return info.backend.read(dataId)}async time(query){let start=now(),timingInfo=await this.backend.time(query);return timingInfo.wallMs=now()-start,timingInfo}track(result){return this.state.activeScope!=null&&(result.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(result)),result}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new EngineState;for(let backendName in this.registry)this.disposeRegisteredKernels(backendName),this.registry[backendName].dispose(),delete this.registry[backendName];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};Engine.nextTensorId=0;Engine.nextVariableId=0;function ones(shape){let values=makeOnesTypedArray(sizeFromShape(shape),"float32");return ENGINE.makeTensor(values,shape,"float32")}function getOrMakeEngine(){let ns=getGlobalNamespace();if(ns._tfengine==null){let environment15=new Environment(ns);ns._tfengine=new Engine(environment15)}return setEnvironmentGlobal(ns._tfengine.ENV),setTensorTracker(()=>ns._tfengine),ns._tfengine}var ENGINE=getOrMakeEngine();function add(a,b){let inputs={a,b};return ENGINE.runKernelFunc((backend3,save)=>{let res=backend3.add(a,b);return save([a,b]),res},inputs,null,Add)}var device_util_exports={};__export(device_util_exports,{isBrowser:()=>isBrowser,isMobile:()=>isMobile});function _isNavigatorDefined(){return typeof navigator!="undefined"&&navigator!=null}function isMobile(){if(_isNavigatorDefined()){let a=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))}return!1}function isBrowser(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}var ENV2=env();ENV2.registerFlag("DEBUG",()=>!1,debugValue=>{debugValue&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});ENV2.registerFlag("IS_BROWSER",()=>isBrowser());ENV2.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");ENV2.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));ENV2.registerFlag("PROD",()=>!1);ENV2.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ENV2.getBool("DEBUG"));ENV2.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);ENV2.registerFlag("IS_TEST",()=>!1);function inferShape(val,dtype){let firstElem=val;if(isTypedArray(val))return dtype==="string"?[]:[val.length];if(!Array.isArray(val))return[];let shape=[];for(;Array.isArray(firstElem)||isTypedArray(firstElem)&&dtype!=="string";)shape.push(firstElem.length),firstElem=firstElem[0];return Array.isArray(val)&&env().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&deepAssertShapeConsistency(val,shape,[]),shape}function deepAssertShapeConsistency(val,shape,indices){if(indices=indices||[],!Array.isArray(val)&&!isTypedArray(val)){assert(shape.length===0,()=>`Element arr[${indices.join("][")}] is a primitive, but should be an array/TypedArray of ${shape[0]} elements`);return}assert(shape.length>0,()=>`Element arr[${indices.join("][")}] should be a primitive, but is an array of ${val.length} elements`),assert(val.length===shape[0],()=>`Element arr[${indices.join("][")}] should have ${shape[0]} elements, but has ${val.length} elements`);let subShape=shape.slice(1);for(let i=0;i<val.length;++i)deepAssertShapeConsistency(val[i],subShape,indices.concat(i))}function assertDtype(expectedDtype,actualDType,argName,functionName){if(expectedDtype==null)return;if(expectedDtype!=="numeric"&&expectedDtype!==actualDType||expectedDtype==="numeric"&&actualDType==="string")throw new Error(`Argument '${argName}' passed to '${functionName}' must be ${expectedDtype} tensor, but got ${actualDType} tensor`)}function convertToTensor(x,argName,functionName,parseAsDtype="numeric"){if(x instanceof Tensor)return assertDtype(parseAsDtype,x.dtype,argName,functionName),x;let inferredDtype=inferDtype(x);if(inferredDtype!=="string"&&["bool","int32","float32"].indexOf(parseAsDtype)>=0&&(inferredDtype=parseAsDtype),assertDtype(parseAsDtype,inferredDtype,argName,functionName),x==null||!isTypedArray(x)&&!Array.isArray(x)&&typeof x!="number"&&typeof x!="boolean"&&typeof x!="string"){let type=x==null?"null":x.constructor.name;throw new Error(`Argument '${argName}' passed to '${functionName}' must be a Tensor or TensorLike, but got '${type}'`)}let inferredShape=inferShape(x,inferredDtype);!isTypedArray(x)&&!Array.isArray(x)&&(x=[x]);let skipTypedArray=!0,values=inferredDtype!=="string"?toTypedArray(x,inferredDtype):flatten(x,[],skipTypedArray);return ENGINE.makeTensor(values,inferredShape,inferredDtype)}function convertToTensorArray(arg,argName,functionName,parseAsDtype="numeric"){if(!Array.isArray(arg))throw new Error(`Argument ${argName} passed to ${functionName} must be a \`Tensor[]\` or \`TensorLike[]\``);let tensors=arg;return tensors.map((t,i)=>convertToTensor(t,`${argName}[${i}]`,functionName),parseAsDtype)}var OP_SCOPE_SUFFIX="__op";function op(f){let keys=Object.keys(f);if(keys.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${keys.length} keys.`);let opName=keys[0],fn=f[opName];opName.endsWith("_")&&(opName=opName.substring(0,opName.length-1)),opName=opName+OP_SCOPE_SUFFIX;let f2=(...args)=>{ENGINE.startScope(opName);try{let result=fn(...args);return isPromise(result)&&console.error("Cannot return a Promise inside of tidy."),ENGINE.endScope(result),result}catch(ex){throw ENGINE.endScope(null),ex}};return Object.defineProperty(f2,"name",{value:opName,configurable:!0}),f2}function complex_(real8,imag8){let $real=convertToTensor(real8,"real","complex"),$imag=convertToTensor(imag8,"imag","complex");assertShapesMatch($real.shape,$imag.shape,`real and imag shapes, ${$real.shape} and ${$imag.shape}, must match in call to tf.complex().`);let forward=backend3=>backend3.complex($real,$imag),inputs={real:$real,imag:$imag};return ENGINE.runKernelFunc(forward,inputs,null,Complex)}var complex=op({complex_});function makeTensor(values,shape,inferredShape,dtype){if(dtype==null&&(dtype=inferDtype(values)),dtype==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!isTypedArray(values)&&!Array.isArray(values)&&typeof values!="number"&&typeof values!="boolean"&&typeof values!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(shape!=null){assertNonNegativeIntegerDimensions(shape);let providedSize=sizeFromShape(shape),inferredSize=sizeFromShape(inferredShape);assert(providedSize===inferredSize,()=>`Based on the provided shape, [${shape}], the tensor should have ${providedSize} values but has ${inferredSize}`);for(let i=0;i<inferredShape.length;++i){let inferred=inferredShape[i],flatDimsDontMatch=i===inferredShape.length-1?inferred!==sizeFromShape(shape.slice(i)):!0;assert(inferredShape[i]===shape[i]||!flatDimsDontMatch,()=>`Error creating a new Tensor. Inferred shape (${inferredShape}) does not match the provided shape (${shape}). `)}}return!isTypedArray(values)&&!Array.isArray(values)&&(values=[values]),shape=shape||inferredShape,values=dtype!=="string"?toTypedArray(values,dtype):flatten(values,[],!0),ENGINE.makeTensor(values,shape,dtype)}function tensor4(values,shape,dtype){let inferredShape=inferShape(values,dtype);return makeTensor(values,shape,inferredShape,dtype)}var DTYPE_VALUE_SIZE_MAP={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};var NUM_BYTES_STRING_LENGTH=4;async function encodeWeights(tensors,group){let specs=[],dataPromises=[],names=Array.isArray(tensors)?tensors.map(tensor166=>tensor166.name):Object.keys(tensors);for(let i=0;i<names.length;++i){let name=names[i],t=Array.isArray(tensors)?tensors[i].tensor:tensors[name];if(t.dtype!=="float32"&&t.dtype!=="int32"&&t.dtype!=="bool"&&t.dtype!=="string"&&t.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${name}': ${t.dtype}`);let spec={name,shape:t.shape,dtype:t.dtype};if(t.dtype==="string"){let utf8bytes=new Promise(async resolve=>{let vals=await t.bytes(),totalNumBytes=vals.reduce((p2,c)=>p2+c.length,0)+NUM_BYTES_STRING_LENGTH*vals.length,bytes=new Uint8Array(totalNumBytes),offset=0;for(let i2=0;i2<vals.length;i2++){let val=vals[i2],bytesOfLength=new Uint8Array(new Uint32Array([val.length]).buffer);bytes.set(bytesOfLength,offset),offset+=NUM_BYTES_STRING_LENGTH,bytes.set(val,offset),offset+=val.length}resolve(bytes)});dataPromises.push(utf8bytes)}else dataPromises.push(t.data());group!=null&&(spec.group=group),specs.push(spec)}let tensorValues=await Promise.all(dataPromises);return{data:concatenateTypedArrays(tensorValues),specs}}function decodeWeights(buffer10,specs){let out={},float16Decode,offset=0;for(let spec of specs){let name=spec.name,dtype=spec.dtype,shape=spec.shape,size=sizeFromShape(shape),values;if("quantization"in spec){let quantization=spec.quantization;if(quantization.dtype==="uint8"||quantization.dtype==="uint16"){if(!("min"in quantization&&"scale"in quantization))throw new Error(`Weight ${spec.name} with quantization ${quantization.dtype} doesn't have corresponding metadata min and scale.`)}else if(quantization.dtype==="float16"){if(dtype!=="float32")throw new Error(`Weight ${spec.name} is quantized with ${quantization.dtype} which only supports weights of type float32 not ${dtype}.`)}else throw new Error(`Weight ${spec.name} has unknown quantization dtype ${quantization.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let quantizationSizeFactor=DTYPE_VALUE_SIZE_MAP[quantization.dtype],byteBuffer=buffer10.slice(offset,offset+size*quantizationSizeFactor),quantizedArray=quantization.dtype==="uint8"?new Uint8Array(byteBuffer):new Uint16Array(byteBuffer);if(dtype==="float32")if(quantization.dtype==="uint8"||quantization.dtype==="uint16"){values=new Float32Array(quantizedArray.length);for(let i=0;i<quantizedArray.length;i++){let v=quantizedArray[i];values[i]=v*quantization.scale+quantization.min}}else if(quantization.dtype==="float16")float16Decode===void 0&&(float16Decode=getFloat16Decoder()),values=float16Decode(quantizedArray);else throw new Error(`Unsupported quantization type ${quantization.dtype} for weight type float32.`);else if(dtype==="int32"){if(quantization.dtype!=="uint8"&&quantization.dtype!=="uint16")throw new Error(`Unsupported quantization type ${quantization.dtype} for weight type int32.`);values=new Int32Array(quantizedArray.length);for(let i=0;i<quantizedArray.length;i++){let v=quantizedArray[i];values[i]=Math.round(v*quantization.scale+quantization.min)}}else throw new Error(`Unsupported dtype in weight '${name}': ${dtype}`);offset+=size*quantizationSizeFactor}else if(dtype==="string"){let size2=sizeFromShape(spec.shape);values=[];for(let i=0;i<size2;i++){let byteLength=new Uint32Array(buffer10.slice(offset,offset+NUM_BYTES_STRING_LENGTH))[0];offset+=NUM_BYTES_STRING_LENGTH;let bytes=new Uint8Array(buffer10.slice(offset,offset+byteLength));values.push(bytes),offset+=byteLength}}else{let dtypeFactor=DTYPE_VALUE_SIZE_MAP[dtype],byteBuffer=buffer10.slice(offset,offset+size*dtypeFactor);if(dtype==="float32")values=new Float32Array(byteBuffer);else if(dtype==="int32")values=new Int32Array(byteBuffer);else if(dtype==="bool")values=new Uint8Array(byteBuffer);else if(dtype==="complex64"){values=new Float32Array(byteBuffer);let real8=new Float32Array(values.length/2),image3=new Float32Array(values.length/2);for(let i=0;i<real8.length;i++)real8[i]=values[i*2],image3[i]=values[i*2+1];let realTensor=tensor4(real8,shape,"float32"),imageTensor=tensor4(image3,shape,"float32");out[name]=complex(realTensor,imageTensor),realTensor.dispose(),imageTensor.dispose()}else throw new Error(`Unsupported dtype in weight '${name}': ${dtype}`);offset+=size*dtypeFactor}dtype!=="complex64"&&(out[name]=tensor4(values,shape,dtype))}return out}function concatenateTypedArrays(xs){if(xs===null)throw new Error(`Invalid input value: ${JSON.stringify(xs)}`);let totalByteLength=0,normalizedXs=[];xs.forEach(x=>{if(totalByteLength+=x.byteLength,normalizedXs.push(x.byteLength===x.buffer.byteLength?x:new x.constructor(x)),!(x instanceof Float32Array||x instanceof Int32Array||x instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${x.constructor.name}`)});let y=new Uint8Array(totalByteLength),offset=0;return normalizedXs.forEach(x=>{y.set(new Uint8Array(x.buffer),offset),offset+=x.byteLength}),y.buffer}var useNodeBuffer=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function stringByteLength(str2){return useNodeBuffer?Buffer.byteLength(str2):new Blob([str2]).size}function arrayBufferToBase64String(buffer10){if(useNodeBuffer)return Buffer.from(buffer10).toString("base64");let buf=new Uint8Array(buffer10),s="";for(let i=0,l=buf.length;i<l;i++)s+=String.fromCharCode(buf[i]);return btoa(s)}function base64StringToArrayBuffer(str2){if(useNodeBuffer){let buf=Buffer.from(str2,"base64");return buf.buffer.slice(buf.byteOffset,buf.byteOffset+buf.byteLength)}let s=atob(str2),buffer10=new Uint8Array(s.length);for(let i=0;i<s.length;++i)buffer10.set([s.charCodeAt(i)],i);return buffer10.buffer}function concatenateArrayBuffers(buffers){if(buffers.length===1)return buffers[0];let totalByteLength=0;buffers.forEach(buffer10=>{totalByteLength+=buffer10.byteLength});let temp=new Uint8Array(totalByteLength),offset=0;return buffers.forEach(buffer10=>{temp.set(new Uint8Array(buffer10),offset),offset+=buffer10.byteLength}),temp.buffer}function basename(path){let SEPARATOR="/";for(path=path.trim();path.endsWith(SEPARATOR);)path=path.slice(0,path.length-1);let items=path.split(SEPARATOR);return items[items.length-1]}function getModelArtifactsInfoForJSON(modelArtifacts){if(modelArtifacts.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:modelArtifacts.modelTopology==null?0:stringByteLength(JSON.stringify(modelArtifacts.modelTopology)),weightSpecsBytes:modelArtifacts.weightSpecs==null?0:stringByteLength(JSON.stringify(modelArtifacts.weightSpecs)),weightDataBytes:modelArtifacts.weightData==null?0:modelArtifacts.weightData.byteLength}}function computeFloat16MantisaTable(){let convertMantissa=i=>{let m=i<<13,e=0;for(;(m&8388608)===0;)e-=8388608,m<<=1;return m&=~8388608,e+=947912704,m|e},mantisaTable=new Uint32Array(2048);mantisaTable[0]=0;for(let i=1;i<1024;i++)mantisaTable[i]=convertMantissa(i);for(let i=1024;i<2048;i++)mantisaTable[i]=939524096+(i-1024<<13);return mantisaTable}function computeFloat16ExponentTable(){let exponentTable=new Uint32Array(64);exponentTable[0]=0,exponentTable[31]=1199570944,exponentTable[32]=2147483648,exponentTable[63]=3347054592;for(let i=1;i<31;i++)exponentTable[i]=i<<23;for(let i=33;i<63;i++)exponentTable[i]=2147483648+(i-32<<23);return exponentTable}function computeFloat16OffsetTable(){let offsetTable=new Uint32Array(64);for(let i=0;i<64;i++)offsetTable[i]=1024;return offsetTable[0]=offsetTable[32]=0,offsetTable}function getFloat16Decoder(){let mantisaTable=computeFloat16MantisaTable(),exponentTable=computeFloat16ExponentTable(),offsetTable=computeFloat16OffsetTable();return quantizedArray=>{let buffer10=new ArrayBuffer(4*quantizedArray.length),bufferUint32View=new Uint32Array(buffer10);for(let index=0;index<quantizedArray.length;index++){let float16Bits=quantizedArray[index],float32Bits=mantisaTable[offsetTable[float16Bits>>10]+(float16Bits&1023)]+exponentTable[float16Bits>>10];bufferUint32View[index]=float32Bits}return new Float32Array(buffer10)}}var IORouterRegistry=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return IORouterRegistry.instance==null&&(IORouterRegistry.instance=new IORouterRegistry),IORouterRegistry.instance}static registerSaveRouter(saveRouter){IORouterRegistry.getInstance().saveRouters.push(saveRouter)}static registerLoadRouter(loadRouter){IORouterRegistry.getInstance().loadRouters.push(loadRouter)}static getSaveHandlers(url){return IORouterRegistry.getHandlers(url,"save")}static getLoadHandlers(url,loadOptions){return IORouterRegistry.getHandlers(url,"load",loadOptions)}static getHandlers(url,handlerType,loadOptions){let validHandlers=[],routers=handlerType==="load"?IORouterRegistry.getInstance().loadRouters:IORouterRegistry.getInstance().saveRouters;return routers.forEach(router=>{let handler=router(url,loadOptions);handler!==null&&validHandlers.push(handler)}),validHandlers}},registerSaveRouter=loudRouter=>IORouterRegistry.registerSaveRouter(loudRouter),registerLoadRouter=loudRouter=>IORouterRegistry.registerLoadRouter(loudRouter),getSaveHandlers=url=>IORouterRegistry.getSaveHandlers(url),getLoadHandlers=(url,loadOptions)=>IORouterRegistry.getLoadHandlers(url,loadOptions);var DATABASE_NAME="tensorflowjs",DATABASE_VERSION=1,MODEL_STORE_NAME="models_store",INFO_STORE_NAME="model_info_store";function getIndexedDBFactory(){if(!env().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let theWindow=typeof window=="undefined"?self:window,factory=theWindow.indexedDB||theWindow.mozIndexedDB||theWindow.webkitIndexedDB||theWindow.msIndexedDB||theWindow.shimIndexedDB;if(factory==null)throw new Error("The current browser does not appear to support IndexedDB.");return factory}function setUpDatabase(openRequest){let db=openRequest.result;db.createObjectStore(MODEL_STORE_NAME,{keyPath:"modelPath"}),db.createObjectStore(INFO_STORE_NAME,{keyPath:"modelPath"})}var BrowserIndexedDB=class{constructor(modelPath){if(this.indexedDB=getIndexedDBFactory(),modelPath==null||!modelPath)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=modelPath}async save(modelArtifacts){if(modelArtifacts.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,modelArtifacts)}async load(){return this.databaseAction(this.modelPath)}databaseAction(modelPath,modelArtifacts){return new Promise((resolve,reject)=>{let openRequest=this.indexedDB.open(DATABASE_NAME,DATABASE_VERSION);openRequest.onupgradeneeded=()=>setUpDatabase(openRequest),openRequest.onsuccess=()=>{let db=openRequest.result;if(modelArtifacts==null){let modelTx=db.transaction(MODEL_STORE_NAME,"readonly"),modelStore=modelTx.objectStore(MODEL_STORE_NAME),getRequest=modelStore.get(this.modelPath);getRequest.onsuccess=()=>{if(getRequest.result==null)return db.close(),reject(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));resolve(getRequest.result.modelArtifacts)},getRequest.onerror=error=>(db.close(),reject(getRequest.error)),modelTx.oncomplete=()=>db.close()}else{let modelArtifactsInfo=getModelArtifactsInfoForJSON(modelArtifacts),infoTx=db.transaction(INFO_STORE_NAME,"readwrite"),infoStore=infoTx.objectStore(INFO_STORE_NAME),putInfoRequest=infoStore.put({modelPath:this.modelPath,modelArtifactsInfo}),modelTx;putInfoRequest.onsuccess=()=>{modelTx=db.transaction(MODEL_STORE_NAME,"readwrite");let modelStore=modelTx.objectStore(MODEL_STORE_NAME),putModelRequest=modelStore.put({modelPath:this.modelPath,modelArtifacts,modelArtifactsInfo});putModelRequest.onsuccess=()=>resolve({modelArtifactsInfo}),putModelRequest.onerror=error=>{infoStore=infoTx.objectStore(INFO_STORE_NAME);let deleteInfoRequest=infoStore.delete(this.modelPath);deleteInfoRequest.onsuccess=()=>(db.close(),reject(putModelRequest.error)),deleteInfoRequest.onerror=error2=>(db.close(),reject(putModelRequest.error))}},putInfoRequest.onerror=error=>(db.close(),reject(putInfoRequest.error)),infoTx.oncomplete=()=>{modelTx==null?db.close():modelTx.oncomplete=()=>db.close()}}},openRequest.onerror=error=>reject(openRequest.error)})}};BrowserIndexedDB.URL_SCHEME="indexeddb://";var indexedDBRouter=url=>env().getBool("IS_BROWSER")&&(!Array.isArray(url)&&url.startsWith(BrowserIndexedDB.URL_SCHEME))?browserIndexedDB(url.slice(BrowserIndexedDB.URL_SCHEME.length)):null;IORouterRegistry.registerSaveRouter(indexedDBRouter);IORouterRegistry.registerLoadRouter(indexedDBRouter);function browserIndexedDB(modelPath){return new BrowserIndexedDB(modelPath)}function maybeStripScheme(key){return key.startsWith(BrowserIndexedDB.URL_SCHEME)?key.slice(BrowserIndexedDB.URL_SCHEME.length):key}var BrowserIndexedDBManager=class{constructor(){this.indexedDB=getIndexedDBFactory()}async listModels(){return new Promise((resolve,reject)=>{let openRequest=this.indexedDB.open(DATABASE_NAME,DATABASE_VERSION);openRequest.onupgradeneeded=()=>setUpDatabase(openRequest),openRequest.onsuccess=()=>{let db=openRequest.result,tx=db.transaction(INFO_STORE_NAME,"readonly"),store=tx.objectStore(INFO_STORE_NAME),getAllInfoRequest=store.getAll();getAllInfoRequest.onsuccess=()=>{let out={};for(let item of getAllInfoRequest.result)out[item.modelPath]=item.modelArtifactsInfo;resolve(out)},getAllInfoRequest.onerror=error=>(db.close(),reject(getAllInfoRequest.error)),tx.oncomplete=()=>db.close()},openRequest.onerror=error=>reject(openRequest.error)})}async removeModel(path){return path=maybeStripScheme(path),new Promise((resolve,reject)=>{let openRequest=this.indexedDB.open(DATABASE_NAME,DATABASE_VERSION);openRequest.onupgradeneeded=()=>setUpDatabase(openRequest),openRequest.onsuccess=()=>{let db=openRequest.result,infoTx=db.transaction(INFO_STORE_NAME,"readwrite"),infoStore=infoTx.objectStore(INFO_STORE_NAME),getInfoRequest=infoStore.get(path),modelTx;getInfoRequest.onsuccess=()=>{if(getInfoRequest.result==null)return db.close(),reject(new Error(`Cannot find model with path '${path}' in IndexedDB.`));{let deleteInfoRequest=infoStore.delete(path),deleteModelData=()=>{modelTx=db.transaction(MODEL_STORE_NAME,"readwrite");let modelStore=modelTx.objectStore(MODEL_STORE_NAME),deleteModelRequest=modelStore.delete(path);deleteModelRequest.onsuccess=()=>resolve(getInfoRequest.result.modelArtifactsInfo),deleteModelRequest.onerror=error=>reject(getInfoRequest.error)};deleteInfoRequest.onsuccess=deleteModelData,deleteInfoRequest.onerror=error=>(deleteModelData(),db.close(),reject(getInfoRequest.error))}},getInfoRequest.onerror=error=>(db.close(),reject(getInfoRequest.error)),infoTx.oncomplete=()=>{modelTx==null?db.close():modelTx.oncomplete=()=>db.close()}},openRequest.onerror=error=>reject(openRequest.error)})}};var PATH_SEPARATOR="/",PATH_PREFIX="tensorflowjs_models",INFO_SUFFIX="info",MODEL_TOPOLOGY_SUFFIX="model_topology",WEIGHT_SPECS_SUFFIX="weight_specs",WEIGHT_DATA_SUFFIX="weight_data",MODEL_METADATA_SUFFIX="model_metadata";function getModelKeys(path){return{info:[PATH_PREFIX,path,INFO_SUFFIX].join(PATH_SEPARATOR),topology:[PATH_PREFIX,path,MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),weightSpecs:[PATH_PREFIX,path,WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),weightData:[PATH_PREFIX,path,WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR),modelMetadata:[PATH_PREFIX,path,MODEL_METADATA_SUFFIX].join(PATH_SEPARATOR)}}function getModelPathFromKey(key){let items=key.split(PATH_SEPARATOR);if(items.length<3)throw new Error(`Invalid key format: ${key}`);return items.slice(1,items.length-1).join(PATH_SEPARATOR)}function maybeStripScheme2(key){return key.startsWith(BrowserLocalStorage.URL_SCHEME)?key.slice(BrowserLocalStorage.URL_SCHEME.length):key}var BrowserLocalStorage=class{constructor(modelPath){if(!env().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,modelPath==null||!modelPath)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=modelPath,this.keys=getModelKeys(this.modelPath)}async save(modelArtifacts){if(modelArtifacts.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let topology21=JSON.stringify(modelArtifacts.modelTopology),weightSpecs=JSON.stringify(modelArtifacts.weightSpecs),modelArtifactsInfo=getModelArtifactsInfoForJSON(modelArtifacts);try{return this.LS.setItem(this.keys.info,JSON.stringify(modelArtifactsInfo)),this.LS.setItem(this.keys.topology,topology21),this.LS.setItem(this.keys.weightSpecs,weightSpecs),this.LS.setItem(this.keys.weightData,arrayBufferToBase64String(modelArtifacts.weightData)),this.LS.setItem(this.keys.modelMetadata,JSON.stringify({format:modelArtifacts.format,generatedBy:modelArtifacts.generatedBy,convertedBy:modelArtifacts.convertedBy,userDefinedMetadata:modelArtifacts.userDefinedMetadata})),{modelArtifactsInfo}}catch(err){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${modelArtifactsInfo.modelTopologyBytes}, weightSpecsBytes=${modelArtifactsInfo.weightSpecsBytes}, weightDataBytes=${modelArtifactsInfo.weightDataBytes}.`)}}}async load(){let info=JSON.parse(this.LS.getItem(this.keys.info));if(info==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(info.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let out={},topology21=JSON.parse(this.LS.getItem(this.keys.topology));if(topology21==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);out.modelTopology=topology21;let weightSpecs=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(weightSpecs==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);out.weightSpecs=weightSpecs;let metadataString=this.LS.getItem(this.keys.modelMetadata);if(metadataString!=null){let metadata=JSON.parse(metadataString);out.format=metadata.format,out.generatedBy=metadata.generatedBy,out.convertedBy=metadata.convertedBy,out.userDefinedMetadata=metadata.userDefinedMetadata}let weightDataBase64=this.LS.getItem(this.keys.weightData);if(weightDataBase64==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return out.weightData=base64StringToArrayBuffer(weightDataBase64),out}};BrowserLocalStorage.URL_SCHEME="localstorage://";var localStorageRouter=url=>env().getBool("IS_BROWSER")&&(!Array.isArray(url)&&url.startsWith(BrowserLocalStorage.URL_SCHEME))?browserLocalStorage(url.slice(BrowserLocalStorage.URL_SCHEME.length)):null;IORouterRegistry.registerSaveRouter(localStorageRouter);IORouterRegistry.registerLoadRouter(localStorageRouter);function browserLocalStorage(modelPath){return new BrowserLocalStorage(modelPath)}var BrowserLocalStorageManager=class{constructor(){assert(env().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),assert(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let out={},prefix=PATH_PREFIX+PATH_SEPARATOR,suffix=PATH_SEPARATOR+INFO_SUFFIX;for(let i=0;i<this.LS.length;++i){let key=this.LS.key(i);if(key.startsWith(prefix)&&key.endsWith(suffix)){let modelPath=getModelPathFromKey(key);out[modelPath]=JSON.parse(this.LS.getItem(key))}}return out}async removeModel(path){path=maybeStripScheme2(path);let keys=getModelKeys(path);if(this.LS.getItem(keys.info)==null)throw new Error(`Cannot find model at path '${path}'`);let info=JSON.parse(this.LS.getItem(keys.info));return this.LS.removeItem(keys.info),this.LS.removeItem(keys.topology),this.LS.removeItem(keys.weightSpecs),this.LS.removeItem(keys.weightData),info}};var URL_SCHEME_SUFFIX="://",ModelStoreManagerRegistry=class{constructor(){this.managers={}}static getInstance(){return ModelStoreManagerRegistry.instance==null&&(ModelStoreManagerRegistry.instance=new ModelStoreManagerRegistry),ModelStoreManagerRegistry.instance}static registerManager(scheme,manager){assert(scheme!=null,()=>"scheme must not be undefined or null."),scheme.endsWith(URL_SCHEME_SUFFIX)&&(scheme=scheme.slice(0,scheme.indexOf(URL_SCHEME_SUFFIX))),assert(scheme.length>0,()=>"scheme must not be an empty string.");let registry=ModelStoreManagerRegistry.getInstance();assert(registry.managers[scheme]==null,()=>`A model store manager is already registered for scheme '${scheme}'.`),registry.managers[scheme]=manager}static getManager(scheme){let manager=this.getInstance().managers[scheme];if(manager==null)throw new Error(`Cannot find model manager for scheme '${scheme}'`);return manager}static getSchemes(){return Object.keys(this.getInstance().managers)}};function parseURL(url){if(url.indexOf(URL_SCHEME_SUFFIX)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${ModelStoreManagerRegistry.getSchemes().join(",")}`);return{scheme:url.split(URL_SCHEME_SUFFIX)[0],path:url.split(URL_SCHEME_SUFFIX)[1]}}async function cloneModelInternal(sourceURL,destURL,deleteSource=!1){assert(sourceURL!==destURL,()=>`Old path and new path are the same: '${sourceURL}'`);let loadHandlers=IORouterRegistry.getLoadHandlers(sourceURL);assert(loadHandlers.length>0,()=>`Copying failed because no load handler is found for source URL ${sourceURL}.`),assert(loadHandlers.length<2,()=>`Copying failed because more than one (${loadHandlers.length}) load handlers for source URL ${sourceURL}.`);let loadHandler=loadHandlers[0],saveHandlers=IORouterRegistry.getSaveHandlers(destURL);assert(saveHandlers.length>0,()=>`Copying failed because no save handler is found for destination URL ${destURL}.`),assert(saveHandlers.length<2,()=>`Copying failed because more than one (${loadHandlers.length}) save handlers for destination URL ${destURL}.`);let saveHandler=saveHandlers[0],sourceScheme=parseURL(sourceURL).scheme,sourcePath=parseURL(sourceURL).path,sameMedium=sourceScheme===parseURL(sourceURL).scheme,modelArtifacts=await loadHandler.load();deleteSource&&sameMedium&&await ModelStoreManagerRegistry.getManager(sourceScheme).removeModel(sourcePath);let saveResult=await saveHandler.save(modelArtifacts);return deleteSource&&!sameMedium&&await ModelStoreManagerRegistry.getManager(sourceScheme).removeModel(sourcePath),saveResult.modelArtifactsInfo}async function listModels(){let schemes=ModelStoreManagerRegistry.getSchemes(),out={};for(let scheme of schemes){let schemeOut=await ModelStoreManagerRegistry.getManager(scheme).listModels();for(let path in schemeOut){let url=scheme+URL_SCHEME_SUFFIX+path;out[url]=schemeOut[path]}}return out}async function removeModel(url){let schemeAndPath=parseURL(url),manager=ModelStoreManagerRegistry.getManager(schemeAndPath.scheme);return manager.removeModel(schemeAndPath.path)}async function copyModel(sourceURL,destURL){let deleteSource=!1;return cloneModelInternal(sourceURL,destURL,deleteSource)}async function moveModel(sourceURL,destURL){let deleteSource=!0;return cloneModelInternal(sourceURL,destURL,deleteSource)}var PlatformBrowser=class{fetch(path,init){return fetch(path,init)}now(){return performance.now()}encode(text,encoding){if(encoding!=="utf-8"&&encoding!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${encoding}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(text)}decode(bytes,encoding){return new TextDecoder(encoding).decode(bytes)}};if(env().get("IS_BROWSER")){env().setPlatform("browser",new PlatformBrowser);try{ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME,new BrowserLocalStorageManager)}catch(err){}try{ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME,new BrowserIndexedDBManager)}catch(err){}}var getNodeFetch={importFetch:()=>require_browser()},systemFetch,PlatformNode=class{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(path,requestInits){return env().global.fetch!=null?env().global.fetch(path,requestInits):(systemFetch==null&&(systemFetch=getNodeFetch.importFetch()),systemFetch(path,requestInits))}now(){let time=process.hrtime();return time[0]*1e3+time[1]/1e6}encode(text,encoding){if(encoding!=="utf-8"&&encoding!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${encoding}`);return this.textEncoder.encode(text)}decode(bytes,encoding){return bytes.length===0?"":new this.util.TextDecoder(encoding).decode(bytes)}};env().get("IS_NODE")&&env().setPlatform("node",new PlatformNode);function buffer(shape,dtype="float32",values){return dtype=dtype||"float32",assertNonNegativeIntegerDimensions(shape),new TensorBuffer(shape,dtype,values)}function cast_(x,dtype){let $x=convertToTensor(x,"x","cast");if(!isValidDtype(dtype))throw new Error(`Failed to cast to unknown dtype ${dtype}`);if(dtype==="string"&&$x.dtype!=="string"||dtype!=="string"&&$x.dtype==="string")throw new Error("Only strings can be casted to strings");let inputs={x:$x},attrs={dtype};return ENGINE.runKernelFunc(backend3=>backend3.cast($x,dtype),inputs,null,Cast,attrs)}var cast=op({cast_});function clone_(x){let $x=convertToTensor(x,"x","clone",null),forward=()=>ENGINE.makeTensorFromDataId($x.dataId,$x.shape,$x.dtype),inputs={x:$x};return ENGINE.runKernelFunc(forward,inputs,null,Identity)}var clone=op({clone_});function print(x,verbose=!1){console.log(x.toString(verbose))}getOrMakeEngine();var opHandler2={buffer,cast,clone,print};setOpHandler(opHandler2);var io_exports={};__export(io_exports,{browserFiles:()=>browserFiles,browserHTTPRequest:()=>browserHTTPRequest,concatenateArrayBuffers:()=>concatenateArrayBuffers,copyModel:()=>copyModel,decodeWeights:()=>decodeWeights,encodeWeights:()=>encodeWeights,fromMemory:()=>fromMemory,getLoadHandlers:()=>getLoadHandlers,getModelArtifactsInfoForJSON:()=>getModelArtifactsInfoForJSON,getSaveHandlers:()=>getSaveHandlers,http:()=>http,isHTTPScheme:()=>isHTTPScheme,listModels:()=>listModels,loadWeights:()=>loadWeights,moveModel:()=>moveModel,registerLoadRouter:()=>registerLoadRouter,registerSaveRouter:()=>registerSaveRouter,removeModel:()=>removeModel,weightsLoaderFactory:()=>weightsLoaderFactory,withSaveHandler:()=>withSaveHandler});var DEFAULT_FILE_NAME_PREFIX="model",DEFAULT_JSON_EXTENSION_NAME=".json",DEFAULT_WEIGHT_DATA_EXTENSION_NAME=".weights.bin";function defer(f){return new Promise(resolve=>setTimeout(resolve)).then(f)}var BrowserDownloads=class{constructor(fileNamePrefix){if(!env().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");fileNamePrefix.startsWith(BrowserDownloads.URL_SCHEME)&&(fileNamePrefix=fileNamePrefix.slice(BrowserDownloads.URL_SCHEME.length)),(fileNamePrefix==null||fileNamePrefix.length===0)&&(fileNamePrefix=DEFAULT_FILE_NAME_PREFIX),this.modelTopologyFileName=fileNamePrefix+DEFAULT_JSON_EXTENSION_NAME,this.weightDataFileName=fileNamePrefix+DEFAULT_WEIGHT_DATA_EXTENSION_NAME}async save(modelArtifacts){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let weightsURL=window.URL.createObjectURL(new Blob([modelArtifacts.weightData],{type:"application/octet-stream"}));if(modelArtifacts.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let weightsManifest=[{paths:["./"+this.weightDataFileName],weights:modelArtifacts.weightSpecs}],modelTopologyAndWeightManifest={modelTopology:modelArtifacts.modelTopology,format:modelArtifacts.format,generatedBy:modelArtifacts.generatedBy,convertedBy:modelArtifacts.convertedBy,weightsManifest},modelTopologyAndWeightManifestURL=window.URL.createObjectURL(new Blob([JSON.stringify(modelTopologyAndWeightManifest)],{type:"application/json"})),jsonAnchor=this.jsonAnchor==null?document.createElement("a"):this.jsonAnchor;if(jsonAnchor.download=this.modelTopologyFileName,jsonAnchor.href=modelTopologyAndWeightManifestURL,await defer(()=>jsonAnchor.dispatchEvent(new MouseEvent("click"))),modelArtifacts.weightData!=null){let weightDataAnchor=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;weightDataAnchor.download=this.weightDataFileName,weightDataAnchor.href=weightsURL,await defer(()=>weightDataAnchor.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:getModelArtifactsInfoForJSON(modelArtifacts)}}}};BrowserDownloads.URL_SCHEME="downloads://";var BrowserFiles=class{constructor(files){if(files==null||files.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${files}`);this.files=files}async load(){let jsonFile=this.files[0],weightFiles=this.files.slice(1);return new Promise((resolve,reject)=>{let jsonReader=new FileReader;jsonReader.onload=event=>{let modelJSON=JSON.parse(event.target.result),modelTopology=modelJSON.modelTopology;if(modelTopology==null){reject(new Error(`modelTopology field is missing from file ${jsonFile.name}`));return}weightFiles.length===0&&resolve({modelTopology});let weightsManifest=modelJSON.weightsManifest;if(weightsManifest==null){reject(new Error(`weightManifest field is missing from file ${jsonFile.name}`));return}let pathToFile;try{pathToFile=this.checkManifestAndWeightFiles(weightsManifest,weightFiles)}catch(err){reject(err);return}let weightSpecs=[],paths=[],perFileBuffers=[];weightsManifest.forEach(weightsGroup=>{weightsGroup.paths.forEach(path=>{paths.push(path),perFileBuffers.push(null)}),weightSpecs.push(...weightsGroup.weights)}),weightsManifest.forEach(weightsGroup=>{weightsGroup.paths.forEach(path=>{let weightFileReader=new FileReader;weightFileReader.onload=event2=>{let weightData=event2.target.result,index=paths.indexOf(path);perFileBuffers[index]=weightData,perFileBuffers.indexOf(null)===-1&&resolve({modelTopology,weightSpecs,weightData:concatenateArrayBuffers(perFileBuffers),format:modelJSON.format,generatedBy:modelJSON.generatedBy,convertedBy:modelJSON.convertedBy,userDefinedMetadata:modelJSON.userDefinedMetadata})},weightFileReader.onerror=error=>reject(`Failed to weights data from file of path '${path}'.`),weightFileReader.readAsArrayBuffer(pathToFile[path])})})},jsonReader.onerror=error=>reject(`Failed to read model topology and weights manifest JSON from file '${jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),jsonReader.readAsText(jsonFile)})}checkManifestAndWeightFiles(manifest,files){let basenames=[],fileNames=files.map(file=>basename(file.name)),pathToFile={};for(let group of manifest)group.paths.forEach(path=>{let pathBasename=basename(path);if(basenames.indexOf(pathBasename)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${pathBasename}'`);if(basenames.push(pathBasename),fileNames.indexOf(pathBasename)===-1)throw new Error(`Weight file with basename '${pathBasename}' is not provided.`);pathToFile[path]=files[fileNames.indexOf(pathBasename)]});if(basenames.length!==files.length)throw new Error(`Mismatch in the number of files in weights manifest (${basenames.length}) and the number of weight files provided (${files.length}).`);return pathToFile}},browserDownloadsRouter=url=>env().getBool("IS_BROWSER")&&(!Array.isArray(url)&&url.startsWith(BrowserDownloads.URL_SCHEME))?browserDownloads(url.slice(BrowserDownloads.URL_SCHEME.length)):null;IORouterRegistry.registerSaveRouter(browserDownloadsRouter);function browserDownloads(fileNamePrefix="model"){return new BrowserDownloads(fileNamePrefix)}function browserFiles(files){return new BrowserFiles(files)}function monitorPromisesProgress(promises,onProgress,startFraction,endFraction){checkPromises(promises),startFraction=startFraction==null?0:startFraction,endFraction=endFraction==null?1:endFraction,checkFraction(startFraction,endFraction);let resolvedPromise=0,registerMonitor=promise=>(promise.then(value=>{let fraction=startFraction+ ++resolvedPromise/promises.length*(endFraction-startFraction);return onProgress(fraction),value}),promise);function checkPromises(promises2){assert(promises2!=null&&Array.isArray(promises2)&&promises2.length>0,()=>"promises must be a none empty array")}function checkFraction(startFraction2,endFraction2){assert(startFraction2>=0&&startFraction2<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${startFraction2}`),assert(endFraction2>=0&&endFraction2<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${endFraction2}`),assert(endFraction2>=startFraction2,()=>`startFraction must be no more than endFraction, but got startFraction ${startFraction2} and endFraction ${endFraction2}`)}return Promise.all(promises.map(registerMonitor))}async function loadWeightsAsArrayBuffer(fetchURLs,loadOptions){loadOptions==null&&(loadOptions={});let fetchFunc=loadOptions.fetchFunc==null?env().platform.fetch:loadOptions.fetchFunc,requests=fetchURLs.map(fetchURL=>fetchFunc(fetchURL,loadOptions.requestInit,{isBinary:!0})),fetchStartFraction=0,fetchEndFraction=.5,responses=loadOptions.onProgress==null?await Promise.all(requests):await monitorPromisesProgress(requests,loadOptions.onProgress,fetchStartFraction,fetchEndFraction),bufferPromises=responses.map(response=>response.arrayBuffer()),bufferStartFraction=.5,bufferEndFraction=1,buffers=loadOptions.onProgress==null?await Promise.all(bufferPromises):await monitorPromisesProgress(bufferPromises,loadOptions.onProgress,bufferStartFraction,bufferEndFraction);return buffers}async function loadWeights(manifest,filePathPrefix="",weightNames,requestInit){let fetchWeights=fetchUrls=>loadWeightsAsArrayBuffer(fetchUrls,{requestInit}),loadWeights2=weightsLoaderFactory(fetchWeights);return loadWeights2(manifest,filePathPrefix,weightNames)}function weightsLoaderFactory(fetchWeightsFunction){return async(manifest,filePathPrefix="",weightNames)=>{let groupIndicesToFetchMap=manifest.map(()=>!1),groupWeightsToFetch={},weightsFound=weightNames!=null?weightNames.map(()=>!1):[],allManifestWeightNames=[];if(manifest.forEach((manifestGroupConfig,groupIndex)=>{let groupOffset=0;manifestGroupConfig.weights.forEach(weightsEntry=>{let rawDtype="quantization"in weightsEntry?weightsEntry.quantization.dtype:weightsEntry.dtype,weightsBytes=DTYPE_VALUE_SIZE_MAP[rawDtype]*sizeFromShape(weightsEntry.shape),enqueueWeightsForFetchingFn=()=>{groupIndicesToFetchMap[groupIndex]=!0,groupWeightsToFetch[groupIndex]==null&&(groupWeightsToFetch[groupIndex]=[]),groupWeightsToFetch[groupIndex].push({manifestEntry:weightsEntry,groupOffset,sizeBytes:weightsBytes})};weightNames!=null?weightNames.forEach((weightName,weightIndex)=>{weightName===weightsEntry.name&&(enqueueWeightsForFetchingFn(),weightsFound[weightIndex]=!0)}):enqueueWeightsForFetchingFn(),allManifestWeightNames.push(weightsEntry.name),groupOffset+=weightsBytes})}),!weightsFound.every(found=>found)){let weightsNotFound=weightNames.filter((_,i)=>!weightsFound[i]);throw new Error(`Could not find weights in manifest with names: ${weightsNotFound.join(", ")}. 
Manifest JSON has weights with names: ${allManifestWeightNames.join(", ")}.`)}let groupIndicesToFetch=groupIndicesToFetchMap.reduce((accumulator,shouldFetch,i)=>(shouldFetch&&accumulator.push(i),accumulator),[]),fetchUrls=[];groupIndicesToFetch.forEach(i=>{manifest[i].paths.forEach(filepath=>{let fetchUrl=filePathPrefix+(filePathPrefix.endsWith("/")?"":"/")+filepath;fetchUrls.push(fetchUrl)})});let buffers=await fetchWeightsFunction(fetchUrls),weightsTensorMap={},bufferIndexOffset=0;return groupIndicesToFetch.forEach(i=>{let numBuffers=manifest[i].paths.length,groupBytes=0;for(let i2=0;i2<numBuffers;i2++)groupBytes+=buffers[bufferIndexOffset+i2].byteLength;let groupBuffer=new ArrayBuffer(groupBytes),groupByteBuffer=new Uint8Array(groupBuffer),groupBufferOffset=0;for(let i2=0;i2<numBuffers;i2++){let buffer10=new Uint8Array(buffers[bufferIndexOffset+i2]);groupByteBuffer.set(buffer10,groupBufferOffset),groupBufferOffset+=buffer10.byteLength}let weightsEntries=groupWeightsToFetch[i];weightsEntries.forEach(weightsEntry=>{let byteBuffer=groupBuffer.slice(weightsEntry.groupOffset,weightsEntry.groupOffset+weightsEntry.sizeBytes),nameToTensorMap=decodeWeights(byteBuffer,[weightsEntry.manifestEntry]);for(let name in nameToTensorMap)weightsTensorMap[name]=nameToTensorMap[name]}),bufferIndexOffset+=numBuffers}),weightsTensorMap}}var OCTET_STREAM_MIME_TYPE="application/octet-stream",JSON_TYPE="application/json",HTTPRequest=class{constructor(path,loadOptions){if(this.DEFAULT_METHOD="POST",loadOptions==null&&(loadOptions={}),this.weightPathPrefix=loadOptions.weightPathPrefix,this.onProgress=loadOptions.onProgress,this.weightUrlConverter=loadOptions.weightUrlConverter,loadOptions.fetchFunc!=null?(assert(typeof loadOptions.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=loadOptions.fetchFunc):this.fetch=env().platform.fetch,assert(path!=null&&path.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(path)&&assert(path.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${path.length}).`),this.path=path,loadOptions.requestInit!=null&&loadOptions.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=loadOptions.requestInit||{}}async save(modelArtifacts){if(modelArtifacts.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let init=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);init.body=new FormData;let weightsManifest=[{paths:["./model.weights.bin"],weights:modelArtifacts.weightSpecs}],modelTopologyAndWeightManifest={modelTopology:modelArtifacts.modelTopology,format:modelArtifacts.format,generatedBy:modelArtifacts.generatedBy,convertedBy:modelArtifacts.convertedBy,userDefinedMetadata:modelArtifacts.userDefinedMetadata,weightsManifest};init.body.append("model.json",new Blob([JSON.stringify(modelTopologyAndWeightManifest)],{type:JSON_TYPE}),"model.json"),modelArtifacts.weightData!=null&&init.body.append("model.weights.bin",new Blob([modelArtifacts.weightData],{type:OCTET_STREAM_MIME_TYPE}),"model.weights.bin");let response=await this.fetch(this.path,init);if(response.ok)return{modelArtifactsInfo:getModelArtifactsInfoForJSON(modelArtifacts),responses:[response]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${response.status}.`)}async load(){let modelConfigRequest=await this.fetch(this.path,this.requestInit);if(!modelConfigRequest.ok)throw new Error(`Request to ${this.path} failed with status code ${modelConfigRequest.status}. Please verify this URL points to the model JSON of the model to load.`);let modelConfig;try{modelConfig=await modelConfigRequest.json()}catch(e){let message=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?message+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":message+=" Please make sure the server is serving valid JSON for this request.",new Error(message)}let modelTopology=modelConfig.modelTopology,weightsManifest=modelConfig.weightsManifest,generatedBy=modelConfig.generatedBy,convertedBy=modelConfig.convertedBy,format=modelConfig.format,userDefinedMetadata=modelConfig.userDefinedMetadata;if(modelTopology==null&&weightsManifest==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);let weightSpecs,weightData;if(weightsManifest!=null){let results=await this.loadWeights(weightsManifest);[weightSpecs,weightData]=results}let artifacts={modelTopology,weightSpecs,weightData,userDefinedMetadata,generatedBy,convertedBy,format},initializer=modelConfig.modelInitializer;return initializer&&(artifacts.modelInitializer=initializer),artifacts}async loadWeights(weightsManifest){let weightPath=Array.isArray(this.path)?this.path[1]:this.path,[prefix,suffix]=parseUrl(weightPath),pathPrefix=this.weightPathPrefix||prefix,weightSpecs=[];for(let entry of weightsManifest)weightSpecs.push(...entry.weights);let fetchURLs=[],urlPromises=[];for(let weightsGroup of weightsManifest)for(let path of weightsGroup.paths)this.weightUrlConverter!=null?urlPromises.push(this.weightUrlConverter(path)):fetchURLs.push(pathPrefix+path+suffix);this.weightUrlConverter&&fetchURLs.push(...await Promise.all(urlPromises));let buffers=await loadWeightsAsArrayBuffer(fetchURLs,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[weightSpecs,concatenateArrayBuffers(buffers)]}};HTTPRequest.URL_SCHEME_REGEX=/^https?:\/\//;function parseUrl(url){let lastSlash=url.lastIndexOf("/"),lastSearchParam=url.lastIndexOf("?"),prefix=url.substring(0,lastSlash),suffix=lastSearchParam>lastSlash?url.substring(lastSearchParam):"";return[prefix+"/",suffix]}function isHTTPScheme(url){return url.match(HTTPRequest.URL_SCHEME_REGEX)!=null}var httpRouter=(url,loadOptions)=>{if(typeof fetch=="undefined"&&(loadOptions==null||loadOptions.fetchFunc==null))return null;{let isHTTP=!0;if(Array.isArray(url)?isHTTP=url.every(urlItem=>isHTTPScheme(urlItem)):isHTTP=isHTTPScheme(url),isHTTP)return http(url,loadOptions)}return null};IORouterRegistry.registerSaveRouter(httpRouter);IORouterRegistry.registerLoadRouter(httpRouter);function http(path,loadOptions){return new HTTPRequest(path,loadOptions)}function browserHTTPRequest(path,loadOptions){return http(path,loadOptions)}var PassthroughLoader=class{constructor(modelArtifacts){this.modelArtifacts=modelArtifacts}async load(){return this.modelArtifacts}},PassthroughSaver=class{constructor(saveHandler){this.saveHandler=saveHandler}async save(modelArtifacts){return this.saveHandler(modelArtifacts)}};function fromMemory(modelArtifacts,weightSpecs,weightData,trainingConfig){if(arguments.length===1){let isModelArtifacts=modelArtifacts.modelTopology!=null||modelArtifacts.weightSpecs!=null;return isModelArtifacts?new PassthroughLoader(modelArtifacts):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new PassthroughLoader({modelTopology:modelArtifacts}))}else return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new PassthroughLoader({modelTopology:modelArtifacts,weightSpecs,weightData,trainingConfig})}function withSaveHandler(saveHandler){return new PassthroughSaver(saveHandler)}function reshape_(x,shape){let $x=convertToTensor(x,"x","reshape",null),inputs={x:$x},attrs={shape},forward=(backend3,save)=>(shape=inferFromImplicitShape(shape,$x.size),assert($x.size===sizeFromShape(shape),()=>"new shape and old shape must have the same number of elements."),save([$x]),backend3.reshape($x,shape));return ENGINE.runKernelFunc(forward,inputs,null,Reshape,attrs)}var reshape=op({reshape_});function matMul_(a,b,transposeA=!1,transposeB=!1){let $a=convertToTensor(a,"a","matMul"),$b=convertToTensor(b,"b","matMul");[$a,$b]=makeTypesMatch($a,$b);let forward=(backend3,save)=>{save([$a,$b]);let innerShapeA=transposeA?$a.shape[$a.rank-2]:$a.shape[$a.rank-1],innerShapeB=transposeB?$b.shape[$b.rank-1]:$b.shape[$b.rank-2],outerShapeA=transposeA?$a.shape[$a.rank-1]:$a.shape[$a.rank-2],outerShapeB=transposeB?$b.shape[$b.rank-2]:$b.shape[$b.rank-1],outerDimsA=$a.shape.slice(0,-2),outerDimsB=$b.shape.slice(0,-2),batchDimA=sizeFromShape(outerDimsA),batchDimB=sizeFromShape(outerDimsB),batchDimsCompatible=batchDimA===batchDimB||batchDimA===1||batchDimB===1;assert($a.rank>=2&&$b.rank>=2&&batchDimsCompatible,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${outerDimsA}) and (${outerDimsB}).`),assert(innerShapeA===innerShapeB,()=>`Error in matMul: inner shapes (${innerShapeA}) and (${innerShapeB}) of Tensors with shapes ${$a.shape} and ${$b.shape} and transposeA=${transposeA} and transposeB=${transposeB} must match.`);let outShapeOuterDims=batchDimA>batchDimB?outerDimsA:outerDimsB,outShape=outShapeOuterDims.concat([outerShapeA,outerShapeB]),a3D=transposeA?reshape($a,[batchDimA,innerShapeA,outerShapeA]):reshape($a,[batchDimA,outerShapeA,innerShapeA]),b3D=transposeB?reshape($b,[batchDimB,outerShapeB,innerShapeB]):reshape($b,[batchDimB,innerShapeB,outerShapeB]),res3d=backend3.batchMatMul(a3D,b3D,transposeA,transposeB);return reshape(res3d,outShape)},inputs={a:$a,b:$b},attrs={transposeA,transposeB};return ENGINE.runKernelFunc(forward,inputs,null,BatchMatMul,attrs)}var matMul=op({matMul_});function oneHot_(indices,depth,onValue=1,offValue=0){if(depth<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${depth}`);let $indices=convertToTensor(indices,"indices","oneHot","int32"),outShape=[...$indices.shape,depth],forward=(backend3,save)=>(save([$indices]),reshape(backend3.oneHot(reshape($indices,[$indices.size]),depth,onValue,offValue),outShape)),inputs={indices:$indices},attrs={depth,onValue,offValue};return ENGINE.runKernelFunc(forward,inputs,null,OneHot,attrs)}var oneHot=op({oneHot_});function transpose_(x,perm){let $x=convertToTensor(x,"x","transpose");if(perm==null&&(perm=$x.shape.map((s,i)=>i).reverse()),assert($x.rank===perm.length,()=>`Error in transpose: rank of input ${$x.rank} must match length of perm ${perm}.`),perm.forEach(axis=>{assert(axis>=0&&axis<$x.rank,()=>`All entries in 'perm' must be between 0 and ${$x.rank-1} but got ${perm}`)}),$x.rank<=1)return $x.clone();let inputs={x:$x},attrs={perm};return ENGINE.runKernelFunc(backend3=>backend3.transpose($x,perm),inputs,null,Transpose,attrs)}var transpose=op({transpose_}),browser_exports={};__export(browser_exports,{fromPixels:()=>fromPixels,toPixels:()=>toPixels});function tensor3d(values,shape,dtype){if(assertNonNull(values),shape!=null&&shape.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let inferredShape=inferShape(values,dtype);if(inferredShape.length!==3&&inferredShape.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(inferredShape.length===1&&shape==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return makeTensor(values,shape,inferredShape,dtype)}var fromPixels2DContext;function fromPixels_(pixels,numChannels=3){if(numChannels>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(pixels==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let isPixelData=!1,isImageData=!1,isVideo=!1,isImage=!1,isCanvasLike=!1;if(pixels.data instanceof Uint8Array)isPixelData=!0;else if(typeof ImageData!="undefined"&&pixels instanceof ImageData)isImageData=!0;else if(typeof HTMLVideoElement!="undefined"&&pixels instanceof HTMLVideoElement)isVideo=!0;else if(typeof HTMLImageElement!="undefined"&&pixels instanceof HTMLImageElement)isImage=!0;else if(pixels.getContext!=null)isCanvasLike=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${pixels.constructor.name}`);if(isVideo){let HAVE_CURRENT_DATA_READY_STATE=2;if(isVideo&&pixels.readyState<HAVE_CURRENT_DATA_READY_STATE)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}let kernel=getKernel(FromPixels,ENGINE.backendName);if(kernel!=null){let inputs={pixels},attrs={numChannels};return ENGINE.runKernel(FromPixels,inputs,attrs)}let[width,height]=isVideo?[pixels.videoWidth,pixels.videoHeight]:[pixels.width,pixels.height],vals;isCanvasLike?vals=pixels.getContext("2d").getImageData(0,0,width,height).data:isImageData||isPixelData?vals=pixels.data:(isImage||isVideo)&&(fromPixels2DContext==null&&(fromPixels2DContext=document.createElement("canvas").getContext("2d")),fromPixels2DContext.canvas.width=width,fromPixels2DContext.canvas.height=height,fromPixels2DContext.drawImage(pixels,0,0,width,height),vals=fromPixels2DContext.getImageData(0,0,width,height).data);let values;if(numChannels===4)values=new Int32Array(vals);else{let numPixels=width*height;values=new Int32Array(numPixels*numChannels);for(let i=0;i<numPixels;i++)for(let channel=0;channel<numChannels;++channel)values[i*numChannels+channel]=vals[i*4+channel]}let outShape=[height,width,numChannels];return tensor3d(values,outShape,"int32")}async function toPixels(img,canvas){let $img=convertToTensor(img,"img","toPixels");if(!(img instanceof Tensor)){let originalImgTensor=$img;$img=cast(originalImgTensor,"int32"),originalImgTensor.dispose()}if($img.rank!==2&&$img.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${$img.rank}.`);let[height,width]=$img.shape.slice(0,2),depth=$img.rank===2?1:$img.shape[2];if(depth>4||depth===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${depth}`);if($img.dtype!=="float32"&&$img.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${$img.dtype}. Please use float32 or int32 tensors.`);let data=await $img.data(),multiplier=$img.dtype==="float32"?255:1,bytes=new Uint8ClampedArray(width*height*4);for(let i=0;i<height*width;++i){let rgba=[0,0,0,255];for(let d=0;d<depth;d++){let value=data[i*depth+d];if($img.dtype==="float32"){if(value<0||value>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${value}.`)}else if($img.dtype==="int32"&&(value<0||value>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${value}.`);depth===1?(rgba[0]=value*multiplier,rgba[1]=value*multiplier,rgba[2]=value*multiplier):rgba[d]=value*multiplier}let j=i*4;bytes[j+0]=Math.round(rgba[0]),bytes[j+1]=Math.round(rgba[1]),bytes[j+2]=Math.round(rgba[2]),bytes[j+3]=Math.round(rgba[3])}if(canvas!=null){canvas.width=width,canvas.height=height;let ctx=canvas.getContext("2d"),imageData=new ImageData(bytes,width,height);ctx.putImageData(imageData,0,0)}return $img!==img&&$img.dispose(),bytes}var fromPixels=op({fromPixels_});function prepareAndValidate(tensor166,indices){if(tensor166.rank<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${tensor166.rank}.`);if(indices.rank<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${indices.rank}.`);if(indices.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${indices.dtype}.`);if(indices.shape[indices.rank-1]>tensor166.rank)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${indices.shape[indices.rank-1]} vs. ${tensor166.rank}`);if(tensor166.size===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${tensor166.shape}.`);let indicesShape=indices.shape,sliceRank=indicesShape[indicesShape.length-1],nResult=1;for(let i=0;i<indicesShape.length-1;++i)nResult*=indicesShape[i];let inputShape=tensor166.shape,resultShape=indicesShape.slice();resultShape.pop();let sliceSize=1;for(let i=sliceRank;i<tensor166.rank;++i)sliceSize*=inputShape[i],resultShape.push(inputShape[i]);let strides=[...computeStrides(tensor166.shape).map(stride=>stride/sliceSize),1].slice(0,sliceRank);return[resultShape,nResult,sliceSize,strides]}function validateUpdateShape(shape,indices,updates){let sliceDim=indices.rank>1?indices.shape[indices.rank-1]:1,batchDim=indices.rank>1?indices.rank-1:1,shapeError=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${updates.shape}, indices.shape: ${indices.shape}, shape: ${shape}, sliceDim: ${sliceDim}, and batchDim: ${batchDim}.`;if(updates.rank<batchDim)throw new Error(shapeError+` update.rank < ${batchDim}. `);if(shape.length<sliceDim+(updates.rank-batchDim))throw new Error(shapeError+` Output shape length < ${sliceDim+(updates.rank-batchDim)}`);if(updates.rank!==batchDim+shape.length-sliceDim)throw new Error(shapeError+` update.rank != ${batchDim+shape.length-sliceDim}`);for(let d=0;d<batchDim;++d)if(updates.shape[d]!==indices.shape[d])throw new Error(shapeError+` updates.shape[${d}] (${updates.shape[d]}) != indices.shape[${d}] (${indices.shape[d]}).`);for(let d=0;d<updates.rank-batchDim;++d)if(updates.shape[d+batchDim]!==shape[d+sliceDim])throw new Error(shapeError+` updates.shape[${d+batchDim}] (${updates.shape[d+batchDim]}) != shape[${d+batchDim}] (${shape[d+batchDim]})`)}function validateInput(updates,indices,shape){if(indices.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${indices.rank}.`);if(updates.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${updates.rank}.`);if(indices.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${indices.dtype}`);if(shape.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${shape}`);if(shape.length===0){if(indices.size===0)throw new Error(`Indices specified for empty output. indices shape: ${indices.shape}`);if(updates.size===0)throw new Error(`Updates specified for empty output. updates shape: ${updates.shape}`)}validateUpdateShape(shape,indices,updates)}function calculateShapes(updates,indices,shape){let indicesRank=indices.shape.length,sliceRank=indicesRank>1?indices.shape[indicesRank-1]:1,totalNd=shape.length,sliceSize=1;for(let i=sliceRank;i<totalNd;++i)sliceSize*=shape[i];let safeSliceDim=sliceRank<1?1:sliceRank,numUpdates=sizeFromShape(indices.shape)/safeSliceDim,strides=[...computeStrides(shape.slice(0,sliceRank)),1],outputSize=sizeFromShape(shape);return{sliceRank,numUpdates,sliceSize,strides,outputSize}}var slice_util_exports={};__export(slice_util_exports,{assertParamsValid:()=>assertParamsValid,computeFlatOffset:()=>computeFlatOffset,computeOutShape:()=>computeOutShape,getNormalizedAxes:()=>getNormalizedAxes,isSliceContinous:()=>isSliceContinous,maskToAxes:()=>maskToAxes,parseSliceParams:()=>parseSliceParams,startForAxis:()=>startForAxis,startIndicesWithElidedDims:()=>startIndicesWithElidedDims,stopForAxis:()=>stopForAxis,stopIndicesWithElidedDims:()=>stopIndicesWithElidedDims,stridesForAxis:()=>stridesForAxis,stridesWithElidedDims:()=>stridesWithElidedDims});function assertParamsValid(input2,begin,size){let inputRank=input2.shape.length;assert(inputRank===begin.length,()=>`Error in slice${inputRank}D: Length of begin ${begin} must match the rank of the array (${inputRank}).`),assert(inputRank===size.length,()=>`Error in slice${inputRank}D: Length of size ${size} must match the rank of the array (${inputRank}).`);for(let i=0;i<inputRank;++i)assert(begin[i]+size[i]<=input2.shape[i],()=>`Error in slice${inputRank}D: begin[${i}] + size[${i}] (${begin[i]+size[i]}) would overflow input.shape[${i}] (${input2.shape[i]})`)}function maskToAxes(mask){let axes=[],axis=0;for(;mask>0;)mask&1&&axes.push(axis),mask/=2,axis++;return axes}function computeOutShape(begin,end,strides){let size=[];for(let axis=0;axis<begin.length;axis++)size[axis]=Math.ceil((end[axis]-begin[axis])/strides[axis]);return size}function stridesWithElidedDims(strides,ellipsisInsertionIndex,numElidedAxes,inputShape){let newStrides=[...strides];for(let i=newStrides.length;i<inputShape.length;i++)newStrides.push(1);for(let i=0;i<numElidedAxes;i++)i===0?newStrides[ellipsisInsertionIndex]=1:(newStrides.splice(ellipsisInsertionIndex,0,1),newStrides.pop());return newStrides}function unnormalizeAxis(ellipsisInsertionIndex,numElidedAxes,normalizedAxis){return normalizedAxis<=ellipsisInsertionIndex?normalizedAxis:normalizedAxis-(numElidedAxes-1)}function getElidedAxes(numElidedAxes,ellipsisInsertionIndex){let elidedAxes=[];for(let i=0;i<numElidedAxes;i++)elidedAxes.push(ellipsisInsertionIndex+i);return elidedAxes}function getNormalizedAxes(inputShape,ellipsisAxes,numInterpolatedAxes,begin,end,strides,beginMask,endMask,ellipsisMask){let inputRank=inputShape.length,normalizedBegin=new Array(inputRank),normalizedEnd=new Array(inputRank),normalizedStrides=new Array(inputRank);if(ellipsisAxes.length&&numInterpolatedAxes>0){let fullIndex=ellipsisAxes[0],numElidedAxes=numInterpolatedAxes+1;normalizedBegin=startIndicesWithElidedDims(beginMask,fullIndex,numElidedAxes,begin,inputShape),normalizedEnd=stopIndicesWithElidedDims(endMask,fullIndex,numElidedAxes,end,inputShape),normalizedStrides=stridesWithElidedDims(strides,fullIndex,numElidedAxes,inputShape)}else for(let axis=0;axis<inputRank;axis++)normalizedBegin[axis]=startForAxis(beginMask,begin,strides,inputShape,axis,ellipsisMask),normalizedEnd[axis]=stopForAxis(endMask,end,strides,inputShape,axis,ellipsisMask),normalizedStrides[axis]=stridesForAxis(strides,axis,ellipsisMask);return{begin:normalizedBegin,end:normalizedEnd,strides:normalizedStrides}}function startIndicesWithElidedDims(beginMask,ellipsisInsertionIndex,numElidedAxes,originalBegin,inputShape){let newIndices=[...inputShape],elidedAxes=getElidedAxes(numElidedAxes,ellipsisInsertionIndex);for(let axis=0;axis<newIndices.length;axis++)if(elidedAxes.indexOf(axis)>-1)newIndices[axis]=0;else{let originalAxis=unnormalizeAxis(ellipsisInsertionIndex,numElidedAxes,axis),originalValue=originalBegin[originalAxis];beginMask&1<<originalAxis&&(originalValue=0),newIndices[axis]=originalValue}return newIndices}function stopIndicesWithElidedDims(endMask,ellipsisInsertionIndex,numElidedAxes,originalEnd,inputShape){let newIndices=[...inputShape],elidedAxes=getElidedAxes(numElidedAxes,ellipsisInsertionIndex);for(let axis=0;axis<newIndices.length;axis++)if(elidedAxes.indexOf(axis)>-1)newIndices[axis]=Number.MAX_SAFE_INTEGER;else{let originalAxis=unnormalizeAxis(ellipsisInsertionIndex,numElidedAxes,axis),originalValue=originalEnd[originalAxis];endMask&1<<originalAxis&&(originalValue=Number.MAX_SAFE_INTEGER),newIndices[axis]=originalValue}for(let i=0;i<newIndices.length;i++){let axisSize=inputShape[i];newIndices[i]<0&&(newIndices[i]+=axisSize),newIndices[i]=clamp(0,newIndices[i],inputShape[i])}return newIndices}function stridesForAxis(strides,axis,ellipsisMask){let stride=strides[axis];return(ellipsisMask&1<<axis||stride==null)&&(stride=1),stride}function startForAxis(beginMask,startIndices,strides,inputShape,axis,ellipsisMask){let start=startIndices[axis],stride=strides[axis]||1;(beginMask&1<<axis||ellipsisMask&1<<axis||start==null)&&(stride>0?start=Number.MIN_SAFE_INTEGER:start=Number.MAX_SAFE_INTEGER);let axisSize=inputShape[axis];return start<0&&(start+=axisSize),start=clamp(0,start,axisSize-1),start}function stopForAxis(endMask,stopIndices,strides,inputShape,axis,ellipsisMask){let stop=stopIndices[axis],stride=strides[axis]||1;(endMask&1<<axis||ellipsisMask&1<<axis||stop==null)&&(stride>0?stop=Number.MAX_SAFE_INTEGER:stop=Number.MIN_SAFE_INTEGER);let axisSize=inputShape[axis];return stop<0&&(stop+=axisSize),stride>0?stop=clamp(0,stop,axisSize):stop=clamp(-1,stop,axisSize-1),stop}function isSliceContinous(shape,begin,size){let firstNonOneAxis=size.length;for(let i=0;i<size.length;i++)if(size[i]>1){firstNonOneAxis=i;break}for(let i=firstNonOneAxis+1;i<size.length;i++)if(begin[i]>0||size[i]!==shape[i])return!1;return!0}function computeFlatOffset(begin,strides){let flatOffset=begin.length>0?begin[begin.length-1]:1;for(let i=0;i<begin.length-1;i++)flatOffset+=begin[i]*strides[i];return flatOffset}function parseSliceParams(x,begin,size){let begin_,xRank=x.shape.length;typeof begin=="number"?begin_=[begin,...new Array(xRank-1).fill(0)]:begin.length<xRank?begin_=begin.concat(new Array(xRank-begin.length).fill(0)):begin_=begin.slice(),begin_.forEach(d=>{assert(d!==-1,()=>"slice() does not support negative begin indexing.")});let size_;return size==null?size_=new Array(xRank).fill(-1):typeof size=="number"?size_=[size,...new Array(xRank-1).fill(-1)]:size.length<xRank?size_=size.concat(new Array(xRank-size.length).fill(-1)):size_=size,size_=size_.map((d,i)=>d>=0?d:(assert(d===-1,()=>`Negative size values should be exactly -1 but got ${d} for the slice() size at index ${i}.`),x.shape[i]-begin_[i])),[begin_,size_]}var serialization_exports={};__export(serialization_exports,{Serializable:()=>Serializable,SerializationMap:()=>SerializationMap,registerClass:()=>registerClass});var Serializable=class{getClassName(){return this.constructor.className}static fromConfig(cls,config){return new cls(config)}},SerializationMap=class{constructor(){this.classNameMap={}}static getMap(){return SerializationMap.instance==null&&(SerializationMap.instance=new SerializationMap),SerializationMap.instance}static register(cls){SerializationMap.getMap().classNameMap[cls.className]=[cls,cls.fromConfig]}};function registerClass(cls){assert(cls.className!=null,()=>"Class being registered does not have the static className property defined."),assert(typeof cls.className=="string",()=>"className is required to be a string, but got type "+typeof cls.className),assert(cls.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),SerializationMap.register(cls)}var version="2.7.0";function enableProdMode(){env().set("PROD",!0)}function deprecationWarn(msg){env().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(msg+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}setDeprecationWarningFn(deprecationWarn);function engine14(){return ENGINE}function memory(){return ENGINE.memory()}function tidy(nameOrFn,fn){return ENGINE.tidy(nameOrFn,fn)}function dispose(container2){let tensors=getTensorsInContainer(container2);tensors.forEach(tensor166=>tensor166.dispose())}function keep(result){return ENGINE.keep(result)}function setBackend(backendName){return ENGINE.setBackend(backendName)}function ready(){return ENGINE.ready()}function getBackend(){return ENGINE.backendName}function registerBackend(name,factory,priority=1){return ENGINE.registerBackend(name,factory,priority)}function backend2(){return ENGINE.backend}function add_(a,b){let $a=convertToTensor(a,"a","add"),$b=convertToTensor(b,"b","add");[$a,$b]=makeTypesMatch($a,$b);let forward=(backend3,save)=>{let res=backend3.add($a,$b);return save([$a,$b]),res},inputs={a:$a,b:$b};return ENGINE.runKernelFunc(forward,inputs,null,Add)}var add2=op({add_});function floorDiv_(a,b){let $a=convertToTensor(a,"a","floorDiv"),$b=convertToTensor(b,"b","floorDiv");[$a,$b]=makeTypesMatch($a,$b);let forward=(backend3,save)=>{let res=backend3.floorDiv($a,$b);return save([$a,$b]),res},inputs={a:$a,b:$b};return ENGINE.runKernelFunc(forward,inputs,null,FloorDiv)}var floorDiv=op({floorDiv_});function div_(a,b){let $a=convertToTensor(a,"a","div"),$b=convertToTensor(b,"b","div");if([$a,$b]=makeTypesMatch($a,$b),$a.dtype==="int32"&&$b.dtype==="int32")return floorDiv($a,$b);let forward=(backend3,save)=>{let res=backend3.realDivide($a,$b);return save([$a,$b]),res},inputs={a:$a,b:$b},attrs={};return ENGINE.runKernelFunc(forward,inputs,null,Div,attrs)}var div=op({div_});function mul_(a,b){let $a=convertToTensor(a,"a","mul"),$b=convertToTensor(b,"b","mul");[$a,$b]=makeTypesMatch($a,$b);let forward=(backend3,save)=>{let res=backend3.multiply($a,$b);return save([$a,$b]),res},inputs={a:$a,b:$b};return ENGINE.runKernelFunc(forward,inputs,null,Multiply)}var mul=op({mul_});function abs_(x){let $x=convertToTensor(x,"x","abs"),inputs={x:$x};return ENGINE.runKernelFunc((backend3,save)=>(save([$x]),$x.dtype==="complex64"?backend3.complexAbs($x):backend3.abs($x)),inputs,null,Abs)}var abs=op({abs_});function acos_(x){let $x=convertToTensor(x,"x","acos"),inputs={x:$x};return ENGINE.runKernelFunc((backend3,save)=>{let res=backend3.acos($x);return save([$x]),res},inputs,null,Acos)}var acos=op({acos_});function acosh_(x){let $x=convertToTensor(x,"x","acosh"),inputs={x:$x};return ENGINE.runKernelFunc((backend3,save)=>{let res=backend3.acosh($x);return save([$x]),res},inputs,null,Acosh)}var acosh=op({acosh_});function axesAreInnerMostDims(axes,rank){for(let i=0;i<axes.length;++i)if(axes[axes.length-i-1]!==rank-1-i)return!1;return!0}function combineLocations(outputLoc,reduceLoc,axes){let rank=outputLoc.length+reduceLoc.length,loc=[],outIdx=0,reduceIdx=0;for(let dim=0;dim<rank;dim++)axes.indexOf(dim)===-1?loc.push(outputLoc[outIdx++]):loc.push(reduceLoc[reduceIdx++]);return loc}function computeOutAndReduceShapes(aShape,axes){let outShape=[],rank=aShape.length;for(let dim=0;dim<rank;dim++)axes.indexOf(dim)===-1&&outShape.push(aShape[dim]);let reduceShape=axes.map(dim=>aShape[dim]);return[outShape,reduceShape]}function expandShapeToKeepDim(shape,axes){let reduceSubShape=axes.map(x=>1);return combineLocations(shape,reduceSubShape,axes)}function assertAxesAreInnerMostDims(msg,axes,rank){assert(axesAreInnerMostDims(axes,rank),()=>`${msg} supports only inner-most axes for now. Got axes ${axes} and rank-${rank} input.`)}function getAxesPermutation(axes,rank){if(axesAreInnerMostDims(axes,rank))return null;let result=[];for(let i=0;i<rank;++i)axes.indexOf(i)===-1&&result.push(i);return axes.forEach(axis=>result.push(axis)),result}function getUndoAxesPermutation(axes){return axes.map((axis,i)=>[i,axis]).sort((a,b)=>a[1]-b[1]).map(x=>x[0])}function getInnerMostAxes(numAxes,rank){let res=[];for(let i=rank-numAxes;i<rank;++i)res.push(i);return res}function all_(x,axis=null,keepDims=!1){let $x=convertToTensor(x,"x","all","bool"),forward=backend3=>{let origAxes=parseAxisParam(axis,$x.shape),axes=origAxes,permutedAxes=getAxesPermutation(axes,$x.rank);permutedAxes!=null&&($x=transpose($x,permutedAxes),axes=getInnerMostAxes(axes.length,$x.rank));let res=backend3.all($x,axes);if(keepDims){let newShape=expandShapeToKeepDim(res.shape,origAxes);return reshape(res,newShape)}return res},inputs={x:$x},attrs={axis,keepDims};return ENGINE.runKernelFunc(forward,inputs,null,All,attrs)}var all=op({all_});function any_(x,axis=null,keepDims=!1){let $x=convertToTensor(x,"x","any","bool"),forward=backend3=>{let origAxes=parseAxisParam(axis,$x.shape),axes=origAxes,permutedAxes=getAxesPermutation(axes,$x.rank);permutedAxes!=null&&($x=transpose($x,permutedAxes),axes=getInnerMostAxes(axes.length,$x.rank));let res=backend3.any($x,axes);if(keepDims){let newShape=expandShapeToKeepDim(res.shape,origAxes);return reshape(res,newShape)}return res},inputs={x:$x},attrs={axis,keepDims};return ENGINE.runKernelFunc(forward,inputs,null,Any,attrs)}var any=op({any_});function argMax_(x,axis=0){let $x=convertToTensor(x,"x","argMax"),forward=(backend3,save)=>{save([$x]);let axes=parseAxisParam(axis,$x.shape),permutedAxes=getAxesPermutation(axes,$x.rank);return permutedAxes!=null&&($x=transpose($x,permutedAxes),axes=getInnerMostAxes(axes.length,$x.rank)),backend3.argMax($x,axes[0])},inputs={x:$x},attrs={axis};return ENGINE.runKernelFunc(forward,inputs,null,ArgMax,attrs)}var argMax=op({argMax_});function argMin_(x,axis=0){let $x=convertToTensor(x,"x","argMin"),forward=(backend3,save)=>{save([$x]),axis==null&&(axis=0);let axes=parseAxisParam(axis,$x.shape),permutedAxes=getAxesPermutation(axes,$x.rank);return permutedAxes!=null&&($x=transpose($x,permutedAxes),axes=getInnerMostAxes(axes.length,$x.rank)),backend3.argMin($x,axes[0])},inputs={x:$x},attrs={axis};return ENGINE.runKernelFunc(forward,inputs,null,ArgMin,attrs)}var argMin=op({argMin_});function asin_(x){let $x=convertToTensor(x,"x","asin"),inputs={x:$x};return ENGINE.runKernelFunc((backend3,save)=>{let res=backend3.asin($x);return save([$x]),res},inputs,null,Asin)}var asin=op({asin_});function asinh_(x){let $x=convertToTensor(x,"x","asinh"),inputs={x:$x};return ENGINE.runKernelFunc((backend3,save)=>{let res=backend3.asinh($x);return save([$x]),res},inputs,null,Asinh)}var asinh=op({asinh_});function atan_(x){let $x=convertToTensor(x,"x","atan"),inputs={x:$x};return ENGINE.runKernelFunc((backend3,save)=>{let res=backend3.atan($x);return save([$x]),res},inputs,null,Atan)}var atan=op({atan_});function atan2_(a,b){let $a=convertToTensor(a,"a","atan2"),$b=convertToTensor(b,"b","atan2");[$a,$b]=makeTypesMatch($a,$b);let forward=(backend3,save)=>{let res=backend3.atan2($a,$b);return save([$a,$b]),res},inputs={a:$a,b:$b};return ENGINE.runKernelFunc(forward,inputs,null,Atan2)}var atan2=op({atan2_});function atanh_(x){let $x=convertToTensor(x,"x","atanh"),inputs={x:$x};return ENGINE.runKernelFunc((backend3,save)=>{let res=backend3.atanh($x);return save([$x]),res},inputs,null,Atanh)}var atanh=op({atanh_});function computeDilation2DInfo(inputShape,filterShape,strides,pad6,dataFormat="NHWC",dilations){let inputChannels=inputShape[3],$filterShape=[...filterShape,inputChannels],$dataFormat=convertConv2DDataFormat(dataFormat);return computeConv2DInfo(inputShape,$filterShape,strides,dilations,pad6,null,null,$dataFormat)}function computePool2DInfo(inShape,filterSize,strides,dilations,pad6,roundingMode,dataFormat="channelsLast"){let[filterHeight,filterWidth]=parseTupleParam(filterSize),filterShape;if(dataFormat==="channelsLast")filterShape=[filterHeight,filterWidth,inShape[3],inShape[3]];else if(dataFormat==="channelsFirst")filterShape=[filterHeight,filterWidth,inShape[1],inShape[1]];else throw new Error(`Unknown dataFormat ${dataFormat}`);return computeConv2DInfo(inShape,filterShape,strides,dilations,pad6,roundingMode,!1,dataFormat)}function computePool3DInfo(inShape,filterSize,strides,dilations,pad6,roundingMode,dataFormat="NDHWC"){let[filterDepth,filterHeight,filterWidth]=parse3TupleParam(filterSize),filterShape,$dataFormat;if(dataFormat==="NDHWC")$dataFormat="channelsLast",filterShape=[filterDepth,filterHeight,filterWidth,inShape[4],inShape[4]];else if(dataFormat==="NCDHW")$dataFormat="channelsFirst",filterShape=[filterDepth,filterHeight,filterWidth,inShape[1],inShape[1]];else throw new Error(`Unknown dataFormat ${dataFormat}`);return computeConv3DInfo(inShape,filterShape,strides,dilations,pad6,!1,$dataFormat,roundingMode)}function computeConv2DInfo(inShape,filterShape,strides,dilations,pad6,roundingMode,depthwise=!1,dataFormat="channelsLast"){let[batchSize,inHeight,inWidth,inChannels]=[-1,-1,-1,-1];if(dataFormat==="channelsLast")[batchSize,inHeight,inWidth,inChannels]=inShape;else if(dataFormat==="channelsFirst")[batchSize,inChannels,inHeight,inWidth]=inShape;else throw new Error(`Unknown dataFormat ${dataFormat}`);let[filterHeight,filterWidth,,filterChannels]=filterShape,[strideHeight,strideWidth]=parseTupleParam(strides),[dilationHeight,dilationWidth]=parseTupleParam(dilations),effectiveFilterHeight=getEffectiveFilterSize(filterHeight,dilationHeight),effectiveFilterWidth=getEffectiveFilterSize(filterWidth,dilationWidth),{padInfo,outHeight,outWidth}=getPadAndOutInfo(pad6,inHeight,inWidth,strideHeight,strideWidth,effectiveFilterHeight,effectiveFilterWidth,roundingMode,dataFormat),outChannels=depthwise?filterChannels*inChannels:filterChannels,outShape;return dataFormat==="channelsFirst"?outShape=[batchSize,outChannels,outHeight,outWidth]:dataFormat==="channelsLast"&&(outShape=[batchSize,outHeight,outWidth,outChannels]),{batchSize,dataFormat,inHeight,inWidth,inChannels,outHeight,outWidth,outChannels,padInfo,strideHeight,strideWidth,filterHeight,filterWidth,effectiveFilterHeight,effectiveFilterWidth,dilationHeight,dilationWidth,inShape,outShape,filterShape}}function computeConv3DInfo(inShape,filterShape,strides,dilations,pad6,depthwise=!1,dataFormat="channelsLast",roundingMode){let[batchSize,inDepth,inHeight,inWidth,inChannels]=[-1,-1,-1,-1,-1];if(dataFormat==="channelsLast")[batchSize,inDepth,inHeight,inWidth,inChannels]=inShape;else if(dataFormat==="channelsFirst")[batchSize,inChannels,inDepth,inHeight,inWidth]=inShape;else throw new Error(`Unknown dataFormat ${dataFormat}`);let[filterDepth,filterHeight,filterWidth,,filterChannels]=filterShape,[strideDepth,strideHeight,strideWidth]=parse3TupleParam(strides),[dilationDepth,dilationHeight,dilationWidth]=parse3TupleParam(dilations),effectiveFilterDepth=getEffectiveFilterSize(filterDepth,dilationDepth),effectiveFilterHeight=getEffectiveFilterSize(filterHeight,dilationHeight),effectiveFilterWidth=getEffectiveFilterSize(filterWidth,dilationWidth),{padInfo,outDepth,outHeight,outWidth}=get3DPadAndOutInfo(pad6,inDepth,inHeight,inWidth,strideDepth,strideHeight,strideWidth,effectiveFilterDepth,effectiveFilterHeight,effectiveFilterWidth,roundingMode),outChannels=depthwise?filterChannels*inChannels:filterChannels,outShape;return dataFormat==="channelsFirst"?outShape=[batchSize,outChannels,outDepth,outHeight,outWidth]:dataFormat==="channelsLast"&&(outShape=[batchSize,outDepth,outHeight,outWidth,outChannels]),{batchSize,dataFormat,inDepth,inHeight,inWidth,inChannels,outDepth,outHeight,outWidth,outChannels,padInfo,strideDepth,strideHeight,strideWidth,filterDepth,filterHeight,filterWidth,effectiveFilterDepth,effectiveFilterHeight,effectiveFilterWidth,dilationDepth,dilationHeight,dilationWidth,inShape,outShape,filterShape}}function computeOutputShape2D(inShape,fieldSize,stride,zeroPad,roundingMode){zeroPad==null&&(zeroPad=computeDefaultPad(inShape,fieldSize,stride));let inputRows=inShape[0],inputCols=inShape[1],outputRows=conditionalRound((inputRows-fieldSize+2*zeroPad)/stride+1,roundingMode);assert(isInt(outputRows),()=>`The output # of rows (${outputRows}) must be an integer. Change the stride and/or zero pad parameters`);let outputCols=conditionalRound((inputCols-fieldSize+2*zeroPad)/stride+1,roundingMode);return assert(isInt(outputCols),()=>`The output # of columns (${outputCols}) must be an integer. Change the stride and/or zero pad parameters`),[outputRows,outputCols]}function computeOutputShape4D(inShape,fieldSize,outChannels,stride,zeroPad,roundingMode){zeroPad==null&&(zeroPad=computeDefaultPad(inShape,fieldSize,stride));let inputDepth=inShape[0],inputRows=inShape[1],inputCols=inShape[2],outputDepths=conditionalRound((inputDepth-fieldSize+2*zeroPad)/stride+1,roundingMode);assert(isInt(outputDepths),()=>`The output # of depths (${outputDepths}) must be an integer. Change the stride and/or zero pad parameters`);let outputRows=conditionalRound((inputRows-fieldSize+2*zeroPad)/stride+1,roundingMode);assert(isInt(outputRows),()=>`The output # of rows (${outputRows}) must be an integer. Change the stride and/or zero pad parameters`);let outputCols=conditionalRound((inputCols-fieldSize+2*zeroPad)/stride+1,roundingMode);return assert(isInt(outputCols),()=>`The output # of columns (${outputCols}) must be an integer. Change the stride and/or zero pad parameters`),[outputDepths,outputRows,outputCols,outChannels]}function computeDefaultPad(inputShape,fieldSize,stride,dilation=1){let effectiveFieldSize=getEffectiveFilterSize(fieldSize,dilation);return Math.floor((inputShape[0]*(stride-1)-stride+effectiveFieldSize)/2)}function parseTupleParam(param){return typeof param=="number"?[param,param,param]:param.length===2?[param[0],param[1],1]:param}function parse3TupleParam(param){return typeof param=="number"?[param,param,param]:param}function getEffectiveFilterSize(filterSize,dilation){return dilation<=1?filterSize:filterSize+(filterSize-1)*(dilation-1)}function getPadAndOutInfo(pad6,inHeight,inWidth,strideHeight,strideWidth,filterHeight,filterWidth,roundingMode,dataFormat){let padInfo,outHeight,outWidth;if(typeof pad6=="number"){let padType=pad6===0?"VALID":"NUMBER";padInfo={top:pad6,bottom:pad6,left:pad6,right:pad6,type:padType};let outShape=computeOutputShape2D([inHeight,inWidth],filterHeight,strideHeight,pad6,roundingMode);outHeight=outShape[0],outWidth=outShape[1]}else if(pad6==="same"){outHeight=Math.ceil(inHeight/strideHeight),outWidth=Math.ceil(inWidth/strideWidth);let padAlongHeight=Math.max(0,(outHeight-1)*strideHeight+filterHeight-inHeight),padAlongWidth=Math.max(0,(outWidth-1)*strideWidth+filterWidth-inWidth),top=Math.floor(padAlongHeight/2),bottom=padAlongHeight-top,left=Math.floor(padAlongWidth/2),right=padAlongWidth-left;padInfo={top,bottom,left,right,type:"SAME"}}else if(pad6==="valid")padInfo={top:0,bottom:0,left:0,right:0,type:"VALID"},outHeight=Math.ceil((inHeight-filterHeight+1)/strideHeight),outWidth=Math.ceil((inWidth-filterWidth+1)/strideWidth);else if(typeof pad6=="object"){let top=dataFormat==="channelsLast"?pad6[1][0]:pad6[2][0],bottom=dataFormat==="channelsLast"?pad6[1][1]:pad6[2][1],left=dataFormat==="channelsLast"?pad6[2][0]:pad6[3][0],right=dataFormat==="channelsLast"?pad6[2][1]:pad6[3][1],padType=top===0&&bottom===0&&left===0&&right===0?"VALID":"EXPLICIT";padInfo={top,bottom,left,right,type:padType},outHeight=conditionalRound((inHeight-filterHeight+top+bottom)/strideHeight+1,roundingMode),outWidth=conditionalRound((inWidth-filterWidth+left+right)/strideWidth+1,roundingMode)}else throw Error(`Unknown padding parameter: ${pad6}`);return{padInfo,outHeight,outWidth}}function get3DPadAndOutInfo(pad6,inDepth,inHeight,inWidth,strideDepth,strideHeight,strideWidth,filterDepth,filterHeight,filterWidth,roundingMode){let padInfo,outDepth,outHeight,outWidth;if(typeof pad6=="number"){let padType=pad6===0?"VALID":"NUMBER";padInfo={top:pad6,bottom:pad6,left:pad6,right:pad6,front:pad6,back:pad6,type:padType};let outShape=computeOutputShape4D([inDepth,inHeight,inWidth,1],filterDepth,1,strideDepth,pad6,roundingMode);outDepth=outShape[0],outHeight=outShape[1],outWidth=outShape[2]}else if(pad6==="same"){outDepth=Math.ceil(inDepth/strideDepth),outHeight=Math.ceil(inHeight/strideHeight),outWidth=Math.ceil(inWidth/strideWidth);let padAlongDepth=(outDepth-1)*strideDepth+filterDepth-inDepth,padAlongHeight=(outHeight-1)*strideHeight+filterHeight-inHeight,padAlongWidth=(outWidth-1)*strideWidth+filterWidth-inWidth,front=Math.floor(padAlongDepth/2),back=padAlongDepth-front,top=Math.floor(padAlongHeight/2),bottom=padAlongHeight-top,left=Math.floor(padAlongWidth/2),right=padAlongWidth-left;padInfo={top,bottom,left,right,front,back,type:"SAME"}}else if(pad6==="valid")padInfo={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},outDepth=Math.ceil((inDepth-filterDepth+1)/strideDepth),outHeight=Math.ceil((inHeight-filterHeight+1)/strideHeight),outWidth=Math.ceil((inWidth-filterWidth+1)/strideWidth);else throw Error(`Unknown padding parameter: ${pad6}`);return{padInfo,outDepth,outHeight,outWidth}}function conditionalRound(value,roundingMode){if(!roundingMode)return value;switch(roundingMode){case"round":return Math.round(value);case"ceil":return Math.ceil(value);case"floor":return Math.floor(value);default:throw new Error(`Unknown roundingMode ${roundingMode}`)}}function tupleValuesAreOne(param){let[dimA,dimB,dimC]=parseTupleParam(param);return dimA===1&&dimB===1&&dimC===1}function eitherStridesOrDilationsAreOne(strides,dilations){return tupleValuesAreOne(strides)||tupleValuesAreOne(dilations)}function convertConv2DDataFormat(dataFormat){if(dataFormat==="NHWC")return"channelsLast";if(dataFormat==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${dataFormat}`)}function avgPool_(x,filterSize,strides,pad6,dimRoundingMode){let $x=convertToTensor(x,"x","avgPool","float32"),dilations=1;assert(eitherStridesOrDilationsAreOne(strides,dilations),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);let x4D=$x,reshapedTo4D=!1;$x.rank===3&&(reshapedTo4D=!0,x4D=reshape($x,[1,$x.shape[0],$x.shape[1],$x.shape[2]])),assert(x4D.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${x4D.rank}.`),dimRoundingMode!=null&&assert(isInt(pad6),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad6}.`);let forward=(backend3,save)=>{let convInfo=computePool2DInfo(x4D.shape,filterSize,strides,1,pad6,dimRoundingMode);return save([x4D]),convInfo.filterWidth===1&&convInfo.filterHeight===1&&arraysEqual(convInfo.inShape,convInfo.outShape)?x4D.clone():backend3.avgPool(x4D,convInfo)},inputs={x:x4D},attrs={filterSize,strides,pad:pad6,dimRoundingMode},res=ENGINE.runKernelFunc(forward,inputs,null,AvgPool,attrs);return res=cast(res,$x.dtype),reshapedTo4D?reshape(res,[res.shape[1],res.shape[2],res.shape[3]]):res}var avgPool=op({avgPool_});function avgPool3d_(x,filterSize,strides,pad6,dimRoundingMode,dataFormat="NDHWC",dilations){dilations==null?dilations=[1,1,1]:deprecationWarn("dilations is deprecated, this field will be gone in v3.0.0.");let $x=convertToTensor(x,"x","avgPool3d","float32"),x5D=$x,reshapedTo5D=!1;$x.rank===4&&(reshapedTo5D=!0,x5D=reshape($x,[1,$x.shape[0],$x.shape[1],$x.shape[2],$x.shape[3]])),assert(x5D.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${x5D.rank}.`),assert(dataFormat==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${dataFormat}`),assert(eitherStridesOrDilationsAreOne(strides,dilations),()=>`Error in avgPool3d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`),dimRoundingMode!=null&&assert(isInt(pad6),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad6}.`);let forward=(backend3,save)=>{dilations==null&&(dilations=[1,1,1]);let convInfo=computePool3DInfo(x5D.shape,filterSize,strides,dilations,pad6,dimRoundingMode,dataFormat);return save([x5D]),backend3.avgPool3d(x5D,convInfo)},inputs={x:x5D},attrs={filterSize,strides,pad:pad6,dimRoundingMode,dataFormat,dilations},res=ENGINE.runKernelFunc(forward,inputs,null,AvgPool3D,attrs);return res=cast(res,x5D.dtype),reshapedTo5D?reshape(res,[res.shape[1],res.shape[2],res.shape[3],res.shape[4]]):res}var avgPool3d=op({avgPool3d_});function assertParamsConsistent(shapes,axis){let rank=shapes[0].length;shapes.forEach((shape,i)=>{assert(shape.length===rank,()=>`Error in concat${rank}D: rank of tensors[${i}] must be the same as the rank of the rest (${rank})`)}),assert(axis>=0&&axis<rank,()=>`Error in concat${rank}D: axis must be between 0 and ${rank-1}.`);let firstShape=shapes[0];shapes.forEach((shape,i)=>{for(let r=0;r<rank;r++)assert(r===axis||shape[r]===firstShape[r],()=>`Error in concat${rank}D: Shape of tensors[${i}] (${shape}) does not match the shape of the rest (${firstShape}) along the non-concatenated axis ${i}.`)})}function computeOutShape2(shapes,axis){let outputShape=shapes[0].slice();for(let i=1;i<shapes.length;i++)outputShape[axis]+=shapes[i][axis];return outputShape}function concat_(tensors,axis=0){assert(tensors.length>=1,()=>"Pass at least one tensor to concat");let $tensors=convertToTensorArray(tensors,"tensors","concat");$tensors[0].dtype==="complex64"&&$tensors.forEach(tensor166=>{if(tensor166.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${tensor166.dtype}. `)});let forward=(backend3,save)=>{let $axis=parseAxisParam(axis,$tensors[0].shape)[0],outShape=computeOutShape2($tensors.map(t=>t.shape),$axis);if(sizeFromShape(outShape)===0)return tensor4([],outShape);if($tensors=$tensors.filter(t=>t.size>0),$tensors.length===1)return $tensors[0];let shapes=$tensors.map(t=>t.shape);assertParamsConsistent(shapes,$axis);let res=backend3.concat($tensors,$axis);return save($tensors),res},inputs=$tensors,attr={axis};return ENGINE.runKernelFunc(forward,inputs,null,Concat,attr)}var concat=op({concat_});function sigmoid_(x){let $x=convertToTensor(x,"x","sigmoid"),inputs={x:$x};return ENGINE.runKernelFunc((backend3,save)=>{let res=backend3.sigmoid($x);return save([res]),res},inputs,null,Sigmoid)}var sigmoid=op({sigmoid_});function slice_(x,begin,size){let $x=convertToTensor(x,"x","slice");if($x.rank===0)throw new Error("Slicing scalar is not possible");let forward=(backend3,save)=>{let[begin_,size_]=parseSliceParams($x,begin,size);return assertParamsValid($x,begin_,size_),save([$x]),backend3.slice($x,begin_,size_)},inputs={x:$x},attrs={begin,size};return ENGINE.runKernelFunc(forward,inputs,null,Slice,attrs)}var slice=op({slice_});function tanh_(x){let $x=convertToTensor(x,"x","tanh"),inputs={x:$x};return ENGINE.runKernelFunc((backend3,save)=>{let y=backend3.tanh($x);return save([y]),y},inputs,null,Tanh)}var tanh2=op({tanh_});function batchToSpaceND_(x,blockShape,crops){let $x=convertToTensor(x,"x","batchToSpaceND"),prod5=blockShape.reduce((a,b)=>a*b);assert($x.rank>=1+blockShape.length,()=>`input rank is ${$x.rank} but should be > than blockShape.length ${blockShape.length}`),assert(crops.length===blockShape.length,()=>`crops.length is ${crops.length} but should be equal to blockShape.length  ${blockShape.length}`),assert($x.shape[0]%prod5===0,()=>`input tensor batch is ${$x.shape[0]} but is not divisible by the product of the elements of blockShape ${blockShape.join(" * ")} === ${prod5}`);let forward=backend3=>backend3.batchToSpaceND($x,blockShape,crops),inputs={x:$x},attrs={blockShape,crops};return ENGINE.runKernelFunc(forward,inputs,null,BatchToSpaceND,attrs)}var batchToSpaceND=op({batchToSpaceND_});function xAs4D(x){let x4D;return x.rank===0||x.rank===1?x4D=reshape(x,[1,1,1,x.size]):x.rank===2?x4D=reshape(x,[1,1,x.shape[0],x.shape[1]]):x.rank===3?x4D=reshape(x,[1,x.shape[0],x.shape[1],x.shape[2]]):x4D=x,x4D}function batchNorm_(x,mean7,variance,offset,scale2,varianceEpsilon){varianceEpsilon==null&&(varianceEpsilon=.001);let $x=convertToTensor(x,"x","batchNorm"),$mean=convertToTensor(mean7,"mean","batchNorm"),$variance=convertToTensor(variance,"variance","batchNorm"),$scale;scale2!=null&&($scale=convertToTensor(scale2,"scale","batchNorm"));let $offset;offset!=null&&($offset=convertToTensor(offset,"offset","batchNorm")),assert($mean.rank===$variance.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),assert($offset==null||$mean.rank===$offset.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),assert($scale==null||$mean.rank===$scale.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let x4D=xAs4D($x),forward=(backend3,save)=>(save([x4D,$mean,$variance,$scale]),backend3.batchNorm(x4D,as1DOr4D($mean),as1DOr4D($variance),as1DOr4D($offset),as1DOr4D($scale),varianceEpsilon)),inputs={x:x4D,scale:$scale,offset:$offset,mean:$mean,variance:$variance},attrs={varianceEpsilon},res=ENGINE.runKernelFunc(forward,inputs,null,FusedBatchNorm,attrs);return reshape(res,$x.shape)}function as1DOr4D(x){return x==null?null:x.rank===0?reshape(x,[x.size]):x.rank===1?x:x.rank===2?reshape(x,[1,1,x.shape[0],x.shape[1]]):x.rank===3?reshape(x,[1,x.shape[0],x.shape[1],x.shape[2]]):x}var batchNorm=op({batchNorm_});function batchNorm2d_(x,mean7,variance,offset,scale2,varianceEpsilon){let $x=convertToTensor(x,"x","batchNorm"),$mean=convertToTensor(mean7,"mean","batchNorm"),$variance=convertToTensor(variance,"variance","batchNorm"),$scale;scale2!=null&&($scale=convertToTensor(scale2,"scale","batchNorm"));let $offset;return offset!=null&&($offset=convertToTensor(offset,"offset","batchNorm")),assert($x.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${$x.rank}.`),assert($mean.rank===2||$mean.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${$mean.rank}.`),assert($variance.rank===2||$variance.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${$variance.rank}.`),$scale!=null&&assert($scale.rank===2||$scale.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${$scale.rank}.`),$offset!=null&&assert($offset.rank===2||$offset.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${$offset.rank}.`),batchNorm($x,$mean,$variance,$offset,$scale,varianceEpsilon)}var batchNorm2d=op({batchNorm2d_});function batchNorm3d_(x,mean7,variance,offset,scale2,varianceEpsilon){let $x=convertToTensor(x,"x","batchNorm"),$mean=convertToTensor(mean7,"mean","batchNorm"),$variance=convertToTensor(variance,"variance","batchNorm"),$scale;scale2!=null&&($scale=convertToTensor(scale2,"scale","batchNorm"));let $offset;return offset!=null&&($offset=convertToTensor(offset,"offset","batchNorm")),assert($x.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${$x.rank}.`),assert($mean.rank===3||$mean.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${$mean.rank}.`),assert($variance.rank===3||$variance.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${$variance.rank}.`),$scale!=null&&assert($scale.rank===3||$scale.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${$scale.rank}.`),$offset!=null&&assert($offset.rank===3||$offset.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${$offset.rank}.`),batchNorm($x,$mean,$variance,$offset,$scale,varianceEpsilon)}var batchNorm3d=op({batchNorm3d_});function batchNorm4d_(x,mean7,variance,offset,scale2,varianceEpsilon){let $x=convertToTensor(x,"x","batchNorm"),$mean=convertToTensor(mean7,"mean","batchNorm"),$variance=convertToTensor(variance,"variance","batchNorm"),$scale;scale2!=null&&($scale=convertToTensor(scale2,"scale","batchNorm"));let $offset;return offset!=null&&($offset=convertToTensor(offset,"offset","batchNorm")),assert($x.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${$x.rank}.`),assert($mean.rank===4||$mean.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${$mean.rank}.`),assert($variance.rank===4||$variance.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${$variance.rank}.`),$scale!=null&&assert($scale.rank===4||$scale.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${$scale.rank}.`),$offset!=null&&assert($offset.rank===4||$offset.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${$offset.rank}.`),batchNorm($x,$mean,$variance,$offset,$scale,varianceEpsilon)}var batchNorm4d=op({batchNorm4d_});function broadcastTo_(x,shape){let input2=convertToTensor(x,"broadcastTo","x"),xShape=input2.shape;if(shape.some(d=>!(d>0)||d%1!==0))throw new Error(`broadcastTo(): Invalid broadcast shape [${shape}].`);if(shape.length<input2.rank)throw new Error(`broadcastTo(): shape.length=${shape.length} < input.rank=${input2.rank}.`);if(shape.length>input2.rank){let newShape=input2.shape.slice();for(;newShape.length<shape.length;)newShape.unshift(1);input2=reshape(input2,newShape)}let inputShape=input2.shape,reps=Array.from(shape);for(let i=shape.length-1;i>=0;i--)if(inputShape[i]===shape[i])reps[i]=1;else if(input2.shape[i]!==1)throw new Error(`broadcastTo(): [${xShape}] cannot be broadcast to [${shape}].`);let axes=reps.map((n,i)=>n>1?i:-1).filter(i=>i>=0);if(axes.length===0)return clone(input2);let forward=backend3=>backend3.tile(input2,reps),inputs={x:input2},attrs={shape,inputShape};return ENGINE.runKernelFunc(forward,inputs,null,BroadcastTo,attrs)}var broadcastTo=op({broadcastTo_});function ceil_(x){let $x=convertToTensor(x,"x","ceil"),inputs={x:$x};return ENGINE.runKernelFunc(backend3=>backend3.ceil($x),inputs,null,Ceil)}var ceil=op({ceil_});function clipByValue_(x,clipValueMin,clipValueMax){let $x=convertToTensor(x,"x","clipByValue");assert(clipValueMin<=clipValueMax,()=>`Error in clip: min (${clipValueMin}) must be less than or equal to max (${clipValueMax}).`);let inputs={x:$x},attrs={clipValueMin,clipValueMax};return ENGINE.runKernelFunc((backend3,save)=>{let res=backend3.clip($x,clipValueMin,clipValueMax);return save([$x]),res},inputs,null,ClipByValue,attrs)}var clipByValue=op({clipByValue_});function concat1d_(tensors){return concat(tensors,0)}var concat1d=op({concat1d_});function concat2d_(tensors,axis){return concat(tensors,axis)}var concat2d=op({concat2d_});function concat3d_(tensors,axis){return concat(tensors,axis)}var concat3d=op({concat3d_});function concat4d_(tensors,axis){return concat(tensors,axis)}var concat4d=op({concat4d_});function conv2d_(x,filter,strides,pad6,dataFormat="NHWC",dilations=[1,1],dimRoundingMode){let $x=convertToTensor(x,"x","conv2d"),$filter=convertToTensor(filter,"filter","conv2d"),x4D=$x,reshapedTo4D=!1;$x.rank===3&&(reshapedTo4D=!0,x4D=reshape($x,[1,$x.shape[0],$x.shape[1],$x.shape[2]])),assert(x4D.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${x4D.rank}.`),assert($filter.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${$filter.rank}.`),dimRoundingMode!=null&&assert(isInt(pad6),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad6}.`);let inDepth=dataFormat==="NHWC"?x4D.shape[3]:x4D.shape[1];assert(inDepth===$filter.shape[2],()=>`Error in conv2d: depth of input (${inDepth}) must match input depth for filter ${$filter.shape[2]}.`),assert(eitherStridesOrDilationsAreOne(strides,dilations),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);let forward=(backend3,save)=>{let $dataFormat=convertConv2DDataFormat(dataFormat),convInfo=computeConv2DInfo(x4D.shape,$filter.shape,strides,dilations,pad6,dimRoundingMode,!1,$dataFormat),res2=backend3.conv2d(x4D,$filter,convInfo);return save([x4D,$filter]),res2},inputs={x:x4D,filter:$filter},attrs={strides,pad:pad6,dataFormat,dilations,dimRoundingMode},res=ENGINE.runKernelFunc(forward,inputs,null,Conv2D,attrs);return reshapedTo4D?reshape(res,[res.shape[1],res.shape[2],res.shape[3]]):res}var conv2d=op({conv2d_});function conv1d_(x,filter,stride,pad6,dataFormat="NWC",dilation=1,dimRoundingMode){let $x=convertToTensor(x,"x","conv1d"),$filter=convertToTensor(filter,"filter","conv1d"),x3D=$x,reshapedTo3D=!1;$x.rank===2&&(reshapedTo3D=!0,x3D=reshape($x,[1,$x.shape[0],$x.shape[1]])),assert(x3D.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${x3D.rank}.`),assert($filter.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${$filter.rank}.`),dimRoundingMode!=null&&assert(isInt(pad6),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad6}.`),assert(x3D.shape[2]===$filter.shape[1],()=>`Error in conv1d: depth of input (${x3D.shape[2]}) must match input depth for filter ${$filter.shape[1]}.`),assert(eitherStridesOrDilationsAreOne(stride,dilation),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${stride} and dilation '${dilation}'`),assert(dataFormat==="NWC",()=>`Error in conv1d: got dataFormat of ${dataFormat} but only NWC is currently supported.`);let filter4D=reshape($filter,[1,$filter.shape[0],$filter.shape[1],$filter.shape[2]]),input4D=reshape(x3D,[x3D.shape[0],1,x3D.shape[1],x3D.shape[2]]),strides=[1,stride],dilations=[1,dilation],conv2dDataFormat="NHWC",res=conv2d(input4D,filter4D,strides,pad6,conv2dDataFormat,dilations,dimRoundingMode);return reshapedTo3D?reshape(res,[res.shape[2],res.shape[3]]):reshape(res,[res.shape[0],res.shape[2],res.shape[3]])}var conv1d=op({conv1d_});function conv2DBackpropInput_(xShape,dy,filter,strides,pad6,dataFormat="NHWC",dimRoundingMode){assert(xShape.length===dy.rank,()=>`Length of inShape (${xShape.length}) and rank of dy (${dy.rank}) must match`);let xShape4D=xShape,dy4D=dy,reshapedTo4D=!1;dy.rank===3&&(reshapedTo4D=!0,dy4D=reshape(dy,[1,dy.shape[0],dy.shape[1],dy.shape[2]]),xShape4D=[1,xShape[0],xShape[1],xShape[2]]),assert(xShape4D.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${xShape4D.length}.`),assert(dy4D.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${dy4D.rank}`),assert(filter.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${filter.rank}`);let inDepth=dataFormat==="NHWC"?xShape4D[3]:xShape4D[1],outDepth=dataFormat==="NHWC"?dy4D.shape[3]:dy4D.shape[1];assert(inDepth===filter.shape[2],()=>`Error in conv2dDerInput: depth of input (${inDepth}) must match input depth for filter ${filter.shape[2]}.`),assert(outDepth===filter.shape[3],()=>`Error in conv2dDerInput: depth of output (${outDepth}) must match output depth for filter ${filter.shape[3]}.`),dimRoundingMode!=null&&assert(isInt(pad6),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad6}.`);let forward=(backend3,save)=>{let dilations=1,$dataFormat=convertConv2DDataFormat(dataFormat),convInfo=computeConv2DInfo(xShape4D,filter.shape,strides,dilations,pad6,dimRoundingMode,!1,$dataFormat),res2=backend3.conv2dDerInput(dy4D,filter,convInfo);return save([dy4D,filter]),res2},inputs={dy:dy4D,filter},attrs={strides,pad:pad6,dataFormat,dimRoundingMode,inputShape:xShape4D},res=ENGINE.runKernelFunc(forward,inputs,null,Conv2DBackpropInput,attrs);return reshapedTo4D?reshape(res,[res.shape[1],res.shape[2],res.shape[3]]):res}var conv2DBackpropInput=op({conv2DBackpropInput_});function conv2dTranspose_(x,filter,outputShape,strides,pad6,dimRoundingMode){let $x=convertToTensor(x,"x","conv2dTranspose"),$filter=convertToTensor(filter,"filter","conv2dTranspose");return conv2DBackpropInput(outputShape,$x,$filter,strides,pad6,"NHWC",dimRoundingMode)}var conv2dTranspose=op({conv2dTranspose_});function conv3d_(x,filter,strides,pad6,dataFormat="NDHWC",dilations=[1,1,1]){let $x=convertToTensor(x,"x","conv3d"),$filter=convertToTensor(filter,"filter","conv3d"),x5D=$x,reshapedTo5D=!1;$x.rank===4&&(reshapedTo5D=!0,x5D=reshape($x,[1,$x.shape[0],$x.shape[1],$x.shape[2],$x.shape[3]])),assert(x5D.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${x5D.rank}.`),assert($filter.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${$filter.rank}.`),assert(x5D.shape[4]===$filter.shape[3],()=>`Error in conv3d: depth of input (${x5D.shape[4]}) must match input depth for filter ${$filter.shape[3]}.`),assert(eitherStridesOrDilationsAreOne(strides,dilations),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`),assert(dataFormat==="NDHWC",()=>`Error in conv3d: got dataFormat of ${dataFormat} but only NDHWC is currently supported.`);let forward=(backend3,save)=>{let convInfo=computeConv3DInfo(x5D.shape,$filter.shape,strides,dilations,pad6),res2=backend3.conv3d(x5D,$filter,convInfo);return save([x5D,$filter]),res2},inputs={x:x5D,filter:$filter},attrs={strides,pad:pad6,dataFormat,dilations},res=ENGINE.runKernelFunc(forward,inputs,null,Conv3D,attrs);return reshapedTo5D?reshape(res,[res.shape[1],res.shape[2],res.shape[3],res.shape[4]]):res}var conv3d=op({conv3d_});function conv3DBackpropInput_(xShape,dy,filter,strides,pad6){assert(xShape.length===dy.rank,()=>`Length of inShape (${xShape.length}) and rank of dy (${dy.rank}) must match`);let xShape5D=xShape,dy5D=dy,reshapedTo5D=!1;dy.rank===4&&(reshapedTo5D=!0,dy5D=reshape(dy,[1,dy.shape[0],dy.shape[1],dy.shape[2],dy.shape[3]]),xShape5D=[1,xShape[0],xShape[1],xShape[2],xShape[3]]);let inDepth=xShape5D[4],outDepth=dy5D.shape[4];assert(xShape5D.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${xShape5D.length}.`),assert(dy5D.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${dy5D.rank}`),assert(filter.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${filter.rank}`),assert(inDepth===filter.shape[3],()=>`Error in conv3dDerInput: depth of input (${inDepth}) must match input depth for filter ${filter.shape[3]}.`),assert(outDepth===filter.shape[4],()=>`Error in conv3dDerInput: depth of output (${outDepth}) must match output depth for filter ${filter.shape[4]}.`);let forward=backend3=>{let dilations=1,convInfo=computeConv3DInfo(xShape5D,filter.shape,strides,dilations,pad6);return backend3.conv3dDerInput(dy5D,filter,convInfo)},inputs={dy:dy5D,filter},attrs={pad:pad6,strides,inputShape:xShape5D},res=ENGINE.runKernelFunc(forward,inputs,null,Conv3DBackpropInputV2,attrs);return reshapedTo5D?reshape(res,[res.shape[1],res.shape[2],res.shape[3],res.shape[4]]):res}var conv3DBackpropInput=op({conv3DBackpropInput_});function cos_(x){let $x=convertToTensor(x,"x","cos"),inputs={x:$x};return ENGINE.runKernelFunc((backend3,save)=>{let res=backend3.cos($x);return save([$x]),res},inputs,null,Cos)}var cos=op({cos_});function cosh_(x){let $x=convertToTensor(x,"x","cosh"),inputs={x:$x};return ENGINE.runKernelFunc((backend3,save)=>{let res=backend3.cosh($x);return save([$x]),res},inputs,null,Cosh)}var cosh=op({cosh_});function cumsum_(x,axis=0,exclusive=!1,reverse7=!1){let $x=convertToTensor(x,"x","cumsum"),forward=(backend3,save)=>{let permutation=getAxesPermutation([axis],$x.rank),permutedX=$x;permutation!=null&&(permutedX=transpose($x,permutation));let permutedAxis=getInnerMostAxes(1,$x.rank)[0],value=backend3.cumsum(permutedX,permutedAxis,exclusive,reverse7);if(save([$x]),permutation!=null){let reversePermutation=getUndoAxesPermutation(permutation);value=transpose(value,reversePermutation)}return value},inputs={x:$x},attrs={axis,exclusive,reverse:reverse7};return ENGINE.runKernelFunc(forward,inputs,null,Cumsum,attrs)}var cumsum=op({cumsum_});function depthToSpace_(x,blockSize,dataFormat="NHWC"){let $x=convertToTensor(x,"x","depthToSpace"),inputHeight=dataFormat==="NHWC"?$x.shape[1]:$x.shape[2],inputWidth=dataFormat==="NHWC"?$x.shape[2]:$x.shape[3],inputDepth=dataFormat==="NHWC"?$x.shape[3]:$x.shape[1];assert(inputHeight*blockSize>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${inputHeight} and ${blockSize}  for depthToSpace with input shape
    ${$x.shape}`),assert(inputWidth*blockSize>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${inputWidth} and ${blockSize} for depthToSpace with input shape
        ${$x.shape}`),assert(inputDepth%(blockSize*blockSize)===0,()=>`Dimension size must be evenly divisible by ${blockSize*blockSize} but is ${inputDepth} for depthToSpace with input shape ${$x.shape}`);let forward=backend3=>backend3.depthToSpace($x,blockSize,dataFormat),inputs={x:$x},attrs={blockSize,dataFormat};return ENGINE.runKernelFunc(forward,inputs,null,DepthToSpace,attrs)}var depthToSpace=op({depthToSpace_});function depthwiseConv2d_(x,filter,strides,pad6,dataFormat="NHWC",dilations=[1,1],dimRoundingMode){let $x=convertToTensor(x,"x","depthwiseConv2d"),$filter=convertToTensor(filter,"filter","depthwiseConv2d"),x4D=$x,reshapedTo4D=!1;$x.rank===3&&(reshapedTo4D=!0,x4D=reshape($x,[1,$x.shape[0],$x.shape[1],$x.shape[2]])),assert(x4D.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${x4D.rank}.`),assert($filter.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${$filter.rank}.`),assert(x4D.shape[3]===$filter.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${x4D.shape[3]}) must match the inChannels dimension in filter ${$filter.shape[2]}.`),dimRoundingMode!=null&&assert(isInt(pad6),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad6}.`);let forward=(backend3,save)=>{dilations==null&&(dilations=[1,1]),assert(eitherStridesOrDilationsAreOne(strides,dilations),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);let convInfo=computeConv2DInfo(x4D.shape,$filter.shape,strides,dilations,pad6,dimRoundingMode,!0),res2=backend3.depthwiseConv2D(x4D,$filter,convInfo);return save([x4D,$filter]),res2},inputs={x:x4D,filter:$filter},attrs={strides,pad:pad6,dataFormat,dilations,dimRoundingMode},res=ENGINE.runKernelFunc(forward,inputs,null,DepthwiseConv2dNative,attrs);return reshapedTo4D?reshape(res,[res.shape[1],res.shape[2],res.shape[3]]):res}var depthwiseConv2d=op({depthwiseConv2d_});function dilation2d_(x,filter,strides,pad6,dilations=[1,1],dataFormat="NHWC"){let $x=convertToTensor(x,"x","dilation2d"),$filter=convertToTensor(filter,"filter","dilation2d");assert($x.rank===3||$x.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${$x.rank}.`),assert($filter.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${$filter.rank}.`),assert(dataFormat==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${dataFormat}`);let x4D=$x,reshapedTo4D=!1;$x.rank===3&&(x4D=reshape($x,[1,$x.shape[0],$x.shape[1],$x.shape[2]]),reshapedTo4D=!0);let inputs={x:x4D,filter:$filter},attrs={strides,pad:pad6,dilations},res=ENGINE.runKernel(Dilation2D,inputs,attrs);return reshapedTo4D?reshape(res,[res.shape[1],res.shape[2],res.shape[3]]):res}var dilation2d=op({dilation2d_});function getBroadcastDims(inShape,outShape){let inRank=inShape.length,dims=[];for(let i=0;i<inRank;i++){let dim=inRank-1-i,a=inShape[dim]||1,b=outShape[outShape.length-1-i]||1;b>1&&a===1&&dims.unshift(dim)}return dims}function getReductionAxes(inShape,outShape){let result=[];for(let i=0;i<outShape.length;i++){let inDim=inShape[inShape.length-i-1],outAxis=outShape.length-i-1,outDim=outShape[outAxis];(inDim==null||inDim===1&&outDim>1)&&result.unshift(outAxis)}return result}function assertAndGetBroadcastShape(shapeA,shapeB){let result=[],l=Math.max(shapeA.length,shapeB.length);for(let i=0;i<l;i++){let a=shapeA[shapeA.length-i-1];a==null&&(a=1);let b=shapeB[shapeB.length-i-1];if(b==null&&(b=1),a===1)result.unshift(b);else if(b===1)result.unshift(a);else if(a!==b){let errMsg=`Operands could not be broadcast together with shapes ${shapeA} and ${shapeB}.`;throw Error(errMsg)}else result.unshift(a)}return result}function equal_(a,b){let $a=convertToTensor(a,"a","equal"),$b=convertToTensor(b,"b","equal");[$a,$b]=makeTypesMatch($a,$b),assertAndGetBroadcastShape($a.shape,$b.shape);let forward=backend3=>backend3.equal($a,$b),inputs={a:$a,b:$b};return ENGINE.runKernelFunc(forward,inputs,null,Equal)}var equal=op({equal_});function where_(condition,a,b){let $a=convertToTensor(a,"a","where"),$b=convertToTensor(b,"b","where"),$condition=convertToTensor(condition,"condition","where","bool"),broadcastShape=assertAndGetBroadcastShape($a.shape,$b.shape),$broadcastedA=broadcastTo($a,broadcastShape),$broadcastedB=broadcastTo($b,broadcastShape);$condition.rank===1&&assert($condition.shape[0]===$a.shape[0],()=>"The first dimension of `a` must match the size of `condition`."),$condition.rank!==1&&assertShapesMatch($condition.shape,$broadcastedB.shape,"Error in where: ");let forward=(backend3,save)=>{let res=backend3.select($condition,$broadcastedA,$broadcastedB);return save([$condition]),res},inputs={condition:$condition,t:$broadcastedA,e:$broadcastedB};return ENGINE.runKernelFunc(forward,inputs,null,SelectV2)}var where=op({where_});function zerosLike_(x){let $x=convertToTensor(x,"x","zerosLike"),inputs={x:$x};return ENGINE.runKernelFunc(backend3=>backend3.zerosLike($x),inputs,null,ZerosLike)}var zerosLike=op({zerosLike_});function divNoNan_(a,b){let $a=convertToTensor(a,"a","div"),$b=convertToTensor(b,"b","div");[$a,$b]=makeTypesMatch($a,$b);let divResult=div($a,$b),zeros9=zerosLike(divResult),bEqualsZero=equal($b,zeros9);return where(bEqualsZero,zeros9,divResult)}var divNoNan=op({divNoNan_});function dot_(t1,t2){let $t1=convertToTensor(t1,"t1","dot"),$t2=convertToTensor(t2,"t2","dot");assert(($t1.rank===1||$t1.rank===2)&&($t2.rank===1||$t2.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${$t1.rank} and ${$t2.rank}.`);let t1Inner=$t1.rank===1?$t1.size:$t1.shape[1],t2Inner=$t2.rank===1?$t2.size:$t2.shape[0];if(assert(t1Inner===t2Inner,()=>`Error in dot: inner dimensions of inputs must match, but got ${t1Inner} and ${t2Inner}.`),$t1.rank===1&&$t2.rank===1){let t12D=reshape($t1,[1,-1]),t22D=reshape($t2,[-1,1]),t1t2=matMul(t12D,t22D);return reshape(t1t2,[])}else if($t1.rank===1&&$t2.rank===2){let t12D=reshape($t1,[1,-1]),t22D=reshape($t2,[$t2.shape[0],$t2.shape[1]]),t1t2=matMul(t12D,t22D);return reshape(t1t2,[t1t2.size])}else if($t1.rank===2&&$t2.rank===1){let t22D=reshape($t2,[-1,1]),t1t2=matMul($t1,t22D);return reshape(t1t2,[t1t2.size])}else{let t22D=reshape($t2,[$t2.shape[0],$t2.shape[1]]),t1t2=matMul($t1,t22D);return t1t2}}var dot=op({dot_});function elu_(x){let $x=convertToTensor(x,"x","elu"),forward=(backend3,save)=>{let y=backend3.elu($x);return save([y]),y},inputs={x:$x};return ENGINE.runKernelFunc(forward,inputs,null,Elu)}var elu=op({elu_});function erf_(x){let $x=convertToTensor(x,"x","erf");assert($x.dtype==="int32"||$x.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),$x.dtype==="int32"&&($x=cast($x,"float32"));let inputs={x:$x};return ENGINE.runKernelFunc((backend3,save)=>{let res=backend3.erf($x);return save([$x]),res},inputs,null,Erf)}var erf=op({erf_});function exp_(x){let $x=convertToTensor(x,"x","exp"),inputs={x:$x};return ENGINE.runKernelFunc((backend3,save)=>{let res=backend3.exp($x);return save([res]),res},inputs,null,Exp)}var exp=op({exp_});function expandDims_(x,axis=0){let parseAs=null,$x=convertToTensor(x,"x","expandDims",parseAs);assert(axis<=$x.rank,()=>"Axis must be <= rank of the tensor");let newShape=$x.shape.slice();return axis<0&&(assert(-($x.rank+1)<=axis,()=>`Axis must be in the interval [${-($x.rank+1)}, ${$x.rank}]`),axis=$x.rank+axis+1),newShape.splice(axis,0,1),reshape($x,newShape)}var expandDims=op({expandDims_});function expm1_(x){let $x=convertToTensor(x,"x","expm1"),inputs={x:$x};return ENGINE.runKernelFunc((backend3,save)=>{let res=backend3.expm1($x);return save([$x]),res},inputs,null,Expm1)}var expm1=op({expm1_});function tile_(x,reps){let parseAs=null,$x=convertToTensor(x,"x","tile",parseAs);assert($x.rank===reps.length,()=>`Error in transpose: rank of input ${$x.rank} must match length of reps ${reps}.`);let forward=(backend3,save)=>{let res=backend3.tile($x,reps);return save([$x]),res},inputsToSave=[$x],inputs={x:$x},attrs={reps};return ENGINE.runKernelFunc(forward,inputs,null,Tile,attrs,inputsToSave)}var tile=op({tile_});function eye_(numRows,numColumns,batchShape,dtype="float32"){numColumns==null&&(numColumns=numRows);let buff=buffer([numRows,numColumns],dtype),n=numRows<=numColumns?numRows:numColumns;for(let i=0;i<n;++i)buff.set(1,i,i);let out=reshape(buff.toTensor(),[numRows,numColumns]);if(batchShape==null)return out;if(batchShape.length===1)return tile(expandDims(out,0),[batchShape[0],1,1]);if(batchShape.length===2)return tile(expandDims(expandDims(out,0),0),[batchShape[0],batchShape[1],1,1]);if(batchShape.length===3)return tile(expandDims(expandDims(expandDims(out,0),0),0),[batchShape[0],batchShape[1],batchShape[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${batchShape.length}D.`)}var eye=op({eye_});function fill(shape,value,dtype){let attrs={shape,value,dtype};return ENGINE.runKernelFunc(backend3=>backend3.fill(shape,value,dtype),{},null,Fill,attrs)}function floor_(x){let $x=convertToTensor(x,"x","floor"),inputs={x:$x};return ENGINE.runKernelFunc(backend3=>backend3.floor($x),inputs,null,Floor)}var floor=op({floor_});var segment_util_exports={};__export(segment_util_exports,{collectGatherOpShapeInfo:()=>collectGatherOpShapeInfo,computeOutShape:()=>computeOutShape3,segOpComputeOptimalWindowSize:()=>segOpComputeOptimalWindowSize});var PARALLELIZE_THRESHOLD=30;function computeOptimalWindowSize(inSize){return inSize<=PARALLELIZE_THRESHOLD?inSize:nearestDivisor(inSize,Math.floor(Math.sqrt(inSize)))}function segOpComputeOptimalWindowSize(inSize,numSegments){let done=!1,res;for(inSize<=PARALLELIZE_THRESHOLD?(res=inSize,done=!0):res=nearestDivisor(inSize,Math.floor(Math.sqrt(inSize)));!done;)res>numSegments||res===inSize?done=!0:res=nearestDivisor(inSize,res+1);return res}function computeOutShape3(aShape,axis,numSegments){let outShape=[],rank=aShape.length;for(let dim=0;dim<rank;dim++)dim!==axis?outShape.push(aShape[dim]):outShape.push(numSegments);return outShape}function collectGatherOpShapeInfo(x,indices,axis){let dimSize=x.shape[axis],outputShape=[],batchSize=1,sliceSize=1;for(let i=0;i<axis;i++)outputShape.push(x.shape[i]),batchSize*=x.shape[i];for(let i=0;i<indices.rank;i++)outputShape.push(indices.shape[i]);for(let i=axis+1;i<x.rank;i++)outputShape.push(x.shape[i]),sliceSize*=x.shape[i];return{batchSize,sliceSize,dimSize,outputShape}}function gather_(x,indices,axis=0){let $x=convertToTensor(x,"x","gather"),$indices=convertToTensor(indices,"indices","gather","int32"),inputs={x:$x,indices:$indices},attrs={axis},forward=(backend3,save)=>{let parsedAxis=parseAxisParam(axis,$x.shape)[0],shapeInfo=collectGatherOpShapeInfo($x,$indices,parsedAxis),res=backend3.gather($x,reshape($indices,[$indices.size]),parsedAxis);return save([$x,$indices]),reshape(res,shapeInfo.outputShape)};return ENGINE.runKernelFunc(forward,inputs,null,GatherV2,attrs)}var gather=op({gather_});function greater_(a,b){let $a=convertToTensor(a,"a","greater"),$b=convertToTensor(b,"b","greater");[$a,$b]=makeTypesMatch($a,$b),assertAndGetBroadcastShape($a.shape,$b.shape);let forward=backend3=>backend3.greater($a,$b),inputs={a:$a,b:$b};return ENGINE.runKernelFunc(forward,inputs,null,Greater)}var greater=op({greater_});function greaterEqual_(a,b){let $a=convertToTensor(a,"a","greaterEqual"),$b=convertToTensor(b,"b","greaterEqual");[$a,$b]=makeTypesMatch($a,$b),assertAndGetBroadcastShape($a.shape,$b.shape);let forward=(backend3,save)=>{let res=backend3.greaterEqual($a,$b);return save([$a,$b]),res},inputs={a:$a,b:$b};return ENGINE.runKernelFunc(forward,inputs,null,GreaterEqual)}var greaterEqual=op({greaterEqual_});function imag_(input2){let $input=convertToTensor(input2,"input","imag"),forward=backend3=>backend3.imag($input),inputs={input:$input};return ENGINE.runKernelFunc(forward,inputs,null,Imag)}var imag=op({imag_});function isFinite_(x){let $x=convertToTensor(x,"x","isFinite"),inputs={x:$x};return ENGINE.runKernelFunc(backend3=>backend3.isFinite($x),inputs,null,IsFinite)}var isFinite2=op({isFinite_});function isInf_(x){let $x=convertToTensor(x,"x","isInf"),inputs={x:$x};return ENGINE.runKernelFunc(backend3=>backend3.isInf($x),inputs,null,IsInf)}var isInf=op({isInf_});function isNaN_(x){let $x=convertToTensor(x,"x","isNaN"),inputs={x:$x};return ENGINE.runKernelFunc(backend3=>backend3.isNaN($x),inputs,null,IsNan)}var isNaN2=op({isNaN_});function maximum_(a,b){let $a=convertToTensor(a,"a","maximum"),$b=convertToTensor(b,"b","maximum");[$a,$b]=makeTypesMatch($a,$b),$a.dtype==="bool"&&($a=cast($a,"int32"),$b=cast($b,"int32")),assertAndGetBroadcastShape($a.shape,$b.shape);let forward=(backend3,save)=>{let res=backend3.maximum($a,$b);return save([$a,$b]),res},inputs={a:$a,b:$b};return ENGINE.runKernelFunc(forward,inputs,null,Maximum)}var maximum=op({maximum_});function scalar(value,dtype){if((isTypedArray(value)&&dtype!=="string"||Array.isArray(value))&&dtype!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(dtype==="string"&&isTypedArray(value)&&!(value instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");let shape=[],inferredShape=[];return makeTensor(value,shape,inferredShape,dtype)}function leakyRelu_(x,alpha=.2){let $x=convertToTensor(x,"x","leakyRelu");return maximum(mul(scalar(alpha),$x),$x)}var leakyRelu=op({leakyRelu_});function less_(a,b){let $a=convertToTensor(a,"a","less"),$b=convertToTensor(b,"b","less");[$a,$b]=makeTypesMatch($a,$b),assertAndGetBroadcastShape($a.shape,$b.shape);let forward=backend3=>backend3.less($a,$b),inputs={a:$a,b:$b};return ENGINE.runKernelFunc(forward,inputs,null,Less)}var less=op({less_});function lessEqual_(a,b){let $a=convertToTensor(a,"a","lessEqual"),$b=convertToTensor(b,"b","lessEqual");[$a,$b]=makeTypesMatch($a,$b),assertAndGetBroadcastShape($a.shape,$b.shape);let forward=(backend3,save)=>{let res=backend3.lessEqual($a,$b);return save([$a,$b]),res},inputs={a:$a,b:$b};return ENGINE.runKernelFunc(forward,inputs,null,LessEqual)}var lessEqual=op({lessEqual_});function localResponseNormalization_(x,depthRadius=5,bias=1,alpha=1,beta=.5){let $x=convertToTensor(x,"x","localResponseNormalization");assert($x.rank===4||$x.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${$x.rank}.`),assert(isInt(depthRadius),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${depthRadius}.`);let x4D=$x,reshapedTo4D=!1;$x.rank===3&&(reshapedTo4D=!0,x4D=reshape($x,[1,$x.shape[0],$x.shape[1],$x.shape[2]]));let forward=(backend3,save)=>{let y=backend3.localResponseNormalization4D(x4D,depthRadius,bias,alpha,beta);return save([x4D,y]),y},inputs={x:x4D},attrs={depthRadius,bias,alpha,beta},res=ENGINE.runKernelFunc(forward,inputs,null,LRN,attrs);return reshapedTo4D?reshape(res,[res.shape[1],res.shape[2],res.shape[3]]):res}var localResponseNormalization=op({localResponseNormalization_});function log_(x){let $x=convertToTensor(x,"x","log"),inputs={x:$x};return ENGINE.runKernelFunc((backend3,save)=>{let res=backend3.log($x);return save([$x]),res},inputs,null,Log)}var log=op({log_});function log1p_(x){let $x=convertToTensor(x,"x","log1p"),inputs={x:$x};return ENGINE.runKernelFunc((backend3,save)=>{let res=backend3.log1p($x);return save([$x]),res},inputs,null,Log1p)}var log1p=op({log1p_});function variableGrads(f,varList){assert(isFunction(f),()=>"The f passed in variableGrads(f) must be a function"),assert(varList==null||Array.isArray(varList)&&varList.every(v=>v instanceof Variable),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let specifiedVarList=varList!=null;if(!specifiedVarList){varList=[];for(let varName in ENGINE.registeredVariables)varList.push(ENGINE.registeredVariables[varName])}let specifiedNonTrainable=specifiedVarList?varList.filter(variable3=>!variable3.trainable):null,originalVarCount=varList.length;varList=varList.filter(variable3=>variable3.trainable),assert(varList.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${originalVarCount} variables is trainable.`);let allowNoGradients=!0,{value,grads}=ENGINE.gradients(f,varList,null,allowNoGradients);assert(grads.some(g=>g!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),assert(value.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${value.rank} tensor`);let namedGrads={};return varList.forEach((v,i)=>{grads[i]!=null&&(namedGrads[v.name]=grads[i])}),specifiedNonTrainable!=null&&specifiedNonTrainable.forEach(v=>namedGrads[v.name]=null),{value,grads:namedGrads}}function customGrad(f){return ENGINE.customGrad(f)}function neg_(x){let $x=convertToTensor(x,"x","neg"),inputs={x:$x};return ENGINE.runKernelFunc(backend3=>backend3.neg($x),inputs,null,Negate)}var neg=op({neg_});function softplus_(x){let $x=convertToTensor(x,"x","softplus"),inputs={x:$x};return ENGINE.runKernelFunc((backend3,save)=>{let res=backend3.softplus($x);return save([$x]),res},inputs,null,Softplus)}var softplus=op({softplus_});function logSigmoid_(x){let $x=convertToTensor(x,"x","logSigmoid"),customOp=customGrad(x2=>{let value=neg(softplus(neg(x2))),gradFunc=dy=>{let derX=mul(dy,sigmoid(neg(x2)));return derX};return{value,gradFunc}});return customOp($x)}var logSigmoid=op({logSigmoid_});function max_(x,axis=null,keepDims=!1){let $x=convertToTensor(x,"x","max"),forward=(backend3,save)=>{let origAxes=parseAxisParam(axis,$x.shape),axes=origAxes,permutedAxes=getAxesPermutation(axes,$x.rank),maxInput=$x;permutedAxes!=null&&(maxInput=transpose($x,permutedAxes),axes=getInnerMostAxes(axes.length,maxInput.rank));let y=backend3.max(maxInput,axes);permutedAxes!=null&&maxInput.dispose();let res=y;if(keepDims){let expandedShape=expandShapeToKeepDim(res.shape,parseAxisParam(axis,$x.shape));res=reshape(res,expandedShape),y.dispose()}return save([$x,res]),res},inputs={x:$x},attrs={reductionIndices:axis,keepDims};return ENGINE.runKernelFunc(forward,inputs,null,Max,attrs)}var max=op({max_});function sub_(a,b){let $a=convertToTensor(a,"a","sub"),$b=convertToTensor(b,"b","sub");[$a,$b]=makeTypesMatch($a,$b);let forward=(backend3,save)=>{let res=backend3.subtract($a,$b);return save([$a,$b]),res},inputs={a:$a,b:$b};return ENGINE.runKernelFunc(forward,inputs,null,Sub)}var sub=op({sub_});function sum_(x,axis=null,keepDims=!1){let $x=convertToTensor(x,"x","sum");$x.dtype==="bool"&&($x=cast($x,"int32"));let forward=(backend3,save)=>{save([$x]);let axes=parseAxisParam(axis,$x.shape),permutation=getAxesPermutation(axes,$x.rank),reductionAxes=axes,permutedX=$x;permutation!=null&&(permutedX=transpose($x,permutation),reductionAxes=getInnerMostAxes(reductionAxes.length,$x.rank));let value=backend3.sum(permutedX,reductionAxes);if(keepDims){let newShape=expandShapeToKeepDim(value.shape,axes);value=reshape(value,newShape)}return value},inputs={x:$x},attrs={axis,keepDims};return ENGINE.runKernelFunc(forward,inputs,null,Sum,attrs)}var sum2=op({sum_});function logSoftmax_(logits,axis=-1){let $logits=convertToTensor(logits,"logits","logSoftmax");if(axis===-1&&(axis=$logits.rank-1),axis!==$logits.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${$logits.rank} and axis was ${axis}`);let forward=(backend3,save)=>{let keepDims=!0,xMax=max(logits,axis,!0),shifted=sub(logits,xMax),value=sub(cast(shifted,"float32"),log(sum2(exp(shifted),axis,keepDims)));return save([value]),value},inputs={logits:$logits},attrs={axis};return ENGINE.runKernelFunc(forward,inputs,null,LogSoftmax,attrs)}var logSoftmax=op({logSoftmax_});function logSumExp_(x,axis=null,keepDims=!1){let $x=convertToTensor(x,"x","logSumExp"),axes=parseAxisParam(axis,$x.shape),xMax=max($x,axes,!0),a=sub($x,xMax),b=exp(a),c=sum2(b,axes),d=log(c),res=add2(reshape(xMax,d.shape),d);if(keepDims){let newShape=expandShapeToKeepDim(res.shape,axes);return reshape(res,newShape)}return res}var logSumExp=op({logSumExp_});function logicalAnd_(a,b){let $a=convertToTensor(a,"a","logicalAnd","bool"),$b=convertToTensor(b,"b","logicalAnd","bool");assertAndGetBroadcastShape($a.shape,$b.shape);let inputs={a:$a,b:$b};return ENGINE.runKernelFunc(backend3=>backend3.logicalAnd($a,$b),inputs,null,LogicalAnd)}var logicalAnd=op({logicalAnd_});function logicalNot_(x){let $x=convertToTensor(x,"x","logicalNot","bool"),inputs={x:$x};return ENGINE.runKernelFunc(backend3=>backend3.logicalNot($x),inputs,null,LogicalNot)}var logicalNot=op({logicalNot_});function logicalOr_(a,b){let $a=convertToTensor(a,"a","logicalOr","bool"),$b=convertToTensor(b,"b","logicalOr","bool");assertAndGetBroadcastShape($a.shape,$b.shape);let inputs={a:$a,b:$b};return ENGINE.runKernelFunc(backend3=>backend3.logicalOr($a,$b),inputs,null,LogicalOr)}var logicalOr=op({logicalOr_});function logicalXor_(a,b){let $a=convertToTensor(a,"a","logicalXor","bool"),$b=convertToTensor(b,"b","logicalXor","bool");return assertAndGetBroadcastShape($a.shape,$b.shape),logicalAnd(logicalOr(a,b),logicalNot(logicalAnd(a,b)))}var logicalXor=op({logicalXor_});function maxPool_(x,filterSize,strides,pad6,dimRoundingMode){let $x=convertToTensor(x,"x","maxPool"),dilations=1,x4D=$x,reshapedTo4D=!1;$x.rank===3&&(reshapedTo4D=!0,x4D=reshape($x,[1,$x.shape[0],$x.shape[1],$x.shape[2]])),assert(x4D.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${x4D.rank}.`),assert(eitherStridesOrDilationsAreOne(strides,dilations),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`),dimRoundingMode!=null&&assert(isInt(pad6),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad6}.`);let forward=(backend3,save)=>{let convInfo=computePool2DInfo(x4D.shape,filterSize,strides,1,pad6,dimRoundingMode),y;return convInfo.filterWidth===1&&convInfo.filterHeight===1&&arraysEqual(convInfo.inShape,convInfo.outShape)?y=x4D.clone():y=backend3.maxPool(x4D,convInfo),save([x4D,y]),y},inputs={x:x4D},attrs={filterSize,strides,pad:pad6,dimRoundingMode},res=ENGINE.runKernelFunc(forward,inputs,null,MaxPool,attrs);return reshapedTo4D?reshape(res,[res.shape[1],res.shape[2],res.shape[3]]):res}var maxPool=op({maxPool_});function maxPool3d_(x,filterSize=[1,1,1],strides,pad6,dimRoundingMode,dataFormat="NDHWC",dilations){dilations==null?dilations=[1,1,1]:deprecationWarn("dilations is deprecated, this field will be gone in v3.0.0.");let $x=convertToTensor(x,"x","maxPool3d"),x5D=$x,reshapedTo5D=!1;$x.rank===4&&(reshapedTo5D=!0,x5D=reshape($x,[1,$x.shape[0],$x.shape[1],$x.shape[2],$x.shape[3]])),assert(x5D.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${x5D.rank}.`),assert(dataFormat==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${dataFormat}`),assert(eitherStridesOrDilationsAreOne(strides,dilations),()=>`Error in maxPool3d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`),dimRoundingMode!=null&&assert(isInt(pad6),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad6}.`);let forward=(backend3,save)=>{dilations==null&&(dilations=[1,1,1]);let convInfo=computePool3DInfo(x5D.shape,filterSize,strides,dilations,pad6,dimRoundingMode,dataFormat),y=backend3.maxPool3d(x5D,convInfo);return save([x5D,y]),y},inputs={x:x5D},attrs={filterSize,strides,pad:pad6,dimRoundingMode,dataFormat,dilations},res=ENGINE.runKernelFunc(forward,inputs,null,MaxPool3D,attrs);return reshapedTo5D?reshape(res,[res.shape[1],res.shape[2],res.shape[3],res.shape[4]]):res}var maxPool3d=op({maxPool3d_});function zeros(shape,dtype="float32"){if(dtype==="complex64"){let real8=zeros(shape,"float32"),imag8=zeros(shape,"float32");return complex(real8,imag8)}let values=makeZerosTypedArray(sizeFromShape(shape),dtype);return ENGINE.makeTensor(values,shape,dtype)}function ones2(shape,dtype="float32"){if(dtype==="complex64"){let real8=ones2(shape,"float32"),imag8=zeros(shape,"float32");return complex(real8,imag8)}let values=makeOnesTypedArray(sizeFromShape(shape),dtype);return ENGINE.makeTensor(values,shape,dtype)}function mean_(x,axis=null,keepDims=!1){let $x=convertToTensor(x,"x","mean"),axes=parseAxisParam(axis,$x.shape),shapes=computeOutAndReduceShapes($x.shape,axes),reduceShape=shapes[1],reduceSize=sizeFromShape(reduceShape),inputs={x:$x},attrs={axis,keepDims},forward=()=>{let reduceSizeScalar=scalar(reduceSize),xReduce=reduceSizeScalar.dtype===$x.dtype?$x:cast($x,reduceSizeScalar.dtype),res=div(xReduce,reduceSizeScalar);return sum2(res,axis,keepDims)},customOp=customGrad(x2=>{let value=ENGINE.runKernelFunc(forward,inputs,null,Mean,attrs),gradFunc=dy=>{let expandedDyShape=x2.shape.slice();axes.forEach(axis2=>{expandedDyShape[axis2]=1});let expandedDy=reshape(dy,expandedDyShape),derX=div(mul(expandedDy,ones2(x2.shape,"float32")),reduceSize);return derX};return{value,gradFunc}});return customOp($x)}var mean=op({mean_});function min_(x,axis=null,keepDims=!1){let $x=convertToTensor(x,"x","min"),forward=(backend3,save)=>{let origAxes=parseAxisParam(axis,$x.shape),axes=origAxes,permutedAxes=getAxesPermutation(axes,$x.rank),minInput=$x;permutedAxes!=null&&(minInput=transpose($x,permutedAxes),axes=getInnerMostAxes(axes.length,$x.rank));let y=backend3.min(minInput,axes);permutedAxes!=null&&minInput.dispose();let res=y;if(keepDims){let expandedShape=expandShapeToKeepDim(res.shape,origAxes);res=reshape(y,expandedShape),y.dispose()}return save([$x,res]),res},inputs={x:$x},attrs={axis,keepDims};return ENGINE.runKernelFunc(forward,inputs,null,Min,attrs)}var min=op({min_});function minimum_(a,b){let $a=convertToTensor(a,"a","minimum"),$b=convertToTensor(b,"b","minimum");[$a,$b]=makeTypesMatch($a,$b),$a.dtype==="bool"&&($a=cast($a,"int32"),$b=cast($b,"int32")),assertAndGetBroadcastShape($a.shape,$b.shape);let forward=(backend3,save)=>{let res=backend3.minimum($a,$b);return save([$a,$b]),res},inputs={a:$a,b:$b};return ENGINE.runKernelFunc(forward,inputs,null,Minimum)}var minimum=op({minimum_});function mirrorPad_(x,paddings,mode){assert(mode==="reflect"||mode==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${mode}.`);let $x=convertToTensor(x,"x","mirrorPad");if($x.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");assert(paddings.length===$x.rank,()=>`Padding doesn't match input. Must be ${$x.rank}. Got ${paddings.length}.`);let shapeOffset=mode==="reflect"?1:0;for(let i=0;i<$x.rank;i++)assert(paddings[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),assert(paddings[i][0]>=0&&paddings[i][0]<=$x.shape[i]-shapeOffset&&paddings[i][1]>=0&&paddings[i][1]<=$x.shape[i]-shapeOffset,()=>`Padding in dimension ${i} cannot be greater than or equal to ${$x.shape[i]-shapeOffset} or less than 0 for input of shape ${$x.shape}`);let attrs={paddings,mode},inputs={x:$x};return ENGINE.runKernel(MirrorPad,inputs,attrs)}var mirrorPad=op({mirrorPad_});function mod_(a,b){let $a=convertToTensor(a,"a","mod"),$b=convertToTensor(b,"b","mod");[$a,$b]=makeTypesMatch($a,$b);let forward=(backend3,save)=>{let res=backend3.mod($a,$b);return save([$a,$b]),res},inputs={a:$a,b:$b};return ENGINE.runKernelFunc(forward,inputs,null,Mod)}var mod=op({mod_});function square_(x){let $x=convertToTensor(x,"x","square"),attrs={},inputsToSave=[$x],outputsToSave=[];return ENGINE.runKernelFunc((backend3,save)=>(save([$x]),backend3.square($x)),{x:$x},null,"Square",attrs,inputsToSave,outputsToSave)}var square=op({square_});function moments_(x,axis=null,keepDims=!1){x=convertToTensor(x,"x","moments");let axes=parseAxisParam(axis,x.shape),xMean=mean(x,axes,keepDims),keepDimsShape=xMean.shape;keepDims||(keepDimsShape=expandShapeToKeepDim(xMean.shape,axes));let devSquared=square(sub(cast(x,"float32"),reshape(xMean,keepDimsShape))),variance=mean(devSquared,axes,keepDims);return{mean:xMean,variance}}var moments=op({moments_});function notEqual_(a,b){let $a=convertToTensor(a,"a","notEqual"),$b=convertToTensor(b,"b","notEqual");[$a,$b]=makeTypesMatch($a,$b),assertAndGetBroadcastShape($a.shape,$b.shape);let forward=backend3=>backend3.notEqual($a,$b),inputs={a:$a,b:$b};return ENGINE.runKernelFunc(forward,inputs,null,NotEqual)}var notEqual=op({notEqual_});function real_(input2){let $input=convertToTensor(input2,"input","real"),forward=backend3=>backend3.real($input),inputs={input:$input};return ENGINE.runKernelFunc(forward,inputs,null,Real)}var real=op({real_});function onesLike_(x){let $x=convertToTensor(x,"x","onesLike"),forward=(backend3,save)=>{if($x.dtype==="complex64"){let r=onesLike(real($x)),i=zerosLike(imag($x));return complex(r,i)}return backend3.onesLike($x)},inputs={x:$x};return ENGINE.runKernelFunc(forward,inputs,null,OnesLike)}var onesLike=op({onesLike_});function pad_(x,paddings,constantValue=0){let $x=convertToTensor(x,"x","pad");if($x.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let forward=(backend3,save)=>(save([$x]),backend3.pad($x,paddings,constantValue)),attrs={paddings,constantValue},inputs={x:$x};return ENGINE.runKernelFunc(forward,inputs,null,PadV2,attrs)}var pad=op({pad_});function spaceToBatchND_(x,blockShape,paddings){let $x=convertToTensor(x,"x","spaceToBatchND");assert($x.rank>=1+blockShape.length,()=>`input rank ${$x.rank} should be > than [blockShape] ${blockShape.length}`),assert(paddings.length===blockShape.length,()=>`paddings.shape[0] ${paddings.length} must be equal to [blockShape] ${blockShape.length}`),assert($x.shape.reduce((a,b,i)=>i>0&&i<=blockShape.length?a&&(b+paddings[i-1][0]+paddings[i-1][1])%blockShape[i-1]===0:a,!0),()=>`input spatial dimensions ${$x.shape.slice(1)} with paddings ${paddings.toString()} must be divisible by blockShapes ${blockShape.toString()}`);let forward=backend3=>backend3.spaceToBatchND($x,blockShape,paddings),inputs={x:$x},attrs={blockShape,paddings};return ENGINE.runKernelFunc(forward,inputs,null,SpaceToBatchND,attrs)}var spaceToBatchND=op({spaceToBatchND_});function pool_(input2,windowShape,poolingType,pad6,dilations,strides){dilations==null&&(dilations=[1,1]),strides==null&&(strides=1),pad6===0&&(pad6="valid");let $x=convertToTensor(input2,"x","maxPool"),x4D=$x,reshapedTo4D=!1;$x.rank===3&&(reshapedTo4D=!0,x4D=reshape($x,[1,$x.shape[0],$x.shape[1],$x.shape[2]])),assert(eitherStridesOrDilationsAreOne(strides,dilations),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);let convInfo=computePool2DInfo(x4D.shape,windowShape,strides,dilations,pad6),dilation=[convInfo.dilationHeight,convInfo.dilationWidth],basePadding;pad6==="same"?basePadding=withSpaceToBatchBasePaddings([convInfo.filterHeight,convInfo.filterWidth],dilation):basePadding=[[0,0],[0,0]];let isDilationOne=dilation[0]===1&&dilation[1]===1,[adjustedPadding,adjustedCrops]=requiredSpaceToBatchPaddings([convInfo.inHeight,convInfo.inWidth],dilation,basePadding),convertedPad=isDilationOne?pad6:"valid",convertedX=isDilationOne?x4D:spaceToBatchND(x4D,dilation,adjustedPadding),forwardOp=poolingType==="avg"?()=>avgPool(convertedX,windowShape,strides,convertedPad):()=>maxPool(convertedX,windowShape,strides,convertedPad),y=forwardOp(),res=isDilationOne?y:batchToSpaceND(y,dilation,adjustedCrops);return reshapedTo4D?reshape(res,[res.shape[1],res.shape[2],res.shape[3]]):res}function requiredSpaceToBatchPaddings(inputShape,blockShape,basePadding){let padStart=basePadding.map(b=>b[0]),origPadEnd=basePadding.map(b=>b[1]),fullInputShape=inputShape.concat(padStart,origPadEnd),padEndExtra=blockShape.map((b,i)=>(b-fullInputShape[i]%b)%b),padEnd=origPadEnd.map((s,i)=>s+padEndExtra[i]),paddings=blockShape.map((_,i)=>[padStart[i],padEnd[i]]),crops=blockShape.map((_,i)=>[0,padEndExtra[i]]);return[paddings,crops]}function withSpaceToBatchBasePaddings(filterShape,dilation){let dilatedFilterShape=filterShape.map((s,i)=>s+(s-1)*(dilation[i]-1)),padExtraShape=dilatedFilterShape.map(s=>s-1),padExtraStart=padExtraShape.map(s=>Math.floor(s/2)),padExtraEnd=padExtraShape.map((s,i)=>s-padExtraStart[i]);return padExtraShape.map((_,i)=>[padExtraStart[i],padExtraEnd[i]])}var pool=op({pool_});function pow_(base2,exp13){let $base=convertToTensor(base2,"base","pow"),$exp=convertToTensor(exp13,"exp","pow");[$base,$exp]=makeTypesMatch($base,$exp);let inputs={a:$base,b:$exp},forward=(backend3,save)=>{let y=backend3.pow($base,$exp);return save([$base,$exp,y]),y};return ENGINE.runKernelFunc(forward,inputs,null,Pow)}var pow=op({pow_});function prelu_(x,alpha){let $x=convertToTensor(x,"x","prelu"),$alpha=convertToTensor(alpha,"alpha","prelu"),forward=(backend3,save)=>{let res=backend3.prelu($x,$alpha);return save([$x,$alpha]),res},inputs={x:$x,alpha:$alpha};return ENGINE.runKernelFunc(forward,inputs,null,Prelu)}var prelu=op({prelu_});function prod_(x,axis=null,keepDims=!1){let $x=convertToTensor(x,"x","prod");$x.dtype==="bool"&&($x=cast($x,"int32"));let forward=backend3=>{let axes=parseAxisParam(axis,$x.shape),permutation=getAxesPermutation(axes,$x.rank),reductionAxes=axes,permutedX=$x;permutation!=null&&(permutedX=transpose($x,permutation),reductionAxes=getInnerMostAxes(reductionAxes.length,$x.rank));let value=backend3.prod(permutedX,reductionAxes);if(keepDims){let newShape=expandShapeToKeepDim(value.shape,axes);value=reshape(value,newShape)}return value},inputs={x:$x},attrs={axis,keepDims};return ENGINE.runKernelFunc(forward,inputs,null,Prod,attrs)}var prod=op({prod_});var seedrandom=__toModule(require_seedrandom2());var MPRandGauss=class{constructor(mean7,stdDeviation,dtype,truncated,seed){this.mean=mean7,this.stdDev=stdDeviation,this.dtype=dtype,this.nextVal=NaN,this.truncated=truncated,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let seedValue=seed||Math.random();this.random=seedrandom.alea(seedValue.toString())}nextValue(){if(!isNaN(this.nextVal)){let value=this.nextVal;return this.nextVal=NaN,value}let resultX,resultY,isValid=!1;for(;!isValid;){let v1,v2,s;do v1=2*this.random()-1,v2=2*this.random()-1,s=v1*v1+v2*v2;while(s>=1||s===0);let mul62=Math.sqrt(-2*Math.log(s)/s);resultX=this.mean+this.stdDev*v1*mul62,resultY=this.mean+this.stdDev*v2*mul62,(!this.truncated||this.isValidTruncated(resultX))&&(isValid=!0)}return(!this.truncated||this.isValidTruncated(resultY))&&(this.nextVal=this.convertValue(resultY)),this.convertValue(resultX)}convertValue(value){return this.dtype==null||this.dtype==="float32"?value:Math.round(value)}isValidTruncated(value){return value<=this.upper&&value>=this.lower}},UniformRandom=class{constructor(min7=0,max9=1,dtype,seed){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=min7,this.range=max9-min7,this.dtype=dtype,seed==null&&(seed=Math.random()),typeof seed=="number"&&(seed=seed.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${min7} - ${max9} <= 1 and dtype is not float`);this.random=seedrandom.alea(seed)}convertValue(value){return this.canReturnFloat()?value:Math.round(value)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function randomNormal_(shape,mean7=0,stdDev=1,dtype,seed){if(dtype!=null&&dtype==="bool")throw new Error(`Unsupported data type ${dtype}`);let randGauss=new MPRandGauss(mean7,stdDev,dtype,!1,seed),res=buffer(shape,dtype);for(let i=0;i<res.values.length;i++)res.values[i]=randGauss.nextValue();return res.toTensor()}var randomNormal=op({randomNormal_});function randomUniform_(shape,minval=0,maxval=1,dtype="float32",seed){let res=buffer(shape,dtype),random=new UniformRandom(minval,maxval,null,seed);for(let i=0;i<res.values.length;i++)res.values[i]=random.nextValue();return res.toTensor()}var randomUniform=op({randomUniform_});function tensor1d(values,dtype){assertNonNull(values);let inferredShape=inferShape(values,dtype);if(inferredShape.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");let shape=null;return makeTensor(values,shape,inferredShape,dtype)}function range(start,stop,step9=1,dtype="float32"){if(step9===0)throw new Error("Cannot have a step of zero");let forward=()=>{let sameStartStop=start===stop,increasingRangeNegativeStep=start<stop&&step9<0,decreasingRangePositiveStep=stop<start&&step9>1;if(sameStartStop||increasingRangeNegativeStep||decreasingRangePositiveStep)return zeros([0],dtype);let numElements=Math.abs(Math.ceil((stop-start)/step9)),values=makeZerosTypedArray(numElements,dtype);stop<start&&step9===1&&(step9=-1),values[0]=start;for(let i=1;i<values.length;i++)values[i]=values[i-1]+step9;return tensor1d(values,dtype)},attrs={start,stop,step:step9,dtype};return ENGINE.runKernelFunc(forward,{},null,Range,attrs)}function reciprocal_(x){let $x=convertToTensor(x,"x","reciprocal"),inputs={x:$x};return ENGINE.runKernelFunc((backend3,save)=>{let res=backend3.reciprocal($x);return save([$x]),res},inputs,null,Reciprocal)}var reciprocal=op({reciprocal_});function relu_(x){let $x=convertToTensor(x,"x","relu"),forward=(backend3,save)=>(save([$x]),$x.dtype==="bool"?cast($x,"int32"):backend3.relu($x)),inputs={x:$x};return ENGINE.runKernelFunc(forward,inputs,null,Relu)}var relu=op({relu_});function relu6_(x){let $x=convertToTensor(x,"x","relu6"),forward=(backend3,save)=>(save([$x]),$x.dtype==="bool"?cast($x,"int32"):backend3.relu6($x)),inputs={x:$x};return ENGINE.runKernelFunc(forward,inputs,null,Relu6)}var relu6=op({relu6_});function reverse_(x,axis){let $x=convertToTensor(x,"x","reverse"),forward=backend3=>{let axes=parseAxisParam(axis,$x.shape);if($x.rank===0)return clone($x);let res=backend3.reverse($x,axes);return reshape(res,$x.shape)},inputs={x:$x},attrs={dims:axis};return ENGINE.runKernelFunc(forward,inputs,null,Reverse,attrs)}var reverse=op({reverse_});function round_(x){let $x=convertToTensor(x,"x","round"),inputs={x:$x};return ENGINE.runKernelFunc(backend3=>backend3.round($x),inputs,null,Round)}var round=op({round_});function rsqrt_(x){let $x=convertToTensor(x,"x","rsqrt"),inputs={x:$x};return ENGINE.runKernelFunc((backend3,save)=>{let res=backend3.rsqrt($x);return save([$x]),res},inputs,null,Rsqrt)}var rsqrt=op({rsqrt_});function selu_(x){let $x=convertToTensor(x,"x","selu"),forward=(backend3,save)=>{let res=backend3.selu($x);return save([$x]),res},inputs={x:$x};return ENGINE.runKernelFunc(forward,inputs,null,Selu)}var selu=op({selu_});function separableConv2d_(x,depthwiseFilter,pointwiseFilter,strides,pad6,dilation=[1,1],dataFormat="NHWC"){let $x=convertToTensor(x,"x","separableConv2d"),$depthwiseFilter=convertToTensor(depthwiseFilter,"depthwiseFilter","separableConv2d"),$pointwiseFilter=convertToTensor(pointwiseFilter,"pointwiseFilter","separableConv2d"),x4D=$x,reshapedTo4D=!1;if($x.rank===3&&(reshapedTo4D=!0,x4D=reshape($x,[1,$x.shape[0],$x.shape[1],$x.shape[2]])),dataFormat==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");assert(x4D.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${x4D.rank}.`),assert($depthwiseFilter.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${$depthwiseFilter.rank}.`),assert($pointwiseFilter.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${$depthwiseFilter.rank}.`),assert($pointwiseFilter.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${$pointwiseFilter.shape[0]}.`),assert($pointwiseFilter.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${$pointwiseFilter.shape[1]}.`);let inChannels=$depthwiseFilter.shape[2],channelMultiplier=$depthwiseFilter.shape[3];assert($pointwiseFilter.shape[2]===inChannels*channelMultiplier,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${inChannels*channelMultiplier}, but got ${$pointwiseFilter.shape[2]}.`);let depthwise=depthwiseConv2d(x4D,$depthwiseFilter,strides,pad6,dataFormat,dilation),pointwiseStride=1,res=conv2d(depthwise,$pointwiseFilter,pointwiseStride,"valid",dataFormat);return reshapedTo4D?reshape(res,[res.shape[1],res.shape[2],res.shape[3]]):res}var separableConv2d=op({separableConv2d_});function sign_(x){let $x=convertToTensor(x,"x","sign"),inputs={x:$x};return ENGINE.runKernelFunc(backend3=>backend3.sign($x),inputs,null,Sign)}var sign=op({sign_});function sin_(x){let $x=convertToTensor(x,"x","sin"),inputs={x:$x};return ENGINE.runKernelFunc((backend3,save)=>{let res=backend3.sin($x);return save([$x]),res},inputs,null,Sin)}var sin=op({sin_});function sinh_(x){let $x=convertToTensor(x,"x","sinh"),inputs={x:$x};return ENGINE.runKernelFunc((backend3,save)=>{let res=backend3.sinh($x);return save([$x]),res},inputs,null,Sinh)}var sinh=op({sinh_});function slice1d_(x,begin,size){let $x=convertToTensor(x,"x","slice1d");return assert($x.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${$x.rank} tensor`),slice($x,[begin],[size])}var slice1d=op({slice1d_});function slice2d_(x,begin,size){let $x=convertToTensor(x,"x","slice2d");return assert($x.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${$x.rank} tensor`),slice($x,begin,size)}var slice2d=op({slice2d_});function slice3d_(x,begin,size){let $x=convertToTensor(x,"x","slice3d");return assert($x.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${$x.rank} tensor`),slice($x,begin,size)}var slice3d=op({slice3d_});function slice4d_(x,begin,size){let $x=convertToTensor(x,"x","slice4d");return assert($x.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${$x.rank} tensor`),slice($x,begin,size)}var slice4d=op({slice4d_});function softmax_(logits,dim=-1){let $logits=convertToTensor(logits,"logits","softmax","float32");if(dim===-1&&(dim=$logits.rank-1),dim!==$logits.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${$logits.rank} and dim was ${dim}`);let inputs={logits:$logits},attrs={dim};return ENGINE.runKernelFunc((backend3,save)=>{let y=backend3.softmax($logits,dim);return save([y]),y},inputs,null,Softmax,attrs)}var softmax=op({softmax_});function fft_(input2){assert(input2.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${input2.dtype}.`);let inputs={input:input2};return ENGINE.runKernelFunc(backend3=>{let innerDimensionSize=input2.shape[input2.shape.length-1],batch=input2.size/innerDimensionSize,input2D=input2.as2D(batch,innerDimensionSize),result=backend3.fft(input2D);return result.reshape(input2.shape)},inputs,null,FFT)}var fft=op({fft_});function ifft_(input2){assert(input2.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${input2.dtype}.`);let inputs={input:input2};return ENGINE.runKernelFunc(backend3=>{let innerDimensionSize=input2.shape[input2.shape.length-1],batch=input2.size/innerDimensionSize,input2D=reshape(input2,[batch,innerDimensionSize]),result=backend3.ifft(input2D);return reshape(result,input2.shape)},inputs,null,IFFT)}var ifft=op({ifft_});function irfft_(input2){let innerDimensionSize=input2.shape[input2.shape.length-1],batch=input2.size/innerDimensionSize,ret;if(innerDimensionSize<=2){let complexInput=reshape(input2,[batch,innerDimensionSize]);ret=ifft(complexInput)}else{let outputShape=[batch,2*(innerDimensionSize-1)],realInput=reshape(real(input2),[batch,innerDimensionSize]),imagInput=reshape(imag(input2),[batch,innerDimensionSize]),realConjugate=reverse(slice(realInput,[0,1],[batch,innerDimensionSize-2]),1),imagConjugate=mul(reverse(slice(imagInput,[0,1],[batch,innerDimensionSize-2]),1),scalar(-1)),r=concat([realInput,realConjugate],1),i=concat([imagInput,imagConjugate],1),complexInput=reshape(complex(r,i),[outputShape[0],outputShape[1]]);ret=ifft(complexInput)}if(ret=real(ret),input2.rank===3&&input2.shape[0]!==0){let temp=ret,batch2=input2.shape[0];ret=reshape(ret,[batch2,ret.shape[0]/batch2,ret.shape[1]]),temp.dispose()}return ret}var irfft=op({irfft_});function prepareSplitSize(x,numOrSizeSplits,axis=0){let splitSizes=[];if(typeof numOrSizeSplits=="number")assert(x.shape[axis]%numOrSizeSplits===0,()=>"Number of splits must evenly divide the axis."),splitSizes=new Array(numOrSizeSplits).fill(x.shape[axis]/numOrSizeSplits);else{let numOfNegs=numOrSizeSplits.reduce((count2,value)=>(value===-1&&(count2+=1),count2),0);assert(numOfNegs<=1,()=>"There should be only one negative value in split array.");let negIndex=numOrSizeSplits.indexOf(-1);if(negIndex!==-1){let total=numOrSizeSplits.reduce((a,b)=>b>0?a+b:a);numOrSizeSplits[negIndex]=x.shape[axis]-total}assert(x.shape[axis]===numOrSizeSplits.reduce((a,b)=>a+b),()=>"The sum of sizes must match the size of the axis dimension."),splitSizes=numOrSizeSplits}return splitSizes}function split_(x,numOrSizeSplits,axis=0){let $x=convertToTensor(x,"x","split"),forward=(backend3,_)=>{let $axis=parseAxisParam(axis,$x.shape)[0],splitSizes=prepareSplitSize($x,numOrSizeSplits,$axis);return backend3.split($x,splitSizes,$axis)},inputs={x:$x},attr={numOrSizeSplits,axis};return ENGINE.runKernelFunc(forward,inputs,null,SplitV,attr)}var split=op({split_});function rfft_(input2,fftLength){assert(input2.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${input2.dtype}`);let innerDimensionSize=input2.shape[input2.shape.length-1],batch=input2.size/innerDimensionSize,adjustedInput;if(fftLength!=null&&fftLength<innerDimensionSize){let begin=input2.shape.map(v=>0),size=input2.shape.map(v=>v);size[input2.shape.length-1]=fftLength,adjustedInput=slice(input2,begin,size),innerDimensionSize=fftLength}else if(fftLength!=null&&fftLength>innerDimensionSize){let zerosShape=input2.shape.map(v=>v);zerosShape[input2.shape.length-1]=fftLength-innerDimensionSize,adjustedInput=concat([input2,zeros(zerosShape)],input2.shape.length-1),innerDimensionSize=fftLength}else adjustedInput=input2;let zerosInput=zerosLike(adjustedInput),complexInput=reshape(complex(adjustedInput,zerosInput),[batch,innerDimensionSize]),ret=fft(complexInput),half=Math.floor(innerDimensionSize/2)+1,realValues=real(ret),imagValues=imag(ret),realComplexConjugate=split(realValues,[half,innerDimensionSize-half],realValues.shape.length-1),imagComplexConjugate=split(imagValues,[half,innerDimensionSize-half],imagValues.shape.length-1),outputShape=adjustedInput.shape.slice();return outputShape[adjustedInput.shape.length-1]=half,reshape(complex(realComplexConjugate[0],imagComplexConjugate[0]),outputShape)}var rfft=op({rfft_});function sqrt_(x){let $x=convertToTensor(x,"x","sqrt"),inputs={x:$x};return ENGINE.runKernelFunc((backend3,save)=>{let res=backend3.sqrt($x);return save([$x]),res},inputs,null,Sqrt)}var sqrt=op({sqrt_});function squaredDifference_(a,b){let $a=convertToTensor(a,"a","squaredDifference"),$b=convertToTensor(b,"b","squaredDifference");[$a,$b]=makeTypesMatch($a,$b),assertAndGetBroadcastShape($a.shape,$b.shape);let forward=(backend3,save)=>{let res=backend3.squaredDifference($a,$b);return save([$a,$b]),res},inputs={a:$a,b:$b},attrs={};return ENGINE.runKernelFunc(forward,inputs,null,SquaredDifference,attrs)}var squaredDifference=op({squaredDifference_});function squeeze_(x,axis){let $x=convertToTensor(x,"x","squeeze");return reshape($x,squeezeShape($x.shape,axis).newShape)}var squeeze=op({squeeze_});function stack_(tensors,axis=0){let $tensors=convertToTensorArray(tensors,"tensors","stack");if(assert($tensors.length>=1,()=>"Pass at least one tensor to tf.stack"),$tensors.length===1)return expandDims($tensors[0],axis);let rank=$tensors[0].rank,shape=$tensors[0].shape,dtype=$tensors[0].dtype;assert(axis<=rank,()=>"Axis must be <= rank of the tensor"),$tensors.forEach(t=>{assertShapesMatch(shape,t.shape,"All tensors passed to stack must have matching shapes"),assert(dtype===t.dtype,()=>"All tensors passed to stack must have matching dtypes")});let expandedTensors=$tensors.map(t=>expandDims(t,axis));return concat(expandedTensors,axis)}var stack=op({stack_});function step_(x,alpha=0){let $x=convertToTensor(x,"x","step"),inputs={x:$x},attrs={alpha};return ENGINE.runKernelFunc(backend3=>backend3.step($x,alpha),inputs,null,Step,attrs)}var step=op({step_});function stridedSlice_(x,begin,end,strides,beginMask=0,endMask=0,ellipsisMask=0,newAxisMask=0,shrinkAxisMask=0){let $x=convertToTensor(x,"x","stridedSlice"),forward=backend3=>{strides==null&&(strides=new Array(begin.length));let ellipsisAxes=maskToAxes(ellipsisMask);if(ellipsisAxes.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(ellipsisMask!==0&&newAxisMask!==0)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(ellipsisMask!==0&&shrinkAxisMask!==0)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");let numInterpolatedAxes=$x.rank-begin.length,expandAxes=maskToAxes(newAxisMask),newShape=$x.shape.slice();expandAxes.forEach(axis=>{begin[axis]=0,end[axis]=1,newShape.splice(axis,0,1)}),$x=reshape($x,newShape);let{begin:normalizedBegin,end:normalizedEnd,strides:normalizedStrides}=getNormalizedAxes($x.shape,ellipsisAxes,numInterpolatedAxes,begin,end,strides,beginMask,endMask,ellipsisMask);begin=normalizedBegin,end=normalizedEnd,strides=normalizedStrides;let shrinkAxes=maskToAxes(shrinkAxisMask);shrinkAxes.forEach(axis=>{end[axis]=begin[axis]+1,strides[axis]=1});let size=computeOutShape(begin,end,strides),outShape=size.filter((_,axis)=>shrinkAxes.indexOf(axis)===-1),nonStrided=strides.every(v=>v===1);if(nonStrided)return reshape(slice($x,begin,size),outShape);let res=backend3.stridedSlice($x,begin,end,strides);return reshape(res,outShape)},inputs={x:$x},attrs={begin,end,strides,beginMask,endMask,ellipsisMask,newAxisMask,shrinkAxisMask};return ENGINE.runKernelFunc(forward,inputs,null,StridedSlice,attrs)}var stridedSlice=op({stridedSlice_});function tan_(x){let $x=convertToTensor(x,"x","tan"),inputs={x:$x};return ENGINE.runKernelFunc((backend3,save)=>{let res=backend3.tan($x);return save([$x]),res},inputs,null,Tan)}var tan=op({tan_});function tensor2d(values,shape,dtype){if(assertNonNull(values),shape!=null&&shape.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let inferredShape=inferShape(values,dtype);if(inferredShape.length!==2&&inferredShape.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(inferredShape.length===1&&shape==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return makeTensor(values,shape,inferredShape,dtype)}function tensor4d(values,shape,dtype){if(assertNonNull(values),shape!=null&&shape.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let inferredShape=inferShape(values,dtype);if(inferredShape.length!==4&&inferredShape.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(inferredShape.length===1&&shape==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return makeTensor(values,shape,inferredShape,dtype)}function topk_(x,k=1,sorted=!0){let $x=convertToTensor(x,"x","topk");if($x.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let lastDim=$x.shape[$x.shape.length-1];if(k>lastDim)throw new Error(`'k' passed to topk() must be <= the last dimension (${lastDim}) but got ${k}`);let inputs={x:$x},attrs={k,sorted},[values,indices]=ENGINE.runKernelFunc(b=>b.topk($x,k,sorted),inputs,null,TopK,attrs);return{values,indices}}var topk=op({topk_});function truncatedNormal_(shape,mean7=0,stdDev=1,dtype,seed){if(dtype!=null&&dtype==="bool")throw new Error("Unsupported data type $ { dtype }");let randGauss=new MPRandGauss(mean7,stdDev,dtype,!0,seed),res=buffer(shape,dtype);for(let i=0;i<res.values.length;i++)res.values[i]=randGauss.nextValue();return res.toTensor()}var truncatedNormal=op({truncatedNormal_});function unique_(x,axis=0){let $x=convertToTensor(x,"x","unique",null);assert($x.rank>0,()=>"The input tensor must be at least 1D");let inputs={x:$x},attrs={axis},[values,indices]=ENGINE.runKernel(Unique,inputs,attrs);return{values,indices}}var unique=op({unique_});function unsortedSegmentSum_(x,segmentIds,numSegments){let $x=convertToTensor(x,"x","unsortedSegmentSum"),$segmentIds=convertToTensor(segmentIds,"segmentIds","unsortedSegmentSum","int32");assert(isInt(numSegments),()=>"numSegments must be of dtype int");let inputs={x:$x,segmentIds:$segmentIds},attrs={numSegments},forward=(backend3,save)=>{let res=backend3.unsortedSegmentSum($x,$segmentIds,numSegments);return save([$segmentIds]),res};return ENGINE.runKernelFunc(forward,inputs,null,UnsortedSegmentSum,attrs)}var unsortedSegmentSum=op({unsortedSegmentSum_});function unstack_(x,axis=0){let $x=convertToTensor(x,"x","unstack");assert(axis>=-$x.shape.length&&axis<$x.shape.length,()=>`Axis = ${axis} is not in [-${$x.shape.length}, ${$x.shape.length})`),axis<0&&(axis+=$x.shape.length);let inputs={value:$x},attrs={axis},forward=backend3=>backend3.unstack($x,axis);return ENGINE.runKernelFunc(forward,inputs,null,Unpack,attrs)}var unstack=op({unstack_});function variable(initialValue,trainable=!0,name,dtype){return ENGINE.makeVariable(initialValue,trainable,name,dtype)}function whereImpl(condShape,condVals){let indices=[];for(let i=0;i<condVals.length;i++)condVals[i]&&indices.push(i);let inBuffer=buffer(condShape,"int32"),out=buffer([indices.length,condShape.length],"int32");for(let i=0;i<indices.length;i++){let loc=inBuffer.indexToLoc(indices[i]),offset=i*condShape.length;out.values.set(loc,offset)}return out.toTensor()}function notEqualStrict_(a,b){deprecationWarn("strict variants of ops have been deprecated and will be removed in future");let $a=convertToTensor(a,"a","notEqualStrict"),$b=convertToTensor(b,"b","notEqualStrict");return assertShapesMatch($a.shape,$b.shape,"Error in notEqualStrict: "),notEqual($a,$b)}function lessStrict_(a,b){deprecationWarn("strict variants of ops have been deprecated and will be removed in future");let $a=convertToTensor(a,"a","lessStrict"),$b=convertToTensor(b,"b","lessStrict");return assertShapesMatch($a.shape,$b.shape,"Error in lessStrict: "),less($a,$b)}function equalStrict_(a,b){deprecationWarn("strict variants of ops have been deprecated and will be removed in future");let $a=convertToTensor(a,"a","equalStrict"),$b=convertToTensor(b,"b","equalStrict");return assertShapesMatch($a.shape,$b.shape,"Error in equalStrict: "),equal($a,$b)}function lessEqualStrict_(a,b){deprecationWarn("strict variants of ops have been deprecated and will be removed in future");let $a=convertToTensor(a,"a","lessEqualStrict"),$b=convertToTensor(b,"b","lessEqualStrict");return assertShapesMatch($a.shape,$b.shape,"Error in lessEqualStrict: "),lessEqual($a,$b)}function greaterStrict_(a,b){deprecationWarn("strict variants of ops have been deprecated and will be removed in future");let $a=convertToTensor(a,"a","greaterStrict"),$b=convertToTensor(b,"b","greaterStrict");return assertShapesMatch($a.shape,$b.shape,"Error in greaterStrict: "),greater($a,$b)}function greaterEqualStrict_(a,b){deprecationWarn("strict variants of ops have been deprecated and will be removed in future");let $a=convertToTensor(a,"a","greaterEqualStrict"),$b=convertToTensor(b,"b","greaterEqualStrict");return assertShapesMatch($a.shape,$b.shape,"Error in greaterEqualStrict: "),greaterEqual($a,$b)}var equalStrict=op({equalStrict_}),greaterEqualStrict=op({greaterEqualStrict_}),greaterStrict=op({greaterStrict_}),lessEqualStrict=op({lessEqualStrict_}),lessStrict=op({lessStrict_}),notEqualStrict=op({notEqualStrict_});function addStrict_(a,b){deprecationWarn("strict variants of ops have been deprecated and will be removed in future");let $a=convertToTensor(a,"a","addStrict"),$b=convertToTensor(b,"b","addStrict");return assertShapesMatch($a.shape,$b.shape,"Error in addStrict: "),add2($a,$b)}function subStrict_(a,b){deprecationWarn("strict variants of ops have been deprecated and will be removed in future");let $a=convertToTensor(a,"a","subStrict"),$b=convertToTensor(b,"b","subStrict");return assertShapesMatch($a.shape,$b.shape,"Error in subStrict: "),sub($a,$b)}function powStrict_(base2,exp13){return deprecationWarn("strict variants of ops have been deprecated and will be removed in future"),assertShapesMatch(base2.shape,exp13.shape,"Error in powStrict: "),pow(base2,exp13)}function mulStrict_(a,b){deprecationWarn("strict variants of ops have been deprecated and will be removed in future");let $a=convertToTensor(a,"a","mul"),$b=convertToTensor(b,"b","mul");return assertShapesMatch($a.shape,$b.shape,"Error in multiplyStrict: "),mul($a,$b)}function divStrict_(a,b){deprecationWarn("strict variants of ops have been deprecated and will be removed in future");let $a=convertToTensor(a,"a","div"),$b=convertToTensor(b,"b","div");return assertShapesMatch($a.shape,$b.shape,"Error in divideStrict: "),div($a,$b)}function modStrict_(a,b){deprecationWarn("strict variants of ops have been deprecated and will be removed in future");let $a=convertToTensor(a,"a","modStrict"),$b=convertToTensor(b,"b","modStrict");return assertShapesMatch($a.shape,$b.shape,"Error in modStrict: "),mod($a,$b)}function minimumStrict_(a,b){deprecationWarn("strict variants of ops have been deprecated and will be removed in future");let $a=convertToTensor(a,"a","minimumStrict"),$b=convertToTensor(b,"b","minimumStrict");return assertShapesMatch($a.shape,$b.shape,"Error in minimumStrict: "),minimum($a,$b)}function maximumStrict_(a,b){deprecationWarn("strict variants of ops have been deprecated and will be removed in future");let $a=convertToTensor(a,"a","maximumStrict"),$b=convertToTensor(b,"b","maximumStrict");return assertShapesMatch($a.shape,$b.shape,"Error in maximumStrict: "),maximum($a,$b)}function squaredDifferenceStrict_(a,b){deprecationWarn("strict variants of ops have been deprecated and will be removed in future");let $a=convertToTensor(a,"a","squaredDifferenceStrict"),$b=convertToTensor(b,"b","squaredDifferenceStrict");return assertShapesMatch($a.shape,$b.shape,"Error in squaredDifferenceStrict: "),squaredDifference($a,$b)}var addStrict=op({addStrict_}),divStrict=op({divStrict_}),maximumStrict=op({maximumStrict_}),minimumStrict=op({minimumStrict_}),modStrict=op({modStrict_}),mulStrict=op({mulStrict_}),powStrict=op({powStrict_}),squaredDifferenceStrict=op({squaredDifferenceStrict_}),subStrict=op({subStrict_});function norm_(x,ord="euclidean",axis=null,keepDims=!1){x=convertToTensor(x,"x","norm");let norm5=normImpl(x,ord,axis),keepDimsShape=norm5.shape;if(keepDims){let axes=parseAxisParam(axis,x.shape);keepDimsShape=expandShapeToKeepDim(norm5.shape,axes)}return reshape(norm5,keepDimsShape)}function normImpl(x,p2,axis=null){if(x.rank===0)return abs(x);if(x.rank!==1&&axis===null)return normImpl(reshape(x,[-1]),p2,axis);if(x.rank===1||typeof axis=="number"||Array.isArray(axis)&&axis.length===1){if(p2===1)return sum2(abs(x),axis);if(p2===Infinity)return max(abs(x),axis);if(p2===-Infinity)return min(abs(x),axis);if(p2==="euclidean"||p2===2)return sqrt(sum2(pow(abs(x),scalar(2,"int32")),axis));throw new Error(`Error in norm: invalid ord value: ${p2}`)}if(Array.isArray(axis)&&axis.length===2){if(p2===1)return max(sum2(abs(x),axis[0]),axis[1]-1);if(p2===Infinity)return max(sum2(abs(x),axis[1]),axis[0]);if(p2===-Infinity)return min(sum2(abs(x),axis[1]),axis[0]);if(p2==="fro"||p2==="euclidean")return sqrt(sum2(square(x),axis));throw new Error(`Error in norm: invalid ord value: ${p2}`)}throw new Error(`Error in norm: invalid axis: ${axis}`)}var norm=op({norm_});function getNoiseShape(x,noiseShape){if(noiseShape==null)return x.shape.slice();if(arraysEqual(x.shape,noiseShape))return noiseShape;if(x.shape.length===noiseShape.length){let newDimension=[];for(let i=0;i<x.shape.length;i++)noiseShape[i]==null&&x.shape[i]!=null?newDimension.push(x.shape[i]):newDimension.push(noiseShape[i]);return newDimension}return noiseShape}function dropout_(x,rate,noiseShape,seed){let $x=convertToTensor(x,"x","dropout");if(assert($x.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${$x.dtype} tensor instead.`),assert(rate>=0&&rate<1,()=>`rate must be a float in the range [0, 1), but got ${rate}.`),rate===0)return x instanceof Tensor?$x.clone():$x;let $noiseShape=getNoiseShape($x,noiseShape),keepProb=1-rate,multiplier=div(floor(add2(randomUniform($noiseShape,0,1,"float32",seed),keepProb)),keepProb);return mul($x,multiplier)}var dropout=op({dropout_});function enclosingPowerOfTwo(value){return Math.floor(Math.pow(2,Math.ceil(Math.log(value)/Math.log(2))))}function cosineWindow(windowLength,a,b){let even=1-windowLength%2,newValues=new Float32Array(windowLength);for(let i=0;i<windowLength;++i){let cosArg=2*Math.PI*i/(windowLength+even-1);newValues[i]=a-b*Math.cos(cosArg)}return tensor1d(newValues,"float32")}var fused_ops_exports={};__export(fused_ops_exports,{conv2d:()=>conv2d5,depthwiseConv2d:()=>depthwiseConv2d2,matMul:()=>matMul2});function conv2DBackpropFilter_(x,dy,filterShape,strides,pad6,dataFormat="NHWC",dimRoundingMode){let x4D=x;x.rank===3&&(x4D=reshape(x,[1,x.shape[0],x.shape[1],x.shape[2]]));let dy4D=dy;dy4D.rank===3&&(dy4D=reshape(dy,[1,dy.shape[0],dy.shape[1],dy.shape[2]])),assert(x4D.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${x4D.shape}.`),assert(dy4D.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${dy4D.shape}.`),assert(filterShape.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${filterShape}.`);let inDepth=dataFormat==="NHWC"?x4D.shape[3]:x4D.shape[1],outDepth=dataFormat==="NHWC"?dy4D.shape[3]:dy4D.shape[1];assert(inDepth===filterShape[2],()=>`Error in conv2dDerFilter: depth of input ${inDepth}) must match input depth in filter (${filterShape[2]}.`),assert(outDepth===filterShape[3],()=>`Error in conv2dDerFilter: depth of dy (${outDepth}) must match output depth for filter (${filterShape[3]}).`),dimRoundingMode!=null&&assert(isInt(pad6),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad6}.`);let forward=backend3=>{let dilations=1,$dataFormat=convertConv2DDataFormat(dataFormat),convInfo=computeConv2DInfo(x4D.shape,filterShape,strides,dilations,pad6,dimRoundingMode,!1,$dataFormat);return backend3.conv2dDerFilter(x4D,dy4D,convInfo)},inputs={x:x4D,dy:dy4D},attrs={strides,pad:pad6,dataFormat,dimRoundingMode,filterShape};return ENGINE.runKernelFunc(forward,inputs,null,Conv2DBackpropFilter,attrs)}var conv2DBackpropFilter=op({conv2DBackpropFilter_});function getFusedDyActivation(dy,y,activation){if(activation==null||activation==="linear")return dy;if(activation==="relu")return mul(dy,step(y));throw new Error(`Cannot compute gradient for fused activation ${activation}.`)}function getFusedBiasGradient(bias,dyActivation){let res=dyActivation,reduceAxes=getReductionAxes(bias.shape,dyActivation.shape);return reduceAxes.length>0&&(res=sum2(res,reduceAxes)),reshape(res,bias.shape)}function applyActivation(x,activation,preluActivationWeights){if(activation==="linear")return x;if(activation==="relu")return relu(x);if(activation==="elu")return elu(x);if(activation==="relu6")return relu6(x);if(activation==="prelu")return prelu(x,preluActivationWeights);throw new Error(`Unknown fused activation ${activation}.`)}var shouldFuse=(gradientDepth,activation)=>{let gradientMode=gradientDepth>0;return!gradientMode||activation==="linear"};function fusedConv2d_({x,filter,strides,pad:pad6,dataFormat="NHWC",dilations=[1,1],dimRoundingMode,bias,activation="linear",preluActivationWeights}){if(activation=activation||"linear",shouldFuse(ENGINE.state.gradientDepth,activation)===!1){let result=conv2d(x,filter,strides,pad6,dataFormat,dilations,dimRoundingMode);return bias!=null&&(result=add2(result,bias)),applyActivation(result,activation,preluActivationWeights)}let $x=convertToTensor(x,"x","conv2d"),$filter=convertToTensor(filter,"filter","conv2d"),x4D=$x,reshapedTo4D=!1;$x.rank===3&&(reshapedTo4D=!0,x4D=reshape($x,[1,$x.shape[0],$x.shape[1],$x.shape[2]])),assert(x4D.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${x4D.rank}.`),assert($filter.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${$filter.rank}.`),dimRoundingMode!=null&&assert(isInt(pad6),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad6}.`),assert(x4D.shape[3]===$filter.shape[2],()=>`Error in conv2d: depth of input (${x4D.shape[3]}) must match input depth for filter ${$filter.shape[2]}.`),assert(eitherStridesOrDilationsAreOne(strides,dilations),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`),assert(dataFormat==="NHWC",()=>`Error in conv2d: got dataFormat of ${dataFormat} but only NHWC is currently supported.`);let convInfo=computeConv2DInfo(x4D.shape,$filter.shape,strides,dilations,pad6,dimRoundingMode),$bias;bias!=null&&($bias=convertToTensor(bias,"bias","fused conv2d"),[$bias]=makeTypesMatch($bias,$x),assertAndGetBroadcastShape(convInfo.outShape,$bias.shape));let $preluActivationWeights;preluActivationWeights!=null&&($preluActivationWeights=convertToTensor(preluActivationWeights,"prelu weights","fused conv2d"));let grad=(dy,saved)=>{let[$filter2,x4D2,y,$bias2]=saved,dyActivation=getFusedDyActivation(dy,y,activation);assert(tupleValuesAreOne(dilations),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${dilations}'`);let xDer=conv2DBackpropInput(x4D2.shape,dyActivation,$filter2,strides,pad6),filterDer=conv2DBackpropFilter(x4D2,dyActivation,$filter2.shape,strides,pad6),der=[xDer,filterDer];if($bias2!=null){let biasDer=getFusedBiasGradient($bias2,dyActivation);der.push(biasDer)}return der},forward=backend3=>{let res=backend3.fusedConv2d({input:x4D,filter:$filter,convInfo,bias:$bias,activation,preluActivationWeights:$preluActivationWeights});return res},inputs={x:x4D,filter:$filter,bias:$bias,preluActivationWeights:$preluActivationWeights},attrs={strides,pad:pad6,dataFormat,dilations,dimRoundingMode,activation};if(bias==null){let customOp=customGrad((x4D2,filter2,save)=>{let res=ENGINE.runKernelFunc(forward,inputs,null,FusedConv2D,attrs);return save([filter2,x4D2,res]),reshapedTo4D&&(res=reshape(res,[res.shape[1],res.shape[2],res.shape[3]])),{value:res,gradFunc:grad}});return customOp(x4D,$filter)}else{let customOpWithBias=customGrad((x4D2,filter2,bias2,save)=>{let res=ENGINE.runKernelFunc(forward,inputs,null,FusedConv2D,attrs);return save([filter2,x4D2,res,bias2]),reshapedTo4D&&(res=reshape(res,[res.shape[1],res.shape[2],res.shape[3]])),{value:res,gradFunc:grad}});return customOpWithBias(x4D,$filter,$bias)}}var conv2d5=op({fusedConv2d_});function depthwiseConv2dNativeBackpropFilter_(x,dy,filterShape,strides,pad6,dilations=[1,1],dimRoundingMode){let x4D=x;x.rank===3&&(x4D=reshape(x,[1,x.shape[0],x.shape[1],x.shape[2]]));let dy4D=dy;dy4D.rank===3&&(dy4D=reshape(dy,[1,dy.shape[0],dy.shape[1],dy.shape[2]]));let forward=backend3=>{let convInfo=computeConv2DInfo(x.shape,filterShape,strides,dilations,pad6,dimRoundingMode,!0);return backend3.depthwiseConv2DDerFilter(x4D,dy4D,convInfo)},inputs={x:x4D,dy:dy4D},attrs={strides,pad:pad6,dimRoundingMode,dilations,filterShape};return ENGINE.runKernelFunc(forward,inputs,null,DepthwiseConv2dNativeBackpropFilter,attrs)}var depthwiseConv2dNativeBackpropFilter=op({depthwiseConv2dNativeBackpropFilter_});function depthwiseConv2dNativeBackpropInput_(xShape,dy,filter,strides,pad6,dilations=[1,1],dimRoundingMode){let dy4D=dy,reshapedTo4D=!1;dy.rank===3&&(reshapedTo4D=!0,dy4D=reshape(dy,[1,dy.shape[0],dy.shape[1],dy.shape[2]]));let forward=backend3=>{let convInfo=computeConv2DInfo(xShape,filter.shape,strides,dilations,pad6,dimRoundingMode,!0);return backend3.depthwiseConv2DDerInput(dy4D,filter,convInfo)},inputs={dy:dy4D,filter},attrs={strides,pad:pad6,dimRoundingMode,dilations,inputShape:xShape},res=ENGINE.runKernelFunc(forward,inputs,null,DepthwiseConv2dNativeBackpropInput,attrs);return reshapedTo4D?reshape(res,[res.shape[1],res.shape[2],res.shape[3]]):res}var depthwiseConv2dNativeBackpropInput=op({depthwiseConv2dNativeBackpropInput_});function fusedDepthwiseConv2d_({x,filter,strides,pad:pad6,dataFormat="NHWC",dilations=[1,1],dimRoundingMode,bias,activation="linear",preluActivationWeights}){if(shouldFuse(ENGINE.state.gradientDepth,activation)===!1){let result=depthwiseConv2d(x,filter,strides,pad6,dataFormat,dilations,dimRoundingMode);return bias!=null&&(result=add2(result,bias)),applyActivation(result,activation,preluActivationWeights)}let $x=convertToTensor(x,"x","depthwiseConv2d"),$filter=convertToTensor(filter,"filter","depthwiseConv2d"),x4D=$x,reshapedTo4D=!1;$x.rank===3&&(reshapedTo4D=!0,x4D=reshape($x,[1,$x.shape[0],$x.shape[1],$x.shape[2]])),assert(x4D.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${x4D.rank}.`),assert($filter.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${$filter.rank}.`),assert(x4D.shape[3]===$filter.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${x4D.shape[3]}) must match the inChannels dimension in filter ${$filter.shape[2]}.`),dilations==null&&(dilations=[1,1]),assert(eitherStridesOrDilationsAreOne(strides,dilations),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`),dimRoundingMode!=null&&assert(isInt(pad6),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${dimRoundingMode} but got pad ${pad6}.`);let convInfo=computeConv2DInfo(x4D.shape,$filter.shape,strides,dilations,pad6,dimRoundingMode,!0),$bias;bias!=null&&($bias=convertToTensor(bias,"bias","fused conv2d"),[$bias]=makeTypesMatch($bias,$x),assertAndGetBroadcastShape(convInfo.outShape,$bias.shape));let $preluActivationWeights;preluActivationWeights!=null&&($preluActivationWeights=convertToTensor(preluActivationWeights,"prelu weights","fused depthwiseConv2d"));let grad=(dy,saved)=>{assert(tupleValuesAreOne(dilations),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${dilations}'`);let[$filter2,x4D2,y,bias2]=saved,dyActivation=getFusedDyActivation(dy,y,activation),xDer=depthwiseConv2dNativeBackpropInput(x4D2.shape,dyActivation,$filter2,strides,pad6,dilations,dimRoundingMode),filterDer=depthwiseConv2dNativeBackpropFilter(x4D2,dyActivation,$filter2.shape,strides,pad6,dilations,dimRoundingMode);if(bias2!=null){let biasDer=getFusedBiasGradient($bias,dyActivation);return[xDer,filterDer,biasDer]}return[xDer,filterDer]},forward=backend3=>{let res=backend3.fusedDepthwiseConv2D({input:x4D,filter:$filter,convInfo,bias:$bias,activation,preluActivationWeights:$preluActivationWeights});return res},inputs={x:x4D,filter:$filter,bias:$bias,preluActivationWeights:$preluActivationWeights},attrs={strides,pad:pad6,dataFormat,dilations,dimRoundingMode,activation};if(bias==null){let customOp=customGrad((x4D2,filter2,save)=>{let res=ENGINE.runKernelFunc(forward,inputs,null,FusedDepthwiseConv2D,attrs);return save([filter2,x4D2,res]),reshapedTo4D&&(res=reshape(res,[res.shape[1],res.shape[2],res.shape[3]])),{value:res,gradFunc:grad}});return customOp(x4D,$filter)}else{let customOpWithBias=customGrad((x4D2,filter2,bias2,save)=>{let res=ENGINE.runKernelFunc(forward,inputs,null,FusedDepthwiseConv2D,attrs);return save([filter2,x4D2,res,bias2]),reshapedTo4D&&(res=reshape(res,[res.shape[1],res.shape[2],res.shape[3]])),{value:res,gradFunc:grad}});return customOpWithBias(x4D,$filter,$bias)}}var depthwiseConv2d2=op({fusedDepthwiseConv2d_});function fusedMatMul_({a,b,transposeA=!1,transposeB=!1,bias,activation="linear",preluActivationWeights}){if(shouldFuse(ENGINE.state.gradientDepth,activation)===!1){let result=matMul(a,b,transposeA,transposeB);return bias!=null&&(result=add2(result,bias)),applyActivation(result,activation,preluActivationWeights)}let $a=convertToTensor(a,"a","fused matMul"),$b=convertToTensor(b,"b","fused matMul");[$a,$b]=makeTypesMatch($a,$b);let innerShapeA=transposeA?$a.shape[$a.rank-2]:$a.shape[$a.rank-1],innerShapeB=transposeB?$b.shape[$b.rank-1]:$b.shape[$b.rank-2],outerShapeA=transposeA?$a.shape[$a.rank-1]:$a.shape[$a.rank-2],outerShapeB=transposeB?$b.shape[$b.rank-2]:$b.shape[$b.rank-1],outerDimsA=$a.shape.slice(0,-2),outerDimsB=$b.shape.slice(0,-2),batchDimA=sizeFromShape(outerDimsA),batchDimB=sizeFromShape(outerDimsB);assert($a.rank>=2&&$b.rank>=2&&$a.rank===$b.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${$a.rank} and ${$b.rank}.`),assert(arraysEqual(outerDimsA,outerDimsB),()=>`Error in fused matMul: outer dimensions (${outerDimsA}) and (${outerDimsB}) of Tensors with shapes ${$a.shape} and ${$b.shape} must match.`),assert(innerShapeA===innerShapeB,()=>`Error in fused matMul: inner shapes (${innerShapeA}) and (${innerShapeB}) of Tensors with shapes ${$a.shape} and ${$b.shape} and transposeA=${transposeA} and transposeB=${transposeB} must match.`);let outShape=$a.shape.slice(0,-2).concat([outerShapeA,outerShapeB]),a3D=transposeA?reshape($a,[batchDimA,innerShapeA,outerShapeA]):reshape($a,[batchDimA,outerShapeA,innerShapeA]),b3D=transposeB?reshape($b,[batchDimB,outerShapeB,innerShapeB]):reshape($b,[batchDimB,innerShapeB,outerShapeB]),$bias;bias!=null&&($bias=convertToTensor(bias,"bias","fused matMul"),[$bias]=makeTypesMatch($bias,$a),assertAndGetBroadcastShape(outShape,$bias.shape));let $preluActivationWeights;preluActivationWeights!=null&&($preluActivationWeights=convertToTensor(preluActivationWeights,"prelu weights","fused matMul"));let grad=(dy,saved)=>{let[a3D2,b3D2,y,$bias2]=saved,dyActivation=getFusedDyActivation(reshape(dy,y.shape),y,activation),aDer,bDer;if(!transposeA&&!transposeB?(aDer=matMul(dyActivation,b3D2,!1,!0),bDer=matMul(a3D2,dyActivation,!0,!1)):!transposeA&&transposeB?(aDer=matMul(dyActivation,b3D2,!1,!1),bDer=matMul(dyActivation,a3D2,!0,!1)):transposeA&&!transposeB?(aDer=matMul(b3D2,dyActivation,!1,!0),bDer=matMul(a3D2,dyActivation,!1,!1)):(aDer=matMul(b3D2,dyActivation,!0,!0),bDer=matMul(dyActivation,a3D2,!0,!0)),bias!=null){let biasDer=getFusedBiasGradient($bias2,dyActivation);return[aDer,bDer,biasDer]}else return[aDer,bDer]},forward=backend3=>{let y=backend3.fusedBatchMatMul({a:a3D,b:b3D,transposeA,transposeB,bias:$bias,activation,preluActivationWeights:$preluActivationWeights});return y},inputs={a:a3D,b:b3D,bias:$bias,preluActivationWeights:$preluActivationWeights},attrs={transposeA,transposeB,activation};if(bias==null){let customOp=customGrad((a3D2,b3D2,save)=>{let res=ENGINE.runKernelFunc(forward,inputs,null,_FusedMatMul,attrs);return save([a3D2,b3D2,res]),{value:reshape(res,outShape),gradFunc:grad}});return customOp(a3D,b3D)}else{let customOpWithBias=customGrad((a3D2,b3D2,$bias2,save)=>{let res=ENGINE.runKernelFunc(forward,inputs,null,_FusedMatMul,attrs);return save([a3D2,b3D2,res,$bias2]),{value:reshape(res,outShape),gradFunc:grad}});return customOpWithBias(a3D,b3D,$bias)}}var matMul2=op({fusedMatMul_});function hammingWindow_(windowLength){return cosineWindow(windowLength,.54,.46)}var hammingWindow=op({hammingWindow_});function hannWindow_(windowLength){return cosineWindow(windowLength,.5,.5)}var hannWindow=op({hannWindow_});function frame_(signal2,frameLength,frameStep,padEnd=!1,padValue=0){let start=0,output=[];for(;start+frameLength<=signal2.size;)output.push(slice(signal2,start,frameLength)),start+=frameStep;if(padEnd)for(;start<signal2.size;){let padLen=start+frameLength-signal2.size,pad6=concat([slice(signal2,start,frameLength-padLen),fill([padLen],padValue)]);output.push(pad6),start+=frameStep}return output.length===0?tensor2d([],[0,frameLength]):reshape(concat(output),[output.length,frameLength])}var frame=op({frame_});function stft_(signal2,frameLength,frameStep,fftLength,windowFn=hannWindow){fftLength==null&&(fftLength=enclosingPowerOfTwo(frameLength));let framedSignal=frame(signal2,frameLength,frameStep),windowedSignal=mul(framedSignal,windowFn(frameLength)),output=[];for(let i=0;i<framedSignal.shape[0];i++)output.push(rfft(slice(windowedSignal,[i,0],[1,frameLength]),fftLength));return concat(output)}var stft=op({stft_});function cropAndResize_(image3,boxes,boxInd,cropSize,method,extrapolationValue){let $image=convertToTensor(image3,"image","cropAndResize"),$boxes=convertToTensor(boxes,"boxes","cropAndResize","float32"),$boxInd=convertToTensor(boxInd,"boxInd","cropAndResize","int32");method=method||"bilinear",extrapolationValue=extrapolationValue||0;let numBoxes=$boxes.shape[0];assert($image.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${$image.rank}.`),assert($boxes.rank===2&&$boxes.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${numBoxes},4] but had shape ${$boxes.shape}.`),assert($boxInd.rank===1&&$boxInd.shape[0]===numBoxes,()=>`Error in cropAndResize: boxInd must be have size [${numBoxes}] but had shape ${$boxes.shape}.`),assert(cropSize.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${cropSize.length}.`),assert(cropSize[0]>=1&&cropSize[1]>=1,()=>`cropSize must be atleast [1,1], but was ${cropSize}`),assert(method==="bilinear"||method==="nearest",()=>`method must be bilinear or nearest, but was ${method}`);let forward=backend3=>backend3.cropAndResize($image,$boxes,$boxInd,cropSize,method,extrapolationValue),inputs={image:$image,boxes:$boxes,boxInd:$boxInd},attrs={method,extrapolationValue,cropSize},res=ENGINE.runKernelFunc(forward,inputs,null,CropAndResize,attrs);return res}var cropAndResize=op({cropAndResize_});function flipLeftRight_(image3){let $image=convertToTensor(image3,"image","flipLeftRight","float32");assert($image.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${$image.rank}.`);let inputs={image:$image},res=ENGINE.runKernel(FlipLeftRight,inputs,{});return res}var flipLeftRight=op({flipLeftRight_});function rotateWithOffset_(image3,radians,fillValue=0,center=.5){let $image=convertToTensor(image3,"image","rotateWithOffset","float32");assert($image.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${$image.rank}.`);let inputs={image:$image},attrs={radians,fillValue,center},res=ENGINE.runKernel(RotateWithOffset,inputs,attrs);return res}var rotateWithOffset=op({rotateWithOffset_});function nonMaxSuppSanityCheck(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma){iouThreshold==null&&(iouThreshold=.5),scoreThreshold==null&&(scoreThreshold=Number.NEGATIVE_INFINITY),softNmsSigma==null&&(softNmsSigma=0);let numBoxes=boxes.shape[0];return maxOutputSize=Math.min(maxOutputSize,numBoxes),assert(0<=iouThreshold&&iouThreshold<=1,()=>`iouThreshold must be in [0, 1], but was '${iouThreshold}'`),assert(boxes.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${boxes.rank}'`),assert(boxes.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${boxes.shape[1]}`),assert(scores.rank===1,()=>"scores must be a 1D tensor"),assert(scores.shape[0]===numBoxes,()=>`scores has incompatible shape with boxes. Expected ${numBoxes}, but was ${scores.shape[0]}`),assert(0<=softNmsSigma&&softNmsSigma<=1,()=>`softNmsSigma must be in [0, 1], but was '${softNmsSigma}'`),{maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma}}function nonMaxSuppression_(boxes,scores,maxOutputSize,iouThreshold=.5,scoreThreshold=Number.NEGATIVE_INFINITY){let $boxes=convertToTensor(boxes,"boxes","nonMaxSuppression"),$scores=convertToTensor(scores,"scores","nonMaxSuppression"),inputs=nonMaxSuppSanityCheck($boxes,$scores,maxOutputSize,iouThreshold,scoreThreshold);maxOutputSize=inputs.maxOutputSize,iouThreshold=inputs.iouThreshold,scoreThreshold=inputs.scoreThreshold;let attrs={maxOutputSize,iouThreshold,scoreThreshold};return ENGINE.runKernelFunc(b=>b.nonMaxSuppression($boxes,$scores,maxOutputSize,iouThreshold,scoreThreshold),{boxes:$boxes,scores:$scores},null,NonMaxSuppressionV3,attrs)}var nonMaxSuppression=op({nonMaxSuppression_});function binaryInsert(arr,element,comparator){let index=binarySearch(arr,element,comparator),insertionPoint=index<0?-(index+1):index;arr.splice(insertionPoint,0,element)}function binarySearch(arr,target,comparator){return binarySearch_(arr,target,comparator||defaultComparator)}function defaultComparator(a,b){return a>b?1:a<b?-1:0}function binarySearch_(arr,target,comparator){let left=0,right=arr.length,middle=0,found=!1;for(;left<right;){middle=left+(right-left>>>1);let compareResult=comparator(target,arr[middle]);compareResult>0?left=middle+1:(right=middle,found=!compareResult)}return found?left:-left-1}function nonMaxSuppressionV3Impl(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold){return nonMaxSuppressionImpl_(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold,0).selectedIndices}function nonMaxSuppressionV4Impl(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold,padToMaxOutputSize){return nonMaxSuppressionImpl_(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold,0,!1,padToMaxOutputSize,!0)}function nonMaxSuppressionV5Impl(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma){return nonMaxSuppressionImpl_(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma,!0)}function nonMaxSuppressionImpl_(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma,returnScoresTensor=!1,padToMaxOutputSize=!1,returnValidOutputs=!1){let candidates=[];for(let i=0;i<scores.length;i++)scores[i]>scoreThreshold&&candidates.push({score:scores[i],boxIndex:i,suppressBeginIndex:0});candidates.sort(ascendingComparator);let scale2=softNmsSigma>0?-.5/softNmsSigma:0,selectedIndices=[],selectedScores=[];for(;selectedIndices.length<maxOutputSize&&candidates.length>0;){let candidate=candidates.pop(),{score:originalScore,boxIndex,suppressBeginIndex}=candidate;if(originalScore<scoreThreshold)break;let ignoreCandidate=!1;for(let j=selectedIndices.length-1;j>=suppressBeginIndex;--j){let iou=intersectionOverUnion(boxes,boxIndex,selectedIndices[j]);if(iou>=iouThreshold){ignoreCandidate=!0;break}if(candidate.score=candidate.score*suppressWeight(iouThreshold,scale2,iou),candidate.score<=scoreThreshold)break}candidate.suppressBeginIndex=selectedIndices.length,ignoreCandidate||(candidate.score===originalScore?(selectedIndices.push(boxIndex),selectedScores.push(candidate.score)):candidate.score>scoreThreshold&&binaryInsert(candidates,candidate,ascendingComparator))}let validOutputs=selectedIndices.length,elemsToPad=maxOutputSize-validOutputs;padToMaxOutputSize&&elemsToPad>0&&(selectedIndices.push(...new Array(elemsToPad).fill(0)),selectedScores.push(...new Array(elemsToPad).fill(0)));let result={selectedIndices:tensor1d(selectedIndices,"int32")};return returnScoresTensor&&(result.selectedScores=tensor1d(selectedScores,"float32")),returnValidOutputs&&(result.validOutputs=scalar(validOutputs,"int32")),result}function intersectionOverUnion(boxes,i,j){let iCoord=boxes.subarray(i*4,i*4+4),jCoord=boxes.subarray(j*4,j*4+4),yminI=Math.min(iCoord[0],iCoord[2]),xminI=Math.min(iCoord[1],iCoord[3]),ymaxI=Math.max(iCoord[0],iCoord[2]),xmaxI=Math.max(iCoord[1],iCoord[3]),yminJ=Math.min(jCoord[0],jCoord[2]),xminJ=Math.min(jCoord[1],jCoord[3]),ymaxJ=Math.max(jCoord[0],jCoord[2]),xmaxJ=Math.max(jCoord[1],jCoord[3]),areaI=(ymaxI-yminI)*(xmaxI-xminI),areaJ=(ymaxJ-yminJ)*(xmaxJ-xminJ);if(areaI<=0||areaJ<=0)return 0;let intersectionYmin=Math.max(yminI,yminJ),intersectionXmin=Math.max(xminI,xminJ),intersectionYmax=Math.min(ymaxI,ymaxJ),intersectionXmax=Math.min(xmaxI,xmaxJ),intersectionArea=Math.max(intersectionYmax-intersectionYmin,0)*Math.max(intersectionXmax-intersectionXmin,0);return intersectionArea/(areaI+areaJ-intersectionArea)}function suppressWeight(iouThreshold,scale2,iou){let weight=Math.exp(scale2*iou*iou);return iou<=iouThreshold?weight:0}function ascendingComparator(c1,c2){return c1.score-c2.score||c1.score===c2.score&&c2.boxIndex-c1.boxIndex}async function nonMaxSuppressionAsync_(boxes,scores,maxOutputSize,iouThreshold=.5,scoreThreshold=Number.NEGATIVE_INFINITY){let $boxes=convertToTensor(boxes,"boxes","nonMaxSuppressionAsync"),$scores=convertToTensor(scores,"scores","nonMaxSuppressionAsync"),inputs=nonMaxSuppSanityCheck($boxes,$scores,maxOutputSize,iouThreshold,scoreThreshold);maxOutputSize=inputs.maxOutputSize,iouThreshold=inputs.iouThreshold,scoreThreshold=inputs.scoreThreshold;let boxesAndScores=await Promise.all([$boxes.data(),$scores.data()]),boxesVals=boxesAndScores[0],scoresVals=boxesAndScores[1],res=nonMaxSuppressionV3Impl(boxesVals,scoresVals,maxOutputSize,iouThreshold,scoreThreshold);return $boxes!==boxes&&$boxes.dispose(),$scores!==scores&&$scores.dispose(),res}var nonMaxSuppressionAsync=nonMaxSuppressionAsync_;function nonMaxSuppressionWithScore_(boxes,scores,maxOutputSize,iouThreshold=.5,scoreThreshold=Number.NEGATIVE_INFINITY,softNmsSigma=0){let $boxes=convertToTensor(boxes,"boxes","nonMaxSuppression"),$scores=convertToTensor(scores,"scores","nonMaxSuppression"),params=nonMaxSuppSanityCheck($boxes,$scores,maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma);maxOutputSize=params.maxOutputSize,iouThreshold=params.iouThreshold,scoreThreshold=params.scoreThreshold,softNmsSigma=params.softNmsSigma;let inputs={boxes:$boxes,scores:$scores},attrs={maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma},result=ENGINE.runKernel(NonMaxSuppressionV5,inputs,attrs);return{selectedIndices:result[0],selectedScores:result[1]}}var nonMaxSuppressionWithScore=op({nonMaxSuppressionWithScore_});async function nonMaxSuppressionWithScoreAsync_(boxes,scores,maxOutputSize,iouThreshold=.5,scoreThreshold=Number.NEGATIVE_INFINITY,softNmsSigma=0){let $boxes=convertToTensor(boxes,"boxes","nonMaxSuppressionAsync"),$scores=convertToTensor(scores,"scores","nonMaxSuppressionAsync"),params=nonMaxSuppSanityCheck($boxes,$scores,maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma);maxOutputSize=params.maxOutputSize,iouThreshold=params.iouThreshold,scoreThreshold=params.scoreThreshold,softNmsSigma=params.softNmsSigma;let boxesAndScores=await Promise.all([$boxes.data(),$scores.data()]),boxesVals=boxesAndScores[0],scoresVals=boxesAndScores[1],res=nonMaxSuppressionV5Impl(boxesVals,scoresVals,maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma);return $boxes!==boxes&&$boxes.dispose(),$scores!==scores&&$scores.dispose(),res}var nonMaxSuppressionWithScoreAsync=nonMaxSuppressionWithScoreAsync_;function nonMaxSuppressionPadded_(boxes,scores,maxOutputSize,iouThreshold=.5,scoreThreshold=Number.NEGATIVE_INFINITY,padToMaxOutputSize=!1){let $boxes=convertToTensor(boxes,"boxes","nonMaxSuppression"),$scores=convertToTensor(scores,"scores","nonMaxSuppression"),params=nonMaxSuppSanityCheck($boxes,$scores,maxOutputSize,iouThreshold,scoreThreshold,null),$maxOutputSize=params.maxOutputSize,$iouThreshold=params.iouThreshold,$scoreThreshold=params.scoreThreshold,inputs={boxes:$boxes,scores:$scores},attrs={maxOutputSize:$maxOutputSize,iouThreshold:$iouThreshold,scoreThreshold:$scoreThreshold,padToMaxOutputSize},result=ENGINE.runKernel(NonMaxSuppressionV4,inputs,attrs);return{selectedIndices:result[0],validOutputs:result[1]}}var nonMaxSuppressionPadded=op({nonMaxSuppressionPadded_});async function nonMaxSuppressionPaddedAsync_(boxes,scores,maxOutputSize,iouThreshold=.5,scoreThreshold=Number.NEGATIVE_INFINITY,padToMaxOutputSize=!1){let $boxes=convertToTensor(boxes,"boxes","nonMaxSuppressionAsync"),$scores=convertToTensor(scores,"scores","nonMaxSuppressionAsync"),params=nonMaxSuppSanityCheck($boxes,$scores,maxOutputSize,iouThreshold,scoreThreshold,null),$maxOutputSize=params.maxOutputSize,$iouThreshold=params.iouThreshold,$scoreThreshold=params.scoreThreshold,[boxesVals,scoresVals]=await Promise.all([$boxes.data(),$scores.data()]),res=nonMaxSuppressionV4Impl(boxesVals,scoresVals,$maxOutputSize,$iouThreshold,$scoreThreshold,padToMaxOutputSize);return $boxes!==boxes&&$boxes.dispose(),$scores!==scores&&$scores.dispose(),res}var nonMaxSuppressionPaddedAsync=nonMaxSuppressionPaddedAsync_;function resizeBilinear_(images,size,alignCorners=!1){let $images=convertToTensor(images,"images","resizeBilinear");assert($images.rank===3||$images.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${$images.rank}.`),assert(size.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${size}.`);let batchImages=$images,reshapedTo4D=!1;$images.rank===3&&(reshapedTo4D=!0,batchImages=reshape($images,[1,$images.shape[0],$images.shape[1],$images.shape[2]]));let[newHeight,newWidth]=size,forward=(backend3,save)=>(save([batchImages]),backend3.resizeBilinear(batchImages,newHeight,newWidth,alignCorners)),inputs={images:batchImages},attrs={alignCorners,size},res=ENGINE.runKernelFunc(forward,inputs,null,ResizeBilinear,attrs);return reshapedTo4D?reshape(res,[res.shape[1],res.shape[2],res.shape[3]]):res}var resizeBilinear=op({resizeBilinear_});function resizeNearestNeighbor_(images,size,alignCorners=!1){let $images=convertToTensor(images,"images","resizeNearestNeighbor");assert($images.rank===3||$images.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${$images.rank}.`),assert(size.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${size}.`),assert($images.dtype==="float32"||$images.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype");let batchImages=$images,reshapedTo4D=!1;$images.rank===3&&(reshapedTo4D=!0,batchImages=reshape($images,[1,$images.shape[0],$images.shape[1],$images.shape[2]]));let[newHeight,newWidth]=size,inputs={images:batchImages},attrs={alignCorners,size},forward=(backend3,save)=>(save([batchImages]),backend3.resizeNearestNeighbor(batchImages,newHeight,newWidth,alignCorners)),res=ENGINE.runKernelFunc(forward,inputs,null,ResizeNearestNeighbor,attrs);return reshapedTo4D?reshape(res,[res.shape[1],res.shape[2],res.shape[3]]):res}var resizeNearestNeighbor=op({resizeNearestNeighbor_});function bandPart_(a,numLower,numUpper){assert(numLower%1===0,()=>`bandPart(): numLower must be an integer, got ${numLower}.`),assert(numUpper%1===0,()=>`bandPart(): numUpper must be an integer, got ${numUpper}.`);let $a=convertToTensor(a,"a","bandPart");assert($a.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${$a.rank}.`);let shape=$a.shape,[M,N]=$a.shape.slice(-2);if(!(numLower<=M))throw new Error(`bandPart(): numLower (${numLower}) must not be greater than the number of rows (${M}).`);if(!(numUpper<=N))throw new Error(`bandPart(): numUpper (${numUpper}) must not be greater than the number of columns (${N}).`);numLower<0&&(numLower=M),numUpper<0&&(numUpper=N);let i=reshape(range(0,M,1,"int32"),[-1,1]),j=range(0,N,1,"int32"),ij=sub(i,j),inBand=logicalAnd(lessEqual(ij,scalar(+numLower,"int32")),greaterEqual(ij,scalar(-numUpper,"int32"))),zero=zeros([M,N],$a.dtype);return reshape(stack(unstack(reshape($a,[-1,M,N])).map(mat=>where(inBand,mat,zero))),shape)}var bandPart=op({bandPart_});function gramSchmidt_(xs){let inputIsTensor2D;if(Array.isArray(xs)){inputIsTensor2D=!1,assert(xs!=null&&xs.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let dim=xs[0].shape[0];for(let i=1;i<xs.length;++i)assert(xs[i].shape[0]===dim,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${xs[i].shape[0]} vs. ${dim})`)}else inputIsTensor2D=!0,xs=split(xs,xs.shape[0],0).map(x=>squeeze(x,[0]));assert(xs.length<=xs[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${xs.length}) exceeds number of dimensions (${xs[0].shape[0]}).`);let ys=[],xs1d=xs;for(let i=0;i<xs.length;++i)ys.push(ENGINE.tidy(()=>{let x=xs1d[i];if(i>0)for(let j=0;j<i;++j){let proj=mul(sum2(mul(ys[j],x)),ys[j]);x=sub(x,proj)}return div(x,norm(x,"euclidean"))}));return inputIsTensor2D?stack(ys,0):ys}var gramSchmidt=op({gramSchmidt_});function qr_(x,fullMatrices=!1){if(assert(x.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${x.rank}`),x.rank===2)return qr2d(x,fullMatrices);{let outerDimsProd=x.shape.slice(0,x.shape.length-2).reduce((value,prev)=>value*prev),x2ds=unstack(reshape(x,[outerDimsProd,x.shape[x.shape.length-2],x.shape[x.shape.length-1]]),0),q2ds=[],r2ds=[];x2ds.forEach(x2d=>{let[q2d,r2d]=qr2d(x2d,fullMatrices);q2ds.push(q2d),r2ds.push(r2d)});let q=reshape(stack(q2ds,0),x.shape),r=reshape(stack(r2ds,0),x.shape);return[q,r]}}function qr2d(x,fullMatrices=!1){return ENGINE.tidy(()=>{assert(x.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${x.shape.length}D Tensor.`);let m=x.shape[0],n=x.shape[1],q=eye(m),r=clone(x),one2D=tensor2d([[1]],[1,1]),w=clone(one2D),iters=m>=n?n:m;for(let j=0;j<iters;++j){let rTemp=r,wTemp=w,qTemp=q;[w,r,q]=ENGINE.tidy(()=>{let rjEnd1=slice(r,[j,j],[m-j,1]),normX=norm(rjEnd1),rjj=slice(r,[j,j],[1,1]),s=where(greater(rjj,0),tensor2d([[-1]]),tensor2d([[1]])),u1=sub(rjj,mul(s,normX)),wPre=div(rjEnd1,u1);wPre.shape[0]===1?w=clone(one2D):w=concat([one2D,slice(wPre,[1,0],[wPre.shape[0]-1,wPre.shape[1]])],0);let tau=neg(div(matMul(s,u1),normX)),rjEndAll=slice(r,[j,0],[m-j,n]),tauTimesW=mul(tau,w),wT=transpose(w);if(j===0)r=sub(rjEndAll,matMul(tauTimesW,matMul(wT,rjEndAll)));else{let rTimesTau=sub(rjEndAll,matMul(tauTimesW,matMul(wT,rjEndAll)));r=concat([slice(r,[0,0],[j,n]),rTimesTau],0)}let tawTimesWT=transpose(tauTimesW),qAllJEnd=slice(q,[0,j],[m,q.shape[1]-j]);if(j===0)q=sub(qAllJEnd,matMul(matMul(qAllJEnd,w),tawTimesWT));else{let qTimesTau=sub(qAllJEnd,matMul(matMul(qAllJEnd,w),tawTimesWT));q=concat([slice(q,[0,0],[m,j]),qTimesTau],1)}return[w,r,q]}),dispose([rTemp,wTemp,qTemp])}return!fullMatrices&&m>n&&(q=slice(q,[0,0],[m,n]),r=slice(r,[0,0],[n,n])),[q,r]})}var qr=op({qr_});var Reduction;(function(Reduction2){Reduction2[Reduction2.NONE=0]="NONE",Reduction2[Reduction2.MEAN=1]="MEAN",Reduction2[Reduction2.SUM=2]="SUM",Reduction2[Reduction2.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Reduction||(Reduction={}));function computeWeightedLoss_(losses8,weights,reduction2=Reduction.SUM_BY_NONZERO_WEIGHTS){let $losses=convertToTensor(losses8,"losses","computeWeightedLoss"),$weights=null;weights!=null&&($weights=convertToTensor(weights,"weights","computeWeightedLoss"));let weightedLoss=$weights==null?$losses:mul($losses,$weights);if(reduction2===Reduction.NONE)return weightedLoss;if(reduction2===Reduction.SUM)return sum2(weightedLoss);if(reduction2===Reduction.MEAN){if($weights==null)return mean(weightedLoss);{let broadcastFactor=$losses.size/$weights.size,result=div(sum2(weightedLoss),sum2($weights));return broadcastFactor>1?div(result,scalar(broadcastFactor)):result}}if(reduction2===Reduction.SUM_BY_NONZERO_WEIGHTS){if($weights==null)return div(sum2(weightedLoss),scalar($losses.size));{let broadcastedWeights=mul($weights,ones2($losses.shape)),numNonZeros=cast(sum2(notEqual(broadcastedWeights,scalar(0))),"float32");return div(sum2(weightedLoss),numNonZeros)}}throw Error(`Unknown reduction: ${reduction2}`)}var computeWeightedLoss=op({computeWeightedLoss_});function absoluteDifference_(labels,predictions,weights,reduction2=Reduction.SUM_BY_NONZERO_WEIGHTS){let $labels=convertToTensor(labels,"labels","absoluteDifference"),$predictions=convertToTensor(predictions,"predictions","absoluteDifference"),$weights=null;weights!=null&&($weights=convertToTensor(weights,"weights","absoluteDifference")),assertShapesMatch($labels.shape,$predictions.shape,"Error in absoluteDifference: ");let losses8=abs(sub($labels,$predictions));return computeWeightedLoss(losses8,$weights,reduction2)}var absoluteDifference=op({absoluteDifference_});function cosineDistance_(labels,predictions,axis,weights,reduction2=Reduction.SUM_BY_NONZERO_WEIGHTS){let $labels=convertToTensor(labels,"labels","cosineDistance"),$predictions=convertToTensor(predictions,"predictions","cosineDistance"),$weights=null;weights!=null&&($weights=convertToTensor(weights,"weights","cosineDistance")),assertShapesMatch($labels.shape,$predictions.shape,"Error in cosineDistance: ");let one=scalar(1),losses8=sub(one,sum2(mul($labels,$predictions),axis,!0));return computeWeightedLoss(losses8,$weights,reduction2)}var cosineDistance=op({cosineDistance_});function hingeLoss_(labels,predictions,weights,reduction2=Reduction.SUM_BY_NONZERO_WEIGHTS){let $labels=convertToTensor(labels,"labels","hingeLoss"),$predictions=convertToTensor(predictions,"predictions","hingeLoss"),$weights=null;weights!=null&&($weights=convertToTensor(weights,"weights","hingeLoss")),assertShapesMatch($labels.shape,$predictions.shape,"Error in hingeLoss: ");let one=scalar(1);$labels=sub(mul(scalar(2),$labels),one);let losses8=relu(sub(one,mul($labels,$predictions)));return computeWeightedLoss(losses8,$weights,reduction2)}var hingeLoss=op({hingeLoss_});function huberLoss_(labels,predictions,weights,delta=1,reduction2=Reduction.SUM_BY_NONZERO_WEIGHTS){let $labels=convertToTensor(labels,"labels","huberLoss"),$predictions=convertToTensor(predictions,"predictions","huberLoss"),$weights=null;weights!=null&&($weights=convertToTensor(weights,"weights","huberLoss")),assertShapesMatch($labels.shape,$predictions.shape,"Error in huberLoss: ");let deltaScalar=scalar(delta),error=abs(sub($predictions,$labels)),quadratic=minimum(error,deltaScalar),linear=sub(error,quadratic),losses8=add2(mul(scalar(.5),square(quadratic)),mul(deltaScalar,linear));return computeWeightedLoss(losses8,$weights,reduction2)}var huberLoss=op({huberLoss_});function logLoss_(labels,predictions,weights,epsilon3=1e-7,reduction2=Reduction.SUM_BY_NONZERO_WEIGHTS){let $labels=convertToTensor(labels,"labels","logLoss"),$predictions=convertToTensor(predictions,"predictions","logLoss"),$weights=null;weights!=null&&($weights=convertToTensor(weights,"weights","logLoss")),assertShapesMatch($labels.shape,$predictions.shape,"Error in logLoss: ");let one=scalar(1),epsilonScalar=scalar(epsilon3),l12=neg(mul($labels,log(add2($predictions,epsilonScalar)))),l22=mul(sub(one,$labels),log(add2(sub(one,$predictions),epsilonScalar))),losses8=sub(l12,l22);return computeWeightedLoss(losses8,$weights,reduction2)}var logLoss=op({logLoss_});function meanSquaredError_(labels,predictions,weights,reduction2=Reduction.SUM_BY_NONZERO_WEIGHTS){let $labels=convertToTensor(labels,"labels","meanSquaredError"),$predictions=convertToTensor(predictions,"predictions","meanSquaredError"),$weights=null;weights!=null&&($weights=convertToTensor(weights,"weights","meanSquaredError")),assertShapesMatch($labels.shape,$predictions.shape,"Error in meanSquaredError: ");let losses8=squaredDifference($labels,$predictions);return computeWeightedLoss(losses8,$weights,reduction2)}var meanSquaredError=op({meanSquaredError_});function sigmoidCrossEntropyWithLogits_(labels,logits){let $labels=convertToTensor(labels,"labels","sigmoidCrossEntropyWithLogits"),$logits=convertToTensor(logits,"logits","sigmoidCrossEntropyWithLogits");assertShapesMatch($labels.shape,$logits.shape,"Error in sigmoidCrossEntropyWithLogits: ");let maxOutput=relu($logits),outputXTarget=mul($logits,$labels),sigmoidOutput=log1p(exp(neg(abs($logits))));return add2(sub(maxOutput,outputXTarget),sigmoidOutput)}function sigmoidCrossEntropy_(multiClassLabels,logits,weights,labelSmoothing=0,reduction2=Reduction.SUM_BY_NONZERO_WEIGHTS){let $multiClassLabels=convertToTensor(multiClassLabels,"multiClassLabels","sigmoidCrossEntropy"),$logits=convertToTensor(logits,"logits","sigmoidCrossEntropy"),$weights=null;if(weights!=null&&($weights=convertToTensor(weights,"weights","sigmoidCrossEntropy")),assertShapesMatch($multiClassLabels.shape,$logits.shape,"Error in sigmoidCrossEntropy: "),labelSmoothing>0){let labelSmoothingScalar=scalar(labelSmoothing),one=scalar(1),half=scalar(.5);$multiClassLabels=add2(mul($multiClassLabels,sub(one,labelSmoothingScalar)),mul(half,labelSmoothingScalar))}let losses8=sigmoidCrossEntropyWithLogits_($multiClassLabels,$logits);return computeWeightedLoss(losses8,$weights,reduction2)}var sigmoidCrossEntropy=op({sigmoidCrossEntropy_});function softmaxCrossEntropyWithLogits_(labels,logits,dim=-1){if(dim===-1&&(dim=logits.rank-1),dim!==logits.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${logits.rank} and dim was ${dim}`);let customOp=customGrad((labels2,logits2,save)=>{let keepDims=!0,lse=logSumExp(logits2,[dim],keepDims),logResult=sub(cast(logits2,"float32"),lse);save([labels2,logResult]);let costVector=neg(mul(logResult,labels2)),value=sum2(costVector,[dim]),gradFunc=(dy,saved)=>{let[labels3,logResult2]=saved,dyShape=expandShapeToKeepDim(dy.shape,[dim]);return[mul(reshape(dy,dyShape),sub(cast(labels3,"float32"),exp(logResult2))),mul(reshape(dy,dyShape),sub(exp(logResult2),cast(labels3,"float32")))]};return{value,gradFunc}});return customOp(labels,logits)}function softmaxCrossEntropy_(onehotLabels,logits,weights,labelSmoothing=0,reduction2=Reduction.SUM_BY_NONZERO_WEIGHTS){let $onehotLabels=convertToTensor(onehotLabels,"onehotLabels","softmaxCrossEntropy"),$logits=convertToTensor(logits,"logits","softmaxCrossEntropy"),$weights=null;if(weights!=null&&($weights=convertToTensor(weights,"weights","softmaxCrossEntropy")),assertShapesMatch($onehotLabels.shape,$logits.shape,"Error in softmaxCrossEntropy: "),labelSmoothing>0){let labelSmoothingScalar=scalar(labelSmoothing),one=scalar(1),numClasses=scalar($onehotLabels.shape[1]);$onehotLabels=add2(mul($onehotLabels,sub(one,labelSmoothingScalar)),div(labelSmoothingScalar,numClasses))}let losses8=softmaxCrossEntropyWithLogits_($onehotLabels,$logits);return computeWeightedLoss(losses8,$weights,reduction2)}var softmaxCrossEntropy=op({softmaxCrossEntropy_});var spectral={fft,ifft,rfft,irfft},signal={hammingWindow,hannWindow,frame,stft},image={flipLeftRight,resizeNearestNeighbor,resizeBilinear,rotateWithOffset,cropAndResize,nonMaxSuppression,nonMaxSuppressionAsync,nonMaxSuppressionWithScore,nonMaxSuppressionWithScoreAsync,nonMaxSuppressionPadded,nonMaxSuppressionPaddedAsync},linalg={bandPart,gramSchmidt,qr},losses={absoluteDifference,computeWeightedLoss,cosineDistance,hingeLoss,huberLoss,logLoss,meanSquaredError,sigmoidCrossEntropy,softmaxCrossEntropy};var Optimizer=class extends Serializable{minimize(f,returnCost=!1,varList){let{value,grads}=this.computeGradients(f,varList);if(varList!=null){let gradArray=varList.map(v=>({name:v.name,tensor:grads[v.name]}));this.applyGradients(gradArray)}else this.applyGradients(grads);return dispose(grads),returnCost?value:(value.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(f,varList){return variableGrads(f,varList)}dispose(){this.iterations_!=null&&dispose(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:scalar(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(weightValues){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(weightValues){return this.iterations_=(await weightValues[0].tensor.data())[0],weightValues.slice(1)}};Object.defineProperty(Optimizer,Symbol.hasInstance,{value:instance=>instance.minimize!=null&&instance.computeGradients!=null&&instance.applyGradients!=null});var AdadeltaOptimizer=class extends Optimizer{constructor(learningRate,rho,epsilon3=null){super();this.learningRate=learningRate,this.rho=rho,this.epsilon=epsilon3,this.accumulatedGrads=[],this.accumulatedUpdates=[],epsilon3==null&&(this.epsilon=ENGINE.backend.epsilon())}applyGradients(variableGradients){let variableNames=Array.isArray(variableGradients)?variableGradients.map(item=>item.name):Object.keys(variableGradients);variableNames.forEach((name,i)=>{let value=ENGINE.registeredVariables[name],trainable=!1;this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${name}/accum_grad`,variable:tidy(()=>zerosLike(value).variable(trainable))}),this.accumulatedUpdates[i]==null&&(this.accumulatedUpdates[i]={originalName:`${name}/accum_var`,variable:tidy(()=>zerosLike(value).variable(trainable))});let gradient=Array.isArray(variableGradients)?variableGradients[i].tensor:variableGradients[name];if(gradient==null)return;let accumulatedGrad=this.accumulatedGrads[i].variable,accumulatedUpdate=this.accumulatedUpdates[i].variable;tidy(()=>{let newAccumulatedGrad=add2(mul(accumulatedGrad,this.rho),mul(square(gradient),1-this.rho)),updates=mul(div(sqrt(add2(accumulatedUpdate,this.epsilon)),sqrt(add2(accumulatedGrad,this.epsilon))),gradient),newAccumulatedUpdate=add2(mul(accumulatedUpdate,this.rho),mul(square(updates),1-this.rho));accumulatedGrad.assign(newAccumulatedGrad),accumulatedUpdate.assign(newAccumulatedUpdate);let newValue=add2(mul(updates,-this.learningRate),value);value.assign(newValue)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(dispose(this.accumulatedGrads.map(v=>v.variable)),dispose(this.accumulatedUpdates.map(v=>v.variable)))}async getWeights(){let variables5=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(variables5.map(v=>({name:v.originalName,tensor:v.variable})))}async setWeights(weightValues){weightValues=await this.extractIterations(weightValues);let variableCount=weightValues.length/2,trainable=!1;this.accumulatedGrads=weightValues.slice(0,variableCount).map(v=>({originalName:v.name,variable:v.tensor.variable(trainable)})),this.accumulatedUpdates=weightValues.slice(variableCount,variableCount*2).map(v=>({originalName:v.name,variable:v.tensor.variable(trainable)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(cls,config){return new cls(config.learningRate,config.rho,config.epsilon)}};AdadeltaOptimizer.className="Adadelta";registerClass(AdadeltaOptimizer);var AdagradOptimizer=class extends Optimizer{constructor(learningRate,initialAccumulatorValue=.1){super();this.learningRate=learningRate,this.initialAccumulatorValue=initialAccumulatorValue,this.accumulatedGrads=[]}applyGradients(variableGradients){let variableNames=Array.isArray(variableGradients)?variableGradients.map(item=>item.name):Object.keys(variableGradients);variableNames.forEach((name,i)=>{let value=ENGINE.registeredVariables[name];if(this.accumulatedGrads[i]==null){let trainable=!1;this.accumulatedGrads[i]={originalName:`${name}/accumulator`,variable:tidy(()=>fill(value.shape,this.initialAccumulatorValue).variable(trainable))}}let gradient=Array.isArray(variableGradients)?variableGradients[i].tensor:variableGradients[name];if(gradient==null)return;let accumulatedGrad=this.accumulatedGrads[i].variable;tidy(()=>{let newAccumulatedGrad=add2(accumulatedGrad,square(gradient));accumulatedGrad.assign(newAccumulatedGrad);let newValue=add2(mul(div(gradient,sqrt(add2(newAccumulatedGrad,ENGINE.backend.epsilon()))),-this.learningRate),value);value.assign(newValue)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&dispose(this.accumulatedGrads.map(v=>v.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(v=>({name:v.originalName,tensor:v.variable})))}async setWeights(weightValues){weightValues=await this.extractIterations(weightValues);let trainable=!1;this.accumulatedGrads=weightValues.map(v=>({originalName:v.name,variable:v.tensor.variable(trainable)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(cls,config){return new cls(config.learningRate,config.initialAccumulatorValue)}};AdagradOptimizer.className="Adagrad";registerClass(AdagradOptimizer);var AdamOptimizer=class extends Optimizer{constructor(learningRate,beta1,beta2,epsilon3=null){super();this.learningRate=learningRate,this.beta1=beta1,this.beta2=beta2,this.epsilon=epsilon3,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],tidy(()=>{this.accBeta1=scalar(beta1).variable(),this.accBeta2=scalar(beta2).variable()}),epsilon3==null&&(this.epsilon=ENGINE.backend.epsilon())}applyGradients(variableGradients){let varNames=Array.isArray(variableGradients)?variableGradients.map(v=>v.name):Object.keys(variableGradients);tidy(()=>{let oneMinusAccBeta1=sub(1,this.accBeta1),oneMinusAccBeta2=sub(1,this.accBeta2);varNames.forEach((name,i)=>{let value=ENGINE.registeredVariables[name],trainable=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${name}/m`,variable:tidy(()=>zerosLike(value).variable(trainable))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${name}/v`,variable:tidy(()=>zerosLike(value).variable(trainable))});let gradient=Array.isArray(variableGradients)?variableGradients[i].tensor:variableGradients[name];if(gradient==null)return;let firstMoment=this.accumulatedFirstMoment[i].variable,secondMoment=this.accumulatedSecondMoment[i].variable,newFirstMoment=add2(mul(firstMoment,this.beta1),mul(gradient,1-this.beta1)),newSecondMoment=add2(mul(secondMoment,this.beta2),mul(square(gradient),1-this.beta2)),biasCorrectedFirstMoment=div(newFirstMoment,oneMinusAccBeta1),biasCorrectedSecondMoment=div(newSecondMoment,oneMinusAccBeta2);firstMoment.assign(newFirstMoment),secondMoment.assign(newSecondMoment);let newValue=add2(mul(div(biasCorrectedFirstMoment,add2(sqrt(biasCorrectedSecondMoment),this.epsilon)),-this.learningRate),value);value.assign(newValue)}),this.accBeta1.assign(mul(this.accBeta1,this.beta1)),this.accBeta2.assign(mul(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&dispose(this.accumulatedFirstMoment.map(v=>v.variable)),this.accumulatedSecondMoment!=null&&dispose(this.accumulatedSecondMoment.map(v=>v.variable))}async getWeights(){let variables5=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(variables5.map(v=>({name:v.originalName,tensor:v.variable})))}async setWeights(weightValues){weightValues=await this.extractIterations(weightValues),tidy(()=>{this.accBeta1.assign(pow(this.beta1,this.iterations_+1)),this.accBeta2.assign(pow(this.beta2,this.iterations_+1))});let variableCount=weightValues.length/2,trainable=!1;this.accumulatedFirstMoment=weightValues.slice(0,variableCount).map(v=>({originalName:v.name,variable:v.tensor.variable(trainable)})),this.accumulatedSecondMoment=weightValues.slice(variableCount,variableCount*2).map(v=>({originalName:v.name,variable:v.tensor.variable(trainable)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(cls,config){return new cls(config.learningRate,config.beta1,config.beta2,config.epsilon)}};AdamOptimizer.className="Adam";registerClass(AdamOptimizer);var AdamaxOptimizer=class extends Optimizer{constructor(learningRate,beta1,beta2,epsilon3=null,decay=0){super();this.learningRate=learningRate,this.beta1=beta1,this.beta2=beta2,this.epsilon=epsilon3,this.decay=decay,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],tidy(()=>{this.iteration=scalar(0).variable(),this.accBeta1=scalar(beta1).variable()}),epsilon3==null&&(this.epsilon=ENGINE.backend.epsilon())}applyGradients(variableGradients){let variableNames=Array.isArray(variableGradients)?variableGradients.map(item=>item.name):Object.keys(variableGradients);tidy(()=>{let oneMinusAccBeta1=sub(1,this.accBeta1),lr=div(-this.learningRate,add2(mul(this.iteration,this.decay),1));variableNames.forEach((name,i)=>{let value=ENGINE.registeredVariables[name],trainable=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${name}/m`,variable:zerosLike(value).variable(trainable)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${name}/v`,variable:zerosLike(value).variable(trainable)});let gradient=Array.isArray(variableGradients)?variableGradients[i].tensor:variableGradients[name];if(gradient==null)return;let firstMoment=this.accumulatedFirstMoment[i].variable,weightedInfNorm=this.accumulatedWeightedInfNorm[i].variable,newFirstMoment=add2(mul(firstMoment,this.beta1),mul(gradient,1-this.beta1)),ut0=mul(weightedInfNorm,this.beta2),ut1=abs(gradient),newWeightedInfNorm=maximum(ut0,ut1);firstMoment.assign(newFirstMoment),weightedInfNorm.assign(newWeightedInfNorm);let newValue=add2(mul(div(lr,oneMinusAccBeta1),div(newFirstMoment,add2(newWeightedInfNorm,this.epsilon))),value);value.assign(newValue)}),this.iteration.assign(add2(this.iteration,1)),this.accBeta1.assign(mul(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&dispose(this.accumulatedFirstMoment.map(v=>v.variable)),this.accumulatedWeightedInfNorm!=null&&dispose(this.accumulatedWeightedInfNorm.map(v=>v.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(weightValues){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(cls,config){return new cls(config.learningRate,config.beta1,config.beta2,config.epsilon,config.decay)}};AdamaxOptimizer.className="Adamax";registerClass(AdamaxOptimizer);var SGDOptimizer=class extends Optimizer{constructor(learningRate){super();this.learningRate=learningRate,this.setLearningRate(learningRate)}applyGradients(variableGradients){let varNames=Array.isArray(variableGradients)?variableGradients.map(v=>v.name):Object.keys(variableGradients);varNames.forEach((name,i)=>{let gradient=Array.isArray(variableGradients)?variableGradients[i].tensor:variableGradients[name];if(gradient==null)return;let value=ENGINE.registeredVariables[name];tidy(()=>{let newValue=add2(mul(this.c,gradient),value);value.assign(newValue)})}),this.incrementIterations()}setLearningRate(learningRate){this.learningRate=learningRate,this.c!=null&&this.c.dispose(),this.c=keep(scalar(-learningRate))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(weightValues){if(weightValues=await this.extractIterations(weightValues),weightValues.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(cls,config){return new cls(config.learningRate)}};SGDOptimizer.className="SGD";registerClass(SGDOptimizer);var MomentumOptimizer=class extends SGDOptimizer{constructor(learningRate,momentum,useNesterov=!1){super(learningRate);this.learningRate=learningRate,this.momentum=momentum,this.useNesterov=useNesterov,this.accumulations=[],this.m=scalar(this.momentum)}applyGradients(variableGradients){let variableNames=Array.isArray(variableGradients)?variableGradients.map(item=>item.name):Object.keys(variableGradients);variableNames.forEach((name,i)=>{let value=ENGINE.registeredVariables[name];if(this.accumulations[i]==null){let trainable=!1;this.accumulations[i]={originalName:`${name}/momentum`,variable:tidy(()=>zerosLike(value).variable(trainable))}}let accumulation=this.accumulations[i].variable,gradient=Array.isArray(variableGradients)?variableGradients[i].tensor:variableGradients[name];if(gradient==null)return;tidy(()=>{let newValue,newAccumulation=add2(mul(this.m,accumulation),gradient);this.useNesterov?newValue=add2(mul(this.c,add2(gradient,mul(newAccumulation,this.m))),value):newValue=add2(mul(this.c,newAccumulation),value),accumulation.assign(newAccumulation),value.assign(newValue)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&dispose(this.accumulations.map(v=>v.variable))}setMomentum(momentum){this.momentum=momentum}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(v=>({name:v.originalName,tensor:v.variable})))}async setWeights(weightValues){weightValues=await this.extractIterations(weightValues);let trainable=!1;this.accumulations=weightValues.map(v=>({originalName:v.name,variable:v.tensor.variable(trainable)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(cls,config){return new cls(config.learningRate,config.momentum,config.useNesterov)}};MomentumOptimizer.className="Momentum";registerClass(MomentumOptimizer);var RMSPropOptimizer=class extends Optimizer{constructor(learningRate,decay=.9,momentum=0,epsilon3=null,centered=!1){super();if(this.learningRate=learningRate,this.decay=decay,this.momentum=momentum,this.epsilon=epsilon3,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=centered,epsilon3==null&&(this.epsilon=ENGINE.backend.epsilon()),learningRate==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(variableGradients){let variableNames=Array.isArray(variableGradients)?variableGradients.map(item=>item.name):Object.keys(variableGradients);variableNames.forEach((name,i)=>{let value=ENGINE.registeredVariables[name],trainable=!1;this.accumulatedMeanSquares[i]==null&&(this.accumulatedMeanSquares[i]={originalName:`${name}/rms`,variable:tidy(()=>zerosLike(value).variable(trainable))}),this.accumulatedMoments[i]==null&&(this.accumulatedMoments[i]={originalName:`${name}/momentum`,variable:tidy(()=>zerosLike(value).variable(trainable))}),this.accumulatedMeanGrads[i]==null&&this.centered&&(this.accumulatedMeanGrads[i]={originalName:`${name}/mg`,variable:tidy(()=>zerosLike(value).variable(trainable))});let gradient=Array.isArray(variableGradients)?variableGradients[i].tensor:variableGradients[name];if(gradient==null)return;let accumulatedMeanSquare=this.accumulatedMeanSquares[i].variable,accumulatedMoments=this.accumulatedMoments[i].variable;tidy(()=>{let newAccumulatedMeanSquare=add2(mul(accumulatedMeanSquare,this.decay),mul(square(gradient),1-this.decay));if(this.centered){let accumulatedMeanGrad=this.accumulatedMeanGrads[i].variable,newAccumulatedMeanGrad=add2(mul(accumulatedMeanGrad,this.decay),mul(gradient,1-this.decay)),gradContribution=div(mul(gradient,this.learningRate),sqrt(sub(newAccumulatedMeanSquare,add2(square(newAccumulatedMeanGrad),this.epsilon)))),newAccumulatedMoments=add2(mul(accumulatedMoments,this.momentum),gradContribution);accumulatedMeanSquare.assign(newAccumulatedMeanSquare),accumulatedMeanGrad.assign(newAccumulatedMeanGrad),accumulatedMoments.assign(newAccumulatedMoments);let newValue=sub(value,newAccumulatedMoments);value.assign(newValue)}else{let newAccumulatedMeanSquare2=add2(mul(accumulatedMeanSquare,this.decay),mul(square(gradient),1-this.decay)),newAccumulatedMoments=add2(mul(accumulatedMoments,this.momentum),div(mul(gradient,this.learningRate),sqrt(add2(newAccumulatedMeanSquare2,this.epsilon))));accumulatedMeanSquare.assign(newAccumulatedMeanSquare2),accumulatedMoments.assign(newAccumulatedMoments);let newValue=sub(value,newAccumulatedMoments);value.assign(newValue)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&dispose(this.accumulatedMeanSquares.map(v=>v.variable)),this.accumulatedMeanGrads!=null&&this.centered&&dispose(this.accumulatedMeanGrads.map(v=>v.variable)),this.accumulatedMoments!=null&&dispose(this.accumulatedMoments.map(v=>v.variable))}async getWeights(){let variables5=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&variables5.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(variables5.map(v=>({name:v.originalName,tensor:v.variable})))}async setWeights(weightValues){weightValues=await this.extractIterations(weightValues);let variableCount=this.centered?weightValues.length/3:weightValues.length/2,trainable=!1;this.accumulatedMeanSquares=weightValues.slice(0,variableCount).map(v=>({originalName:v.name,variable:v.tensor.variable(trainable)})),this.accumulatedMoments=weightValues.slice(variableCount,variableCount*2).map(v=>({originalName:v.name,variable:v.tensor.variable(trainable)})),this.centered&&(this.accumulatedMeanGrads=weightValues.slice(variableCount*2,variableCount*3).map(v=>({originalName:v.name,variable:v.tensor.variable(trainable)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(cls,config){return new cls(config.learningRate,config.decay,config.momentum,config.epsilon,config.centered)}};RMSPropOptimizer.className="RMSProp";registerClass(RMSPropOptimizer);var OptimizerConstructors=class{static sgd(learningRate){return new SGDOptimizer(learningRate)}static momentum(learningRate,momentum,useNesterov=!1){return new MomentumOptimizer(learningRate,momentum,useNesterov)}static rmsprop(learningRate,decay=.9,momentum=0,epsilon3=null,centered=!1){return new RMSPropOptimizer(learningRate,decay,momentum,epsilon3,centered)}static adam(learningRate=.001,beta1=.9,beta2=.999,epsilon3=null){return new AdamOptimizer(learningRate,beta1,beta2,epsilon3)}static adadelta(learningRate=.001,rho=.95,epsilon3=null){return new AdadeltaOptimizer(learningRate,rho,epsilon3)}static adamax(learningRate=.002,beta1=.9,beta2=.999,epsilon3=null,decay=0){return new AdamaxOptimizer(learningRate,beta1,beta2,epsilon3,decay)}static adagrad(learningRate,initialAccumulatorValue=.1){return new AdagradOptimizer(learningRate,initialAccumulatorValue)}};MomentumOptimizer,SGDOptimizer,AdadeltaOptimizer,AdagradOptimizer,RMSPropOptimizer,AdamaxOptimizer,AdamOptimizer;var train={sgd:OptimizerConstructors.sgd,momentum:OptimizerConstructors.momentum,adadelta:OptimizerConstructors.adadelta,adagrad:OptimizerConstructors.adagrad,rmsprop:OptimizerConstructors.rmsprop,adamax:OptimizerConstructors.adamax,adam:OptimizerConstructors.adam};var delayCallback=(()=>typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:f=>f())();function nextFrame(){return new Promise(resolve=>delayCallback(()=>resolve()))}var backend_util_exports={};__export(backend_util_exports,{ERF_A1:()=>ERF_A1,ERF_A2:()=>ERF_A2,ERF_A3:()=>ERF_A3,ERF_A4:()=>ERF_A4,ERF_A5:()=>ERF_A5,ERF_P:()=>ERF_P,PARALLELIZE_THRESHOLD:()=>PARALLELIZE_THRESHOLD,SELU_SCALE:()=>SELU_SCALE,SELU_SCALEALPHA:()=>SELU_SCALEALPHA,applyActivation:()=>applyActivation,assertAndGetBroadcastShape:()=>assertAndGetBroadcastShape,assertAxesAreInnerMostDims:()=>assertAxesAreInnerMostDims,assertParamsConsistent:()=>assertParamsConsistent,assignToTypedArray:()=>assignToTypedArray,axesAreInnerMostDims:()=>axesAreInnerMostDims,calculateShapes:()=>calculateShapes,castTensor:()=>castTensor,combineLocations:()=>combineLocations,complexWithEvenIndex:()=>complexWithEvenIndex,complexWithOddIndex:()=>complexWithOddIndex,computeConv2DInfo:()=>computeConv2DInfo,computeConv3DInfo:()=>computeConv3DInfo,computeDefaultPad:()=>computeDefaultPad,computeDilation2DInfo:()=>computeDilation2DInfo,computeOptimalWindowSize:()=>computeOptimalWindowSize,computeOutAndReduceShapes:()=>computeOutAndReduceShapes,computeOutShape:()=>computeOutShape2,computePool2DInfo:()=>computePool2DInfo,computePool3DInfo:()=>computePool3DInfo,convertConv2DDataFormat:()=>convertConv2DDataFormat,eitherStridesOrDilationsAreOne:()=>eitherStridesOrDilationsAreOne,expandShapeToKeepDim:()=>expandShapeToKeepDim,exponent:()=>exponent,exponents:()=>exponents,getAxesPermutation:()=>getAxesPermutation,getBroadcastDims:()=>getBroadcastDims,getComplexWithIndex:()=>getComplexWithIndex,getFusedBiasGradient:()=>getFusedBiasGradient,getFusedDyActivation:()=>getFusedDyActivation,getImageCenter:()=>getImageCenter,getInnerMostAxes:()=>getInnerMostAxes,getPermuted:()=>getPermuted,getReductionAxes:()=>getReductionAxes,getReshaped:()=>getReshaped,getReshapedPermuted:()=>getReshapedPermuted,getSliceBeginCoords:()=>getSliceBeginCoords,getSliceSize:()=>getSliceSize,getUndoAxesPermutation:()=>getUndoAxesPermutation,linspaceImpl:()=>linspaceImpl,log:()=>log6,mergeRealAndImagArrays:()=>mergeRealAndImagArrays,prepareAndValidate:()=>prepareAndValidate,prepareSplitSize:()=>prepareSplitSize,reshapeTensor:()=>reshapeTensor,segment_util:()=>segment_util_exports,shouldFuse:()=>shouldFuse,slice_util:()=>slice_util_exports,splitRealAndImagArrays:()=>splitRealAndImagArrays,tupleValuesAreOne:()=>tupleValuesAreOne,upcastType:()=>upcastType,validateInput:()=>validateInput,validateUpdateShape:()=>validateUpdateShape,warn:()=>warn});function getImageCenter(center,imageHeight,imageWidth){let centerX=imageWidth*(typeof center=="number"?center:center[0]),centerY=imageHeight*(typeof center=="number"?center:center[1]);return[centerX,centerY]}function getReshaped(inputShape,blockShape,prod5,batchToSpace=!0){let reshaped=[];if(batchToSpace)reshaped=reshaped.concat(blockShape.slice(0)),reshaped.push(inputShape[0]/prod5),reshaped=reshaped.concat(inputShape.slice(1));else{reshaped=reshaped.concat(inputShape[0]);let spatialLength=blockShape.length;for(let i=0;i<spatialLength;++i)reshaped=reshaped.concat([inputShape[i+1]/blockShape[i],blockShape[i]]);reshaped=reshaped.concat(inputShape.slice(spatialLength+1))}return reshaped}function getPermuted(reshapedRank,blockShapeRank,batchToSpace=!0){let permuted=[];if(batchToSpace){permuted.push(blockShapeRank);for(let i=blockShapeRank+1;i<reshapedRank;++i)i<=2*blockShapeRank?(permuted.push(i),permuted.push(i-(blockShapeRank+1))):permuted.push(i)}else{let permutedBeforeBatch=[],permutedAfterBatch=[];for(let i=1;i<reshapedRank;++i)i>=blockShapeRank*2+1||i%2===1?permutedAfterBatch.push(i):permutedBeforeBatch.push(i);permuted.push(...permutedBeforeBatch),permuted.push(0),permuted.push(...permutedAfterBatch)}return permuted}function getReshapedPermuted(inputShape,blockShape,prod5,batchToSpace=!0){let reshapedPermuted=[];batchToSpace?reshapedPermuted.push(inputShape[0]/prod5):reshapedPermuted.push(inputShape[0]*prod5);for(let i=1;i<inputShape.length;++i)i<=blockShape.length?batchToSpace?reshapedPermuted.push(blockShape[i-1]*inputShape[i]):reshapedPermuted.push(inputShape[i]/blockShape[i-1]):reshapedPermuted.push(inputShape[i]);return reshapedPermuted}function getSliceBeginCoords(crops,blockShape){let sliceBeginCoords=[0];for(let i=0;i<blockShape;++i)sliceBeginCoords.push(crops[i][0]);return sliceBeginCoords}function getSliceSize(uncroppedShape,crops,blockShape){let sliceSize=uncroppedShape.slice(0,1);for(let i=0;i<blockShape;++i)sliceSize.push(uncroppedShape[i+1]-crops[i][0]-crops[i][1]);return sliceSize}var SELU_SCALEALPHA=1.7580993408473768,SELU_SCALE=1.0507009873554805;var ERF_P=.3275911,ERF_A1=.254829592,ERF_A2=-.284496736,ERF_A3=1.421413741,ERF_A4=-1.453152027,ERF_A5=1.061405429;function warn(...msg){env().getBool("IS_TEST")||console.warn(...msg)}function log6(...msg){env().getBool("IS_TEST")||console.log(...msg)}function mergeRealAndImagArrays(real8,imag8){if(real8.length!==imag8.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${real8.length}, imag: ${imag8.length}.`);let result=new Float32Array(real8.length*2);for(let i=0;i<result.length;i+=2)result[i]=real8[i/2],result[i+1]=imag8[i/2];return result}function splitRealAndImagArrays(complex11){let real8=new Float32Array(complex11.length/2),imag8=new Float32Array(complex11.length/2);for(let i=0;i<complex11.length;i+=2)real8[i/2]=complex11[i],imag8[i/2]=complex11[i+1];return{real:real8,imag:imag8}}function complexWithEvenIndex(complex11){let len=Math.ceil(complex11.length/4),real8=new Float32Array(len),imag8=new Float32Array(len);for(let i=0;i<complex11.length;i+=4)real8[Math.floor(i/4)]=complex11[i],imag8[Math.floor(i/4)]=complex11[i+1];return{real:real8,imag:imag8}}function complexWithOddIndex(complex11){let len=Math.floor(complex11.length/4),real8=new Float32Array(len),imag8=new Float32Array(len);for(let i=2;i<complex11.length;i+=4)real8[Math.floor(i/4)]=complex11[i],imag8[Math.floor(i/4)]=complex11[i+1];return{real:real8,imag:imag8}}function getComplexWithIndex(complex11,index){let real8=complex11[index*2],imag8=complex11[index*2+1];return{real:real8,imag:imag8}}function assignToTypedArray(data,real8,imag8,index){data[index*2]=real8,data[index*2+1]=imag8}function exponents(n,inverse){let real8=new Float32Array(n/2),imag8=new Float32Array(n/2);for(let i=0;i<Math.ceil(n/2);i++){let x=(inverse?2:-2)*Math.PI*(i/n);real8[i]=Math.cos(x),imag8[i]=Math.sin(x)}return{real:real8,imag:imag8}}function exponent(k,n,inverse){let x=(inverse?2:-2)*Math.PI*(k/n),real8=Math.cos(x),imag8=Math.sin(x);return{real:real8,imag:imag8}}function castTensor(x,dtype,backend3){if(dtype==="complex64"){if(x.dtype==="complex64")return x.clone();let zerosTensor=zeros(x.shape),floatX=cast(x,"float32"),result=backend3.complex(floatX,zerosTensor);return zerosTensor.dispose(),floatX.dispose(),result}if(!hasEncodingLoss(x.dtype,dtype))return ENGINE.makeTensorFromDataId(x.dataId,x.shape,dtype);if(x.dtype==="complex64"){let real8=backend3.real(x),result=cast(real8,dtype);return real8.dispose(),result}if(dtype==="int32")return backend3.int(x);if(dtype==="bool"){let zero=scalar(0,x.dtype),result=backend3.notEqual(x,zero);return zero.dispose(),result}else throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`)}function reshapeTensor(x,shape){return ENGINE.makeTensorFromDataId(x.dataId,shape,x.dtype)}function linspaceImpl(start,stop,num){let step9=(stop-start)/(num-1),values=makeZerosTypedArray(num,"float32");values[0]=start;for(let i=1;i<values.length;i++)values[i]=values[i-1]+step9;return tensor1d(values,"float32")}var kernel_impls_exports={};__export(kernel_impls_exports,{nonMaxSuppressionV3Impl:()=>nonMaxSuppressionV3Impl,nonMaxSuppressionV4Impl:()=>nonMaxSuppressionV4Impl,nonMaxSuppressionV5Impl:()=>nonMaxSuppressionV5Impl,split:()=>split5,tile:()=>tile4,topkImpl:()=>topkImpl,whereImpl:()=>whereImpl});function split5(x,sizeSplits,axis){let begin=new Array(x.rank).fill(0),size=x.shape.slice();return sizeSplits.map(s=>{let sliceSize=[...size];sliceSize[axis]=s;let sliceT=slice(x,begin,sliceSize);return begin[axis]+=s,sliceT})}function tile4(xBuf,reps){let newShape=new Array(xBuf.rank);for(let i=0;i<newShape.length;i++)newShape[i]=xBuf.shape[i]*reps[i];let result=buffer(newShape,xBuf.dtype);for(let i=0;i<result.values.length;++i){let newLoc=result.indexToLoc(i),originalLoc=new Array(xBuf.rank);for(let j=0;j<originalLoc.length;j++)originalLoc[j]=newLoc[j]%xBuf.shape[j];let originalIndex=xBuf.locToIndex(originalLoc);result.values[i]=xBuf.values[originalIndex]}return result.toTensor()}function topkImpl(x,xShape,xDtype,k,sorted){let lastDim=xShape[xShape.length-1],[batch,size]=[x.length/lastDim,lastDim],allTopKVals=getTypedArrayFromDType(xDtype,batch*k),allTopKIndices=getTypedArrayFromDType("int32",batch*k);for(let b=0;b<batch;b++){let offset=b*size,vals=x.subarray(offset,offset+size),valAndInd=[];for(let i=0;i<vals.length;i++)valAndInd.push({value:vals[i],index:i});valAndInd.sort((a,b2)=>b2.value-a.value);let outOffset=b*k,topKVals=allTopKVals.subarray(outOffset,outOffset+k),topKIndices=allTopKIndices.subarray(outOffset,outOffset+k);for(let i=0;i<k;i++)topKVals[i]=valAndInd[i].value,topKIndices[i]=valAndInd[i].index}let outputShape=xShape.slice();return outputShape[outputShape.length-1]=k,[tensor4(allTopKVals,outputShape,xDtype),tensor4(allTopKIndices,outputShape,"int32")]}var absGradConfig={kernelName:Abs,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>mul(dy,step(cast(x,"float32"),-1))}}};var acosGradConfig={kernelName:Acos,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>{let a=square(cast(x,"float32")),b=sqrt(sub(scalar(1),a));return neg(div(dy,b))}}}};var acoshGradConfig={kernelName:Acosh,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>{let a=sqrt(sub(square(cast(x,"float32")),1));return div(dy,a)}}}};var addGradConfig={kernelName:Add,inputsToSave:["a","b"],gradFunc:(dy,saved)=>{let[a,b]=saved,outShape=assertAndGetBroadcastShape(a.shape,b.shape),derA=()=>{let res=dy,reduceAxes=getReductionAxes(a.shape,outShape);return reduceAxes.length>0&&(res=sum2(res,reduceAxes)),reshape(res,a.shape)},derB=()=>{let res=dy,reduceAxes=getReductionAxes(b.shape,outShape);return reduceAxes.length>0&&(res=sum2(res,reduceAxes)),reshape(res,b.shape)};return{a:derA,b:derB}}};var addNGradConfig={kernelName:AddN,saveAllInputs:!0,gradFunc:(dy,saved)=>{let ders={};return saved.forEach((_,i)=>{ders[i]=()=>dy.clone()}),ders}};var argMaxGradConfig={kernelName:ArgMax,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>zerosLike(x)}}};var argMinGradConfig={kernelName:ArgMin,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>zerosLike(x)}}};var asinGradConfig={kernelName:Asin,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>div(dy,sqrt(sub(scalar(1),square(cast(x,"float32")))))}}};var asinhGradConfig={kernelName:Asinh,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>{let a=sqrt(add2(scalar(1),square(cast(x,"float32"))));return div(dy,a)}}}};var atan2GradConfig={kernelName:Atan2,inputsToSave:["a","b"],gradFunc:(dy,saved)=>{let[a,b]=saved,outShape=assertAndGetBroadcastShape(a.shape,b.shape),derA=()=>{let d=add2(square(a),square(b)),res=mul(dy,div(b,d)),reduceAxes=getReductionAxes(a.shape,outShape);return reduceAxes.length>0&&(res=sum2(res,reduceAxes)),reshape(res,a.shape)},derB=()=>{let d=add2(square(a),square(b)),res=neg(mul(dy,div(a,d))),reduceAxes=getReductionAxes(b.shape,outShape);return reduceAxes.length>0&&(res=sum2(res,reduceAxes)),reshape(res,b.shape)};return{a:derA,b:derB}}};var atanGradConfig={kernelName:Atan,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>div(dy,add2(square(cast(x,"float32")),1))}}};var atanhGradConfig={kernelName:Atanh,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>div(dy,sub(scalar(1),square(cast(x,"float32"))))}}};function avgPool3dBackprop_(dy,input2,filterSize,strides,dilations=[1,1,1],pad6,dimRoundingMode){let $dy=convertToTensor(dy,"dy","avgPool3dBackprop"),$input=convertToTensor(input2,"input","avgPool3dBackprop"),dy5D=$dy,input5D=$input,reshapedTo5D=!1;$input.rank===4&&(reshapedTo5D=!0,dy5D=reshape($dy,[1,$dy.shape[0],$dy.shape[1],$dy.shape[2],$dy.shape[3]]),input5D=reshape($input,[1,$input.shape[0],$input.shape[1],$input.shape[2],$input.shape[3]])),assert(dy5D.rank===5,()=>`Error in avgPool3dBackprop: dy must be rank 5 but got rank ${dy5D.rank}.`),assert(input5D.rank===5,()=>`Error in avgPool3dBackprop: input must be rank 5 but got rank ${input5D.rank}.`),assert(eitherStridesOrDilationsAreOne(strides,dilations),()=>`Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`),dimRoundingMode!=null&&assert(isInt(pad6),()=>`Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad6}.`);let forward=backend3=>{let convInfo=computePool3DInfo(input5D.shape,filterSize,strides,dilations,pad6,dimRoundingMode);return backend3.avgPool3dBackprop(dy5D,input5D,convInfo)},inputs={dy:dy5D,input:input5D},attrs={filterSize,strides,dilations,pad:pad6,dimRoundingMode},res=ENGINE.runKernelFunc(forward,inputs,null,AvgPool3DBackprop,attrs);return reshapedTo5D?reshape(res,[res.shape[1],res.shape[2],res.shape[3],res.shape[4]]):res}var avgPool3dBackprop=op({avgPool3dBackprop_});var avgPool3DGradConfig={kernelName:AvgPool3D,inputsToSave:["x"],gradFunc:(dy,saved,attrs)=>{let[x]=saved,{filterSize,strides,dilations,pad:pad6,dimRoundingMode}=attrs,$dilations=dilations==null?[1,1,1]:dilations;return{x:()=>avgPool3dBackprop(dy,x,filterSize,strides,$dilations,pad6,dimRoundingMode)}}};function avgPoolBackprop_(dy,input2,filterSize,strides,pad6){let $dy=convertToTensor(dy,"dy","avgPoolBackprop"),$input=convertToTensor(input2,"input","avgPoolBackprop");assert($input.rank===$dy.rank,()=>`Rank of input (${$input.rank}) does not match rank of dy (${$dy.rank})`);let input4D=$input,dy4D=$dy,reshapedTo4D=!1;$input.rank===3&&(reshapedTo4D=!0,input4D=reshape($input,[1,$input.shape[0],$input.shape[1],$input.shape[2]]),dy4D=reshape($dy,[1,$dy.shape[0],$dy.shape[1],$dy.shape[2]])),assert(dy4D.rank===4,()=>`Error in avgPoolBackprop: dy must be rank 4 but got rank ${dy4D.rank}.`),assert(input4D.rank===4,()=>`Error in avgPoolBackprop: input must be rank 4 but got rank ${input4D.rank}.`);let forward=backend3=>{let convInfo=computePool2DInfo(input4D.shape,filterSize,strides,1,pad6);return backend3.avgPoolBackprop(dy4D,input4D,convInfo)},inputs={dy:dy4D,input:input4D},attrs={filterSize,strides,pad:pad6},res=ENGINE.runKernelFunc(forward,inputs,null,AvgPoolBackprop,attrs);return reshapedTo4D?reshape(res,[res.shape[1],res.shape[2],res.shape[3]]):res}var avgPoolBackprop=op({avgPoolBackprop_});var avgPoolGradConfig={kernelName:AvgPool,inputsToSave:["x"],gradFunc:(dy,saved,attrs)=>{let[x]=saved,{filterSize,strides,pad:pad6}=attrs;return{x:()=>avgPoolBackprop(dy,x,filterSize,strides,pad6)}}};var batchMatMulGradConfig={kernelName:BatchMatMul,inputsToSave:["a","b"],gradFunc:(dy,saved,attrs)=>{let[a,b]=saved,{transposeA,transposeB}=attrs;return!transposeA&&!transposeB?{a:()=>matMul(dy,b,!1,!0),b:()=>matMul(a,dy,!0,!1)}:!transposeA&&transposeB?{a:()=>matMul(dy,b,!1,!1),b:()=>matMul(dy,a,!0,!1)}:transposeA&&!transposeB?{a:()=>matMul(b,dy,!1,!0),b:()=>matMul(a,dy,!1,!1)}:{a:()=>matMul(b,dy,!0,!0),b:()=>matMul(dy,a,!0,!0)}}};var batchToSpaceNDGradConfig={kernelName:BatchToSpaceND,gradFunc:(dy,saved,attrs)=>{let{blockShape,crops}=attrs;return{x:()=>spaceToBatchND(dy,blockShape,crops)}}};var broadcastToGradConfig={kernelName:BroadcastTo,gradFunc:(dy,saved,attrs)=>{let broadCastToAttrs=attrs,inputShape=broadCastToAttrs.inputShape,outputShape=broadCastToAttrs.shape,reps=Array.from(outputShape);for(let i=inputShape.length-1;i>=0;i--)if(inputShape[i]===outputShape[i])reps[i]=1;else if(inputShape[i]!==1)throw new Error(`broadcastTo(): [${inputShape}] cannot be broadcast to [${outputShape}].`);let axes=[];for(let i=0;i<reps.length;i++)reps[i]>1&&axes.push(i);return{x:()=>sum2(dy,axes,!0)}}};var castGradConfig={kernelName:Cast,gradFunc:dy=>({x:()=>dy.clone()})};var ceilGradConfig={kernelName:Ceil,gradFunc:dy=>({x:()=>zerosLike(dy)})};var clipByValueGradConfig={kernelName:ClipByValue,inputsToSave:["x"],gradFunc:(dy,saved,attrs)=>{let[x]=saved,{clipValueMin,clipValueMax}=attrs;return{x:()=>where(logicalAnd(greaterEqual(x,clipValueMin),lessEqual(x,clipValueMax)),dy,zerosLike(dy))}}};var concatGradConfig={kernelName:Concat,saveAllInputs:!0,gradFunc:(dy,saved,attrs)=>{let shapes=saved.map(t=>t.shape),{axis}=attrs,$axis=parseAxisParam(axis,saved[0].shape)[0],sizeSplits=shapes.map(s=>s[$axis]),derTensors=split(dy,sizeSplits,$axis);return derTensors.map(t=>()=>t)}};var conv2DGradConfig={kernelName:Conv2D,inputsToSave:["x","filter"],gradFunc:(dy,saved,attrs)=>{let[x4D,$filter]=saved,{dilations,strides,pad:pad6,dataFormat}=attrs;return assert(tupleValuesAreOne(dilations),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${dilations}'`),{x:()=>conv2DBackpropInput(x4D.shape,dy,$filter,strides,pad6,dataFormat),filter:()=>conv2DBackpropFilter(x4D,dy,$filter.shape,strides,pad6,dataFormat)}}};var conv2DBackpropInputGradConfig={kernelName:Conv2DBackpropInput,inputsToSave:["dy","filter"],gradFunc:(ddx,saved,attrs)=>{let[dy,filter]=saved,{strides,pad:pad6,dataFormat,dimRoundingMode}=attrs;return{dy:()=>conv2d(ddx,filter,strides,pad6,dataFormat,1,dimRoundingMode),filter:()=>conv2DBackpropFilter(ddx,dy,filter.shape,strides,pad6,dataFormat,dimRoundingMode)}}};function conv3DBackpropFilter_(x,dy,filterShape,strides,pad6){let x5D=x;x.rank===4&&(x5D=reshape(x,[1,x.shape[0],x.shape[1],x.shape[2],x.shape[3]]));let dy5D=dy;dy5D.rank===4&&(dy5D=reshape(dy,[1,dy.shape[0],dy.shape[1],dy.shape[2],dy.shape[3]])),assert(x5D.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${x5D.shape}.`),assert(dy5D.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${dy5D.shape}.`),assert(filterShape.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${filterShape}.`),assert(x5D.shape[4]===filterShape[3],()=>`Error in conv3dDerFilter: depth of input ${x5D.shape[4]}) must match input depth in filter (${filterShape[3]}.`),assert(dy5D.shape[4]===filterShape[4],()=>`Error in conv3dDerFilter: depth of dy (${dy5D.shape[4]}) must match output depth for filter (${filterShape[4]}).`);let forward=backend3=>{let dilations=1,convInfo=computeConv3DInfo(x5D.shape,filterShape,strides,dilations,pad6);return backend3.conv3dDerFilter(x5D,dy5D,convInfo)},inputs={x:x5D,dy:dy5D},attrs={strides,pad:pad6,filterShape};return ENGINE.runKernelFunc(forward,inputs,null,Conv3DBackpropFilterV2,attrs)}var conv3DBackpropFilter=op({conv3DBackpropFilter_});var conv3DGradConfig={kernelName:Conv3D,inputsToSave:["x","filter"],gradFunc:(dy,saved,attrs)=>{let{dilations,strides,pad:pad6}=attrs;assert(tupleValuesAreOne(dilations),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${dilations}'`);let[x5D,$filter]=saved;return{x:()=>conv3DBackpropInput(x5D.shape,dy,$filter,strides,pad6),filter:()=>conv3DBackpropFilter(x5D,dy,$filter.shape,strides,pad6)}}};var cosGradConfig={kernelName:Cos,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>mul(neg(sin(cast(x,"float32"))),dy)}}};var coshGradConfig={kernelName:Cosh,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>mul(sinh(cast(x,"float32")),dy)}}};var cumsumGradConfig={kernelName:Cumsum,inputsToSave:["x"],gradFunc:(dy,saved,attrs)=>{let[x]=saved,{axis,exclusive,reverse:reverse7}=attrs;return{x:()=>{let permutation=getAxesPermutation([axis],x.rank),out=cumsum(dy,axis,exclusive,!reverse7);return permutation!=null&&(out=transpose(out,permutation)),out}}}};var depthwiseConv2dNativeGradConfig={kernelName:DepthwiseConv2dNative,inputsToSave:["x","filter"],gradFunc:(dy,saved,attrs)=>{let{dilations,strides,pad:pad6,dimRoundingMode}=attrs,$dilations=dilations==null?[1,1]:dilations;assert(tupleValuesAreOne($dilations),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${$dilations}'`);let[x,filter]=saved;return assert(x.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${x.rank}.`),assert(filter.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${filter.rank}.`),assert(x.shape[3]===filter.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${x.shape[3]}) must match the inChannels dimension in filter ${filter.shape[2]}.`),assert(eitherStridesOrDilationsAreOne(strides,$dilations),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${strides} and dilations '${$dilations}'.`),dimRoundingMode!=null&&assert(isInt(pad6),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad6}.`),{x:()=>depthwiseConv2dNativeBackpropInput(x.shape,dy,filter,strides,pad6,dilations,dimRoundingMode),filter:()=>depthwiseConv2dNativeBackpropFilter(x,dy,filter.shape,strides,pad6,dilations,dimRoundingMode)}}};var dilation2dGradConfig={kernelName:Dilation2D,inputsToSave:["x","filter"],gradFunc:(dy,saved,attrs)=>{let[x,filter]=saved,inputInputs={x,filter,dy},filterInputs={x,filter,dy};return{x:()=>ENGINE.runKernel(Dilation2DBackpropInput,inputInputs,attrs),filter:()=>ENGINE.runKernel(Dilation2DBackpropFilter,filterInputs,attrs)}}};var divGradConfig={kernelName:Div,inputsToSave:["a","b"],gradFunc:(dy,saved)=>{let[a,b]=saved,outShape=assertAndGetBroadcastShape(a.shape,b.shape),derA=()=>{let res=div(dy,cast(b,"float32")),reduceAxes=getReductionAxes(a.shape,outShape);return reduceAxes.length>0?reshape(sum2(res,reduceAxes),a.shape):res},derB=()=>{let res=mul(dy,cast(a,"float32")),reduceAxes=getReductionAxes(b.shape,outShape);reduceAxes.length>0&&(res=reshape(sum2(res,reduceAxes),b.shape));let tmp=square(b);return neg(div(res,cast(tmp,"float32")))};return{a:derA,b:derB}}};var eluGradConfig={kernelName:Elu,outputsToSave:[!0],gradFunc:(dy,saved)=>{let[y]=saved,backPropKernelFunc=backend3=>backend3.eluDer(dy,y),inputs={dy,y};return{x:()=>ENGINE.runKernelFunc(backPropKernelFunc,inputs,null,EluGrad)}}};var erfGradConfig={kernelName:Erf,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved,a=mul(exp(neg(square(x))),2/Math.sqrt(Math.PI));return{x:()=>mul(dy,a)}}};var expGradConfig={kernelName:Exp,outputsToSave:[!0],gradFunc:(dy,saved)=>{let[y]=saved;return{x:()=>mul(dy,y)}}};var expm1GradConfig={kernelName:Expm1,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>mul(dy,exp(x))}}};var floorGradConfig={kernelName:Floor,gradFunc:dy=>({x:()=>zerosLike(dy)})};var floorDivGradConfig={kernelName:FloorDiv,inputsToSave:["a","b"],gradFunc:(dy,saved)=>{let[a,b]=saved,outShape=assertAndGetBroadcastShape(a.shape,b.shape),derA=()=>{let res=div(dy,cast(b,"float32")),reduceAxes=getReductionAxes(a.shape,outShape);return reduceAxes.length>0?reshape(sum2(res,reduceAxes),a.shape):res},derB=()=>{let res=mul(dy,cast(a,"float32")),reduceAxes=getReductionAxes(b.shape,outShape);reduceAxes.length>0&&(res=reshape(sum2(res,reduceAxes),b.shape));let tmp=square(b);return neg(div(res,cast(tmp,"float32")))};return{a:derA,b:derB}}};var fusedBatchNormGradConfig={kernelName:FusedBatchNorm,inputsToSave:["x","mean","variance","scale"],gradFunc:(dy,saved,attrs)=>{let{varianceEpsilon}=attrs,[x,mean7,variance,scale2]=saved,scaleValue=scale2==null?scalar(1):scale2,reductionAxes=getReductionAxes(mean7.shape,x.shape),tileShape=[];if(mean7.rank===1){for(let i=0;i<x.shape.length-1;++i)tileShape.push(x.shape[i]);tileShape.push(1)}let xMinusMean=sub(x,mean7),dyTimesScaleValue=mul(dy,scaleValue),oneOverSqrtVariance=rsqrt(add2(variance,scalar(varianceEpsilon))),minusHalfRCube=mul(mul(mul(oneOverSqrtVariance,oneOverSqrtVariance),oneOverSqrtVariance),scalar(-.5)),derX=()=>mean7.rank===1?reshape(mul(mul(dy,tile(reshape(oneOverSqrtVariance,[1,1,1,mean7.shape[0]]),tileShape)),scaleValue),x.shape):reshape(mul(mul(dy,oneOverSqrtVariance),scaleValue),x.shape),derMean=()=>{let meanDer=mul(mul(oneOverSqrtVariance,scalar(-1)),dyTimesScaleValue);return mean7.rank===1&&(meanDer=sum2(meanDer,reductionAxes)),reshape(meanDer,mean7.shape)},derVariance=()=>{let varianceDer=mul(mul(minusHalfRCube,xMinusMean),dyTimesScaleValue);return mean7.rank===1&&(varianceDer=sum2(varianceDer,reductionAxes)),reshape(varianceDer,mean7.shape)},derScale=()=>{let xMinusMean2TimesRsqrt=mul(xMinusMean,oneOverSqrtVariance),scaleDer=mul(dy,xMinusMean2TimesRsqrt);return mean7.rank===1&&(scaleDer=sum2(scaleDer,reductionAxes)),reshape(scaleDer,mean7.shape)},derOffset=()=>{let offsetDer=dy;return mean7.rank===1&&(offsetDer=sum2(offsetDer,reductionAxes)),reshape(offsetDer,mean7.shape)};return{x:derX,mean:derMean,variance:derVariance,scale:derScale,offset:derOffset}}};var gatherGradConfig={kernelName:GatherV2,inputsToSave:["x","indices"],gradFunc:(dy,saved,attrs)=>{let[x,indices]=saved,{axis}=attrs,parsedAxis=parseAxisParam(axis,x.shape)[0],derX=()=>{let paramsShape=x.shape,indicesSize=indices.size,outerShape=paramsShape.slice(0,parsedAxis),outerDims=outerShape.length,innerShape=paramsShape.slice(axis,paramsShape.length).slice(1),innerDims=innerShape.length,outerAxesIndices=arrayRange(0,outerDims),innerAxesIndices=arrayRange(outerDims+1,outerDims+1+innerDims),valuesShape=arrayConcat([outerShape,[indicesSize],innerShape]),values=reshape(dy,valuesShape),reshapedIndices=reshape(indices,[indicesSize]),transposeDims=arrayConcat([[outerDims],outerAxesIndices,innerAxesIndices]),valuesTranspose=transpose(values,transposeDims),paramsGrad=unsortedSegmentSum(valuesTranspose,reshapedIndices,x.shape[parsedAxis]),invertTransposeDims=getUndoAxesPermutation(transposeDims);return paramsGrad=transpose(paramsGrad,invertTransposeDims),paramsGrad};return{x:derX,indices:()=>indices}}};function arrayRange(start,stop){let result=[];for(let i=start;i<stop;++i)result.push(i);return result}function arrayConcat(arrays){let result=[];for(let i=0;i<arrays.length;++i)for(let j=0;j<arrays[i].length;++j)result.push(arrays[i][j]);return result}var greaterEqualGradConfig={kernelName:GreaterEqual,inputsToSave:["a","b"],gradFunc:(dy,saved)=>{let[a,b]=saved;return{a:()=>zerosLike(a),b:()=>zerosLike(b)}}};var identityGradConfig={kernelName:Identity,gradFunc:dy=>({x:()=>cast(dy,"float32")})};var isFiniteGradConfig={kernelName:IsFinite,gradFunc:dy=>({x:()=>zerosLike(dy)})};var isInfGradConfig={kernelName:IsInf,gradFunc:dy=>({x:()=>zerosLike(dy)})};var isNanGradConfig={kernelName:IsNan,gradFunc:dy=>({x:()=>zerosLike(dy)})};var log1pGradConfig={kernelName:Log1p,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>div(dy,add2(x,1))}}};var logGradConfig={kernelName:Log,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>div(dy,cast(x,"float32"))}}};var logSoftmaxGradConfig={kernelName:LogSoftmax,inputsToSave:[],outputsToSave:[!0],gradFunc:(dy,saved,attrs)=>{let[value]=saved,{axis}=attrs;return{logits:()=>{let keepDims=!0,softmax4=exp(value);return sub(dy,mul(sum2(dy,axis,keepDims),softmax4))}}}};function localResponseNormalizationBackprop_(x,y,dy,depthRadius=5,bias=1,alpha=1,beta=.5){let forward=backend3=>backend3.LRNGrad(dy,x,y,depthRadius,bias,alpha,beta),inputs={x,y,dy},attrs={depthRadius,bias,alpha,beta};return ENGINE.runKernelFunc(forward,inputs,null,LRNBackprop,attrs)}var localResponseNormalizationBackprop=op({localResponseNormalizationBackprop_});var lrnGradConfig={kernelName:LRN,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(dy,saved,attrs)=>{let[x,y]=saved,{depthRadius,bias,alpha,beta}=attrs;return{x:()=>localResponseNormalizationBackprop(x,y,dy,depthRadius,bias,alpha,beta)}}};function gradForMinAndMax(dy,y,xOrig,origAxes){return y.rank<xOrig.rank&&(y=reshape(y,expandShapeToKeepDim(y.shape,origAxes))),dy.rank<xOrig.rank&&(dy=reshape(dy,expandShapeToKeepDim(dy.shape,origAxes))),{x:()=>{let dx=mul(dy,cast(equal(xOrig,y),dy.dtype));return dx}}}var maxGradConfig={kernelName:Max,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(dy,saved,attrs)=>{let maxAttrs=attrs,{reductionIndices}=maxAttrs,x=saved[0],y=saved[1],origAxes=parseAxisParam(reductionIndices,x.shape),maxGrad=gradForMinAndMax(dy,y,x,origAxes);return{x:()=>maxGrad.x()}}};var maximumGradConfig={kernelName:Maximum,inputsToSave:["a","b"],gradFunc:(dy,saved)=>{let[a,b]=saved,derA=()=>mul(dy,cast(greaterEqual(a,b),"float32")),derB=()=>mul(dy,cast(less(a,b),"float32"));return{a:derA,b:derB}}};function maxPool3dBackprop_(dy,input2,output,filterSize,strides,dilations=[1,1,1],pad6,dimRoundingMode){let $dy=convertToTensor(dy,"dy","maxPool3dBackprop"),$input=convertToTensor(input2,"input","maxPool3dBackprop"),$output=convertToTensor(output,"output","maxPool3dBackprop"),dy5D=$dy,input5D=$input,output5D=$output,reshapedTo5D=!1;$input.rank===4&&(reshapedTo5D=!0,dy5D=reshape($dy,[1,$dy.shape[0],$dy.shape[1],$dy.shape[2],$dy.shape[3]]),input5D=reshape($input,[1,$input.shape[0],$input.shape[1],$input.shape[2],$input.shape[3]]),output5D=reshape($output,[1,$output.shape[0],$output.shape[1],$output.shape[2],$output.shape[3]])),assert(dy5D.rank===5,()=>`Error in maxPool3dBackprop: dy must be rank 5 but got rank ${dy5D.rank}.`),assert(input5D.rank===5,()=>`Error in maxPool3dBackprop: input must be rank 5 but got rank ${input5D.rank}.`),assert(output5D.rank===5,()=>`Error in maxPool3dBackprop: output must be rank 5 but got rank ${output5D.rank}.`),assert(eitherStridesOrDilationsAreOne(strides,dilations),()=>`Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`),dimRoundingMode!=null&&assert(isInt(pad6),()=>`Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad6}.`);let forward=backend3=>{let convInfo=computePool3DInfo(input5D.shape,filterSize,strides,dilations,pad6,dimRoundingMode);return backend3.maxPool3dBackprop(dy5D,input5D,output5D,convInfo)},inputs={dy:dy5D,input:input5D,output:output5D},attrs={filterSize,strides,dilations,pad:pad6,dimRoundingMode},res=ENGINE.runKernelFunc(forward,inputs,null,MaxPool3DBackprop,attrs);return reshapedTo5D?reshape(res,[res.shape[1],res.shape[2],res.shape[3],res.shape[4]]):res}var maxPool3dBackprop=op({maxPool3dBackprop_});var maxPool3DGradConfig={kernelName:MaxPool3D,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(dy,saved,attrs)=>{let[x,y]=saved,{filterSize,strides,dilations,pad:pad6,dimRoundingMode}=attrs,$dilations=dilations==null?[1,1,1]:dilations;return{x:()=>maxPool3dBackprop(dy,x,y,filterSize,strides,$dilations,pad6,dimRoundingMode)}}};function maxPoolBackprop_(dy,input2,output,filterSize,strides,pad6,dimRoundingMode){let $dy=convertToTensor(dy,"dy","maxPoolBackprop"),$input=convertToTensor(input2,"input","maxPoolBackprop"),$output=convertToTensor(output,"output","maxPoolBackprop");assert($input.rank===$dy.rank,()=>`Rank of input (${$input.rank}) does not match rank of dy (${$dy.rank})`),assert($dy.rank===4,()=>`Error in maxPoolBackprop: dy must be rank 4 but got rank ${$dy.rank}.`),assert($input.rank===4,()=>`Error in maxPoolBackprop: input must be rank 4 but got rank ${$input.rank}.`),dimRoundingMode!=null&&assert(isInt(pad6),()=>`Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad6}.`);let forward=backend3=>{let convInfo=computePool2DInfo($input.shape,filterSize,strides,1,pad6,dimRoundingMode);return backend3.maxPoolBackprop($dy,$input,$output,convInfo)},inputs={dy:$dy,input:$input,output:$output},attrs={filterSize,strides,pad:pad6,dimRoundingMode};return ENGINE.runKernelFunc(forward,inputs,null,MaxPoolBackprop,attrs)}var maxPoolBackprop=op({maxPoolBackprop_});var maxPoolGradConfig={kernelName:MaxPool,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(dy,saved,attrs)=>{let[x,y]=saved,{filterSize,strides,pad:pad6}=attrs;return{x:()=>maxPoolBackprop(dy,x,y,filterSize,strides,pad6)}}};var minGradConfig={kernelName:Min,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(dy,saved,attrs)=>{let minAttrs=attrs,{axis}=minAttrs,[x,y]=saved,origAxes=parseAxisParam(axis,x.shape),minGrad=gradForMinAndMax(dy,y,x,origAxes);return{x:()=>minGrad.x()}}};var minimumGradConfig={kernelName:Minimum,inputsToSave:["a","b"],gradFunc:(dy,saved)=>{let[a,b]=saved,derA=()=>mul(dy,cast(lessEqual(a,b),"float32")),derB=()=>mul(dy,cast(greater(a,b),"float32"));return{a:derA,b:derB}}};var mirrorPadGradConfig={kernelName:MirrorPad,inputsToSave:["x"],gradFunc:(dy,saved,attrs)=>{let x=saved[0],{paddings}=attrs,begin=paddings.map(p2=>p2[0]);return{x:()=>slice(dy,begin,x.shape)}}};var modGradConfig={kernelName:Mod,inputsToSave:["a","b"],gradFunc:(dy,saved)=>{let[a,b]=saved,outShape=assertAndGetBroadcastShape(a.shape,b.shape),derA=()=>{let reduceAxes=getReductionAxes(a.shape,outShape);return reduceAxes.length>0?reshape(sum2(dy,reduceAxes),a.shape):dy},derB=()=>{let res=mul(dy,neg(floor(div(a,b)))),reduceAxes=getReductionAxes(b.shape,outShape);return reduceAxes.length>0?reshape(sum2(res,reduceAxes),b.shape):res};return{a:derA,b:derB}}};var multiplyGradConfig={kernelName:Multiply,inputsToSave:["a","b"],gradFunc:(dy,saved)=>{let[a,b]=saved,outShape=assertAndGetBroadcastShape(a.shape,b.shape),derA=()=>{let res=mul(dy,cast(b,"float32")),reduceAxes=getReductionAxes(a.shape,outShape);return reduceAxes.length>0?reshape(sum2(res,reduceAxes),a.shape):res},derB=()=>{let res=mul(dy,cast(a,"float32")),reduceAxes=getReductionAxes(b.shape,outShape);return reduceAxes.length>0?reshape(sum2(res,reduceAxes),b.shape):res};return{a:derA,b:derB}}};var negateGradConfig={kernelName:Negate,gradFunc:dy=>({x:()=>neg(dy)})};var oneHotGradConfig={kernelName:OneHot,inputsToSave:["indices"],gradFunc:(dy,saved)=>{let indices=saved[0];return{indices:()=>zeros(indices.shape,"float32")}}};var onesLikeGradConfig={kernelName:OnesLike,gradFunc:dy=>({x:()=>zerosLike(dy)})};var padV2GradConfig={kernelName:PadV2,inputsToSave:["x"],gradFunc:(dy,saved,attrs)=>{let x=saved[0],{paddings}=attrs,begin=paddings.map(p2=>p2[0]);return{x:()=>slice(dy,begin,x.shape)}}};var powGradConfig={kernelName:Pow,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(dy,saved)=>{let[a,b,y]=saved,base2=a,exp13=b,outShape=assertAndGetBroadcastShape(base2.shape,exp13.shape),derBase=()=>{let expFloat=cast(exp13,"float32"),res=mul(dy,mul(expFloat,pow(base2,sub(expFloat,scalar(1))))),reduceAxes=getReductionAxes(base2.shape,outShape);return reduceAxes.length>0&&(res=sum2(res,reduceAxes)),reshape(res,base2.shape)},derExp=()=>{let condition=greater(base2,0),logBase=where(condition,log(base2),zerosLike(base2)),res=mul(dy,mul(y,logBase)),reduceAxes=getReductionAxes(exp13.shape,outShape);return reduceAxes.length>0&&(res=sum2(res,reduceAxes)),reshape(res,exp13.shape)};return{a:derBase,b:derExp}}};var preluGradConfig={kernelName:Prelu,inputsToSave:["x","alpha"],gradFunc:(dy,saved)=>{let[x,alpha]=saved,mask=greater(x,0);return{x:()=>where(mask,dy,mul(dy,alpha)),alpha:()=>{let res=where(mask,zerosLike(dy),mul(dy,x)),reduceAxes=getReductionAxes(alpha.shape,dy.shape);return reduceAxes.length>0&&(res=sum2(res,reduceAxes)),reshape(res,alpha.shape)}}}};var reciprocalGradConfig={kernelName:Reciprocal,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>div(dy,neg(square(x)))}}};var relu6GradConfig={kernelName:Relu6,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved,mask=mul(lessEqual(x,6),step(x));return{x:()=>mul(dy,cast(mask,"float32"))}}};var reluGradConfig={kernelName:Relu,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>mul(dy,cast(step(x),"float32"))}}};var reshapeGradConfig={kernelName:Reshape,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>reshape(dy,x.shape)}}};var resizeBilinearGradConfig={kernelName:ResizeBilinear,inputsToSave:["images"],gradFunc:(dy,saved,attrs)=>{let[images]=saved,backPropKernelFunc=backend3=>{let{alignCorners}=attrs;return backend3.resizeBilinearBackprop(dy,images,alignCorners)},inputs={images},imagesDer=()=>ENGINE.runKernelFunc(backPropKernelFunc,inputs,null,ResizeBilinearGrad,attrs);return{images:imagesDer}}};var resizeNearestNeighborGradConfig={kernelName:ResizeNearestNeighbor,inputsToSave:["images"],gradFunc:(dy,saved,attrs)=>{let[images]=saved,backPropKernelFunc=backend3=>{let{alignCorners}=attrs;return backend3.resizeNearestNeighborBackprop(dy,images,alignCorners)},inputs={images},imagesDer=()=>ENGINE.runKernelFunc(backPropKernelFunc,inputs,null,ResizeNearestNeighborGrad,attrs);return{images:imagesDer}}};var reverseGradConfig={kernelName:Reverse,gradFunc:(dy,saved,attrs)=>{let{dims}=attrs,axes=parseAxisParam(dims,dy.shape);return{x:()=>reverse(dy,axes)}}};var roundGradConfig={kernelName:Round,gradFunc:dy=>({x:()=>zerosLike(dy)})};var rsqrtGradConfig={kernelName:Rsqrt,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>neg(div(dy,mul(pow(x,1.5),2)))}}};var selectV2PoolGradConfig={kernelName:SelectV2,inputsToSave:["condition"],gradFunc:(dy,saved)=>{let[condition]=saved;return{condition:()=>cast(zerosLike(condition),"float32"),t:()=>mul(dy,cast(condition,dy.dtype)),e:()=>mul(dy,cast(logicalNot(condition),dy.dtype))}}};var seluGradConfig={kernelName:Selu,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>{let mask=greater(x,scalar(0)),scaleAlpha2=scalar(SELU_SCALEALPHA),scale2=scalar(SELU_SCALE),greaterThanZeroDer=mul(dy,scale2),lessEqualZeroDer=mul(mul(dy,scaleAlpha2),exp(cast(x,"float32")));return where(mask,greaterThanZeroDer,lessEqualZeroDer)}}}};var sigmoidGradConfig={kernelName:Sigmoid,outputsToSave:[!0],gradFunc:(dy,saved)=>{let[y]=saved;return{x:()=>mul(dy,mul(y,sub(scalar(1),y)))}}};var signGradConfig={kernelName:Sign,gradFunc:dy=>({x:()=>zerosLike(dy)})};var sinGradConfig={kernelName:Sin,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>mul(cos(cast(x,"float32")),dy)}}};var sinhGradConfig={kernelName:Sinh,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>mul(cosh(cast(x,"float32")),dy)}}};var sliceGradConfig={kernelName:Slice,inputsToSave:["x"],gradFunc:(dy,saved,attrs)=>{let[x]=saved,{begin,size}=attrs,inputShape=x.shape,[begin_,size_]=parseSliceParams(x,begin,size),paddings=[];for(let i=0;i<dy.rank;i++)paddings.push([begin_[i],inputShape[i]-begin_[i]-size_[i]]);return{x:()=>pad(dy,paddings)}}};var softmaxGradConfig={kernelName:Softmax,outputsToSave:[!0],gradFunc:(dy,saved,attrs)=>{let[y]=saved,{dim}=attrs,keepDims=!0,dyTimesY=mul(dy,y);return{logits:()=>sub(dyTimesY,mul(sum2(dyTimesY,[dim],keepDims),y))}}};var softplusGradConfig={kernelName:Softplus,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>mul(dy,sigmoid(x))}}};var spaceToBatchNDGradConfig={kernelName:SpaceToBatchND,gradFunc:(dy,saved,attrs)=>{let{blockShape,paddings}=attrs;return{x:()=>batchToSpaceND(dy,blockShape,paddings)}}};var splitVGradConfig={kernelName:SplitV,gradFunc:(dy,saved,attrs)=>{let{axis}=attrs;return{x:()=>concat(dy,axis)}}};var sqrtGradConfig={kernelName:Sqrt,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>div(dy,mul(sqrt(cast(x,"float32")),2))}}};var squareGradConfig={kernelName:Square,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>mul(dy,mul(cast(x,"float32"),2))}}};var squaredDifferenceGradConfig={kernelName:SquaredDifference,inputsToSave:["a","b"],gradFunc:(dy,saved)=>{let[a,b]=saved,two=scalar(2),derA=()=>mul(dy,mul(two,sub(a,b))),derB=()=>mul(dy,mul(two,sub(b,a)));return{a:derA,b:derB}}};var stepGradConfig={kernelName:Step,gradFunc:dy=>({x:()=>zerosLike(dy)})};var subGradConfig={kernelName:Sub,inputsToSave:["a","b"],gradFunc:(dy,saved)=>{let[a,b]=saved,outShape=assertAndGetBroadcastShape(a.shape,b.shape),derA=()=>{let res=dy,reduceAxes=getReductionAxes(a.shape,outShape);return reduceAxes.length>0&&(res=sum2(res,reduceAxes)),reshape(res,a.shape)},derB=()=>{let res=dy,reduceAxes=getReductionAxes(b.shape,outShape);return reduceAxes.length>0&&(res=sum2(res,reduceAxes)),reshape(neg(res),b.shape)};return{a:derA,b:derB}}};var sumGradConfig={kernelName:Sum,inputsToSave:["x"],gradFunc:(dy,saved,attrs)=>{let[x]=saved,expandedDyShape=x.shape.slice(),{axis}=attrs,axes=parseAxisParam(axis,x.shape);axes.forEach(axis2=>{expandedDyShape[axis2]=1});let expandedDy=reshape(dy,expandedDyShape),derX=mul(expandedDy,ones2(x.shape,"float32"));return{x:()=>derX}}};var tanGradConfig={kernelName:Tan,inputsToSave:["x"],gradFunc:(dy,saved)=>{let[x]=saved;return{x:()=>div(dy,square(cos(x)))}}};var tanhGradConfig={kernelName:Tanh,outputsToSave:[!0],gradFunc:(dy,saved)=>{let[y]=saved;return{x:()=>mul(sub(scalar(1),square(y)),dy)}}};var tileGradConfig={kernelName:Tile,inputsToSave:["x"],gradFunc:(dy,saved,attrs)=>{let[x]=saved,{reps}=attrs,derX=()=>{let xGrad=zerosLike(x);if(x.rank===1)for(let i=0;i<reps[0];++i)xGrad=add2(xGrad,slice(dy,[i*x.shape[0]],[x.shape[0]]));else if(x.rank===2)for(let i=0;i<reps[0];++i)for(let j=0;j<reps[1];++j)xGrad=add2(xGrad,slice(dy,[i*x.shape[0],j*x.shape[1]],[x.shape[0],x.shape[1]]));else if(x.rank===3)for(let i=0;i<reps[0];++i)for(let j=0;j<reps[1];++j)for(let k=0;k<reps[2];++k)xGrad=add2(xGrad,slice(dy,[i*x.shape[0],j*x.shape[1],k*x.shape[2]],[x.shape[0],x.shape[1],x.shape[2]]));else if(x.rank===4)for(let i=0;i<reps[0];++i)for(let j=0;j<reps[1];++j)for(let k=0;k<reps[2];++k)for(let l=0;l<reps[3];++l)xGrad=add2(xGrad,slice(dy,[i*x.shape[0],j*x.shape[1],k*x.shape[2],l*x.shape[3]],[x.shape[0],x.shape[1],x.shape[2],x.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${x.rank} tensors yet.`);return xGrad};return{x:derX}}};var transposeGradConfig={kernelName:Transpose,gradFunc:(dy,saved,attrs)=>{let transposeAttrs=attrs,{perm}=transposeAttrs,undoPerm=getUndoAxesPermutation(perm);return{x:()=>transpose(dy,undoPerm)}}};var unpackGradConfig={kernelName:Unpack,gradFunc:(dy,saved,attrs)=>{let unpackAttrs=attrs,{axis}=unpackAttrs;return{value:()=>stack(dy,axis)}}};var unsortedSegmentSumGradConfig={kernelName:UnsortedSegmentSum,inputsToSave:["segmentIds"],gradFunc:(dy,saved)=>{let[segmentIds]=saved,derX=()=>gatherDropNegatives(dy,segmentIds);return{x:derX}}};function gatherDropNegatives(x,indices){let zeroClippedIndices=maximum(indices,zerosLike(indices)),gathered=gather(x,zeroClippedIndices),isPositive=greaterEqual(indices,scalar(0,"int32")),numIters=gathered.rank-isPositive.rank;for(let i=0;i<numIters;++i)isPositive=expandDims(isPositive,i+1);isPositive=logicalAnd(isPositive,ones2(gathered.shape,"bool"));let zeroSlice=zerosLike(gathered);return where(isPositive,gathered,zeroSlice)}var zerosLikeGradConfig={kernelName:ZerosLike,gradFunc:dy=>({x:()=>zerosLike(dy)})};var gradConfigs=[absGradConfig,acosGradConfig,acoshGradConfig,addGradConfig,addNGradConfig,argMaxGradConfig,argMinGradConfig,asinGradConfig,asinhGradConfig,atan2GradConfig,atanGradConfig,atanhGradConfig,avgPool3DGradConfig,avgPoolGradConfig,batchMatMulGradConfig,batchToSpaceNDGradConfig,broadcastToGradConfig,castGradConfig,ceilGradConfig,clipByValueGradConfig,concatGradConfig,conv2DBackpropInputGradConfig,conv2DGradConfig,conv3DGradConfig,cosGradConfig,coshGradConfig,cumsumGradConfig,depthwiseConv2dNativeGradConfig,dilation2dGradConfig,divGradConfig,eluGradConfig,erfGradConfig,expGradConfig,expm1GradConfig,floorDivGradConfig,floorGradConfig,fusedBatchNormGradConfig,gatherGradConfig,greaterEqualGradConfig,identityGradConfig,isFiniteGradConfig,isInfGradConfig,isNanGradConfig,log1pGradConfig,logGradConfig,logSoftmaxGradConfig,lrnGradConfig,maxGradConfig,maxGradConfig,maximumGradConfig,maxPool3DGradConfig,maxPoolGradConfig,minGradConfig,minimumGradConfig,mirrorPadGradConfig,modGradConfig,multiplyGradConfig,negateGradConfig,oneHotGradConfig,onesLikeGradConfig,padV2GradConfig,padV2GradConfig,powGradConfig,preluGradConfig,reciprocalGradConfig,relu6GradConfig,reluGradConfig,reshapeGradConfig,resizeBilinearGradConfig,resizeNearestNeighborGradConfig,reverseGradConfig,roundGradConfig,rsqrtGradConfig,selectV2PoolGradConfig,seluGradConfig,sigmoidGradConfig,signGradConfig,sinGradConfig,sinhGradConfig,sliceGradConfig,softmaxGradConfig,softplusGradConfig,spaceToBatchNDGradConfig,spaceToBatchNDGradConfig,splitVGradConfig,splitVGradConfig,sqrtGradConfig,squaredDifferenceGradConfig,squareGradConfig,stepGradConfig,subGradConfig,sumGradConfig,tanGradConfig,tanhGradConfig,tileGradConfig,transposeGradConfig,unpackGradConfig,unsortedSegmentSumGradConfig,zerosLikeGradConfig];for(let gradientConfig of gradConfigs)registerGradient(gradientConfig);Tensor.prototype.abs=function(){return this.throwIfDisposed(),abs(this)};Tensor.prototype.acos=function(){return this.throwIfDisposed(),acos(this)};Tensor.prototype.acosh=function(){return this.throwIfDisposed(),acosh(this)};Tensor.prototype.addStrict=function(x){return this.throwIfDisposed(),addStrict(this,x)};Tensor.prototype.add=function(b){return this.throwIfDisposed(),add2(this,b)};Tensor.prototype.all=function(axis,keepDims){return this.throwIfDisposed(),all(this,axis,keepDims)};Tensor.prototype.any=function(axis,keepDims){return this.throwIfDisposed(),any(this,axis,keepDims)};Tensor.prototype.argMax=function(axis){return this.throwIfDisposed(),argMax(this,axis)};Tensor.prototype.argMin=function(axis){return this.throwIfDisposed(),argMin(this,axis)};Tensor.prototype.asScalar=function(){return this.throwIfDisposed(),assert(this.size===1,()=>"The array must have only 1 element."),reshape(this,[])};Tensor.prototype.asType=function(dtype){return this.throwIfDisposed(),cast(this,dtype)};Tensor.prototype.as1D=function(){return this.throwIfDisposed(),reshape(this,[this.size])};Tensor.prototype.as2D=function(rows,columns){return this.throwIfDisposed(),reshape(this,[rows,columns])};Tensor.prototype.as3D=function(rows,columns,depth){return this.throwIfDisposed(),reshape(this,[rows,columns,depth])};Tensor.prototype.as4D=function(rows,columns,depth,depth2){return this.throwIfDisposed(),reshape(this,[rows,columns,depth,depth2])};Tensor.prototype.as5D=function(rows,columns,depth,depth2,depth3){return this.throwIfDisposed(),reshape(this,[rows,columns,depth,depth2,depth3])};Tensor.prototype.asin=function(){return this.throwIfDisposed(),asin(this)};Tensor.prototype.asinh=function(){return this.throwIfDisposed(),asinh(this)};Tensor.prototype.atan=function(){return this.throwIfDisposed(),atan(this)};Tensor.prototype.atan2=function(b){return this.throwIfDisposed(),atan2(this,b)};Tensor.prototype.atanh=function(){return this.throwIfDisposed(),atanh(this)};Tensor.prototype.avgPool=function(filterSize,strides,pad6,dimRoundingMode){return this.throwIfDisposed(),avgPool(this,filterSize,strides,pad6,dimRoundingMode)};Tensor.prototype.batchToSpaceND=function(blockShape,crops){return this.throwIfDisposed(),batchToSpaceND(this,blockShape,crops)};Tensor.prototype.batchNorm=function(mean7,variance,offset,scale2,varianceEpsilon){return this.throwIfDisposed(),batchNorm(this,mean7,variance,offset,scale2,varianceEpsilon)};Tensor.prototype.broadcastTo=function(shape){return this.throwIfDisposed(),broadcastTo(this,shape)};Tensor.prototype.cast=function(dtype){return this.throwIfDisposed(),cast(this,dtype)};Tensor.prototype.ceil=function(){return this.throwIfDisposed(),ceil(this)};Tensor.prototype.clipByValue=function(min7,max9){return this.throwIfDisposed(),clipByValue(this,min7,max9)};Tensor.prototype.concat=function(x,axis){return this.throwIfDisposed(),x instanceof Tensor&&(x=[x]),concat([this,...x],axis)};Tensor.prototype.conv1d=function(filter,stride,pad6,dataFormat,dilation,dimRoundingMode){return this.throwIfDisposed(),conv1d(this,filter,stride,pad6,dataFormat,dilation,dimRoundingMode)};Tensor.prototype.conv2dTranspose=function(filter,outputShape,strides,pad6,dimRoundingMode){return this.throwIfDisposed(),conv2dTranspose(this,filter,outputShape,strides,pad6,dimRoundingMode)};Tensor.prototype.conv2d=function(filter,strides,pad6,dataFormat,dilations,dimRoundingMode){return this.throwIfDisposed(),conv2d(this,filter,strides,pad6,dataFormat,dilations,dimRoundingMode)};Tensor.prototype.cos=function(){return this.throwIfDisposed(),cos(this)};Tensor.prototype.cosh=function(){return this.throwIfDisposed(),cosh(this)};Tensor.prototype.cumsum=function(axis,exclusive,reverse7){return this.throwIfDisposed(),cumsum(this,axis,exclusive,reverse7)};Tensor.prototype.depthToSpace=function(blockSize,dataFormat){return this.throwIfDisposed(),depthToSpace(this,blockSize,dataFormat)};Tensor.prototype.depthwiseConv2D=function(filter,strides,pad6,dataFormat,dilations,dimRoundingMode){return deprecationWarn("depthwiseConv2D is deprecated, use depthwiseConv2d instead"),this.throwIfDisposed(),depthwiseConv2d(this,filter,strides,pad6,dataFormat,dilations,dimRoundingMode)};Tensor.prototype.depthwiseConv2d=function(filter,strides,pad6,dataFormat,dilations,dimRoundingMode){return this.throwIfDisposed(),depthwiseConv2d(this,filter,strides,pad6,dataFormat,dilations,dimRoundingMode)};Tensor.prototype.dilation2d=function(filter,strides,pad6,dilations,dataFormat){return this.throwIfDisposed(),dilation2d(this,filter,strides,pad6,dilations,dataFormat)};Tensor.prototype.divNoNan=function(b){return this.throwIfDisposed(),divNoNan(this,b)};Tensor.prototype.divStrict=function(x){return this.throwIfDisposed(),divStrict(this,x)};Tensor.prototype.div=function(b){return this.throwIfDisposed(),div(this,b)};Tensor.prototype.dot=function(b){return this.throwIfDisposed(),dot(this,b)};Tensor.prototype.elu=function(){return this.throwIfDisposed(),elu(this)};Tensor.prototype.equalStrict=function(x){return this.throwIfDisposed(),equalStrict(this,x)};Tensor.prototype.equal=function(b){return this.throwIfDisposed(),equal(this,b)};Tensor.prototype.erf=function(){return this.throwIfDisposed(),erf(this)};Tensor.prototype.exp=function(){return this.throwIfDisposed(),exp(this)};Tensor.prototype.expandDims=function(axis){return this.throwIfDisposed(),expandDims(this,axis)};Tensor.prototype.expm1=function(){return this.throwIfDisposed(),expm1(this)};Tensor.prototype.fft=function(){return this.throwIfDisposed(),fft(this)};Tensor.prototype.flatten=function(){return this.throwIfDisposed(),reshape(this,[this.size])};Tensor.prototype.floor=function(){return this.throwIfDisposed(),floor(this)};Tensor.prototype.floorDiv=function(b){return this.throwIfDisposed(),floorDiv(this,b)};Tensor.prototype.gather=function(indices,axis){return this.throwIfDisposed(),gather(this,indices,axis)};Tensor.prototype.greaterEqualStrict=function(x){return this.throwIfDisposed(),greaterEqualStrict(this,x)};Tensor.prototype.greaterEqual=function(b){return this.throwIfDisposed(),greaterEqual(this,b)};Tensor.prototype.greaterStrict=function(x){return this.throwIfDisposed(),greaterStrict(this,x)};Tensor.prototype.greater=function(b){return this.throwIfDisposed(),greater(this,b)};Tensor.prototype.ifft=function(){return this.throwIfDisposed(),ifft(this)};Tensor.prototype.irfft=function(){return this.throwIfDisposed(),irfft(this)};Tensor.prototype.isFinite=function(){return this.throwIfDisposed(),isFinite2(this)};Tensor.prototype.isInf=function(){return this.throwIfDisposed(),isInf(this)};Tensor.prototype.isNaN=function(){return this.throwIfDisposed(),isNaN2(this)};Tensor.prototype.leakyRelu=function(alpha){return this.throwIfDisposed(),leakyRelu(this,alpha)};Tensor.prototype.lessEqualStrict=function(x){return this.throwIfDisposed(),lessEqualStrict(this,x)};Tensor.prototype.lessEqual=function(b){return this.throwIfDisposed(),lessEqual(this,b)};Tensor.prototype.lessStrict=function(x){return this.throwIfDisposed(),lessStrict(this,x)};Tensor.prototype.less=function(b){return this.throwIfDisposed(),less(this,b)};Tensor.prototype.localResponseNormalization=function(depthRadius,bias,alpha,beta){return this.throwIfDisposed(),localResponseNormalization(this,depthRadius,bias,alpha,beta)};Tensor.prototype.logSigmoid=function(){return this.throwIfDisposed(),logSigmoid(this)};Tensor.prototype.logSoftmax=function(axis){return this.throwIfDisposed(),logSoftmax(this,axis)};Tensor.prototype.logSumExp=function(axis,keepDims){return this.throwIfDisposed(),logSumExp(this,axis,keepDims)};Tensor.prototype.log=function(){return this.throwIfDisposed(),log(this)};Tensor.prototype.log1p=function(){return this.throwIfDisposed(),log1p(this)};Tensor.prototype.logicalAnd=function(b){return this.throwIfDisposed(),logicalAnd(this,b)};Tensor.prototype.logicalNot=function(){return this.throwIfDisposed(),logicalNot(this)};Tensor.prototype.logicalOr=function(b){return this.throwIfDisposed(),logicalOr(this,b)};Tensor.prototype.logicalXor=function(b){return this.throwIfDisposed(),logicalXor(this,b)};Tensor.prototype.matMul=function(b,transposeA,transposeB){return this.throwIfDisposed(),matMul(this,b,transposeA,transposeB)};Tensor.prototype.maxPool=function(filterSize,strides,pad6,dimRoundingMode){return this.throwIfDisposed(),maxPool(this,filterSize,strides,pad6,dimRoundingMode)};Tensor.prototype.max=function(axis,keepDims){return this.throwIfDisposed(),max(this,axis,keepDims)};Tensor.prototype.maximumStrict=function(x){return this.throwIfDisposed(),maximumStrict(this,x)};Tensor.prototype.maximum=function(b){return this.throwIfDisposed(),maximum(this,b)};Tensor.prototype.mean=function(axis,keepDims){return this.throwIfDisposed(),mean(this,axis,keepDims)};Tensor.prototype.min=function(axis,keepDims){return this.throwIfDisposed(),min(this,axis,keepDims)};Tensor.prototype.minimumStrict=function(x){return this.throwIfDisposed(),minimumStrict(this,x)};Tensor.prototype.minimum=function(b){return this.throwIfDisposed(),minimum(this,b)};Tensor.prototype.mirrorPad=function(paddings,mode){return this.throwIfDisposed(),mirrorPad(this,paddings,mode)};Tensor.prototype.modStrict=function(x){return this.throwIfDisposed(),modStrict(this,x)};Tensor.prototype.mod=function(b){return this.throwIfDisposed(),mod(this,b)};Tensor.prototype.mulStrict=function(x){return this.throwIfDisposed(),mulStrict(this,x)};Tensor.prototype.mul=function(b){return this.throwIfDisposed(),mul(this,b)};Tensor.prototype.neg=function(){return this.throwIfDisposed(),neg(this)};Tensor.prototype.norm=function(ord,axis,keepDims){return this.throwIfDisposed(),norm(this,ord,axis,keepDims)};Tensor.prototype.notEqualStrict=function(x){return this.throwIfDisposed(),notEqualStrict(this,x)};Tensor.prototype.notEqual=function(b){return this.throwIfDisposed(),notEqual(this,b)};Tensor.prototype.oneHot=function(depth,onValue=1,offValue=0){return this.throwIfDisposed(),oneHot(this,depth,onValue,offValue)};Tensor.prototype.onesLike=function(){return this.throwIfDisposed(),onesLike(this)};Tensor.prototype.pad=function(paddings,constantValue){return this.throwIfDisposed(),pad(this,paddings,constantValue)};Tensor.prototype.pool=function(windowShape,poolingType,padding2,dilationRate,strides){return this.throwIfDisposed(),pool(this,windowShape,poolingType,padding2,dilationRate,strides)};Tensor.prototype.powStrict=function(exp13){return this.throwIfDisposed(),powStrict(this,exp13)};Tensor.prototype.pow=function(exp13){return this.throwIfDisposed(),pow(this,exp13)};Tensor.prototype.prelu=function(alpha){return this.throwIfDisposed(),prelu(this,alpha)};Tensor.prototype.prod=function(axis,keepDims){return this.throwIfDisposed(),prod(this,axis,keepDims)};Tensor.prototype.reciprocal=function(){return this.throwIfDisposed(),reciprocal(this)};Tensor.prototype.relu=function(){return this.throwIfDisposed(),relu(this)};Tensor.prototype.relu6=function(){return this.throwIfDisposed(),relu6(this)};Tensor.prototype.reshapeAs=function(x){return this.throwIfDisposed(),reshape(this,x.shape)};Tensor.prototype.reshape=function(shape){return this.throwIfDisposed(),reshape(this,shape)};Tensor.prototype.resizeBilinear=function(newShape2D,alignCorners){return this.throwIfDisposed(),resizeBilinear(this,newShape2D,alignCorners)};Tensor.prototype.resizeNearestNeighbor=function(newShape2D,alignCorners){return this.throwIfDisposed(),resizeNearestNeighbor(this,newShape2D,alignCorners)};Tensor.prototype.reverse=function(axis){return this.throwIfDisposed(),reverse(this,axis)};Tensor.prototype.rfft=function(){return this.throwIfDisposed(),rfft(this)};Tensor.prototype.round=function(){return this.throwIfDisposed(),round(this)};Tensor.prototype.rsqrt=function(){return this.throwIfDisposed(),rsqrt(this)};Tensor.prototype.selu=function(){return this.throwIfDisposed(),selu(this)};Tensor.prototype.separableConv2d=function(depthwiseFilter,pointwiseFilter,strides,pad6,dilation,dataFormat){return this.throwIfDisposed(),separableConv2d(this,depthwiseFilter,pointwiseFilter,strides,pad6,dilation,dataFormat)};Tensor.prototype.sigmoid=function(){return this.throwIfDisposed(),sigmoid(this)};Tensor.prototype.sign=function(){return this.throwIfDisposed(),sign(this)};Tensor.prototype.sin=function(){return this.throwIfDisposed(),sin(this)};Tensor.prototype.sinh=function(){return this.throwIfDisposed(),sinh(this)};Tensor.prototype.slice=function(begin,size){return this.throwIfDisposed(),slice(this,begin,size)};Tensor.prototype.softmax=function(dim){return this.throwIfDisposed(),softmax(this,dim)};Tensor.prototype.softplus=function(){return this.throwIfDisposed(),softplus(this)};Tensor.prototype.spaceToBatchND=function(blockShape,paddings){return this.throwIfDisposed(),spaceToBatchND(this,blockShape,paddings)};Tensor.prototype.split=function(numOrSizeSplits,axis){return this.throwIfDisposed(),split(this,numOrSizeSplits,axis)};Tensor.prototype.sqrt=function(){return this.throwIfDisposed(),sqrt(this)};Tensor.prototype.square=function(){return this.throwIfDisposed(),square(this)};Tensor.prototype.squaredDifference=function(b){return this.throwIfDisposed(),squaredDifference(this,b)};Tensor.prototype.squaredDifferenceStrict=function(x){return this.throwIfDisposed(),squaredDifferenceStrict(this,x)};Tensor.prototype.squeeze=function(axis){return this.throwIfDisposed(),squeeze(this,axis)};Tensor.prototype.stack=function(x,axis){this.throwIfDisposed();let tensorsToBeStacked=x instanceof Tensor?[this,x]:[this,...x];return stack(tensorsToBeStacked,axis)};Tensor.prototype.step=function(alpha){return this.throwIfDisposed(),step(this,alpha)};Tensor.prototype.stridedSlice=function(begin,end,strides,beginMask,endMask,ellipsisMask,newAxisMask,shrinkAxisMask){return this.throwIfDisposed(),stridedSlice(this,begin,end,strides,beginMask,endMask,ellipsisMask,newAxisMask,shrinkAxisMask)};Tensor.prototype.subStrict=function(x){return this.throwIfDisposed(),subStrict(this,x)};Tensor.prototype.sub=function(b){return this.throwIfDisposed(),sub(this,b)};Tensor.prototype.sum=function(axis,keepDims){return this.throwIfDisposed(),sum2(this,axis,keepDims)};Tensor.prototype.tan=function(){return this.throwIfDisposed(),tan(this)};Tensor.prototype.tanh=function(){return this.throwIfDisposed(),tanh2(this)};Tensor.prototype.tile=function(reps){return this.throwIfDisposed(),tile(this,reps)};Tensor.prototype.toBool=function(){return this.throwIfDisposed(),cast(this,"bool")};Tensor.prototype.toFloat=function(){return this.throwIfDisposed(),cast(this,"float32")};Tensor.prototype.toInt=function(){return this.throwIfDisposed(),cast(this,"int32")};Tensor.prototype.topk=function(k,sorted){return this.throwIfDisposed(),topk(this,k,sorted)};Tensor.prototype.transpose=function(perm){return this.throwIfDisposed(),transpose(this,perm)};Tensor.prototype.unique=function(axis){return this.throwIfDisposed(),unique(this,axis)};Tensor.prototype.unsortedSegmentSum=function(segmentIds,numSegments){return this.throwIfDisposed(),unsortedSegmentSum(this,segmentIds,numSegments)};Tensor.prototype.unstack=function(axis){return this.throwIfDisposed(),unstack(this,axis)};Tensor.prototype.where=function(condition,x){return this.throwIfDisposed(),where(condition,this,x)};Tensor.prototype.zerosLike=function(){return this.throwIfDisposed(),zerosLike(this)};var _epsilon;function epsilon(){return _epsilon==null&&(_epsilon=backend2().epsilon()),_epsilon}function imageDataFormat(){return"channelsLast"}var AttributeError=class extends Error{constructor(message){super(message);Object.setPrototypeOf(this,AttributeError.prototype)}},RuntimeError=class extends Error{constructor(message){super(message);Object.setPrototypeOf(this,RuntimeError.prototype)}},ValueError=class extends Error{constructor(message){super(message);Object.setPrototypeOf(this,ValueError.prototype)}},NotImplementedError=class extends Error{constructor(message){super(message);Object.setPrototypeOf(this,NotImplementedError.prototype)}},AssertionError=class extends Error{constructor(message){super(message);Object.setPrototypeOf(this,AssertionError.prototype)}},IndexError=class extends Error{constructor(message){super(message);Object.setPrototypeOf(this,IndexError.prototype)}};function pyListRepeat(value,numValues){if(Array.isArray(value)){let newArray=[];for(let i=0;i<numValues;i++)newArray=newArray.concat(value);return newArray}else{let newArray=new Array(numValues);return newArray.fill(value),newArray}}function assert2(val,message){if(!val)throw new AssertionError(message)}function count(array2,refernce){let counter=0;for(let item of array2)item===refernce&&counter++;return counter}function singletonOrArray(xs){return xs.length===1?xs[0]:xs}function toList(x){return Array.isArray(x)?x:[x]}function toSnakeCase(name){let intermediate=name.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2"),insecure=intermediate.replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return insecure[0]!=="_"?insecure:"private"+insecure}function toCamelCase(identifier){return identifier.length<=1||identifier.indexOf("_")===-1?identifier:identifier.replace(/[_]+(\w|$)/g,(m,p1)=>p1.toUpperCase())}var _GLOBAL_CUSTOM_OBJECTS={};function serializeKerasObject(instance){if(instance==null)return null;let dict={};return dict.className=instance.getClassName(),dict.config=instance.getConfig(),dict}function convertNDArrayScalarsInConfig(config){if(config==null||typeof config!="object")return;if(Array.isArray(config))config.forEach(configItem=>convertNDArrayScalarsInConfig(configItem));else{let fields=Object.keys(config);for(let field of fields){let value=config[field];value!=null&&typeof value=="object"&&(!Array.isArray(value)&&value.type==="ndarray"&&typeof value.value=="number"?config[field]=value.value:convertNDArrayScalarsInConfig(value))}}}function deserializeKerasObject(identifier,moduleObjects={},customObjects={},printableModuleName="object",fastWeightInit=!1){if(typeof identifier=="string"){let functionName=identifier,fn;if(functionName in customObjects)fn=customObjects[functionName];else if(functionName in _GLOBAL_CUSTOM_OBJECTS)fn=_GLOBAL_CUSTOM_OBJECTS[functionName];else if(fn=moduleObjects[functionName],fn==null)throw new ValueError(`Unknown ${printableModuleName}: ${identifier}. This may be due to one of the following reasons:
1. The ${printableModuleName} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${printableModuleName} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return fn}else{let config=identifier;if(config.className==null||config.config==null)throw new ValueError(`${printableModuleName}: Improper config format: ${JSON.stringify(config)}.
'className' and 'config' must set.`);let className=config.className,cls,fromConfig;if(className in customObjects?[cls,fromConfig]=customObjects[className]:className in _GLOBAL_CUSTOM_OBJECTS?[cls,fromConfig]=_GLOBAL_CUSTOM_OBJECTS.className:className in moduleObjects&&([cls,fromConfig]=moduleObjects[className]),cls==null)throw new ValueError(`Unknown ${printableModuleName}: ${className}. This may be due to one of the following reasons:
1. The ${printableModuleName} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${printableModuleName} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(fromConfig!=null){let customObjectsCombined={};for(let key of Object.keys(_GLOBAL_CUSTOM_OBJECTS))customObjectsCombined[key]=_GLOBAL_CUSTOM_OBJECTS[key];for(let key of Object.keys(customObjects))customObjectsCombined[key]=customObjects[key];let nestedConfig=config.config;nestedConfig.customObjects=customObjectsCombined;let backupCustomObjects=Object.assign({},_GLOBAL_CUSTOM_OBJECTS);for(let key of Object.keys(customObjects))_GLOBAL_CUSTOM_OBJECTS[key]=customObjects[key];convertNDArrayScalarsInConfig(config.config);let returnObj=fromConfig(cls,config.config,customObjects,fastWeightInit);return _GLOBAL_CUSTOM_OBJECTS=Object.assign({},backupCustomObjects),returnObj}else{let backupCustomObjects=Object.assign({},_GLOBAL_CUSTOM_OBJECTS);for(let key of Object.keys(customObjects))_GLOBAL_CUSTOM_OBJECTS[key]=customObjects[key];let returnObj=new cls(config.config);return _GLOBAL_CUSTOM_OBJECTS=Object.assign({},backupCustomObjects),returnObj}}}function numberCompare(a,b){return a<b?-1:a>b?1:0}function reverseNumberCompare(a,b){return-1*numberCompare(a,b)}function unique5(xs){if(xs==null)return xs;let out=[];for(let x of xs)out.indexOf(x)===-1&&out.push(x);return out}function isObjectEmpty(obj){if(obj==null)throw new ValueError(`Invalid value in obj: ${JSON.stringify(obj)}`);for(let key in obj)if(obj.hasOwnProperty(key))return!1;return!0}function checkStringTypeUnionValue(values,label,value){if(value==null)return;if(values.indexOf(value)<0)throw new ValueError(`${value} is not a valid ${label}.  Valid values are ${values} or null/undefined.`)}function checkArrayTypeAndLength(x,expectedType,minLength=0,maxLength=Infinity){return assert2(minLength>=0),assert2(maxLength>=minLength),Array.isArray(x)&&x.length>=minLength&&x.length<=maxLength&&x.every(e=>typeof e===expectedType)}function assertPositiveInteger(value,name){Array.isArray(value)?(util_exports.assert(value.length>0,()=>`${name} is unexpectedly an empty array.`),value.forEach((v,i)=>assertPositiveInteger(v,`element ${i+1} of ${name}`))):util_exports.assert(Number.isInteger(value)&&value>0,()=>`Expected ${name} to be a positive integer, but got ${formatAsFriendlyString(value)}.`)}function formatAsFriendlyString(value){return value===null?"null":Array.isArray(value)?"["+value.map(v=>formatAsFriendlyString(v)).join(",")+"]":typeof value=="string"?`"${value}"`:`${value}`}function debounce(f,waitMs){let lastTime=util_exports.now(),lastResult,f2=(...args)=>{let now2=util_exports.now();return now2-lastTime<waitMs||(lastTime=now2,lastResult=f(...args)),lastResult};return f2}function mapActivationToFusedKernel(activationName){return activationName==="relu"?"relu":activationName==="linear"?"linear":activationName==="elu"?"elu":null}function calcL2Norms(w,axis){return tidy(()=>sqrt(sum2(mul(w,w),axis,!0)))}var Constraint=class extends serialization_exports.Serializable{getConfig(){return{}}},MaxNorm=class extends Constraint{constructor(args){super();this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=args.maxValue!=null?args.maxValue:this.defaultMaxValue,this.axis=args.axis!=null?args.axis:this.defaultAxis}apply(w){return tidy(()=>{let norms=calcL2Norms(w,this.axis),desired=clipByValue(norms,0,this.maxValue);return mul(w,div(desired,add2(epsilon(),norms)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};MaxNorm.className="MaxNorm";serialization_exports.registerClass(MaxNorm);var UnitNorm=class extends Constraint{constructor(args){super();this.defaultAxis=0,this.axis=args.axis!=null?args.axis:this.defaultAxis}apply(w){return tidy(()=>div(w,add2(epsilon(),calcL2Norms(w,this.axis))))}getConfig(){return{axis:this.axis}}};UnitNorm.className="UnitNorm";serialization_exports.registerClass(UnitNorm);var NonNeg=class extends Constraint{apply(w){return relu(w)}};NonNeg.className="NonNeg";serialization_exports.registerClass(NonNeg);var MinMaxNorm=class extends Constraint{constructor(args){super();this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=args.minValue!=null?args.minValue:this.defaultMinValue,this.maxValue=args.maxValue!=null?args.maxValue:this.defaultMaxValue,this.rate=args.rate!=null?args.rate:this.defaultRate,this.axis=args.axis!=null?args.axis:this.defaultAxis}apply(w){return tidy(()=>{let norms=calcL2Norms(w,this.axis),desired=add2(mul(this.rate,clipByValue(norms,this.minValue,this.maxValue)),mul(1-this.rate,norms));return mul(w,div(desired,add2(epsilon(),norms)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};MinMaxNorm.className="MinMaxNorm";serialization_exports.registerClass(MinMaxNorm);var CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function serializeConstraint(constraint){return serializeKerasObject(constraint)}function deserializeConstraint(config,customObjects={}){return deserializeKerasObject(config,serialization_exports.SerializationMap.getMap().classNameMap,customObjects,"constraint")}function getConstraint(identifier){if(identifier==null)return null;if(typeof identifier=="string"){let className=identifier in CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP?CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier]:identifier,config={className,config:{}};return deserializeConstraint(config)}else return identifier instanceof Constraint?identifier:deserializeConstraint(identifier)}var VALID_DATA_FORMAT_VALUES=["channelsFirst","channelsLast"],VALID_PADDING_MODE_VALUES=["valid","same","causal"],VALID_POOL_MODE_VALUES=["max","avg"],VALID_BIDIRECTIONAL_MERGE_MODES=["sum","mul","concat","ave"];var nameMap=new Map;function checkDataFormat(value){checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES,"DataFormat",value)}function checkPaddingMode(value){checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES,"PaddingMode",value)}function checkPoolMode(value){checkStringTypeUnionValue(VALID_POOL_MODE_VALUES,"PoolMode",value)}var _nameScopeStack=[],_nameScopeDivider="/";function nameScope(name,fn){_nameScopeStack.push(name);try{let val=fn();return _nameScopeStack.pop(),val}catch(e){throw _nameScopeStack.pop(),e}}function currentNameScopePrefix(){return _nameScopeStack.length===0?"":_nameScopeStack.join(_nameScopeDivider)+_nameScopeDivider}function getScopedTensorName(tensorName){if(!isValidTensorName(tensorName))throw new Error("Not a valid tensor name: '"+tensorName+"'");return currentNameScopePrefix()+tensorName}function getUniqueTensorName(scopedName){if(!isValidTensorName(scopedName))throw new Error("Not a valid tensor name: '"+scopedName+"'");nameMap.has(scopedName)||nameMap.set(scopedName,0);let index=nameMap.get(scopedName);if(nameMap.set(scopedName,nameMap.get(scopedName)+1),index>0){let result=`${scopedName}_${index}`;return nameMap.set(result,1),result}else return scopedName}var tensorNameRegex=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function isValidTensorName(name){return!!name.match(tensorNameRegex)}function isInteger(x){return x===parseInt(x.toString(),10)}function arrayProd(array2,begin,end){begin==null&&(begin=0),end==null&&(end=array2.length);let prod5=1;for(let i=begin;i<end;++i)prod5*=array2[i];return prod5}function toArray1D(array2){return array2=Array.isArray(array2)?new Float32Array(array2):array2,tensor1d(array2)}function min6(array2){return min(toArray1D(array2)).dataSync()[0]}function max8(array2){return max(toArray1D(array2)).dataSync()[0]}function range4(begin,end){if(end<begin)throw new ValueError(`end (${end}) < begin (${begin}) is forbidden.`);let out=[];for(let i=begin;i<end;++i)out.push(i);return out}function cast47(x,dtype){return x.asType(dtype)}function expandDims2(x,axis=-1){let outShape=x.shape.slice();return axis<0&&(axis=outShape.length+axis+1),outShape.splice(axis,0,1),x.reshape(outShape)}function repeat(x,n){return tidy(()=>{if(x.shape.length!==2)throw new ValueError(`repeat() expects a rank-2 tensor, but received a rank-${x.shape.length} tensor.`);let y=expandDims2(x,1);return tile8(y,[1,n,1])})}function flatten3(x){let newShape=[arrayProd(x.shape)];return x.reshape(newShape)}function batchFlatten(x){if(x.rank<=1)throw new ValueError(`batchFlatten requires a minimum rank of 2. Got rank: ${x.rank}.`);let newShape=[x.shape[0],arrayProd(x.shape,1)];return x.reshape(newShape)}function sliceAlongFirstAxis(array2,start,size){return tidy(()=>{switch(array2.rank){case 1:return slice1d(array2,start,size);case 2:return slice2d(array2,[start,0],[size,array2.shape[1]]);case 3:return slice3d(array2,[start,0,0],[size,array2.shape[1],array2.shape[2]]);case 4:return slice4d(array2,[start,0,0,0],[size,array2.shape[1],array2.shape[2],array2.shape[3]]);case 5:return slice(array2,[start,0,0,0,0],[size,array2.shape[1],array2.shape[2],array2.shape[3],array2.shape[4]]);case 6:return slice(array2,[start,0,0,0,0,0],[size,array2.shape[1],array2.shape[2],array2.shape[3],array2.shape[4],array2.shape[5]]);default:throw new ValueError(`sliceAlongFirstAxis() received an unsupported tensor rank: ${array2.rank}`)}})}function sliceAlongLastAxis(array2,start,size){return tidy(()=>{switch(array2.rank){case 1:return slice1d(array2,start,size);case 2:return slice2d(array2,[0,start],[array2.shape[0],size]);case 3:return slice3d(array2,[0,0,start],[array2.shape[0],array2.shape[1],size]);case 4:return slice4d(array2,[0,0,0,start],[array2.shape[0],array2.shape[1],array2.shape[2],size]);default:throw new ValueError(`sliceAlongLastAxis() received an unsupported tensor rank: ${array2.rank}`)}})}function sliceAlongAxis(array2,start,size,axis){return tidy(()=>{switch(array2.rank){case 1:return slice1d(array2,start,size);case 2:switch(axis){case 1:return sliceAlongFirstAxis(array2,start,size);case 2:return sliceAlongLastAxis(array2,start,size);default:throw new ValueError(`The axis is not within the rank of the tensor ${axis}`)}case 3:switch(axis){case 1:return sliceAlongFirstAxis(array2,start,size);case 2:return slice3d(array2,[0,start,0],[array2.shape[0],size,array2.shape[2]]);case 3:return sliceAlongLastAxis(array2,start,size);default:throw new ValueError(`The axis is not within the rank of the tensor ${axis}`)}case 4:switch(axis){case 1:return sliceAlongFirstAxis(array2,start,size);case 2:return slice4d(array2,[0,start,0,0],[array2.shape[0],size,array2.shape[2],array2.shape[3]]);case 3:return slice4d(array2,[0,0,start,0],[array2.shape[0],array2.shape[1],size,array2.shape[3]]);case 4:return sliceAlongLastAxis(array2,start,size);default:throw new ValueError(`The axis is not within the rank of the tensor ${axis}`)}default:throw new ValueError(`sliceAlongLastAxis() received an unsupported tensor rank: ${array2.rank}`)}})}function concatenate(tensors,axis=-1){let rank;return axis<0&&(rank=tensors[0].rank,rank!==0?axis=rank:axis=0),axis===tensors[0].rank&&(axis=-1),concat(tensors,axis)}function concatAlongFirstAxis(a,b){switch(a.rank){case 1:return concat1d([a,b]);case 2:return concat2d([a,b],0);case 3:return concat3d([a,b],0);case 4:return concat4d([a,b],0);default:throw new ValueError(`concatAlongFirstAxis() received an unsupported tensor rank: ${a.rank}`)}}function tile8(x,n){if(Array.isArray(n)||(n=[n]),x.rank!==n.length)throw new ValueError(`The length of input n (${n.length}) does not match the number of dimensions in input x (${x.rank})`);return tile(x,n)}function randomNormal2(shape,mean7=0,stddev=1,dtype,seed){return randomNormal(shape,mean7,stddev,dtype,seed)}function dot5(a,b,activation,bias){if(a.rank<2||b.rank<2)throw new NotImplementedError(`dot requires both inputs to be rank >= 2 but got x shape = ${a.shape} and y shape = ${b.shape}`);if(b.rank>=3){let xLastDim=a.shape.slice(-1)[0],ySecondLastDim=b.shape.slice(-2)[0];if(xLastDim!==ySecondLastDim)throw new NotImplementedError(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${a.shape} and  y shape = ${b.shape}`)}if(a.rank===2&&b.rank===2){let transposeA=!1,transposeB=!1;return fused_ops_exports.matMul({a,b,transposeA,transposeB,bias:bias?reshapeBias(a.rank,bias,imageDataFormat()):null,activation})}else{let aFirstDims=a.shape.slice(),aLastDim=aFirstDims.pop();a=a.reshape([-1,aLastDim]);let bShape=b.shape.slice(),bLastDim=bShape.pop(),ySecondLastDim=bShape.pop(),yOtherDims=[...bShape,bLastDim],perm=Array.from({length:b.rank},(_,i)=>i===0?b.rank-2:i<=b.rank-2?i-1:i);b=b.transpose(perm).reshape([ySecondLastDim,-1]);let outputShape=[...aFirstDims,...yOtherDims],transposeA=!1,transposeB=!1;return fused_ops_exports.matMul({a,b,transposeA,transposeB,bias:bias?reshapeBias(a.rank,bias,imageDataFormat()):null,activation}).reshape(outputShape)}}function gather6(reference,indices,axis){return tidy(()=>(Array.isArray(indices)?indices=tensor1d(indices,"int32"):indices=indices.toInt(),gather(reference,indices,axis)))}function square24(x){return mul(x,x)}function reshapeBias(xRank,bias,dataFormat){let biasShape=bias.shape;if(bias.rank!==1&&bias.rank!==xRank)throw new ValueError(`Unexpected bias dimensions: ${bias.rank}; expected it to be 1 or ${xRank}`);if(xRank===5){if(dataFormat==="channelsFirst")return biasShape.length===1?bias.reshape([1,biasShape[0],1,1,1]):bias.reshape([1,biasShape[3],biasShape[0],biasShape[1],biasShape[2]]);if(dataFormat==="channelsLast")return biasShape.length===1?bias.reshape([1,1,1,1,biasShape[0]]):bias.reshape([1].concat(biasShape))}else if(xRank===4){if(dataFormat==="channelsFirst")return biasShape.length===1?bias.reshape([1,biasShape[0],1,1]):bias.reshape([1,biasShape[2],biasShape[0],biasShape[1]]);if(dataFormat==="channelsLast")return biasShape.length===1?bias.reshape([1,1,1,biasShape[0]]):bias.reshape([1].concat(biasShape))}else if(xRank===3){if(dataFormat==="channelsFirst")return biasShape.length===1?bias.reshape([1,biasShape[0],1]):bias.reshape([1,biasShape[1],biasShape[0]]);if(dataFormat==="channelsLast")return biasShape.length===1?bias.reshape([1,1,biasShape[0]]):bias.reshape([1].concat(biasShape))}else if(xRank<3)return bias;throw new ValueError(`Unsupported input rank by biasAdd: ${bias.rank}`)}function biasAdd(x,bias,dataFormat){return tidy(()=>(dataFormat==null&&(dataFormat=imageDataFormat()),checkDataFormat(dataFormat),x.add(reshapeBias(x.rank,bias,dataFormat))))}function elu6(x,alpha=1){if(alpha!==1)throw new NotImplementedError(`Support for alpha values other than 1 (${alpha}) is not implemented yet.`);return elu(x)}function softsign(x){return tidy(()=>div(x,abs(x).add(1)))}function dropout2(x,level,noiseShape,seed){return tidy(()=>dropout(x,level,noiseShape,seed))}function hardSigmoid(x){return tidy(()=>{let y=add2(.5,mul(.2,x));return clipByValue(y,0,1)})}function inTrainPhase(x,alt,training5=!1){return training5?x():alt()}var VALID_FAN_MODE_VALUES=["fanIn","fanOut","fanAvg"],VALID_DISTRIBUTION_VALUES=["normal","uniform","truncatedNormal"];function checkFanMode(value){checkStringTypeUnionValue(VALID_FAN_MODE_VALUES,"FanMode",value)}function checkDistribution(value){checkStringTypeUnionValue(VALID_DISTRIBUTION_VALUES,"Distribution",value)}var Initializer=class extends serialization_exports.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},Zeros=class extends Initializer{apply(shape,dtype){return zeros(shape,dtype)}};Zeros.className="Zeros";serialization_exports.registerClass(Zeros);var Ones=class extends Initializer{apply(shape,dtype){return ones2(shape,dtype)}};Ones.className="Ones";serialization_exports.registerClass(Ones);var Constant=class extends Initializer{constructor(args){super();if(typeof args!="object")throw new ValueError(`Expected argument of type ConstantConfig but got ${args}`);if(args.value===void 0)throw new ValueError(`config must have value set but got ${args}`);this.value=args.value}apply(shape,dtype){return tidy(()=>mul(scalar(this.value),ones2(shape,dtype)))}getConfig(){return{value:this.value}}};Constant.className="Constant";serialization_exports.registerClass(Constant);var RandomUniform=class extends Initializer{constructor(args){super();this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=args.minval||this.DEFAULT_MINVAL,this.maxval=args.maxval||this.DEFAULT_MAXVAL,this.seed=args.seed}apply(shape,dtype){return randomUniform(shape,this.minval,this.maxval,dtype)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};RandomUniform.className="RandomUniform";serialization_exports.registerClass(RandomUniform);var RandomNormal=class extends Initializer{constructor(args){super();this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=args.mean||this.DEFAULT_MEAN,this.stddev=args.stddev||this.DEFAULT_STDDEV,this.seed=args.seed}apply(shape,dtype){if(dtype=dtype||"float32",dtype!=="float32"&&dtype!=="int32")throw new NotImplementedError(`randomNormal does not support dType ${dtype}.`);return randomNormal2(shape,this.mean,this.stddev,dtype,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};RandomNormal.className="RandomNormal";serialization_exports.registerClass(RandomNormal);var TruncatedNormal=class extends Initializer{constructor(args){super();this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=args.mean||this.DEFAULT_MEAN,this.stddev=args.stddev||this.DEFAULT_STDDEV,this.seed=args.seed}apply(shape,dtype){if(dtype=dtype||"float32",dtype!=="float32"&&dtype!=="int32")throw new NotImplementedError(`truncatedNormal does not support dType ${dtype}.`);return truncatedNormal(shape,this.mean,this.stddev,dtype,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};TruncatedNormal.className="TruncatedNormal";serialization_exports.registerClass(TruncatedNormal);var Identity2=class extends Initializer{constructor(args){super();this.gain=args.gain!=null?args.gain:1}apply(shape,dtype){return tidy(()=>{if(shape.length!==2||shape[0]!==shape[1])throw new ValueError("Identity matrix initializer can only be used for 2D square matrices.");return mul(this.gain,eye(shape[0]))})}getConfig(){return{gain:this.gain}}};Identity2.className="Identity";serialization_exports.registerClass(Identity2);function computeFans(shape,dataFormat="channelsLast"){let fanIn,fanOut;if(checkDataFormat(dataFormat),shape.length===2)fanIn=shape[0],fanOut=shape[1];else if([3,4,5].indexOf(shape.length)!==-1){if(dataFormat==="channelsFirst"){let receptiveFieldSize=arrayProd(shape,2);fanIn=shape[1]*receptiveFieldSize,fanOut=shape[0]*receptiveFieldSize}else if(dataFormat==="channelsLast"){let receptiveFieldSize=arrayProd(shape,0,shape.length-2);fanIn=shape[shape.length-2]*receptiveFieldSize,fanOut=shape[shape.length-1]*receptiveFieldSize}}else{let shapeProd=arrayProd(shape);fanIn=Math.sqrt(shapeProd),fanOut=Math.sqrt(shapeProd)}return[fanIn,fanOut]}var VarianceScaling=class extends Initializer{constructor(args){super();if(args.scale<0)throw new ValueError(`scale must be a positive float. Got: ${args.scale}`);this.scale=args.scale==null?1:args.scale,this.mode=args.mode==null?"fanIn":args.mode,checkFanMode(this.mode),this.distribution=args.distribution==null?"normal":args.distribution,checkDistribution(this.distribution),this.seed=args.seed}apply(shape,dtype){let fans=computeFans(shape),fanIn=fans[0],fanOut=fans[1],scale2=this.scale;if(this.mode==="fanIn"?scale2/=Math.max(1,fanIn):this.mode==="fanOut"?scale2/=Math.max(1,fanOut):scale2/=Math.max(1,(fanIn+fanOut)/2),this.distribution==="normal"){let stddev=Math.sqrt(scale2);if(dtype=dtype||"float32",dtype!=="float32"&&dtype!=="int32")throw new NotImplementedError(`${this.getClassName()} does not support dType ${dtype}.`);return truncatedNormal(shape,0,stddev,dtype,this.seed)}else{let limit=Math.sqrt(3*scale2);return randomUniform(shape,-limit,limit,dtype)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};VarianceScaling.className="VarianceScaling";serialization_exports.registerClass(VarianceScaling);var GlorotUniform=class extends VarianceScaling{constructor(args){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:args==null?null:args.seed})}getClassName(){return VarianceScaling.className}};GlorotUniform.className="GlorotUniform";serialization_exports.registerClass(GlorotUniform);var GlorotNormal=class extends VarianceScaling{constructor(args){super({scale:1,mode:"fanAvg",distribution:"normal",seed:args==null?null:args.seed})}getClassName(){return VarianceScaling.className}};GlorotNormal.className="GlorotNormal";serialization_exports.registerClass(GlorotNormal);var HeNormal=class extends VarianceScaling{constructor(args){super({scale:2,mode:"fanIn",distribution:"normal",seed:args==null?null:args.seed})}getClassName(){return VarianceScaling.className}};HeNormal.className="HeNormal";serialization_exports.registerClass(HeNormal);var HeUniform=class extends VarianceScaling{constructor(args){super({scale:2,mode:"fanIn",distribution:"uniform",seed:args==null?null:args.seed})}getClassName(){return VarianceScaling.className}};HeUniform.className="HeUniform";serialization_exports.registerClass(HeUniform);var LeCunNormal=class extends VarianceScaling{constructor(args){super({scale:1,mode:"fanIn",distribution:"normal",seed:args==null?null:args.seed})}getClassName(){return VarianceScaling.className}};LeCunNormal.className="LeCunNormal";serialization_exports.registerClass(LeCunNormal);var LeCunUniform=class extends VarianceScaling{constructor(args){super({scale:1,mode:"fanIn",distribution:"uniform",seed:args==null?null:args.seed})}getClassName(){return VarianceScaling.className}};LeCunUniform.className="LeCunNormal";serialization_exports.registerClass(LeCunUniform);var Orthogonal=class extends Initializer{constructor(args){super();if(this.DEFAULT_GAIN=1,this.gain=args.gain==null?this.DEFAULT_GAIN:args.gain,this.seed=args.seed,this.seed!=null)throw new NotImplementedError("Random seed is not implemented for Orthogonal Initializer yet.")}apply(shape,dtype){return tidy(()=>{if(shape.length<2)throw new NotImplementedError("Shape must be at least 2D.");shape[0]*shape[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${shape[0]*shape[1]}) elements: Slowness may result.`);let normalizedShape=shape[0]>shape[1]?[shape[1],shape[0]]:shape,a=randomNormal2(normalizedShape,0,1,"float32"),q=linalg.gramSchmidt(a);return shape[0]>shape[1]&&(q=q.transpose()),mul(this.gain,q)})}getConfig(){return{gain:this.gain,seed:this.seed}}};Orthogonal.className="Orthogonal";serialization_exports.registerClass(Orthogonal);var INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function deserializeInitializer(config,customObjects={}){return deserializeKerasObject(config,serialization_exports.SerializationMap.getMap().classNameMap,customObjects,"initializer")}function serializeInitializer(initializer){return serializeKerasObject(initializer)}function getInitializer(identifier){if(typeof identifier=="string"){let className=identifier in INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP?INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier]:identifier;if(className==="GlorotNormal")return new GlorotNormal;if(className==="GlorotUniform")return new GlorotUniform;if(className==="HeNormal")return new HeNormal;if(className==="HeUniform")return new HeUniform;if(className==="LeCunNormal")return new LeCunNormal;if(className==="LeCunUniform")return new LeCunUniform;{let config={};return config.className=className,config.config={},deserializeInitializer(config)}}else return identifier instanceof Initializer?identifier:deserializeInitializer(identifier)}var _nextUniqueTensorId=0;function getNextUniqueTensorId(){return _nextUniqueTensorId++}var _uidPrefixes={};function getUid(prefix=""){return prefix in _uidPrefixes||(_uidPrefixes[prefix]=0),_uidPrefixes[prefix]+=1,prefix+_uidPrefixes[prefix].toString()}function isArrayOfShapes(x){return Array.isArray(x)&&Array.isArray(x[0])}function normalizeShapeList(x){return x.length===0?[]:Array.isArray(x[0])?x:[x]}function getExactlyOneTensor(xs){let x;if(Array.isArray(xs)){if(xs.length!==1)throw new ValueError(`Expected Tensor length to be 1; got ${xs.length}`);x=xs[0]}else x=xs;return x}function getExactlyOneShape(shapes){if(Array.isArray(shapes)&&Array.isArray(shapes[0])){if(shapes.length===1)return shapes=shapes,shapes[0];throw new ValueError(`Expected exactly 1 Shape; got ${shapes.length}`)}else return shapes}function countParamsInWeights(weights){let count2=0;for(let weight of weights)weight.shape.length===0?count2+=1:count2+=weight.shape.reduce((a,b)=>a*b);return count2}var DEFAULT_VARIABLE_NAME_PREFIX="Variable",LayerVariable=class{constructor(val,dtype="float32",name=DEFAULT_VARIABLE_NAME_PREFIX,trainable=!0,constraint=null){this.dtype=dtype==null?"float32":dtype,this.shape=val.shape,this.id=getNextUniqueTensorId(),name=name==null?DEFAULT_VARIABLE_NAME_PREFIX:name,this.originalName=getScopedTensorName(name),this.name=getUniqueTensorName(this.originalName),this.trainable_=trainable,this.constraint=constraint,this.val=variable(val,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(newVal){return this.assertNotDisposed(),checkShapesMatch(this.val,newVal),this.val.id!==newVal.id&&(this.val.assign(newVal),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(trainable){this.trainable_=trainable,this.val.trainable=trainable}};function checkShapesMatch(x,y){if(x.shape.toString()!==y.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(x.shape)+" vs. "+JSON.stringify(y.shape))}function batchGetValue(xs){return xs.map(x=>x.read())}function batchSetValue(variablesAndValues){variablesAndValues.forEach(variableAndValue=>{let variable3=variableAndValue[0];variable3.write(variableAndValue[1])})}var InputSpec=class{constructor(args){this.dtype=args.dtype,this.shape=args.shape,args.shape!=null?this.ndim=args.shape.length:this.ndim=args.ndim,this.maxNDim=args.maxNDim,this.minNDim=args.minNDim,this.axes=args.axes||{}}},SymbolicTensor=class{constructor(dtype,shape,sourceLayer,inputs,callArgs,name,outputTensorIndex){this.dtype=dtype,this.shape=shape,this.sourceLayer=sourceLayer,this.inputs=inputs,this.callArgs=callArgs,this.outputTensorIndex=outputTensorIndex,this.id=getNextUniqueTensorId(),name!=null&&(this.originalName=getScopedTensorName(name),this.name=getUniqueTensorName(this.originalName)),this.rank=shape.length}},_nextNodeID=0,Node=class{constructor(args,callArgs){this.callArgs=callArgs,this.id=_nextNodeID++,this.outboundLayer=args.outboundLayer,this.inboundLayers=args.inboundLayers,this.nodeIndices=args.nodeIndices,this.tensorIndices=args.tensorIndices,this.inputTensors=args.inputTensors,this.outputTensors=args.outputTensors,this.inputMasks=args.inputMasks,this.outputMasks=args.outputMasks,this.inputShapes=args.inputShapes,this.outputShapes=args.outputShapes;for(let layer of args.inboundLayers)layer!=null&&layer.outboundNodes.push(this);args.outboundLayer.inboundNodes.push(this)}getConfig(){let inboundNames=[];for(let layer of this.inboundLayers)layer!=null?inboundNames.push(layer.name):inboundNames.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:inboundNames,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},_nextLayerID=0,Layer=class extends serialization_exports.Serializable{constructor(args={}){super();this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=_nextLayerID++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let name=args.name;if(!name){let prefix=this.getClassName();name=toSnakeCase(prefix)+"_"+getUid(prefix)}if(this.name=name,this.trainable_=args.trainable==null?!0:args.trainable,args.inputShape!=null||args.batchInputShape!=null){let batchInputShape;if(args.batchInputShape!=null)batchInputShape=args.batchInputShape;else if(args.inputShape!=null){let batchSize=null;args.batchSize!=null&&(batchSize=args.batchSize),batchInputShape=[batchSize].concat(args.inputShape)}this.batchInputShape=batchInputShape;let dtype=args.dtype;dtype==null&&(dtype=args.inputDType),dtype==null&&(dtype="float32"),this.dtype=dtype}args.weights!=null?this.initialWeights=args.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(layer,nodeIndex){return layer.name+"_ib-"+nodeIndex.toString()}getNodeAtIndex(nodeIndex,attrName){if(this.inboundNodes.length===0)throw new RuntimeError(`The layer has never been called and thus has no defined ${attrName}.`);if(this.inboundNodes.length<=nodeIndex)throw new ValueError(`Asked to get ${attrName} at node ${nodeIndex}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[nodeIndex]}getInputAt(nodeIndex){return singletonOrArray(this.getNodeAtIndex(nodeIndex,"input").inputTensors)}getOutputAt(nodeIndex){return singletonOrArray(this.getNodeAtIndex(nodeIndex,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new AttributeError(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new AttributeError(`Layer ${this.name} is not connected, no input to return.`);return singletonOrArray(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new AttributeError(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new AttributeError(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return singletonOrArray(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(lossFn=>lossFn())}get updates(){return this._updates}get built(){return this._built}set built(built){this._built=built}get trainable(){return this.trainable_}set trainable(trainable){this._trainableWeights.forEach(w=>w.trainable=trainable),this.trainable_=trainable}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(w=>w.trainable):[]}set trainableWeights(weights){this._trainableWeights=weights}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(w=>!w.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(weights){this._nonTrainableWeights=weights}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(inputs){if(inputs=toList(inputs),this.inputSpec==null||this.inputSpec.length===0)return;let inputSpec=toList(this.inputSpec);if(inputs.length!==inputSpec.length)throw new ValueError(`Layer ${this.name} expects ${inputSpec.length} inputs, but it received ${inputs.length} input tensors. Input received: ${inputs}`);for(let inputIndex=0;inputIndex<inputs.length;inputIndex++){let x=inputs[inputIndex],spec=inputSpec[inputIndex];if(spec==null)continue;let ndim=x.rank;if(spec.ndim!=null&&ndim!==spec.ndim)throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}: expected ndim=${spec.ndim}, found ndim=${ndim}`);if(spec.maxNDim!=null&&ndim>spec.maxNDim)throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}: expected max_ndim=${spec.maxNDim}, found ndim=${ndim}`);if(spec.minNDim!=null&&ndim<spec.minNDim)throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}: expected min_ndim=${spec.minNDim}, found ndim=${ndim}.`);if(spec.dtype!=null&&x.dtype!==spec.dtype)throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name} : expected dtype=${spec.dtype}, found dtype=${x.dtype}.`);if(spec.axes){let xShape=x.shape;for(let key in spec.axes){let axis=Number(key),value=spec.axes[key],xShapeAtAxis=axis>=0?xShape[axis]:xShape[xShape.length+axis];if(value!=null&&[value,null].indexOf(xShapeAtAxis)===-1)throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}: expected axis ${axis} of input shape to have value ${value} but got shape ${xShape}.`)}}if(spec.shape!=null)for(let i=0;i<spec.shape.length;++i){let specDim=spec.shape[i],dim=x.shape[i];if(specDim!=null&&dim!=null&&specDim!==dim)throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}: expected shape=${spec.shape}, found shape=${x.shape}.`)}}}call(inputs,kwargs){return inputs}invokeCallHook(inputs,kwargs){this._callHook!=null&&this._callHook(inputs,kwargs)}setCallHook(callHook){this._callHook=callHook}clearCallHook(){this._callHook=null}apply(inputs,kwargs){kwargs=kwargs||{},this.assertNotDisposed();let inputsList=toList(inputs),allAreSymbolic=!0;for(let input2 of inputsList)if(!(input2 instanceof SymbolicTensor)){allAreSymbolic=!1;break}let noneAreSymbolic=!0;for(let input2 of inputsList)if(input2 instanceof SymbolicTensor){noneAreSymbolic=!1;break}if(allAreSymbolic===noneAreSymbolic)throw new ValueError("Arguments to apply() must be all SymbolicTensors or all Tensors");return nameScope(this.name,()=>{if(!this.built){this.assertInputCompatibility(inputs);let inputShapes=[];for(let xElem of toList(inputs))inputShapes.push(xElem.shape);this.build(singletonOrArray(inputShapes)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&noneAreSymbolic&&(this._refCount=1)}if(this.assertInputCompatibility(inputs),noneAreSymbolic){let output=this.call(inputs,kwargs),outputList=toList(output),outputListCopy=[];for(let x of outputList)inputsList.indexOf(x)!==-1&&(x=x.clone()),outputListCopy.push(x);if(output=singletonOrArray(outputListCopy),this.activityRegularizer!=null)throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return output}else{let inputShape=collectInputShape(inputs),outputShape=this.computeOutputShape(inputShape),output,outputDType=guessOutputDType(inputs);if(this.warnOnIncompatibleInputShape(Array.isArray(inputs)?inputShape[0]:inputShape),outputShape!=null&&outputShape.length>0&&Array.isArray(outputShape[0])?output=outputShape.map((shape,index)=>new SymbolicTensor(outputDType,shape,this,toList(inputs),kwargs,this.name,index)):output=new SymbolicTensor(outputDType,outputShape,this,toList(inputs),kwargs,this.name),this.addInboundNode(inputs,output,null,null,inputShape,outputShape,kwargs),this._refCount++,this.activityRegularizer!=null)throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return output}})}warnOnIncompatibleInputShape(inputShape){if(this.batchInputShape==null)return;if(inputShape.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(inputShape)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let dimMismatch=!1;this.batchInputShape.forEach((dimension,i)=>{dimension!=null&&inputShape[i]!=null&&inputShape[i]!==dimension&&(dimMismatch=!0)}),dimMismatch&&console.warn(`The shape of the input tensor (${JSON.stringify(inputShape)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new AttributeError(`The layer ${this.name} has never been called and thus has no defined output shape.`);let allOutputShapes=[];for(let node of this.inboundNodes){let shapeString=JSON.stringify(node.outputShapes);allOutputShapes.indexOf(shapeString)===-1&&allOutputShapes.push(shapeString)}if(allOutputShapes.length===1){let outputShapes=this.inboundNodes[0].outputShapes;return Array.isArray(outputShapes)&&Array.isArray(outputShapes[0])&&outputShapes.length===1?outputShapes[0]:outputShapes}else throw new AttributeError(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new RuntimeError(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return countParamsInWeights(this.weights)}build(inputShape){this.built=!0}getWeights(trainableOnly=!1){return batchGetValue(trainableOnly?this.trainableWeights:this.weights)}setWeights(weights){tidy(()=>{let params=this.weights;if(params.length!==weights.length)throw new ValueError(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${weights.length}, but the layer was expecting ${params.length} weights. Provided weights: ${weights}...`);if(params.length===0)return;let weightValueTuples=[],paramValues=batchGetValue(params);for(let i=0;i<paramValues.length;++i){let pv=paramValues[i],p2=params[i],w=weights[i];if(!util_exports.arraysEqual(pv.shape,w.shape))throw new ValueError(`Layer weight shape ${pv.shape} not compatible with provided weight shape ${w.shape}`);weightValueTuples.push([p2,w])}batchSetValue(weightValueTuples)})}addWeight(name,shape,dtype,initializer,regularizer,trainable,constraint){if(this._addedWeightNames.indexOf(name)!==-1)throw new ValueError(`Duplicate weight name ${name} for layer ${this.name}`);this._addedWeightNames.push(name),dtype==null&&(dtype="float32"),this.fastWeightInitDuringBuild&&(initializer=getInitializer("zeros"));let initValue=initializer.apply(shape,dtype),weight=new LayerVariable(initValue,dtype,name,trainable,constraint);return initValue.dispose(),regularizer!=null&&this.addLoss(()=>regularizer.apply(weight.read())),trainable==null&&(trainable=!0),trainable?this._trainableWeights.push(weight):this._nonTrainableWeights.push(weight),weight}setFastWeightInitDuringBuild(value){this.fastWeightInitDuringBuild=value}addLoss(losses8){if(losses8==null||Array.isArray(losses8)&&losses8.length===0)return;losses8=toList(losses8),this._losses!==void 0&&this._losses!==null&&this.losses.push(...losses8)}computeOutputShape(inputShape){return inputShape}computeMask(inputs,mask){if(!this.supportsMasking){if(mask!=null)if(Array.isArray(mask))mask.forEach(maskElement=>{if(maskElement!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return mask}addInboundNode(inputTensors,outputTensors,inputMasks,outputMasks,inputShapes,outputShapes,kwargs=null){let inputTensorList=toList(inputTensors);outputTensors=toList(outputTensors),inputMasks=toList(inputMasks),outputMasks=toList(outputMasks),inputShapes=normalizeShapeList(inputShapes),outputShapes=normalizeShapeList(outputShapes);let inboundLayers=[],nodeIndices=[],tensorIndices=[];for(let x of inputTensorList)inboundLayers.push(x.sourceLayer),nodeIndices.push(x.nodeIndex),tensorIndices.push(x.tensorIndex);new Node({outboundLayer:this,inboundLayers,nodeIndices,tensorIndices,inputTensors:inputTensorList,outputTensors,inputMasks,outputMasks,inputShapes,outputShapes},kwargs);for(let i=0;i<outputTensors.length;i++)outputTensors[i].sourceLayer=this,outputTensors[i].nodeIndex=this.inboundNodes.length-1,outputTensors[i].tensorIndex=i}getConfig(){let config={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(config.batchInputShape=this.batchInputShape),this.dtype!=null&&(config.dtype=this.dtype),config}disposeWeights(){return this.weights.forEach(weight=>weight.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let numDisposedVariables=0;return--this._refCount===0&&(numDisposedVariables=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables}}};function collectInputShape(inputTensors){inputTensors=toList(inputTensors);let shapes=[];for(let x of inputTensors)shapes.push(x.shape);return singletonOrArray(shapes)}function guessOutputDType(inputTensors){return"float32"}function getSourceInputs(tensor166,layer,nodeIndex){if((layer==null||nodeIndex!=null&&nodeIndex>0)&&(layer=tensor166.sourceLayer,nodeIndex=tensor166.nodeIndex),layer.inboundNodes.length===0)return[tensor166];{let node=layer.inboundNodes[nodeIndex];if(node.inboundLayers.length===0)return node.inputTensors;{let sourceTensors=[];for(let i=0;i<node.inboundLayers.length;i++){let x=node.inputTensors[i],layer2=node.inboundLayers[i],nodeIndex2=node.nodeIndices[i],previousSources=getSourceInputs(x,layer2,nodeIndex2);for(let x2 of previousSources)sourceTensors.indexOf(x2)===-1&&sourceTensors.push(x2)}return sourceTensors}}}var InputLayer=class extends Layer{constructor(args){super({dtype:args.dtype,name:args.name!=null?args.name:getUid("input").toString()});if(args.batchSize==null&&(args.batchSize=null),args.sparse==null&&(args.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=args.sparse,args.inputShape!=null&&args.batchInputShape!=null)throw new ValueError("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let batchInputShape=args.batchInputShape;if(batchInputShape==null){if(args.inputShape==null)throw new ValueError("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");batchInputShape=[args.batchSize].concat(args.inputShape)}else if(args.batchSize!=null)throw new ValueError("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let dtype=args.dtype||"float32";this.batchInputShape=batchInputShape,this.dtype=dtype,this.inputSpec=[{shape:batchInputShape}];let inputTensor=new SymbolicTensor(this.dtype,this.batchInputShape,this,[],{},this.name);inputTensor.nodeIndex=0,inputTensor.tensorIndex=0,new Node({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[inputTensor],outputTensors:[inputTensor],inputMasks:[null],outputMasks:[null],inputShapes:[batchInputShape],outputShapes:[batchInputShape]})}apply(inputs,kwargs){throw new ValueError(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};InputLayer.className="InputLayer";serialization_exports.registerClass(InputLayer);function Input(config){if(config.batchShape==null&&config.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(config.batchShape!=null&&config.shape!=null)throw new ValueError("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let batchShape=config.batchShape;config.shape!=null&&batchShape==null&&(batchShape=[null].concat(config.shape));let dtype=config.dtype;dtype==null&&(dtype="float32");let inputLayer=new InputLayer({batchInputShape:batchShape,name:config.name,dtype,sparse:config.sparse}),outputs=inputLayer.inboundNodes[0].outputTensors;return outputs[0]}async function resolveScalarsInLogs(logs5){if(logs5==null)return;let promises=[],keys=[],scalarsToDispose=[];for(let key in logs5){let value=logs5[key];if(typeof value!="number"){let valueScalar=value;promises.push(valueScalar.data()),keys.push(key),scalarsToDispose.push(valueScalar)}}if(promises.length>0){let values=await Promise.all(promises);for(let i=0;i<values.length;++i)logs5[keys[i]]=values[i][0];dispose(scalarsToDispose)}}function disposeTensorsInLogs(logs5){if(logs5==null)return;for(let key in logs5){let value=logs5[key];typeof value!="number"&&value.dispose()}}var ModelLoggingVerbosity;(function(ModelLoggingVerbosity2){ModelLoggingVerbosity2[ModelLoggingVerbosity2.SILENT=0]="SILENT",ModelLoggingVerbosity2[ModelLoggingVerbosity2.VERBOSE=1]="VERBOSE"})(ModelLoggingVerbosity||(ModelLoggingVerbosity={}));var DEFAULT_YIELD_EVERY_MS=125,BaseCallback=class{constructor(){this.validationData=null}setParams(params){this.params=params}async onEpochBegin(epoch,logs5){}async onEpochEnd(epoch,logs5){}async onBatchBegin(batch,logs5){}async onBatchEnd(batch,logs5){}async onTrainBegin(logs5){}async onTrainEnd(logs5){}setModel(model2){}},CallbackList=class{constructor(callbacks3,queueLength=10){callbacks3==null&&(callbacks3=[]),this.callbacks=callbacks3,this.queueLength=queueLength}append(callback){this.callbacks.push(callback)}setParams(params){for(let callback of this.callbacks)callback.setParams(params)}setModel(model2){for(let callback of this.callbacks)callback.setModel(model2)}async onEpochBegin(epoch,logs5){logs5==null&&(logs5={});for(let callback of this.callbacks)await callback.onEpochBegin(epoch,logs5)}async onEpochEnd(epoch,logs5){logs5==null&&(logs5={});for(let callback of this.callbacks)await callback.onEpochEnd(epoch,logs5)}async onBatchBegin(batch,logs5){logs5==null&&(logs5={});for(let callback of this.callbacks)await callback.onBatchBegin(batch,logs5)}async onBatchEnd(batch,logs5){logs5==null&&(logs5={});for(let callback of this.callbacks)await callback.onBatchEnd(batch,logs5)}async onTrainBegin(logs5){logs5==null&&(logs5={});for(let callback of this.callbacks)await callback.onTrainBegin(logs5)}async onTrainEnd(logs5){logs5==null&&(logs5={});for(let callback of this.callbacks)await callback.onTrainEnd(logs5)}},BaseLogger=class extends BaseCallback{constructor(){super()}async onEpochBegin(epoch){this.seen=0,this.totals={}}async onBatchEnd(batch,logs5){logs5==null&&(logs5={});let batchSize=logs5.size==null?0:logs5.size;this.seen+=batchSize;for(let key in logs5){let value=logs5[key];if(typeof value=="number")this.totals.hasOwnProperty(key)||(this.totals[key]=0),this.totals[key]=this.totals[key]+value*batchSize;else{let oldTotalsToDispose;key in this.totals?oldTotalsToDispose=this.totals[key]:this.totals[key]=0;let total=tidy(()=>add2(this.totals[key],mul(value,batchSize)));this.totals[key]=total,oldTotalsToDispose!=null&&oldTotalsToDispose.dispose()}}}async onEpochEnd(epoch,logs5){if(logs5!=null)for(let key of this.params.metrics){if(this.totals[key]==null)continue;typeof this.totals[key]=="number"?logs5[key]=this.totals[key]/this.seen:tidy(()=>{let log11=mul(div(1,this.seen),this.totals[key]);logs5[key]=log11,this.totals[key].dispose(),keep(logs5[key])})}}},History=class extends BaseCallback{async onTrainBegin(logs5){this.epoch=[],this.history={}}async onEpochEnd(epoch,logs5){logs5==null&&(logs5={}),this.epoch.push(epoch);for(let key in logs5)this.history[key]==null&&(this.history[key]=[]),this.history[key].push(logs5[key])}async syncData(){let promises=[],keys=[],indices=[];for(let key in this.history){let valueArray=this.history[key];for(let i=0;i<valueArray.length;++i)if(typeof valueArray[i]!="number"){let valueScalar=valueArray[i];promises.push(valueScalar.data()),keys.push(key),indices.push(i)}}let values=await Promise.all(promises);for(let n=0;n<values.length;++n){let tensorToDispose=this.history[keys[n]][indices[n]];tensorToDispose.dispose(),this.history[keys[n]][indices[n]]=values[n][0]}}},CustomCallback=class extends BaseCallback{constructor(args,yieldEvery){super();if(this.currentEpoch=0,this.yieldEvery=yieldEvery||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=DEFAULT_YIELD_EVERY_MS),this.yieldEvery==="never"&&args.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");util_exports.isNumber(this.yieldEvery)&&(this.maybeWait=debounce(this.maybeWait.bind(this),this.yieldEvery)),this.trainBegin=args.onTrainBegin,this.trainEnd=args.onTrainEnd,this.epochBegin=args.onEpochBegin,this.epochEnd=args.onEpochEnd,this.batchBegin=args.onBatchBegin,this.batchEnd=args.onBatchEnd,this.yield=args.onYield}async maybeWait(epoch,batch,logs5){let ps=[];this.yield!=null&&(await resolveScalarsInLogs(logs5),ps.push(this.yield(epoch,batch,logs5))),ps.push(nextFrame()),await Promise.all(ps)}async onEpochBegin(epoch,logs5){this.currentEpoch=epoch,this.epochBegin!=null&&(await resolveScalarsInLogs(logs5),await this.epochBegin(epoch,logs5))}async onEpochEnd(epoch,logs5){let ps=[];this.epochEnd!=null&&(await resolveScalarsInLogs(logs5),ps.push(this.epochEnd(epoch,logs5))),this.yieldEvery==="epoch"&&ps.push(nextFrame()),await Promise.all(ps)}async onBatchBegin(batch,logs5){this.batchBegin!=null&&(await resolveScalarsInLogs(logs5),await this.batchBegin(batch,logs5))}async onBatchEnd(batch,logs5){let ps=[];this.batchEnd!=null&&(await resolveScalarsInLogs(logs5),ps.push(this.batchEnd(batch,logs5))),this.yieldEvery==="batch"?ps.push(nextFrame()):util_exports.isNumber(this.yieldEvery)&&ps.push(this.maybeWait(this.currentEpoch,batch,logs5)),await Promise.all(ps)}async onTrainBegin(logs5){this.trainBegin!=null&&(await resolveScalarsInLogs(logs5),await this.trainBegin(logs5))}async onTrainEnd(logs5){this.trainEnd!=null&&(await resolveScalarsInLogs(logs5),await this.trainEnd(logs5))}};function standardizeCallbacks(callbacks3,yieldEvery){if(callbacks3==null&&(callbacks3={}),callbacks3 instanceof BaseCallback)return[callbacks3];if(Array.isArray(callbacks3)&&callbacks3[0]instanceof BaseCallback)return callbacks3;let callbackConfigs=toList(callbacks3);return callbackConfigs.map(callbackConfig=>new CustomCallback(callbackConfig,yieldEvery))}var CallbackConstructorRegistry=class{constructor(){}static registerCallbackConstructor(verbosityLevel,callbackConstructor){util_exports.assert(verbosityLevel>=0&&Number.isInteger(verbosityLevel),()=>`Verbosity level is expected to be an integer >= 0, but got ${verbosityLevel}`),CallbackConstructorRegistry.checkForDuplicate(callbackConstructor),CallbackConstructorRegistry.constructors[verbosityLevel]==null&&(CallbackConstructorRegistry.constructors[verbosityLevel]=[]),CallbackConstructorRegistry.constructors[verbosityLevel].push(callbackConstructor)}static checkForDuplicate(callbackConstructor){for(let levelName in CallbackConstructorRegistry.constructors){let constructors=CallbackConstructorRegistry.constructors[+levelName];constructors.forEach(ctor=>{if(ctor===callbackConstructor)throw new ValueError("Duplicate callback constructor.")})}}static clear(){CallbackConstructorRegistry.constructors={}}static createCallbacks(verbosityLevel){let constructors=[];for(let levelName in CallbackConstructorRegistry.constructors){let level=+levelName;verbosityLevel>=level&&constructors.push(...CallbackConstructorRegistry.constructors[level])}return constructors.map(ctor=>new ctor)}};CallbackConstructorRegistry.constructors={};function configureCallbacks(callbacks3,verbose,epochs,initialEpoch,numTrainSamples,stepsPerEpoch,batchSize,doValidation,callbackMetrics){let history=new History,actualCallbacks=[new BaseLogger,...CallbackConstructorRegistry.createCallbacks(verbose)];callbacks3!=null&&actualCallbacks.push(...callbacks3),actualCallbacks.push(history);let callbackList=new CallbackList(actualCallbacks);return callbackList.setParams({epochs,initialEpoch,samples:numTrainSamples,steps:stepsPerEpoch,batchSize,verbose,doValidation,metrics:callbackMetrics}),{callbackList,history}}function deserialize(config,customObjects={},fastWeightInit=!1){return deserializeKerasObject(config,serialization_exports.SerializationMap.getMap().classNameMap,customObjects,"layer",fastWeightInit)}function l2Normalize(x,axis){return tidy(()=>{x.dtype!=="float32"&&(x=x.asType("float32"));let squareSum=sum2(square24(x),axis,!0),epsilonTensor=fill(squareSum.shape,epsilon()),norm5=sqrt(maximum(squareSum,epsilonTensor));return div(x,norm5)})}function meanSquaredError2(yTrue,yPred){return tidy(()=>mean(square24(sub(yPred,yTrue)),-1))}function meanAbsoluteError(yTrue,yPred){return tidy(()=>mean(abs(sub(yPred,yTrue)),-1))}function meanAbsolutePercentageError(yTrue,yPred){return tidy(()=>{let diff=sub(yTrue,yPred),clippedTrue=clipByValue(abs(yTrue),epsilon(),Number.MAX_VALUE),absResult=abs(div(diff,clippedTrue));return mul(100,mean(absResult,-1))})}function meanSquaredLogarithmicError(yTrue,yPred){return tidy(()=>{let clippedPred=clipByValue(yPred,epsilon(),Number.MAX_VALUE),firstLog=log(add2(1,clippedPred)),clippedTrue=clipByValue(yTrue,epsilon(),Number.MAX_VALUE),secondLog=log(add2(1,clippedTrue));return mean(square24(sub(firstLog,secondLog)),-1)})}function squaredHinge(yTrue,yPred){return tidy(()=>{let maxResult=maximum(0,sub(1,mul(yTrue,yPred)));return mean(square24(maxResult),-1)})}function hinge(yTrue,yPred){return tidy(()=>{let maxResult=maximum(0,sub(1,mul(yTrue,yPred)));return mean(maxResult,-1)})}function categoricalHinge(yTrue,yPred){return tidy(()=>{let pos=sum2(mul(yTrue,yPred),-1),neg20=max(mul(sub(1,yTrue),yPred),-1);return maximum(0,add2(1,sub(neg20,pos)))})}function logcosh(yTrue,yPred){return tidy(()=>{let log22=Math.log(2),predictionDiff=sub(yPred,yTrue),logcoshResult=sub(add2(predictionDiff,softplus(mul(-2,predictionDiff))),log22);return mean(logcoshResult,-1)})}function categoricalCrossentropy(target,output,fromLogits=!1){return tidy(()=>{if(fromLogits)output=softmax(output);else{let outputSum=sum2(output,output.shape.length-1,!0);output=div(output,outputSum)}return output=clipByValue(output,epsilon(),1-epsilon()),neg(sum2(mul(target.toFloat(),log(output)),output.shape.length-1))})}function sparseCategoricalCrossentropy(target,output,fromLogits=!1){return tidy(()=>{let flatTarget=floor(flatten3(target)).toInt();output=clipByValue(output,epsilon(),1-epsilon());let outputShape=output.shape,oneHotTarget=oneHot(flatTarget,outputShape[outputShape.length-1]).reshape(outputShape);return categoricalCrossentropy(oneHotTarget,output,fromLogits)})}function sigmoidCrossEntropyWithLogits(labels,logits){if(!util_exports.arraysEqual(labels.shape,logits.shape))throw new ValueError(`logits and labels must have the same shape, but got shapes ${JSON.stringify(labels.shape)} and ${JSON.stringify(logits.shape)}`);return tidy(()=>{let reluLogits=logits.relu(),negAbsLogits=logits.abs().neg();return reluLogits.sub(logits.mul(labels)).add(negAbsLogits.exp().log1p())})}function binaryCrossentropy(yTrue,yPred){return tidy(()=>{let y;return y=clipByValue(yPred,epsilon(),1-epsilon()),y=log(div(y,sub(1,y))),mean(sigmoidCrossEntropyWithLogits(yTrue,y),-1)})}function kullbackLeiblerDivergence(yTrue,yPred){return tidy(()=>{let clippedTrue=clipByValue(yTrue,epsilon(),1),clippedPred=clipByValue(yPred,epsilon(),1);return sum2(mul(yTrue,log(div(clippedTrue,clippedPred))),-1)})}function poisson(yTrue,yPred){return tidy(()=>{let logPred=log(add2(epsilon(),yPred));return mean(sub(yPred,mul(yTrue,logPred)),-1)})}function cosineProximity(yTrue,yPred){return tidy(()=>{let trueNormalized=l2Normalize(yTrue,-1),predNormalized=l2Normalize(yPred,-1),trueXPred=mul(trueNormalized,predNormalized);return neg(sum2(trueXPred,-1))})}var lossesMap={meanSquaredError:meanSquaredError2,meanAbsoluteError,meanAbsolutePercentageError,meanSquaredLogarithmicError,squaredHinge,hinge,categoricalHinge,logcosh,categoricalCrossentropy,sparseCategoricalCrossentropy,binaryCrossentropy,kullbackLeiblerDivergence,poisson,cosineProximity};function get(identifierOrFn){if(typeof identifierOrFn=="string"){if(identifierOrFn in lossesMap)return lossesMap[identifierOrFn];let errMsg=`Unknown loss ${identifierOrFn}`;throw identifierOrFn.toLowerCase().includes("softmaxcrossentropy")&&(errMsg=`Unknown loss ${identifierOrFn}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new ValueError(errMsg)}else return identifierOrFn}function binaryAccuracy(yTrue,yPred){return tidy(()=>{let threshold2=mul(.5,onesLike(yPred)),yPredThresholded=cast47(greater(yPred,threshold2),yTrue.dtype);return mean(equal(yTrue,yPredThresholded),-1)})}function categoricalAccuracy(yTrue,yPred){return tidy(()=>cast47(equal(argMax(yTrue,-1),argMax(yPred,-1)),"float32"))}function truePositives(yTrue,yPred){return tidy(()=>logicalAnd(yTrue.equal(1),yPred.equal(1)).sum().cast("float32"))}function falsePositives(yTrue,yPred){return tidy(()=>logicalAnd(yTrue.equal(0),yPred.equal(1)).sum().cast("float32"))}function precision(yTrue,yPred){return tidy(()=>{let tp=truePositives(yTrue,yPred),fp=falsePositives(yTrue,yPred),denominator=tp.add(fp);return where(greater(denominator,0),tp.div(denominator),0).cast("float32")})}function binaryCrossentropy2(yTrue,yPred){return binaryCrossentropy(yTrue,yPred)}function sparseCategoricalAccuracy(yTrue,yPred){return yTrue.rank===yPred.rank&&(yTrue=yTrue.squeeze([yTrue.rank-1])),yPred=yPred.argMax(-1),yPred.dtype!==yTrue.dtype&&(yPred=yPred.asType(yTrue.dtype)),equal(yTrue,yPred).asType("float32")}var mse=meanSquaredError2,MSE=meanSquaredError2,mae=meanAbsoluteError,MAE=meanAbsoluteError,mape=meanAbsolutePercentageError,MAPE=meanAbsolutePercentageError,categoricalCrossentropy2=categoricalCrossentropy,cosine=cosineProximity,sparseCategoricalCrossentropy2=sparseCategoricalCrossentropy,metricsMap={binaryAccuracy,categoricalAccuracy,precision,categoricalCrossentropy:categoricalCrossentropy2,sparseCategoricalCrossentropy:sparseCategoricalCrossentropy2,mse,MSE,mae,MAE,mape,MAPE,cosine};function get2(identifier){if(typeof identifier=="string"&&identifier in metricsMap)return metricsMap[identifier];if(typeof identifier!="string"&&identifier!=null)return identifier;throw new ValueError(`Unknown metric ${identifier}`)}function getLossOrMetricName(fn){if(assert2(fn!==null,`Unknown LossOrMetricFn ${fn}`),typeof fn=="string")return fn;{let fnName;for(let key of Object.keys(lossesMap))if(lossesMap[key]===fn){fnName=key;break}if(fnName!==void 0)return fnName;for(let key of Object.keys(metricsMap))if(metricsMap[key]===fn){fnName=key;break}return fnName!==void 0?fnName:fn.name}}function getOptimizer(identifier){let optimizerMap={Adagrad:()=>train.adagrad(.01),Adadelta:()=>train.adadelta(1,.95,epsilon()),Adam:()=>train.adam(.001,.9,.999,epsilon()),Adamax:()=>train.adamax(.002,.9,.999,epsilon(),0),RMSProp:()=>train.rmsprop(.001,.9,0,epsilon()),SGD:()=>train.sgd(.01)};if(optimizerMap.adagrad=optimizerMap.Adagrad,optimizerMap.adadelta=optimizerMap.Adadelta,optimizerMap.adam=optimizerMap.Adam,optimizerMap.adamax=optimizerMap.Adamax,optimizerMap.rmsprop=optimizerMap.RMSProp,optimizerMap.sgd=optimizerMap.SGD,identifier in optimizerMap)return optimizerMap[identifier]();throw new ValueError(`Unknown Optimizer ${identifier}`)}var MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH=1*1024*1024;function checkUserDefinedMetadata(userDefinedMetadata,modelName,checkSize=!1){if(userDefinedMetadata==null||typeof userDefinedMetadata!="object"||Object.getPrototypeOf(userDefinedMetadata)!==Object.prototype||!plainObjectCheck(userDefinedMetadata))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(checkSize){let out=JSON.stringify(userDefinedMetadata);out.length>MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH&&console.warn(`User-defined metadata of model "${modelName}" is too large in size (length=${out.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH}.`)}}function plainObjectCheck(x){if(x===null)return!0;if(typeof x=="object")if(Object.getPrototypeOf(x)===Object.prototype){let keys=Object.keys(x);for(let key of keys){if(typeof key!="string")return!1;if(!plainObjectCheck(x[key]))return!1}return!0}else if(Array.isArray(x)){for(let item of x)if(!plainObjectCheck(item))return!1;return!0}else return!1;else{let xType=typeof x;return xType==="string"||xType==="number"||xType==="boolean"}}function printSummary(model2,lineLength,positions,printFn=console.log){let sequentialLike=isModelSequentialLike(model2),toDisplay=["Layer (type)","Output shape","Param #"];sequentialLike?(lineLength=lineLength||65,positions=positions||[.45,.85,1]):(lineLength=lineLength||98,positions=positions||[.33,.55,.67,1]),positions[positions.length-1]<=1&&(positions=positions.map(p2=>Math.floor(lineLength*p2)));let relevantNodes;if(!sequentialLike){toDisplay.push("Receives inputs"),relevantNodes=[];for(let depth in model2.nodesByDepth)relevantNodes.push(...model2.nodesByDepth[depth])}printFn("_".repeat(lineLength)),printRow(toDisplay,positions,printFn),printFn("=".repeat(lineLength));let layers=model2.layers;for(let i=0;i<layers.length;++i)sequentialLike?printLayerSummary(layers[i],positions,printFn):printLayerSummaryWithConnections(layers[i],positions,relevantNodes,printFn),printFn((i===layers.length-1?"=":"_").repeat(lineLength));model2.checkTrainableWeightsConsistency();let trainableCount=countTrainableParams(model2),nonTrainableCount=countParamsInWeights(model2.nonTrainableWeights);printFn(`Total params: ${trainableCount+nonTrainableCount}`),printFn(`Trainable params: ${trainableCount}`),printFn(`Non-trainable params: ${nonTrainableCount}`),printFn("_".repeat(lineLength))}function countTrainableParams(model2){let trainableCount;return model2.collectedTrainableWeights!=null?trainableCount=countParamsInWeights(model2.collectedTrainableWeights):trainableCount=countParamsInWeights(model2.trainableWeights),trainableCount}function isModelSequentialLike(model2){let sequentialLike=!0,nodesByDepth=[],nodes=[];for(let depth in model2.nodesByDepth)nodesByDepth.push(model2.nodesByDepth[depth]);for(let depthNodes of nodesByDepth){if(depthNodes.length>1||depthNodes.length===1&&depthNodes[0].inboundLayers.length>1){sequentialLike=!1;break}nodes.push(...depthNodes)}if(sequentialLike)for(let layer of model2.layers){let flag=!1;for(let node of layer.inboundNodes)if(nodes.indexOf(node)!==-1)if(flag){sequentialLike=!1;break}else flag=!0;if(!sequentialLike)break}return sequentialLike}function printRow(fields,positions,printFn=console.log){let line="";for(let i=0;i<fields.length;++i)i>0&&(line=line.slice(0,line.length-1)+" "),line+=fields[i],line=line.slice(0,positions[i]),line+=" ".repeat(positions[i]-line.length);printFn(line)}function printLayerSummary(layer,positions,printFn){let outputShape;try{outputShape=JSON.stringify(layer.outputShape)}catch(err){outputShape="multiple"}let name=layer.name,className=layer.getClassName(),fields=[`${name} (${className})`,outputShape,layer.countParams().toString()];printRow(fields,positions,printFn)}function printLayerSummaryWithConnections(layer,positions,relevantNodes,printFn){let outputShape;try{outputShape=JSON.stringify(layer.outputShape)}catch(err){outputShape="multiple"}let connections=[];for(let node of layer.inboundNodes){if(relevantNodes!=null&&relevantNodes.length>0&&relevantNodes.indexOf(node)===-1)continue;for(let i=0;i<node.inboundLayers.length;++i){let inboundLayer=node.inboundLayers[i].name,inboundLayerIndex=node.nodeIndices[i],inboundTensorIndex=node.tensorIndices[i];connections.push(`${inboundLayer}[${inboundLayerIndex}][${inboundTensorIndex}]`)}}let name=layer.name,className=layer.getClassName(),firstConnection=connections.length===0?"":connections[0],fields=[`${name} (${className})`,outputShape,layer.countParams().toString(),firstConnection];printRow(fields,positions,printFn);for(let i=1;i<connections.length;++i)printRow(["","","",connections[i]],positions,printFn)}function isArrayItemInputOrOutputName(key,index,value){return(key==="inboundNodes"||key==="outputLayers"||key==="inputLayers")&&index===0&&typeof value=="string"}function convertPythonicToTs(pythonicConfig,key){if(pythonicConfig===null)return null;if(typeof pythonicConfig=="string")return toCamelCase(pythonicConfig);if(typeof pythonicConfig=="number"||typeof pythonicConfig=="boolean")return pythonicConfig;if(pythonicConfig instanceof Array){let tsArray=[],arrayLength=pythonicConfig.length;for(let i=0;i<arrayLength;++i){let item=pythonicConfig[i];isArrayItemInputOrOutputName(key,i,item)?tsArray.push(item):tsArray.push(convertPythonicToTs(item,key))}return tsArray}else{let tsDict={};for(let pythonicKey of Object.keys(pythonicConfig)){let pythonicValue=pythonicConfig[pythonicKey];if(pythonicKey==="name"&&typeof pythonicValue=="string")tsDict[pythonicKey]=pythonicValue;else{let tsKey=toCamelCase(pythonicKey);tsDict[tsKey]=convertPythonicToTs(pythonicValue,tsKey)}}return tsDict}}function convertTsToPythonic(tsConfig,key){if(tsConfig==null)return null;if(typeof tsConfig=="string")return toSnakeCase(tsConfig);if(typeof tsConfig=="number"||typeof tsConfig=="boolean")return tsConfig;if(tsConfig instanceof Array){let pyArray=[],arrayLength=tsConfig.length;for(let i=0;i<arrayLength;++i){let item=tsConfig[i];isArrayItemInputOrOutputName(key,i,item)?pyArray.push(item):pyArray.push(convertTsToPythonic(item,key))}return pyArray}else{let pyDict={};for(let tsKey of Object.keys(tsConfig)){let tsValue=tsConfig[tsKey],pyKey=toSnakeCase(tsKey);(tsKey==="name"||tsKey==="className")&&typeof tsValue=="string"?pyDict[pyKey]=tsValue:pyDict[pyKey]=convertTsToPythonic(tsValue,tsKey)}return pyDict}}var version2="2.7.0";function assertFeedCompatibility(key,val){if(key.dtype==null||key.dtype===val.dtype)return val;try{return cast(val,key.dtype)}catch(err){throw new ValueError(`The dtype of the feed (${val.dtype}) can not be cast to the dtype of the key '${key.name}' (${key.dtype}).`)}}var FeedDict=class{constructor(feeds){if(this.id2Value={},this.id2Mask={},this.name2Id={},feeds instanceof FeedDict)for(let id in feeds.id2Value)this.id2Value[id]=feeds.id2Value[id],id in feeds.id2Mask&&(this.id2Mask[id]=feeds.id2Mask[id]);else{if(feeds==null)return;for(let feed of feeds)this.add(feed.key,feed.value)}}add(key,value,mask){if(this.id2Value[key.id]==null)this.id2Value[key.id]=assertFeedCompatibility(key,value),this.name2Id[key.name]=key.id,mask!=null&&(this.id2Mask[key.id]=mask);else throw new ValueError(`Duplicate key: name=${key.name}, id=${key.id}`);return this}addFeed(feed){this.add(feed.key,feed.value)}hasKey(key){return this.id2Value[key.id]!=null}names(){return Object.keys(this.name2Id)}getValue(key){if(key instanceof SymbolicTensor){if(this.id2Value[key.id]==null)throw new ValueError(`Nonexistent key: ${key.name}`);return this.id2Value[key.id]}else{let id=this.name2Id[key];if(id==null)throw new ValueError(`Feed dict has no SymbolicTensor name: ${key}`);return this.id2Value[id]}}getMask(key){if(key instanceof SymbolicTensor){if(this.id2Value[key.id]==null)throw new ValueError(`Nonexistent key: ${key.name}`);return this.id2Mask[key.id]}else{let id=this.name2Id[key];if(id==null)throw new ValueError(`Feed dict has no SymbolicTensor name: ${key}`);return this.id2Mask[id]}}disposeMasks(){this.id2Mask!=null&&dispose(this.id2Mask)}},cachedSorted={},cachedRecipientCounts={};function execute(fetches,feedDict,kwargs,probe){let training5=kwargs==null?!1:kwargs.training,arrayFetches=Array.isArray(fetches),fetchArray=arrayFetches?fetches:[fetches],outputNames=fetchArray.map(t=>t.name),finalOutputs=[],feedNames=feedDict.names();for(let outputName of outputNames)feedNames.indexOf(outputName)!==-1?finalOutputs.push(feedDict.getValue(outputName)):finalOutputs.push(null);probe!=null&&(probe.maxNumTensors=-Infinity,probe.minNumTensors=Infinity);let fetchAndFeedKey=outputNames.join(",")+"|"+feedDict.names().join(","),sorted,recipientCounts;if(cachedSorted[fetchAndFeedKey]==null){let out=getTopologicalSortAndRecipientCounts(fetchArray,feedDict);sorted=out.sorted,recipientCounts=out.recipientCounts,cachedSorted[fetchAndFeedKey]=sorted,cachedRecipientCounts[fetchAndFeedKey]=recipientCounts}sorted=cachedSorted[fetchAndFeedKey],recipientCounts={},training5||Object.assign(recipientCounts,cachedRecipientCounts[fetchAndFeedKey]);let internalFeedDict=new FeedDict(feedDict);for(let i=0;i<sorted.length;++i){if(probe!=null){let numTensors=memory().numTensors;numTensors>probe.maxNumTensors&&(probe.maxNumTensors=numTensors),numTensors<probe.minNumTensors&&(probe.minNumTensors=numTensors)}let symbolic=sorted[i],srcLayer=symbolic.sourceLayer;if(srcLayer instanceof InputLayer)continue;let inputValues=[],inputMasks=[],tensorsToDispose=[],maskExists=!1;for(let input2 of symbolic.inputs){let value=internalFeedDict.getValue(input2),mask=internalFeedDict.getMask(input2);inputValues.push(value),inputMasks.push(mask),mask!=null&&(maskExists=!0),training5||(recipientCounts[input2.name]--,recipientCounts[input2.name]===0&&!feedDict.hasKey(input2)&&outputNames.indexOf(input2.name)===-1&&!value.isDisposed&&input2.sourceLayer.stateful!==!0&&tensorsToDispose.push(value))}maskExists&&(kwargs=kwargs||{},kwargs.mask=inputMasks[0]);let outputTensors=toList(srcLayer.apply(inputValues,kwargs)),outputMask=null;srcLayer.supportsMasking&&(outputMask=srcLayer.computeMask(inputValues,inputMasks));let layerOutputs=getNodeOutputs(symbolic),outputSymbolicTensors=Array.isArray(layerOutputs)?layerOutputs:[layerOutputs];for(let i2=0;i2<outputSymbolicTensors.length;++i2){internalFeedDict.hasKey(outputSymbolicTensors[i2])||internalFeedDict.add(outputSymbolicTensors[i2],outputTensors[i2],Array.isArray(outputMask)?outputMask[0]:outputMask);let index=outputNames.indexOf(outputSymbolicTensors[i2].name);index!==-1&&(finalOutputs[index]=outputTensors[i2])}training5||dispose(tensorsToDispose)}return internalFeedDict.disposeMasks(),arrayFetches?finalOutputs:finalOutputs[0]}function getTopologicalSortAndRecipientCounts(fetches,feedDict){util_exports.assert(fetches!=null&&fetches.length>0,()=>"Expected at least one fetch, got none");let finalSorted=[],finalRecipientMap={};if(fetches.length===1){let out=getTopologicalSortAndRecipientCountsForOneFetch(fetches[0],feedDict);finalSorted=out.sorted,finalRecipientMap=out.recipientMap}else{let visited=new Set;for(let fetch3 of fetches){let{sorted,recipientMap}=getTopologicalSortAndRecipientCountsForOneFetch(fetch3,feedDict);for(let symbolicTensor of sorted)visited.has(symbolicTensor.name)||(finalSorted.push(symbolicTensor),visited.add(symbolicTensor.name));for(let name in recipientMap)finalRecipientMap[name]==null&&(finalRecipientMap[name]=new Set),recipientMap[name].forEach(recipient=>finalRecipientMap[name].add(recipient))}}return{sorted:finalSorted,recipientCounts:recipientMap2Counts(finalRecipientMap)}}function recipientMap2Counts(recipientMap){let recipientCounts={};for(let name in recipientMap)recipientCounts[name]=recipientMap[name].size;return recipientCounts}function getTopologicalSortAndRecipientCountsForOneFetch(fetch3,feedDict){let visited=new Set,sorted=[],recipientMap={};for(let key of feedDict.names())visited.add(key);let stack9=[],marks=[];for(stack9.push(fetch3);stack9.length>0;){let top=stack9[stack9.length-1];if(visited.has(top.name)){stack9.pop();continue}let topIsMarked=marks[marks.length-1]===stack9.length-1;if(top.inputs.length===0||topIsMarked)stack9.pop(),sorted.push(top),visited.add(top.name),topIsMarked&&marks.pop();else{marks.push(stack9.length-1);for(let input2 of top.inputs){if(recipientMap[input2.name]==null&&(recipientMap[input2.name]=new Set),recipientMap[input2.name].add(top.name),visited.has(input2.name))continue;stack9.push(input2)}}}return{sorted,recipientMap}}function getNodeOutputs(fetch3){let layerOutputs;if(fetch3.sourceLayer.inboundNodes.length===1)layerOutputs=fetch3.sourceLayer.output;else{let nodeIndex=null;for(let i=0;i<fetch3.sourceLayer.inboundNodes.length;++i)for(let outputTensor of fetch3.sourceLayer.inboundNodes[i].outputTensors)if(outputTensor.id===fetch3.id){nodeIndex=i;break}layerOutputs=fetch3.sourceLayer.getOutputAt(nodeIndex)}return layerOutputs}var Container=class extends Layer{constructor(args){super({});if(this.containerNodes=new Set,this.name=args.name,this.name==null){let prefix=this.getClassName().toLowerCase();this.name=getUid(prefix)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(args.inputs)?this.inputs=args.inputs.slice():this.inputs=[args.inputs],Array.isArray(args.outputs)?this.outputs=args.outputs.slice():this.outputs=[args.outputs],unique5(this.inputs).length!==this.inputs.length)throw new ValueError(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(x=>x.name)}`);unique5(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(x=>x.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let x of this.outputs){let layer=x.sourceLayer,nodeIndex=x.nodeIndex,tensorIndex=x.tensorIndex;this.outputLayers.push(layer),this.outputLayersNodeIndices.push(nodeIndex),this.outputLayersTensorIndices.push(tensorIndex)}for(let x of this.inputs){let layer=x.sourceLayer,nodeIndex=x.nodeIndex,tensorIndex=x.tensorIndex;assert2(nodeIndex===0,"input layer has >1 nodes"),assert2(tensorIndex===0,"input layer has >1 tensors"),this.inputLayers.push(layer),this.inputLayersNodeIndices.push(nodeIndex),this.inputLayersTensorIndices.push(tensorIndex)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let i=0;i<this.inputLayers.length;i++){let layer=this.inputLayers[i];if(!(layer instanceof InputLayer))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${args.inputs}. Input ${i} (0-based) originates from layer type ${layer.getClassName()}.`);this.inputNames.push(layer.name),this.feedInputShapes.push(layer.batchInputShape),this.feedInputNames.push(layer.name)}for(let layer of this.outputLayers)this.outputNames.push(layer.name);this.internalInputShapes=this.inputs.map(x=>x.shape),this.internalOutputShapes=this.outputs.map(x=>x.shape);let nodesDepths={},nodeIDToNode={},layersDepths={},layerIDToLayer={},layerIndices={},nodesInDecreasingDepth=[],buildMapOfGraph=(tensor166,finishedNodes2,nodesInProgress2,layer,nodeIndex,tensorIndex)=>{(layer==null||nodeIndex==null||tensorIndex==null)&&(layer=tensor166.sourceLayer,nodeIndex=tensor166.nodeIndex,tensorIndex=tensor166.tensorIndex);let node=layer.inboundNodes[nodeIndex];if(nodesInProgress2.indexOf(node)!==-1)throw new RuntimeError(`The tensor ${tensor166.name} at layer "${layer.name}" is part of a cycle.`);if(finishedNodes2.indexOf(node)!==-1)return;this.containerNodes.add(Container.nodeKey(layer,nodeIndex)),layer.id in layerIndices||(layerIndices[layer.id]=Object.keys(layerIndices).length),nodesInProgress2.indexOf(node)===-1&&nodesInProgress2.push(node);let numInboundLayers=node.inboundLayers.length;for(let i=0;i<numInboundLayers;i++){let x=node.inputTensors[i],layer2=node.inboundLayers[i],nodeIndex2=node.nodeIndices[i],tensorIndex2=node.tensorIndices[i];buildMapOfGraph(x,finishedNodes2,nodesInProgress2,layer2,nodeIndex2,tensorIndex2)}for(finishedNodes2.push(node);nodesInProgress2.indexOf(node)>=0;)nodesInProgress2.splice(nodesInProgress2.indexOf(node),1);nodesInDecreasingDepth.push(node)},finishedNodes=[],nodesInProgress=[];for(let x of this.outputs)buildMapOfGraph(x,finishedNodes,nodesInProgress);let reversedNodesInDecreasingDepth=nodesInDecreasingDepth.slice().reverse();for(let node of reversedNodesInDecreasingDepth){nodeIDToNode[node.id]=node,node.id in nodesDepths||(nodesDepths[node.id]=0);let depth=nodesDepths[node.id],previousDepth=layersDepths[node.outboundLayer.id]==null?0:layersDepths[node.outboundLayer.id];depth=Math.max(depth,previousDepth),layersDepths[node.outboundLayer.id]=depth,layerIDToLayer[node.outboundLayer.id]=node.outboundLayer,nodesDepths[node.id]=depth;for(let i=0;i<node.inboundLayers.length;i++){let inboundLayer=node.inboundLayers[i],nodeIndex=node.nodeIndices[i],inboundNode=inboundLayer.inboundNodes[nodeIndex],previousDepth2=nodesDepths[inboundNode.id]==null?0:nodesDepths[inboundNode.id];nodesDepths[inboundNode.id]=Math.max(depth+1,previousDepth2),nodeIDToNode[inboundNode.id]=inboundNode}}let nodesByDepth={};for(let nodeID in nodesDepths){let depth=nodesDepths[nodeID];depth in nodesByDepth||(nodesByDepth[depth]=[]),nodesByDepth[depth].push(nodeIDToNode[nodeID])}let layersByDepth={};for(let layerID in layersDepths){let depth=layersDepths[layerID];depth in layersByDepth||(layersByDepth[depth]=[]),layersByDepth[depth].push(layerIDToLayer[layerID])}let depthKeys=Object.keys(layersByDepth).map(x=>parseInt(x,10)).sort(reverseNumberCompare);this.layers=[];for(let depth of depthKeys){let layersForDepth=layersByDepth[depth];layersForDepth.sort((a,b)=>{let aIndex=layerIndices[a.id],bIndex=layerIndices[b.id];return aIndex<bIndex?-1:aIndex>bIndex?1:0});for(let layer of layersForDepth)layer instanceof Container&&this.internalContainerRefs.push(layer),this.layers.push(layer)}this.layersByDepth=layersByDepth,depthKeys=Object.keys(nodesByDepth).map(x=>parseInt(x,10)).sort(reverseNumberCompare);let computableTensors=this.inputs.slice(),layersWithCompleteInput=[];for(let depth of depthKeys)for(let node of nodesByDepth[depth]){let layer=node.outboundLayer;if(layer!=null){for(let x of node.inputTensors)if(computableTensors.indexOf(x)===-1)throw new RuntimeError(`Graph disconnected: cannot obtain value for tensor ${x} at layer "${layer.name}". The following previous layers were accessed without issue: ${layersWithCompleteInput}`);for(let x of node.outputTensors)computableTensors.push(x);layersWithCompleteInput.push(layer.name)}}this.nodesByDepth=nodesByDepth;let allNames=this.layers.map(x=>x.name);for(let name of allNames){let numOccurrences=allNames.filter(x=>x===name).length;if(numOccurrences!==1)throw new RuntimeError(`The name "${name}" is used ${numOccurrences} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(allNames))}this.outboundNodes=[],this.inboundNodes=[],new Node({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(x=>null),outputMasks:this.outputs.map(x=>null),inputShapes:this.inputs.map(x=>x.shape),outputShapes:this.outputs.map(x=>x.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let result={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let layer of this.layers)result.numDisposedVariables+=layer.dispose().numDisposedVariables;for(let container2 of this.internalContainerRefs)result.numDisposedVariables+=container2.dispose().numDisposedVariables}return result.refCountAfterDispose=this._refCount,result}get trainable(){return this.trainable_}set trainable(trainable){this.layers.forEach(layer=>{layer._trainableWeights.forEach(w=>w.trainable=trainable)}),this.trainable_=trainable}get trainableWeights(){if(this._trainableWeights.length>0)throw new ValueError("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let weights=[];for(let layer of this.layers)weights=weights.concat(layer.trainableWeights);return weights}get nonTrainableWeights(){let weights=[];for(let layer of this.layers)weights.push(...layer.nonTrainableWeights);if(!this.trainable){let trainableWeights=[];for(let layer of this.layers)trainableWeights.push(...layer.trainableWeights);return trainableWeights.concat(weights)}return weights}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(weights,strict=!0){let nameToWeight={},totalWeightsCount=0;for(let layer of this.layers)for(let weight of layer.weights){if(nameToWeight[weight.originalName]!=null)throw new ValueError(`Duplicate weight name: ${weight.originalName}`);nameToWeight[weight.originalName]=weight,totalWeightsCount++}let weightValueTuples=[];for(let name in weights){let validatedName=name;if(nameToWeight[name]==null){let tokens=name.split("/"),shortenNameArray=tokens.slice(0,-2).concat([tokens[tokens.length-1]]);validatedName=shortenNameArray.join("/")}if(nameToWeight[validatedName]!=null)weightValueTuples.push([nameToWeight[validatedName],weights[name]]);else if(strict)throw new ValueError(`Provided weight data has no target variable: ${name}`);delete nameToWeight[validatedName]}if(strict){let unsetNames=[];for(let name in nameToWeight)unsetNames.push(name);if(unsetNames.length>0)throw new ValueError(`${unsetNames.length} of ${totalWeightsCount} weights are not set: ${unsetNames}`)}batchSetValue(weightValueTuples)}updatedConfig(){let theConfig=this.getConfig(),modelConfig={};return modelConfig.className=this.getClassName(),modelConfig.config=theConfig,modelConfig.kerasVersion=`tfjs-layers ${version2}`,modelConfig.backend="TensorFlow.js",modelConfig}toJSON(unused,returnString=!0){let modelConfig=convertTsToPythonic(this.updatedConfig());return returnString?JSON.stringify(modelConfig):modelConfig}call(inputs,kwargs){return tidy(()=>{inputs=toList(inputs);let feedDict=new FeedDict;for(let i=0;i<this.inputs.length;++i)feedDict.add(this.inputs[i],inputs[i]);return execute(this.outputs,feedDict,kwargs)})}computeMask(inputs,mask){return tidy(()=>{inputs=toList(inputs);let masks;return mask==null?masks=pyListRepeat(null,inputs.length):masks=toList(mask),this.runInternalGraph(inputs,masks)[1]})}computeOutputShape(inputShape){let inputShapes=normalizeShapeList(inputShape);if(inputShapes.length!==this.inputLayers.length)throw new ValueError(`Invalid inputShape argument ${inputShape}: model has ${this.inputLayers.length} tensor inputs.`);let layersToOutputShapes={};for(let i=0;i<inputShapes.length;i++){let layer=this.inputLayers[i],inputShape2=inputShapes[i],shapeKey=layer.name+"_0_0";layersToOutputShapes[shapeKey]=inputShape2}let depthKeys=Object.keys(this.nodesByDepth).map(x=>parseInt(x,10)).sort(reverseNumberCompare);if(depthKeys.length>1)for(let depth of depthKeys){let nodes=this.nodesByDepth[depth];for(let node of nodes){let layer=node.outboundLayer;if(this.inputLayers.map(x=>x.id).indexOf(layer.id)!==-1)continue;let inputShapes2=[];for(let j=0;j<node.inboundLayers.length;j++){let inboundLayer=node.inboundLayers[j],nodeIndex2=node.nodeIndices[j],tensorIndex=node.tensorIndices[j],shapeKey=`${inboundLayer.name}_${nodeIndex2}_${tensorIndex}`,inputShape2=layersToOutputShapes[shapeKey];inputShapes2.push(inputShape2)}let outputShape=layer.computeOutputShape(singletonOrArray(inputShapes2)),outputShapes2=normalizeShapeList(outputShape),nodeIndex=layer.inboundNodes.indexOf(node);for(let j=0;j<outputShapes2.length;j++){let shapeKey=`${layer.name}_${nodeIndex}_${j}`;layersToOutputShapes[shapeKey]=outputShapes2[j]}}}let outputShapes=[],outputShapeKeys=[];for(let i=0;i<this.outputLayers.length;i++){let layer=this.outputLayers[i],nodeIndex=this.outputLayersNodeIndices[i],tensorIndex=this.outputLayersTensorIndices[i],shapeKey=`${layer.name}_${nodeIndex}_${tensorIndex}`;outputShapeKeys.push(shapeKey)}for(let i=0;i<outputShapeKeys.length;i++){let key=outputShapeKeys[i];assert2(key in layersToOutputShapes),outputShapes.push(layersToOutputShapes[key])}return singletonOrArray(outputShapes)}runInternalGraph(inputs,masks){masks==null&&(masks=pyListRepeat(null,inputs.length));let tensorMap={};for(let i=0;i<this.inputs.length;++i){let x=this.inputs[i],y=inputs[i],mask=masks[i];tensorMap[x.id]=[y,mask]}let depthKeys=Object.keys(this.nodesByDepth).map(x=>parseInt(x,10)).sort(reverseNumberCompare);for(let depth of depthKeys){let nodes=this.nodesByDepth[depth];for(let node of nodes){let layer=node.outboundLayer,referenceInputTensors=node.inputTensors,referenceOutputTensors=node.outputTensors,computedData=new Array;for(let x of referenceInputTensors)x.id in tensorMap&&computedData.push(tensorMap[x.id]);if(computedData.length===referenceInputTensors.length){let kwargs={},computedTensors,computedMasks,outputTensors2,outputMasks2;if(node.callArgs!=null&&(kwargs=node.callArgs),computedData.length===1){let[computedTensor,computedMask]=computedData[0];kwargs.mask==null&&(kwargs.mask=computedMask),outputTensors2=toList(layer.call(computedTensor,kwargs)),outputMasks2=toList(layer.computeMask(computedTensor,computedMask)),computedTensors=[computedTensor],computedMasks=[computedMask]}else computedTensors=computedData.map(x=>x[0]),computedMasks=computedData.map(x=>x[1]),kwargs.mask==null&&(kwargs.mask=computedMasks),outputTensors2=toList(layer.call(computedTensors,kwargs)),outputMasks2=toList(layer.computeMask(computedTensors,computedMasks));if(layer.activityRegularizer)throw new NotImplementedError("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let i=0;i<referenceOutputTensors.length;++i){let x=referenceOutputTensors[i],y=outputTensors2[i],mask=outputMasks2[i];tensorMap[x.id]=[y,mask]}}}}let outputTensors=[],outputMasks=[],outputShapes=[];for(let x of this.outputs){assert2(x.id in tensorMap,`Could not compute output ${x.name} : ${x.id}`);let[tensor166,mask]=tensorMap[x.id];outputShapes.push(tensor166.shape),outputTensors.push(tensor166),outputMasks.push(mask)}return[outputTensors,outputMasks,outputShapes]}buildNodeConversionMap(layers){let nodeConversionMap={},keptNodes;for(let layer of this.layers){keptNodes=layer instanceof Container?1:0;for(let originalNodeIndex=0;originalNodeIndex<layer.inboundNodes.length;originalNodeIndex++){let nodeKey=Container.nodeKey(layer,originalNodeIndex);this.containerNodes.has(nodeKey)&&(nodeConversionMap[nodeKey]=keptNodes,keptNodes+=1)}}return nodeConversionMap}getLayer(name,index){if(index!=null){if(this.layers.length<=index)throw new ValueError(`Was asked to retrieve layer at index ${index}, but model only has ${this.layers.length} layer(s).`);return this.layers[index]}else if(name==null)throw new ValueError("Provide either a layer name or layer index");for(let layer of this.layers)if(layer.name===name)return layer;throw new ValueError(`No such layer: ${name}`)}calculateLosses(){return tidy(()=>{let losses8=[];for(let layer of this.layers)for(let nodeIndex=0;nodeIndex<layer.inboundNodes.length;++nodeIndex){let nodeKey=Container.nodeKey(layer,nodeIndex);this.containerNodes.has(nodeKey)&&losses8.push(...layer.calculateLosses())}return losses8})}getConfig(){let config={name:this.name},nodeConversionMap=this.buildNodeConversionMap(this.layers),layerConfigs=[];for(let layer of this.layers){let layerClassName=layer.getClassName(),layerConfig=layer.getConfig(),filteredInboundNodes=[];for(let originalNodeIndex=0;originalNodeIndex<layer.inboundNodes.length;originalNodeIndex++){let node=layer.inboundNodes[originalNodeIndex],nodeKey=Container.nodeKey(layer,originalNodeIndex),kwargs={};if(this.containerNodes.has(nodeKey)){if(node.callArgs)try{JSON.stringify(node.callArgs),kwargs=node.callArgs}catch(err){console.warn(`Layer ${layer.name} was passed non-serializable keyword arguments: ${node.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),kwargs={}}if(node.inboundLayers.length>0){let nodeData=[];for(let i=0;i<node.inboundLayers.length;i++){let inboundLayer=node.inboundLayers[i],nodeIndex=node.nodeIndices[i],tensorIndex=node.tensorIndices[i],nodeKey2=Container.nodeKey(inboundLayer,nodeIndex),newNodeIndex=nodeConversionMap[nodeKey2];newNodeIndex==null&&(newNodeIndex=0),nodeData.push([inboundLayer.name,newNodeIndex,tensorIndex,kwargs])}filteredInboundNodes.push(nodeData)}}}let dict={};dict.name=layer.name,dict.className=layerClassName,dict.config=layerConfig,dict.inboundNodes=filteredInboundNodes,layerConfigs.push(dict)}config.layers=layerConfigs;let modelInputs=[];for(let i=0;i<this.inputLayers.length;i++){let layer=this.inputLayers[i],nodeIndex=this.inputLayersNodeIndices[i],nodeKey=Container.nodeKey(layer,nodeIndex);if(!this.containerNodes.has(nodeKey))continue;let newNodeIndex=nodeConversionMap[nodeKey];newNodeIndex==null&&(newNodeIndex=0);let tensorIndex=this.inputLayersTensorIndices[i];modelInputs.push([layer.name,newNodeIndex,tensorIndex])}config.inputLayers=modelInputs;let modelOutputs=[];for(let i=0;i<this.outputLayers.length;i++){let layer=this.outputLayers[i],nodeIndex=this.outputLayersNodeIndices[i],nodeKey=Container.nodeKey(layer,nodeIndex);if(!this.containerNodes.has(nodeKey))continue;let newNodeIndex=nodeConversionMap[nodeKey];newNodeIndex==null&&(newNodeIndex=0);let tensorIndex=this.outputLayersTensorIndices[i];modelOutputs.push([layer.name,newNodeIndex,tensorIndex])}return config.outputLayers=modelOutputs,config}static fromConfig(cls,config,customObjects={},fastWeightInit=!1){let createdLayers={},unprocessedNodes={};function addUnprocessedNode(layer,nodeData){layer.name in unprocessedNodes?unprocessedNodes[layer.name].push(nodeData):unprocessedNodes[layer.name]=[nodeData]}function processNode(layer,nodeData){let inputTensors2=[],kwargs;for(let inputData of nodeData){let inboundLayerName=inputData[0],inboundNodeIndex=inputData[1],inboundTensorIndex=inputData[2];if(kwargs=inputData[3]==null?{}:inputData[3],!(inboundLayerName in createdLayers)){addUnprocessedNode(layer,nodeData);return}let inboundLayer=createdLayers[inboundLayerName];if(inboundLayer.inboundNodes.length<=inboundNodeIndex){addUnprocessedNode(layer,nodeData);return}let inboundNode=inboundLayer.inboundNodes[inboundNodeIndex];inputTensors2.push(inboundNode.outputTensors[inboundTensorIndex])}inputTensors2.length>0&&layer.apply(singletonOrArray(inputTensors2),kwargs)}function processLayer(layerData){let layerName=layerData.name,layer=deserialize(layerData,config.customObjects!=null?config.customObjects:{});layer.setFastWeightInitDuringBuild(fastWeightInit),createdLayers[layerName]=layer;let inboundNodesData=layerData.inboundNodes;inboundNodesData.forEach(nodeData=>{if(!(nodeData instanceof Array))throw new ValueError(`Corrupted configuration, expected array for nodeData: ${nodeData}`);addUnprocessedNode(layer,nodeData)})}let name=config.name,layersFromConfig=config.layers;for(let layerData of layersFromConfig)processLayer(layerData);for(;!isObjectEmpty(unprocessedNodes);)for(let layerData of layersFromConfig){let layer=createdLayers[layerData.name];if(layer.name in unprocessedNodes){let currentUnprocessedNodesForLayer=unprocessedNodes[layer.name];delete unprocessedNodes[layer.name];for(let nodeData of currentUnprocessedNodesForLayer)processNode(layer,nodeData)}}let inputTensors=[],outputTensors=[],inputLayersFromConfig=config.inputLayers;for(let layerData of inputLayersFromConfig){let layerName=layerData[0],nodeIndex=layerData[1],tensorIndex=layerData[2];assert2(layerName in createdLayers);let layer=createdLayers[layerName],layerOutputTensors=layer.inboundNodes[nodeIndex].outputTensors;inputTensors.push(layerOutputTensors[tensorIndex])}let outputLayersFromConfig=config.outputLayers;for(let layerData of outputLayersFromConfig){let layerName=layerData[0],nodeIndex=layerData[1],tensorIndex=layerData[2];assert2(layerName in createdLayers);let layer=createdLayers[layerName],layerOutputTensors=layer.inboundNodes[nodeIndex].outputTensors;outputTensors.push(layerOutputTensors[tensorIndex])}return new cls({inputs:inputTensors,outputs:outputTensors,name})}get stateful(){if(this._stateful)throw new ValueError("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let layer of this.layers)if(layer.stateful)return!0;return!1}resetStates(){tidy(()=>{this.layers.forEach(layer=>{layer.stateful&&layer.resetStates()})})}};function standardizeSampleOrClassWeights(xWeight,outputNames,weightType){let numOutputs=outputNames.length;if(xWeight==null||Array.isArray(xWeight)&&xWeight.length===0)return outputNames.map(name=>null);if(numOutputs===1)return Array.isArray(xWeight)&&xWeight.length===1?xWeight:typeof xWeight=="object"&&outputNames[0]in xWeight?[xWeight[outputNames[0]]]:[xWeight];if(Array.isArray(xWeight)){if(xWeight.length!==numOutputs)throw new Error(`Provided ${weightType} is an array of ${xWeight.length} element(s), but the model has ${numOutputs} outputs. Make sure a set of weights is provided for each model output.`);return xWeight}else if(typeof xWeight=="object"&&Object.keys(xWeight).length>0&&typeof xWeight[Object.keys(xWeight)[0]]=="object"){let output=[];return outputNames.forEach(outputName=>{outputName in xWeight?output.push(xWeight[outputName]):output.push(null)}),output}else throw new Error(`The model has multiple (${numOutputs}) outputs, so ${weightType} must be either an array with ${numOutputs} elements or an object with ${outputNames} keys. Provided ${weightType} not understood: ${JSON.stringify(xWeight)}`)}function standardizeClassWeights(classWeight,outputNames){return standardizeSampleOrClassWeights(classWeight,outputNames,"classWeight")}async function standardizeWeights(y,sampleWeight,classWeight,sampleWeightMode){if(sampleWeight!=null||sampleWeightMode!=null)throw new Error("Support sampleWeight is not implemented yet");if(classWeight!=null){let yClasses=tidy(()=>{if(y.shape.length===1)return y.clone();if(y.shape.length===2)if(y.shape[1]>1){let axis=1;return y.argMax(axis)}else{if(y.shape[1]===1)return y.reshape([y.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${y.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${y.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),yClassIndices=Array.from(await yClasses.data());dispose(yClasses);let classSampleWeight=[];return yClassIndices.forEach(classIndex=>{if(classWeight[classIndex]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${classIndex} exists in the data but not in classWeight`);classSampleWeight.push(classWeight[classIndex])}),tensor1d(classSampleWeight,"float32")}else return null}function computeWeightedLoss2(losses8,sampleWeights){return mul(losses8,sampleWeights)}var DEFAULT_VALIDATION_BATCH_SIZE=32;function standardizeDataIteratorOutput(model2,iteratorOut){let xs,ys,iteratorOutObj=iteratorOut;xs=iteratorOutObj.xs,ys=iteratorOutObj.ys,util_exports.assert(xs!=null&&ys!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${iteratorOut}`);let flattenedXs=flattenTensorOrArrayOrMap("input",model2.inputNames,xs),flattenedYs=flattenTensorOrArrayOrMap("output",model2.outputNames,ys),batchSize=flattenedXs[0].shape[0];util_exports.assert(flattenedXs.length===model2.inputs.length,()=>`LayersModel has ${model2.inputs.length} inputs, but the dataset provides ${flattenedXs.length} inputs.  (Expected input keys: ${JSON.stringify(model2.inputNames)})`),util_exports.assert(flattenedYs.length===model2.outputs.length,()=>`LayersModel has ${model2.outputs.length} outputs, but the dataset provides ${flattenedYs.length} outputs.  (Expected output keys: ${JSON.stringify(model2.outputNames)})`);for(let xIndex=0;xIndex<flattenedXs.length;xIndex++)util_exports.assert(flattenedXs[xIndex].shape[0]===batchSize,()=>`Batch size mismatch: input ${model2.inputNames[xIndex]} has ${flattenedXs[xIndex].shape[0]}; expected  ${batchSize} based on input ${model2.inputNames[0]}.`);for(let yIndex=0;yIndex<flattenedYs.length;yIndex++)util_exports.assert(flattenedYs[yIndex].shape[0]===batchSize,()=>`Batch size mismatch: output ${model2.outputNames[yIndex]} has ${flattenedYs[yIndex].shape[0]}; expected  ${batchSize} based on input ${model2.inputNames[0]}.`);return{xs:flattenedXs,ys:flattenedYs}}function flattenTensorOrArrayOrMap(inputOrOutput,names,values){if(values instanceof Tensor)return[values];if(Array.isArray(values))return util_exports.assert(values.length===names.length,()=>`Received an array of ${values.length} Tensors, but expected ${names.length} to match the ${inputOrOutput} keys ${names}.`),values;{let result=[];for(let name of names){if(values[name]==null)throw new ValueError(`The feature data generated by the dataset lacks the required ${inputOrOutput} key '${name}'.`);result.push(values[name])}return result}}function standardizeTensorValidationData(data){if(data.length===3)throw new NotImplementedError("Validation with sample weights is not implemented yet.");return{xs:data[0],ys:data[1]}}async function fitDataset(model2,dataset5,args){let hasBatchesPerEpoch=args.batchesPerEpoch!=null;if(util_exports.assert(model2.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),util_exports.assert(args!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),util_exports.assert(args.epochs!=null&&args.epochs>0&&Number.isInteger(args.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${args.epochs}`),util_exports.assert(!hasBatchesPerEpoch||args.batchesPerEpoch>0&&Number.isInteger(args.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${args.batchesPerEpoch}`),util_exports.assert(args.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),model2.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");model2.isTraining=!0;try{let doValidation=args.validationData!=null,valXs,valYs;if(doValidation)if(isDatasetObject(args.validationData))util_exports.assert(args.validationBatches==null||args.validationBatches>0&&Number.isInteger(args.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${args.validationBatches}`);else{let validationData=standardizeTensorValidationData(args.validationData);valXs=validationData.xs,valYs=validationData.ys}let trainFunction=model2.makeTrainFunction(),outLabels=model2.getDedupedMetricsNames(),callbackMetrics;doValidation?callbackMetrics=outLabels.slice().concat(outLabels.map(n=>"val_"+n)):callbackMetrics=outLabels.slice();let callbacks3=standardizeCallbacks(args.callbacks,args.yieldEvery),verbose=args.verbose==null?1:args.verbose,{callbackList,history}=configureCallbacks(callbacks3,verbose,args.epochs,null,null,getStepsPerEpoch(dataset5,args),null,doValidation,callbackMetrics);callbackList.setModel(model2),model2.history=history,await callbackList.onTrainBegin(),model2.stopTraining_=!1;let epoch=args.initialEpoch==null?0:args.initialEpoch,dataIterator=await dataset5.iterator();for(;epoch<args.epochs;){let epochLogs={};await callbackList.onEpochBegin(epoch);let stepsDone=0,batchIndex=0;for(hasBatchesPerEpoch||(dataIterator=await dataset5.iterator());hasBatchesPerEpoch?stepsDone<args.batchesPerEpoch:!0;){let iteratorOut=await dataIterator.next();if(hasBatchesPerEpoch&&iteratorOut.done){console.warn(`You provided \`batchesPerEpoch\` as ${args.batchesPerEpoch}, but your dataset iterator ran out of data after ${stepsDone} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${args.batchesPerEpoch*args.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(iteratorOut.value!=null){let{xs,ys}=standardizeDataIteratorOutput(model2,iteratorOut.value),batchLogs={};batchLogs.batch=batchIndex,batchLogs.size=xs[0].shape[0],await callbackList.onBatchBegin(batchIndex,batchLogs);let sampleWeights=[];if(args.classWeight!=null){let standardClassWeights=standardizeClassWeights(args.classWeight,model2.outputNames);for(let i=0;i<standardClassWeights.length;++i)sampleWeights.push(await standardizeWeights(ys[i],null,standardClassWeights[i]))}let ins=xs.concat(ys).concat(sampleWeights),outs=trainFunction(ins);dispose(ins);for(let i=0;i<outLabels.length;++i){let label=outLabels[i],out=outs[i];batchLogs[label]=out,keep(out)}await callbackList.onBatchEnd(batchIndex,batchLogs),disposeTensorsInLogs(batchLogs),batchIndex++,stepsDone++}if(hasBatchesPerEpoch?stepsDone>=args.batchesPerEpoch:iteratorOut.done){if(doValidation){let valOuts;isDatasetObject(args.validationData)?valOuts=toList(await model2.evaluateDataset(args.validationData,{batches:args.validationBatches})):valOuts=toList(model2.evaluate(valXs,valYs,{batchSize:args.validationBatchSize==null?DEFAULT_VALIDATION_BATCH_SIZE:args.validationBatchSize,verbose:0}));for(let i=0;i<model2.metricsNames.length;++i)epochLogs[`val_${model2.metricsNames[i]}`]=valOuts[i]}break}if(model2.stopTraining_)break}if(await callbackList.onEpochEnd(epoch,epochLogs),epoch++,model2.stopTraining_)break}return await callbackList.onTrainEnd(),await model2.history.syncData(),model2.history}finally{model2.isTraining=!1}}function getStepsPerEpoch(dataset5,args){let stepsPerEpoch=null;return args.batchesPerEpoch!=null?stepsPerEpoch=args.batchesPerEpoch:Number.isFinite(dataset5.size)&&(stepsPerEpoch=dataset5.size),stepsPerEpoch}function isDatasetObject(dataset5){return typeof dataset5.iterator=="function"}function isLazyIteratorObject(iterator){return typeof iterator.next=="function"}async function evaluateDataset(model2,dataset5,args){args=args||{};let hasBatches=args.batches!=null,f=model2.testFunction,outs=[];if(args.verbose>0)throw new NotImplementedError("Verbose mode is not implemented yet.");util_exports.assert(!hasBatches||args.batches>0&&Number.isInteger(args.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(args.batches)}`);let dataIterator=isLazyIteratorObject(dataset5)?dataset5:await dataset5.iterator(),numExamples=0,batch=0;for(;hasBatches?batch<args.batches:!0;){let iteratorOut=await dataIterator.next();if(outs=tidy(()=>{if(iteratorOut.value){let{xs,ys}=standardizeDataIteratorOutput(model2,iteratorOut.value),xsAndYs=xs.concat(ys),batchOuts=tidy(()=>f(xsAndYs));if(dispose(xsAndYs),batch===0)for(let i=0;i<batchOuts.length;++i)outs.push(scalar(0));let batchSize=xsAndYs[0].shape[0];for(let i=0;i<batchOuts.length;++i){let batchOut=batchOuts[i],oldScalar=outs[i];outs[i]=tidy(()=>add2(outs[i],mul(batchSize,batchOut))),batch>0&&dispose(oldScalar)}dispose(batchOuts),numExamples+=batchSize,++batch}return outs}),iteratorOut.done){hasBatches&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${args.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let i=0;i<outs.length;++i){let oldScalar=outs[i];outs[i]=div(outs[i],numExamples),dispose(oldScalar)}return singletonOrArray(outs)}function checkBatchSize(batchSize){util_exports.assert(batchSize>0&&Number.isInteger(batchSize),()=>`batchSize is required to be a positive integer, but got ${batchSize}`)}function sliceArrays(arrays,start,stop){return arrays==null?[null]:Array.isArray(arrays)?arrays.map(array2=>sliceAlongFirstAxis(array2,start,stop-start)):sliceAlongFirstAxis(arrays,start,stop-start)}function sliceArraysByIndices(arrays,indices){return tidy(()=>arrays==null?null:Array.isArray(arrays)?arrays.map(array2=>sliceArraysByIndices(array2,indices)):gather6(arrays,indices.dtype==="int32"?indices:indices.toInt()))}function makeBatches(size,batchSize){let output=[],batchStart=0,batchEnd=null;for(;batchStart<size;)batchEnd=batchStart+batchSize,batchEnd>=size&&(batchEnd=size),output.push([batchStart,batchEnd]),batchStart=batchEnd;return output}async function fitLoop(model2,f,ins,outLabels,batchSize,epochs,verbose,callbacks3,valF,valIns,shuffle2,callbackMetrics,initialEpoch,stepsPerEpoch,validationSteps){batchSize==null&&(batchSize=32),epochs==null&&(epochs=1),shuffle2==null&&(shuffle2=!0),initialEpoch==null&&(initialEpoch=0);let doValidation=!1;if(valF!=null&&valIns!=null&&(doValidation=!0),validationSteps!=null&&(doValidation=!0,stepsPerEpoch==null))throw new ValueError("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let numTrainSamples=model2.checkNumSamples(ins,batchSize,stepsPerEpoch,"steps_per_epoch"),indexArray;numTrainSamples!=null&&(indexArray=range4(0,numTrainSamples)),verbose==null&&(verbose=1);let{callbackList,history}=configureCallbacks(callbacks3,verbose,epochs,initialEpoch,numTrainSamples,stepsPerEpoch,batchSize,doValidation,callbackMetrics);callbackList.setModel(model2),model2.history=history,await callbackList.onTrainBegin(),model2.stopTraining_=!1;for(let epoch=initialEpoch;epoch<epochs;++epoch){await callbackList.onEpochBegin(epoch);let epochLogs={};if(stepsPerEpoch!=null)throw new NotImplementedError("stepsPerEpoch mode is not implemented yet.");{if(shuffle2==="batch")throw new NotImplementedError("batch shuffling is not implemneted yet");shuffle2&&util_exports.shuffle(indexArray);let epochIndexArray1D=tensor1d(indexArray),batches=makeBatches(numTrainSamples,batchSize);for(let batchIndex=0;batchIndex<batches.length;++batchIndex){let batchLogs={};if(await callbackList.onBatchBegin(batchIndex,batchLogs),tidy(()=>{let batchStart=batches[batchIndex][0],batchEnd=batches[batchIndex][1],batchIds=sliceAlongFirstAxis(epochIndexArray1D,batchStart,batchEnd-batchStart);batchLogs.batch=batchIndex,batchLogs.size=batchEnd-batchStart;let insBatch=sliceArraysByIndices(ins,batchIds),outs=f(insBatch);for(let i=0;i<outLabels.length;++i){let label=outLabels[i],out=outs[i];batchLogs[label]=out,keep(out)}if(batchIndex===batches.length-1&&doValidation){let valOuts=model2.testLoop(valF,valIns,batchSize);for(let i=0;i<outLabels.length;++i){let label=outLabels[i],out=valOuts[i];keep(out),epochLogs["val_"+label]=out}}}),await callbackList.onBatchEnd(batchIndex,batchLogs),disposeTensorsInLogs(batchLogs),model2.stopTraining_)break}epochIndexArray1D.dispose()}if(await callbackList.onEpochEnd(epoch,epochLogs),model2.stopTraining_)break}return await callbackList.onTrainEnd(),await model2.history.syncData(),model2.history}async function fitTensors(model2,x,y,args={}){if(model2.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");model2.isTraining=!0;let inputs,targets,inputValX,inputValY,valX,valY,sampleWeights;try{let batchSize=args.batchSize==null?32:args.batchSize;checkBatchSize(batchSize);let checkBatchAxis=!1,standardizedOuts=await model2.standardizeUserData(x,y,args.sampleWeight,args.classWeight,checkBatchAxis,batchSize);inputs=standardizedOuts[0],targets=standardizedOuts[1],sampleWeights=standardizedOuts[2];let doValidation=!1,valIns;if(args.validationData!=null&&args.validationData.length>0){if(doValidation=!0,args.validationData.length===2)inputValX=args.validationData[0],inputValY=args.validationData[1];else throw args.validationData.length===3?new NotImplementedError("validationData including sample weights is not supported yet."):new ValueError(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${args.validationData} is invalid.`);let checkBatchAxis2=!0,valStandardized=await model2.standardizeUserData(inputValX,inputValY,null,null,checkBatchAxis2,batchSize);valX=valStandardized[0],valY=valStandardized[1],valIns=valX.concat(valY)}else if(args.validationSplit!=null&&args.validationSplit>0&&args.validationSplit<1){doValidation=!0;let splitAt=Math.floor(inputs[0].shape[0]*(1-args.validationSplit)),originalBatchSize=inputs[0].shape[0];valX=sliceArrays(inputs,splitAt,originalBatchSize),inputs=sliceArrays(inputs,0,splitAt),valY=sliceArrays(targets,splitAt,originalBatchSize),targets=sliceArrays(targets,0,splitAt),valIns=valX.concat(valY)}else args.validationSteps!=null&&(doValidation=!0);let ins=inputs.concat(targets).concat(sampleWeights);model2.checkTrainableWeightsConsistency();let trainFunction=model2.makeTrainFunction(),outLabels=model2.getDedupedMetricsNames(),valFunction,callbackMetrics;doValidation?(model2.makeTestFunction(),valFunction=model2.testFunction,callbackMetrics=outLabels.slice().concat(outLabels.map(n=>"val_"+n))):(valFunction=null,valIns=[],callbackMetrics=outLabels.slice());let callbacks3=standardizeCallbacks(args.callbacks,args.yieldEvery),out=await fitLoop(model2,trainFunction,ins,outLabels,batchSize,args.epochs,args.verbose,callbacks3,valFunction,valIns,args.shuffle,callbackMetrics,args.initialEpoch,null,null);return out}finally{model2.isTraining=!1,disposeNewTensors(inputs,x),disposeNewTensors(targets,y),disposeNewTensors(valX,inputValX),disposeNewTensors(valY,inputValY),sampleWeights!=null&&dispose(sampleWeights)}}function ensureTensorsRank2OrHigher(tensors){let outs=[];tensors instanceof Tensor&&(tensors=[tensors]);for(let i=0;i<tensors.length;++i){let tensor166=tensors[i];if(tensor166.rank===1)outs.push(expandDims2(tensor166,1));else{if(tensor166.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");outs.push(tensor166)}}return outs}function disposeNewTensors(tensors,refTensors){if(tensors==null)return;let oldTensorIds=[];if(refTensors instanceof Tensor)oldTensorIds.push(refTensors.id);else if(Array.isArray(refTensors))refTensors.forEach(t=>oldTensorIds.push(t.id));else if(refTensors!=null)for(let name in refTensors){let oldTensor=refTensors[name];oldTensorIds.push(oldTensor.id)}let tensorsToDispose=[];if(tensors instanceof Tensor)oldTensorIds.indexOf(tensors.id)===-1&&tensorsToDispose.push(tensors);else if(Array.isArray(tensors))tensors.forEach(t=>{oldTensorIds.indexOf(t.id)===-1&&tensorsToDispose.push(t)});else if(tensors!=null)for(let name in tensors){let tensor166=tensors[name];oldTensorIds.indexOf(tensor166.id)===-1&&tensorsToDispose.push(tensor166)}tensorsToDispose.forEach(t=>{t.isDisposed||t.dispose()})}function isDataTensor(x){return x instanceof Tensor}function isDataArray(x){return Array.isArray(x)}function isDataDict(x){return!isDataTensor(x)&&!isDataArray(x)}function standardizeInputData(data,names,shapes,checkBatchAxis=!0,exceptionPrefix=""){if(names==null||names.length===0){if(data!=null){let gotUnexpectedData=!1;if(isDataArray(data)&&data.length>0)gotUnexpectedData=!0;else if(isDataDict(data)){for(let key in data)if(data.hasOwnProperty(key)){gotUnexpectedData=!0;break}}else gotUnexpectedData=!0;if(gotUnexpectedData)throw new ValueError(`Error when checking model ${exceptionPrefix} expected no data, but got ${data}`)}return[]}if(data==null)return names.map(name=>null);let arrays;if(isDataDict(data)){data=data,arrays=[];for(let name of names){if(data[name]==null)throw new ValueError(`No data provided for "${name}". Need data for each key in: ${names}`);arrays.push(data[name])}}else if(isDataArray(data)){if(data=data,data.length!==names.length)throw new ValueError(`Error when checking model ${exceptionPrefix}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${names.length} Tensor(s), but instead got the following list of Tensor(s): ${data}`);arrays=data}else{if(data=data,names.length>1)throw new ValueError(`The model ${exceptionPrefix} expects ${names.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${data.shape}`);arrays=[data]}if(arrays=ensureTensorsRank2OrHigher(arrays),shapes!=null)for(let i=0;i<names.length;++i){if(shapes[i]==null)continue;let array2=arrays[i];if(array2.shape.length!==shapes[i].length)throw new ValueError(`Error when checking ${exceptionPrefix}: expected ${names[i]} to have ${shapes[i].length} dimension(s). but got array with shape ${array2.shape}`);for(let j=0;j<shapes[i].length;++j){if(j===0&&!checkBatchAxis)continue;let dim=array2.shape[j],refDim=shapes[i][j];if(refDim!=null&&refDim>=0&&dim!==refDim)throw new ValueError(`Error when checking ${exceptionPrefix}: expected ${names[i]} to have shape [${shapes[i]}], but got array with shape [${array2.shape}].`)}}return arrays}function checkArrayLengths(inputs,targets,weights){let setX=unique5(inputs.map(input2=>input2.shape[0]));setX.sort();let setY=unique5(targets.map(target=>target.shape[0]));if(setY.sort(),setX.length>1)throw new ValueError(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(inputs.map(input2=>input2.shape))}`);if(setY.length>1)throw new ValueError(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(targets.map(target=>target.shape))}`);if(setX.length>0&&setY.length>0&&!util_exports.arraysEqual(setX,setY))throw new ValueError(`Input Tensors should have the same number of samples as target Tensors. Found ${setX[0]} input sample(s) and ${setY[0]} target sample(s).`)}function checkLossAndTargetCompatibility(targets,lossFns,outputShapes){let keyLosses=[meanSquaredError2,binaryCrossentropy,categoricalCrossentropy];for(let i=0;i<targets.length;++i){let y=targets[i],loss=lossFns[i],shape=outputShapes[i];if(loss==null)continue;if(loss===categoricalCrossentropy&&y.shape[y.shape.length-1]===1)throw new ValueError(`You are passing a target array of shape ${y.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(keyLosses.indexOf(loss)!==-1){let slicedYShape=y.shape.slice(1),slicedShape=shape.slice(1);for(let j=0;j<slicedYShape.length;++j){let targetDim=slicedYShape[j],outDim=slicedShape[j];if(outDim!=null&&targetDim!==outDim)throw new ValueError(`A target Tensor with shape ${y.shape} was passed for an output of shape ${shape}, while using a loss function that expects targets to have the same shape as the output.`)}}}}function checkInputData(data,names,shapes,checkBatchAxis=!0,exceptionPrefix=""){let arrays;if(Array.isArray(data)){if(data.length!==names.length)throw new ValueError(`Error when checking model ${exceptionPrefix}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${names.length} Tensor(s), but instead got ${data.length} Tensors(s).`);arrays=data}else{if(names.length>1)throw new ValueError(`The model expects ${names.length} ${exceptionPrefix} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(data.shape)}.`);arrays=[data]}if(shapes!=null)for(let i=0;i<names.length;++i){if(shapes[i]==null)continue;let array2=arrays[i];if(array2.shape.length!==shapes[i].length)throw new ValueError(`Error when checking ${exceptionPrefix}: expected ${names[i]} to have ${shapes[i].length} dimension(s), but got array with shape ${JSON.stringify(array2.shape)}`);for(let j=0;j<shapes[i].length;++j){if(j===0&&!checkBatchAxis)continue;let dim=array2.shape[j],refDim=shapes[i][j];if(refDim!=null&&refDim!==dim)throw new ValueError(`Error when checking ${exceptionPrefix}: expected ${names[i]} to have shape ${JSON.stringify(shapes[i])} but got array with shape ${JSON.stringify(array2.shape)}.`)}}}function collectMetrics(metrics2,outputNames){if(metrics2==null||Array.isArray(metrics2)&&metrics2.length===0)return outputNames.map(name=>[]);let wrappedMetrics;if(typeof metrics2=="string"||typeof metrics2=="function")wrappedMetrics=[metrics2];else if(Array.isArray(metrics2)||typeof metrics2=="object")wrappedMetrics=metrics2;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${metrics2}`);if(Array.isArray(wrappedMetrics))return outputNames.map(name=>wrappedMetrics);{let nestedMetrics=[];for(let name of outputNames){let outputMetrics=wrappedMetrics.hasOwnProperty(name)?wrappedMetrics[name]:[];Array.isArray(outputMetrics)||(outputMetrics=[outputMetrics]),nestedMetrics.push(outputMetrics)}return nestedMetrics}}var LAYERS_MODEL_FORMAT_NAME="layers-model",LayersModel=class extends Container{constructor(args){super(args);this.isTraining=!1}summary(lineLength,positions,printFn=console.log){if(!this.built)throw new ValueError("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");printSummary(this,lineLength,positions,printFn)}compile(args){if(args.loss==null&&(args.loss=[]),this.loss=args.loss,typeof args.optimizer=="string")this.optimizer_=getOptimizer(args.optimizer),this.isOptimizerOwned=!0;else{if(!(args.optimizer instanceof Optimizer))throw new ValueError("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=args.optimizer,this.isOptimizerOwned=!1}let lossFunctions=[];if(!Array.isArray(args.loss)&&typeof args.loss!="string"&&typeof args.loss!="function"){args.loss=args.loss;for(let name in args.loss)if(this.outputNames.indexOf(name)===-1)throw new ValueError(`Unknown entry in loss dictionary: "${name}". Only expected the following keys: ${this.outputNames}`);for(let name of this.outputNames)args.loss[name]==null&&console.warn(`Output "${name}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${name} during training`),lossFunctions.push(get(args.loss[name]))}else if(Array.isArray(args.loss)){if(args.loss.length!==this.outputs.length)throw new ValueError(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${args.loss}.`);let theLosses=args.loss;lossFunctions=theLosses.map(l=>get(l))}else{let lossFunction=get(args.loss);this.outputs.forEach(_=>{lossFunctions.push(lossFunction)})}this.lossFunctions=lossFunctions,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){let shape=this.internalOutputShapes[i],name=this.outputNames[i];this.feedOutputNames.push(name),this.feedOutputShapes.push(shape),this.feedLossFns.push(this.lossFunctions[i])}let skipTargetIndices=[];this.metrics=args.metrics,this.metricsNames=["loss"],this.metricsTensors=[],nameScope("loss",()=>{for(let i=0;i<this.outputs.length;++i){if(skipTargetIndices.indexOf(i)!==-1)continue;let weightedLoss=this.lossFunctions[i];this.outputs.length>1&&(this.metricsTensors.push([weightedLoss,i]),this.metricsNames.push(this.outputNames[i]+"_loss"))}});let nestedMetrics=collectMetrics(args.metrics,this.outputNames),appendMetric=(outputIndex,metricName,metricTensor)=>{this.outputNames.length>1&&(metricName=this.outputNames[outputIndex]+"_"+metricName),this.metricsNames.push(metricName),this.metricsTensors.push([metricTensor,outputIndex])};nameScope("metric",()=>{for(let i=0;i<this.outputs.length;++i){if(skipTargetIndices.indexOf(i)!==-1)continue;let outputMetrics=nestedMetrics[i],handleMetrics=metrics2=>{let metricNamePrefix="",metricName,accFn,weightedMetricFn;for(let metric of metrics2){if(typeof metric=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(metric)!==-1){let outputShape=this.internalOutputShapes[i];outputShape[outputShape.length-1]===1||this.lossFunctions[i]===binaryCrossentropy?["accuracy","acc"].indexOf(metric)!==-1?accFn=binaryAccuracy:["crossentropy","ce"].indexOf(metric)!==-1&&(accFn=binaryCrossentropy2):this.lossFunctions[i]===sparseCategoricalCrossentropy?["accuracy","acc"].indexOf(metric)!==-1?accFn=sparseCategoricalAccuracy:["crossentropy","ce"].indexOf(metric)!==-1&&(accFn=sparseCategoricalCrossentropy2):["accuracy","acc"].indexOf(metric)!==-1?accFn=categoricalAccuracy:["crossentropy","ce"].indexOf(metric)!==-1&&(accFn=categoricalCrossentropy2);let suffix;["accuracy","acc"].indexOf(metric)!==-1?suffix="acc":["crossentropy","ce"].indexOf(metric)!==-1&&(suffix="ce"),weightedMetricFn=accFn,metricName=metricNamePrefix+suffix}else{let metricFn=get2(metric);weightedMetricFn=metricFn,metricName=metricNamePrefix+getLossOrMetricName(metric)}let metricResult;nameScope(metricName,()=>{metricResult=weightedMetricFn}),appendMetric(i,metricName,metricResult)}};handleMetrics(outputMetrics)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){if(this.collectedTrainableWeights==null)return;this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(x,y,args={}){let batchSize=args.batchSize==null?32:args.batchSize;checkBatchSize(batchSize);let checkBatchAxis=!0,standardizedOuts=this.standardizeUserDataXY(x,y,checkBatchAxis,batchSize);try{let ins=standardizedOuts[0].concat(standardizedOuts[1]);this.makeTestFunction();let f=this.testFunction,testOuts=this.testLoop(f,ins,batchSize,args.verbose,args.steps);return singletonOrArray(testOuts)}finally{disposeNewTensors(standardizedOuts[0],x),disposeNewTensors(standardizedOuts[1],y)}}async evaluateDataset(dataset5,args){return this.makeTestFunction(),evaluateDataset(this,dataset5,args)}checkNumSamples(ins,batchSize,steps,stepsName="steps"){let numSamples;if(steps!=null){if(numSamples=null,batchSize!=null)throw new ValueError(`If ${stepsName} is set, batchSize must be null or undefined.Got batchSize = ${batchSize}`)}else if(ins!=null)Array.isArray(ins)?numSamples=ins[0].shape[0]:numSamples=ins.shape[0];else throw new ValueError(`Either the input data should have a defined shape, or ${stepsName} shoud be specified.`);return numSamples}execute(inputs,outputs){if(Array.isArray(outputs)&&outputs.length===0)throw new ValueError("`outputs` is an empty Array, which is not allowed.");let outputsIsArray=Array.isArray(outputs),outputNames=outputsIsArray?outputs:[outputs],outputSymbolicTensors=this.retrieveSymbolicTensors(outputNames),feedDict=new FeedDict;if(inputs instanceof Tensor&&(inputs=[inputs]),Array.isArray(inputs)){if(inputs.length!==this.inputs.length)throw new ValueError(`The number of inputs provided (${inputs.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let i=0;i<this.inputs.length;++i)feedDict.add(this.inputs[i],inputs[i])}else for(let input2 of this.inputs){let tensorValue=inputs[input2.name];if(tensorValue==null)throw new ValueError(`No value is provided for the model's input ${input2.name}`);feedDict.add(input2,tensorValue)}let executeOutputs=execute(outputSymbolicTensors,feedDict);return outputsIsArray?executeOutputs:executeOutputs[0]}retrieveSymbolicTensors(symbolicTensorNames){let outputSymbolicTensors=pyListRepeat(null,symbolicTensorNames.length),outputsRemaining=symbolicTensorNames.length;for(let layer of this.layers){let layerOutputs=Array.isArray(layer.output)?layer.output:[layer.output],layerOutputNames=layerOutputs.map(output=>output.name);for(let i=0;i<symbolicTensorNames.length;++i){let index=layerOutputNames.indexOf(symbolicTensorNames[i]);if(index!==-1&&(outputSymbolicTensors[i]=layerOutputs[index],outputsRemaining--),outputsRemaining===0)break}if(outputsRemaining===0)break}if(outputsRemaining>0){let remainingNames=[];throw outputSymbolicTensors.forEach((tensor166,i)=>{tensor166==null&&remainingNames.push(symbolicTensorNames[i])}),new ValueError(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(remainingNames)}`)}return outputSymbolicTensors}predictLoop(ins,batchSize=32,verbose=!1){return tidy(()=>{let numSamples=this.checkNumSamples(ins);if(verbose)throw new NotImplementedError("Verbose predictLoop() is not implemented yet.");let batches=makeBatches(numSamples,batchSize),outsBatches=this.outputs.map(output=>[]);for(let batchIndex=0;batchIndex<batches.length;++batchIndex){let batchOuts=tidy(()=>{let batchStart=batches[batchIndex][0],batchEnd=batches[batchIndex][1],insBatch=sliceArrays(ins,batchStart,batchEnd),feeds=[];if(Array.isArray(insBatch))for(let i=0;i<insBatch.length;++i)feeds.push({key:this.inputs[i],value:insBatch[i]});else feeds.push({key:this.inputs[0],value:insBatch});let feedDict=new FeedDict(feeds);return execute(this.outputs,feedDict)});batchOuts.forEach((batchOut,i)=>outsBatches[i].push(batchOut))}return singletonOrArray(outsBatches.map(batches2=>concat(batches2,0)))})}predict(x,args={}){let xsRank2OrHigher=ensureTensorsRank2OrHigher(x);checkInputData(xsRank2OrHigher,this.inputNames,this.feedInputShapes,!1);try{let batchSize=args.batchSize==null?32:args.batchSize;return checkBatchSize(batchSize),this.predictLoop(xsRank2OrHigher,batchSize)}finally{disposeNewTensors(xsRank2OrHigher,x)}}predictOnBatch(x){checkInputData(x,this.inputNames,this.feedInputShapes,!0);let batchSize=(Array.isArray(x)?x[0]:x).shape[0];return this.predictLoop(x,batchSize)}standardizeUserDataXY(x,y,checkBatchAxis=!0,batchSize){if(this.optimizer_==null)throw new RuntimeError("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let outputShapes=[];for(let i=0;i<this.feedOutputShapes.length;++i){let outputShape=this.feedOutputShapes[i],lossFn=this.feedLossFns[i];lossFn===sparseCategoricalCrossentropy?outputShapes.push(outputShape.slice(0,outputShape.length-1).concat([1])):outputShapes.push(outputShape)}if(x=standardizeInputData(x,this.feedInputNames,this.feedInputShapes,!1,"input"),y=standardizeInputData(y,this.feedOutputNames,outputShapes,!1,"target"),checkArrayLengths(x,y,null),checkLossAndTargetCompatibility(y,this.feedLossFns,this.feedOutputShapes),this.stateful&&batchSize!=null&&batchSize>0&&x[0].shape[0]%batchSize!==0)throw new ValueError(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${batchSize}. Found: ${x[0].shape[0]} sample(s).`);return[x,y]}async standardizeUserData(x,y,sampleWeight,classWeight,checkBatchAxis=!0,batchSize){let[standardXs,standardYs]=this.standardizeUserDataXY(x,y,checkBatchAxis,batchSize);if(sampleWeight!=null)throw new Error("sample weight is not supported yet.");let standardSampleWeights=null;if(classWeight!=null){let classWeights=standardizeClassWeights(classWeight,this.outputNames);standardSampleWeights=[];for(let i=0;i<classWeights.length;++i)standardSampleWeights.push(await standardizeWeights(standardYs[i],null,classWeights[i]))}return[standardXs,standardYs,standardSampleWeights]}testLoop(f,ins,batchSize,verbose=0,steps){return tidy(()=>{let numSamples=this.checkNumSamples(ins,batchSize,steps,"steps"),outs=[];if(verbose>0)throw new NotImplementedError("Verbose mode is not implemented yet.");if(steps!=null)throw new NotImplementedError("steps mode in testLoop() is not implemented yet");{let batches=makeBatches(numSamples,batchSize),indexArray=tensor1d(range4(0,numSamples));for(let batchIndex=0;batchIndex<batches.length;++batchIndex){let batchStart=batches[batchIndex][0],batchEnd=batches[batchIndex][1],batchIds=sliceAlongFirstAxis(indexArray,batchStart,batchEnd-batchStart),insBatch=sliceArraysByIndices(ins,batchIds),batchOuts=f(insBatch);if(batchIndex===0)for(let i=0;i<batchOuts.length;++i)outs.push(scalar(0));for(let i=0;i<batchOuts.length;++i){let batchOut=batchOuts[i];outs[i]=add2(outs[i],mul(batchEnd-batchStart,batchOut))}}for(let i=0;i<outs.length;++i)outs[i]=div(outs[i],numSamples)}return outs})}getDedupedMetricsNames(){let outLabels=this.metricsNames,dedupedOutLabels=[];for(let i=0;i<outLabels.length;++i){let label=outLabels[i],newLabel=label;if(count(outLabels,label)>1){let dupIndex=count(outLabels.slice(0,i),label);newLabel+=`_${dupIndex}`}dedupedOutLabels.push(newLabel)}return dedupedOutLabels}makeTrainFunction(){return data=>{let lossValues=[],inputs=data.slice(0,this.inputs.length),targets=data.slice(this.inputs.length,this.inputs.length+this.outputs.length),sampleWeights=data.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),metricsValues=[],totalLossFunction=()=>{let feeds=[];for(let i=0;i<this.inputs.length;++i)feeds.push({key:this.inputs[i],value:inputs[i]});let feedDict=new FeedDict(feeds),outputs=execute(this.outputs,feedDict,{training:!0}),totalLoss;for(let i=0;i<this.lossFunctions.length;++i){let lossFunction=this.lossFunctions[i],loss=lossFunction(targets[i],outputs[i]);sampleWeights[i]!=null&&(loss=computeWeightedLoss2(loss,sampleWeights[i]));let meanLoss=mean(loss);lossValues.push(meanLoss),i===0?totalLoss=loss:totalLoss=add2(totalLoss,loss)}for(let i=0;i<this.metricsTensors.length;++i){let weightedMetric;if(this.outputs.length>1&&i<this.outputs.length)weightedMetric=lossValues[i];else{let metric=this.metricsTensors[i][0],outputIndex=this.metricsTensors[i][1];weightedMetric=mean(metric(targets[outputIndex],outputs[outputIndex]))}keep(weightedMetric),metricsValues.push(weightedMetric)}return totalLoss=mean(totalLoss),this.calculateLosses().forEach(regularizerLoss=>{totalLoss=add2(totalLoss,regularizerLoss)}),totalLoss},variables5=this.collectedTrainableWeights.map(param=>param.read()),returnCost=!0,totalLossValue=this.optimizer_.minimize(totalLossFunction,returnCost,variables5);return[totalLossValue].concat(metricsValues)}}makeTestFunction(){this.testFunction=data=>tidy(()=>{let valOutputs=[],totalLoss,inputs=data.slice(0,this.inputs.length),targets=data.slice(this.inputs.length,this.inputs.length+this.outputs.length),feeds=[];for(let i=0;i<this.inputs.length;++i)feeds.push({key:this.inputs[i],value:inputs[i]});let feedDict=new FeedDict(feeds),outputs=execute(this.outputs,feedDict);for(let i=0;i<this.lossFunctions.length;++i){let lossFunction=this.lossFunctions[i],loss=mean(lossFunction(targets[i],outputs[i]));i===0?totalLoss=loss:totalLoss=add2(totalLoss,loss),valOutputs.push(totalLoss)}for(let i=0;i<this.metricsTensors.length;++i){let metric=this.metricsTensors[i][0],outputIndex=this.metricsTensors[i][1],meanMetric=mean(metric(targets[outputIndex],outputs[outputIndex]));valOutputs.push(meanMetric)}return valOutputs})}async fit(x,y,args={}){return fitTensors(this,x,y,args)}async fitDataset(dataset5,args){return fitDataset(this,dataset5,args)}async trainOnBatch(x,y){let standardizeOut=await this.standardizeUserData(x,y),inputs=standardizeOut[0],targets=standardizeOut[1],trainFunction=this.makeTrainFunction(),losses8=trainFunction(inputs.concat(targets)),lossValues=[];for(let loss of losses8){let v=await loss.data();lossValues.push(v[0])}return dispose(losses8),singletonOrArray(lossValues)}getNamedWeights(config){let namedWeights=[],trainableOnly=config!=null&&config.trainableOnly,weights=trainableOnly?this.trainableWeights:this.weights,weightValues=this.getWeights(trainableOnly);for(let i=0;i<weights.length;++i){if(trainableOnly&&!weights[i].trainable)continue;namedWeights.push({name:weights[i].originalName,tensor:weightValues[i]})}return namedWeights}set stopTraining(stop){this.stopTraining_=stop}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(optimizer7){this.optimizer_!==optimizer7&&(this.optimizer_=optimizer7,this.isOptimizerOwned=!1)}dispose(){let result=super.dispose();if(result.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let numTensorsBeforeOptmizerDisposal=memory().numTensors;this.optimizer_.dispose(),result.numDisposedVariables+=numTensorsBeforeOptmizerDisposal-memory().numTensors}return result}getLossIdentifiers(){let lossNames;if(typeof this.loss=="string")lossNames=toSnakeCase(this.loss);else if(Array.isArray(this.loss)){for(let loss of this.loss)if(typeof loss!="string")throw new Error("Serialization of non-string loss is not supported.");lossNames=this.loss.map(name=>toSnakeCase(name))}else{let outputNames=Object.keys(this.loss);lossNames={};let losses8=this.loss;for(let outputName of outputNames)if(typeof losses8[outputName]=="string")lossNames[outputName]=toSnakeCase(losses8[outputName]);else throw new Error("Serialization of non-string loss is not supported.")}return lossNames}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[toSnakeCase(getLossOrMetricName(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(metric=>toSnakeCase(getLossOrMetricName(metric)));{let metricsIdentifiers={};for(let key in this.metrics)metricsIdentifiers[key]=toSnakeCase(getLossOrMetricName(this.metrics[key]));return metricsIdentifiers}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(trainingConfig){if(trainingConfig.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(trainingConfig.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(trainingConfig.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let tsConfig=convertPythonicToTs(trainingConfig.optimizer_config),optimizer7=deserialize(tsConfig),loss;if(typeof trainingConfig.loss=="string")loss=toCamelCase(trainingConfig.loss);else if(Array.isArray(trainingConfig.loss))loss=trainingConfig.loss.map(lossEntry=>toCamelCase(lossEntry));else if(trainingConfig.loss!=null){loss={};for(let key in trainingConfig.loss)loss[key]=toCamelCase(trainingConfig.loss[key])}let metrics2;if(Array.isArray(trainingConfig.metrics))metrics2=trainingConfig.metrics.map(metric=>toCamelCase(metric));else if(trainingConfig.metrics!=null){metrics2={};for(let key in trainingConfig.metrics)metrics2[key]=toCamelCase(trainingConfig.metrics[key])}this.compile({loss,metrics:metrics2,optimizer:optimizer7})}async save(handlerOrURL,config){if(typeof handlerOrURL=="string"){let handlers=io_exports.getSaveHandlers(handlerOrURL);if(handlers.length===0)throw new ValueError(`Cannot find any save handlers for URL '${handlerOrURL}'`);if(handlers.length>1)throw new ValueError(`Found more than one (${handlers.length}) save handlers for URL '${handlerOrURL}'`);handlerOrURL=handlers[0]}if(handlerOrURL.save==null)throw new ValueError("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let weightDataAndSpecs=await io_exports.encodeWeights(this.getNamedWeights(config)),returnString=!1,unusedArg=null,modelConfig=this.toJSON(unusedArg,returnString),modelArtifacts={modelTopology:modelConfig,format:LAYERS_MODEL_FORMAT_NAME,generatedBy:`TensorFlow.js tfjs-layers v${version2}`,convertedBy:null},includeOptimizer=config==null?!1:config.includeOptimizer;if(includeOptimizer&&this.optimizer!=null){modelArtifacts.trainingConfig=this.getTrainingConfig();let weightType="optimizer",{data:optimizerWeightData,specs:optimizerWeightSpecs}=await io_exports.encodeWeights(await this.optimizer.getWeights(),weightType);weightDataAndSpecs.specs.push(...optimizerWeightSpecs),weightDataAndSpecs.data=io_exports.concatenateArrayBuffers([weightDataAndSpecs.data,optimizerWeightData])}if(this.userDefinedMetadata!=null){let checkSize=!0;checkUserDefinedMetadata(this.userDefinedMetadata,this.name,checkSize),modelArtifacts.userDefinedMetadata=this.userDefinedMetadata}return modelArtifacts.weightData=weightDataAndSpecs.data,modelArtifacts.weightSpecs=weightDataAndSpecs.specs,handlerOrURL.save(modelArtifacts)}setUserDefinedMetadata(userDefinedMetadata){checkUserDefinedMetadata(userDefinedMetadata,this.name),this.userDefinedMetadata=userDefinedMetadata}getUserDefinedMetadata(){return this.userDefinedMetadata}};LayersModel.className="Model";serialization_exports.registerClass(LayersModel);var Functional=class extends LayersModel{};Functional.className="Functional";serialization_exports.registerClass(Functional);var Sequential=class extends LayersModel{constructor(args){super({inputs:[],outputs:[]});if(args=args||{},this.trainable=!0,this.built=!1,this.name=args.name!=null?args.name:getUid("sequential_"),args.layers!=null)for(let layer of args.layers)this.add(layer)}checkShape(layer){let shape=layer.inboundNodes[0].outputTensors[0].shape;if(shape.some(x=>x<0))throw new ValueError(`Negative dimension size caused by adding layer ${layer.name} with input shape [${layer.inboundNodes[0].inputTensors[0].shape}]`)}add(layer){let isLayerModelInstance=layer instanceof Sequential||layer instanceof LayersModel,modelLayer;if(isLayerModelInstance){if(modelLayer=layer,modelLayer.outputs.length!==1)throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(modelLayer.inputs.length!==1)throw new ValueError("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(layer.inboundNodes.length===0){if(layer.batchInputShape==null)throw new ValueError("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let x=Input({batchShape:layer.batchInputShape,dtype:layer.dtype,name:layer.name+"_input"});layer.apply(x)}if(isLayerModelInstance)this.outputs=modelLayer.outputs,this.inputs=modelLayer.inputs;else{if(layer.inboundNodes.length!==1)throw new ValueError(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${layer.name} which has ${layer.inboundNodes.length} pre-existing inbound connections.`);if(layer.inboundNodes[0].outputTensors.length!==1)throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(layer),this.outputs=[layer.inboundNodes[0].outputTensors[0]],this.inputs=getSourceInputs(this.outputs[0])}this.inboundNodes=[],new Node({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:pyListRepeat(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(x=>x.shape),outputShapes:this.outputs[0].shape})}else{let outputTensor=layer.apply(this.outputs[0]);if(Array.isArray(outputTensor))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(layer),this.outputs=[outputTensor],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(layer),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let lastLayerIndex=this.layers.length-1;this.layers[lastLayerIndex].outboundNodes=[],this.outputs=[this.layers[lastLayerIndex].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(inputs,kwargs){return this.model==null&&this.build(),this.model.call(inputs,kwargs)}build(inputShape){if(getExactlyOneShape(inputShape),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new LayersModel({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(lineLength,positions,printFn=console.log){this.built||this.build(),super.summary(lineLength,positions,printFn)}setWeights(weights){this.model==null&&this.build(),this.model.setWeights(weights)}evaluate(x,y,args={}){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return this.model.evaluate(x,y,args)}async evaluateDataset(dataset5,args){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return this.model.evaluateDataset(dataset5,args)}predict(x,args={}){return this.model==null&&this.build(),this.model.predict(x,args)}predictOnBatch(x){return this.model==null&&this.build(),this.model.predictOnBatch(x)}compile(args){this.build(),this.model.compile(args),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(optimizer7){this.model.optimizer=optimizer7}async fit(x,y,args={}){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return this.model.fit(x,y,args)}async fitDataset(dataset5,args){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return this.model.fitDataset(dataset5,args)}async trainOnBatch(x,y){return this.model.trainOnBatch(x,y)}static fromConfig(cls,config,customObjects={},fastWeightInit=!1){let configArray,extraModelConfig={};if(config instanceof Array){if(!(config[0].className!=null)||config[0].className==="Merge")throw new ValueError("Legacy serialization format not supported yet.");configArray=config}else util_exports.assert(config.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),configArray=config.layers,delete config.layers,extraModelConfig=config;let model2=new cls(extraModelConfig);if(!(model2 instanceof Sequential))throw new NotImplementedError(`Sequential.fromConfig called on non-Sequential input: ${model2}`);for(let conf of configArray){let customObjects2=void 0,layer=deserialize(conf,customObjects2,fastWeightInit);fastWeightInit&&layer.setFastWeightInitDuringBuild(!0),model2.add(layer)}return model2}set stopTraining(stop){if(this.model==null)throw new ValueError("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=stop}get stopTraining(){if(this.model==null)throw new ValueError("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let layers=[];for(let layer of this.layers){let dict={};dict.className=layer.getClassName(),dict.config=layer.getConfig(),layers.push(dict)}return{name:this.name,layers}}};Sequential.className="Sequential";serialization_exports.registerClass(Sequential);var Activation=class extends serialization_exports.Serializable{getConfig(){return{}}},Elu2=class extends Activation{apply(x,alpha=1){return elu6(x,alpha)}};Elu2.className="elu";serialization_exports.registerClass(Elu2);var Selu2=class extends Activation{apply(x){return selu(x)}};Selu2.className="selu";serialization_exports.registerClass(Selu2);var Relu2=class extends Activation{apply(x){return relu(x)}};Relu2.className="relu";serialization_exports.registerClass(Relu2);var Relu62=class extends Activation{apply(x){return tidy(()=>minimum(6,relu(x)))}};Relu62.className="relu6";serialization_exports.registerClass(Relu62);var Linear=class extends Activation{apply(x){return x}};Linear.className="linear";serialization_exports.registerClass(Linear);var Sigmoid2=class extends Activation{apply(x){return sigmoid(x)}};Sigmoid2.className="sigmoid";serialization_exports.registerClass(Sigmoid2);var HardSigmoid=class extends Activation{apply(x){return hardSigmoid(x)}};HardSigmoid.className="hardSigmoid";serialization_exports.registerClass(HardSigmoid);var Softplus2=class extends Activation{apply(x){return softplus(x)}};Softplus2.className="softplus";serialization_exports.registerClass(Softplus2);var Softsign=class extends Activation{apply(x){return softsign(x)}};Softsign.className="softsign";serialization_exports.registerClass(Softsign);var Tanh2=class extends Activation{apply(x){return tanh2(x)}};Tanh2.className="tanh";serialization_exports.registerClass(Tanh2);var Softmax2=class extends Activation{apply(x,axis=-1){return softmax(x,axis)}};Softmax2.className="softmax";serialization_exports.registerClass(Softmax2);var LogSoftmax2=class extends Activation{apply(x,axis=-1){return logSoftmax(x,axis)}};LogSoftmax2.className="logSoftmax";serialization_exports.registerClass(LogSoftmax2);var Swish=class extends Activation{apply(x,alpha=1){return tidy(()=>sigmoid(x.mul(alpha)).mul(x))}};Swish.className="swish";serialization_exports.registerClass(Swish);function serializeActivation(activation){return activation.getClassName()}function deserializeActivation(config,customObjects={}){return deserializeKerasObject(config,serialization_exports.SerializationMap.getMap().classNameMap,customObjects,"activation")}function getActivation(identifier){if(identifier==null){let config={};return config.className="linear",config.config={},deserializeActivation(config)}if(typeof identifier=="string"){let config={};return config.className=identifier,config.config={},deserializeActivation(config)}else return identifier instanceof Activation?identifier:deserializeActivation(identifier)}function assertObjectArgs(args){if(args!=null&&typeof args!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${args}`)}var Regularizer=class extends serialization_exports.Serializable{},L1L2=class extends Regularizer{constructor(args){super();assertObjectArgs(args),this.l1=args==null||args.l1==null?.01:args.l1,this.l2=args==null||args.l2==null?.01:args.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(x){return tidy(()=>{let regularization=zeros([1]);return this.hasL1&&(regularization=add2(regularization,sum2(mul(this.l1,abs(x))))),this.hasL2&&(regularization=add2(regularization,sum2(mul(this.l2,square24(x))))),regularization.asScalar()})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(cls,config){return new cls({l1:config.l1,l2:config.l2})}};L1L2.className="L1L2";serialization_exports.registerClass(L1L2);var REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP={l1l2:"L1L2"};function serializeRegularizer(constraint){return serializeKerasObject(constraint)}function deserializeRegularizer(config,customObjects={}){return deserializeKerasObject(config,serialization_exports.SerializationMap.getMap().classNameMap,customObjects,"regularizer")}function getRegularizer(identifier){if(identifier==null)return null;if(typeof identifier=="string"){let className=identifier in REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP?REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier]:identifier,config={className,config:{}};return deserializeRegularizer(config)}else return identifier instanceof Regularizer?identifier:deserializeRegularizer(identifier)}var ReLU=class extends Layer{constructor(args){super(args==null?{}:args);this.supportsMasking=!0,args!=null&&(this.maxValue=args.maxValue)}call(inputs,kwargs){inputs=getExactlyOneTensor(inputs);let output=relu(inputs);return this.maxValue!=null&&(output=clipByValue(output,0,this.maxValue)),output}computeOutputShape(inputShape){return inputShape}getConfig(){let config={maxValue:this.maxValue},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}};ReLU.className="ReLU";serialization_exports.registerClass(ReLU);var LeakyReLU=class extends Layer{constructor(args){super(args==null?{}:args);this.DEFAULT_ALPHA=.3,args==null&&(args={}),this.alpha=args.alpha==null?this.DEFAULT_ALPHA:args.alpha}call(inputs,kwargs){let x=getExactlyOneTensor(inputs);return leakyRelu(x,this.alpha)}computeOutputShape(inputShape){return inputShape}getConfig(){let config={alpha:this.alpha},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}};LeakyReLU.className="LeakyReLU";serialization_exports.registerClass(LeakyReLU);var PReLU=class extends Layer{constructor(args){super(args==null?{}:args);if(this.DEFAULT_ALPHA_INITIALIZER="zeros",args==null&&(args={}),this.supportsMasking=!0,this.alphaInitializer=getInitializer(args.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=getRegularizer(args.alphaRegularizer),this.alphaConstraint=getConstraint(args.alphaConstraint),args.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(args.sharedAxes))this.sharedAxes=args.sharedAxes;else if(typeof args.sharedAxes=="number")this.sharedAxes=[args.sharedAxes];else throw new ValueError(`Expected sharedAxes to be a number or an array of numbers, but got ${args.sharedAxes}`)}build(inputShape){inputShape=getExactlyOneShape(inputShape);let paramShape=inputShape.slice(1);if(this.sharedAxes!=null)for(let i of this.sharedAxes)paramShape[i-1]=1;this.alpha=this.addWeight("alpha",paramShape,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let axes={};if(this.sharedAxes!=null)for(let i=1;i<inputShape.length;++i)axes[i]=inputShape[i];this.inputSpec=[new InputSpec({ndim:inputShape.length,axes})],this.built=!0}call(inputs,kwargs){return inputs=getExactlyOneTensor(inputs),prelu(inputs,this.alpha.read())}getConfig(){let config={alphaInitializer:serializeInitializer(this.alphaInitializer),alphaRegularizer:serializeRegularizer(this.alphaRegularizer),alphaConstraint:serializeConstraint(this.alphaConstraint),sharedAxes:this.sharedAxes},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}};PReLU.className="PReLU";serialization_exports.registerClass(PReLU);var ELU=class extends Layer{constructor(args){super(args==null?{}:args);if(this.DEFAULT_ALPHA=1,args==null&&(args={}),args.alpha!=null&&args.alpha!==this.DEFAULT_ALPHA)throw new NotImplementedError(`Non-default alpha value (${args.alpha}) is not supported by the ELU layer yet.`);this.alpha=args.alpha==null?this.DEFAULT_ALPHA:args.alpha}call(inputs,kwargs){let x=getExactlyOneTensor(inputs);return elu(x)}computeOutputShape(inputShape){return inputShape}getConfig(){let config={alpha:this.alpha},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}};ELU.className="ELU";serialization_exports.registerClass(ELU);var ThresholdedReLU=class extends Layer{constructor(args){super(args==null?{}:args);this.DEFAULT_THETA=1,args==null&&(args={}),this.theta=args.theta==null?this.DEFAULT_THETA:args.theta}call(inputs,kwargs){let x=getExactlyOneTensor(inputs);return x.mul(cast47(x.greater(this.theta),"float32"))}computeOutputShape(inputShape){return inputShape}getConfig(){let config={theta:this.theta},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}};ThresholdedReLU.className="ThresholdedReLU";serialization_exports.registerClass(ThresholdedReLU);var Softmax3=class extends Layer{constructor(args){super(args==null?{}:args);this.DEFAULT_AXIS=1,args==null&&(args={}),this.softmax=new Softmax2().apply,this.axis=args.axis==null?this.DEFAULT_AXIS:args.axis}call(inputs,kwargs){let x=getExactlyOneTensor(inputs);return this.softmax(x,this.axis)}computeOutputShape(inputShape){return inputShape}getConfig(){let config={axis:this.axis},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}};Softmax3.className="Softmax";serialization_exports.registerClass(Softmax3);function normalizeArray(value,n,name){if(typeof value=="number")return pyListRepeat(value,n);if(value.length!==n)throw new ValueError(`The ${name} argument must be an integer or tuple of ${n} integers. Received: ${value.length} elements.`);for(let i=0;i<n;++i){let singleValue=value[i];if(!isInteger(singleValue))throw new ValueError(`The ${name} argument must be an integer or tuple of ${n} integers. Received: ${JSON.stringify(value)} including a non-integer number ${singleValue}`)}return value}function convOutputLength(inputLength,filterSize,padding2,stride,dilation=1){if(inputLength==null)return inputLength;let dilatedFilterSize=filterSize+(filterSize-1)*(dilation-1),outputLength;return padding2==="same"?outputLength=inputLength:outputLength=inputLength-dilatedFilterSize+1,Math.floor((outputLength+stride-1)/stride)}function deconvLength(dimSize,strideSize,kernelSize,padding2){if(dimSize==null)return null;if(padding2==="valid")dimSize=dimSize*strideSize+max8([kernelSize-strideSize,0]);else if(padding2==="same")dimSize=dimSize*strideSize;else throw new ValueError(`Unsupport padding mode: ${padding2}.`);return dimSize}function preprocessConv2DInput(x,dataFormat){return tidy(()=>(checkDataFormat(dataFormat),dataFormat==="channelsFirst"?transpose(x,[0,2,3,1]):x))}function preprocessConv3DInput(x,dataFormat){return tidy(()=>(checkDataFormat(dataFormat),dataFormat==="channelsFirst"?transpose(x,[0,2,3,4,1]):x))}function conv1dWithBias(x,kernel,bias,strides=1,padding2="valid",dataFormat,dilationRate=1){return tidy(()=>{if(dataFormat==null&&(dataFormat=imageDataFormat()),checkDataFormat(dataFormat),x.shape.length!==3)throw new ValueError(`The input of a conv1dWithBias operation should be 3, but is ${x.shape.length} instead.`);if(kernel.shape.length!==3)throw new ValueError(`The kernel for a conv1dWithBias operation should be 3, but is ${kernel.shape.length} instead`);if(bias!=null&&bias.shape.length!==1)throw new ValueError(`The bias for a conv1dWithBias operation should be 1, but is ${kernel.shape.length} instead`);if(dataFormat==="channelsFirst"&&(x=transpose(x,[0,2,1])),padding2==="causal")throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let y=conv1d(x,kernel,strides,padding2==="same"?"same":"valid","NWC",dilationRate);return bias!=null&&(y=biasAdd(y,bias)),y})}function conv2dWithBiasActivation(x,kernel,bias,strides=[1,1],padding2="valid",dataFormat,dilationRate,activation=null){return tidy(()=>{if(dataFormat==null&&(dataFormat=imageDataFormat()),checkDataFormat(dataFormat),x.rank!==3&&x.rank!==4)throw new ValueError(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${x.rank}.`);if(kernel.rank!==3&&kernel.rank!==4)throw new ValueError(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${x.rank}.`);let y=preprocessConv2DInput(x,dataFormat);if(padding2==="causal")throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return y=fused_ops_exports.conv2d({x:y,filter:kernel,strides,pad:padding2==="same"?"same":"valid",dilations:dilationRate,dataFormat:"NHWC",bias,activation}),dataFormat==="channelsFirst"&&(y=transpose(y,[0,3,1,2])),y})}function conv3dWithBias(x,kernel,bias,strides=[1,1,1],padding2="valid",dataFormat,dilationRate){return tidy(()=>{if(dataFormat==null&&(dataFormat=imageDataFormat()),checkDataFormat(dataFormat),x.rank!==4&&x.rank!==5)throw new ValueError(`conv3dWithBias expects input to be of rank 4 or 5, but received ${x.rank}.`);if(kernel.rank!==4&&kernel.rank!==5)throw new ValueError(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${x.rank}.`);let y=preprocessConv3DInput(x,dataFormat);if(padding2==="causal")throw new NotImplementedError("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return y=conv3d(y,kernel,strides,padding2==="same"?"same":"valid","NDHWC",dilationRate),bias!=null&&(y=biasAdd(y,bias)),dataFormat==="channelsFirst"&&(y=transpose(y,[0,4,1,2,3])),y})}var BaseConv=class extends Layer{constructor(rank,args){super(args);if(this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",BaseConv.verifyArgs(args),this.rank=rank,assertPositiveInteger(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new NotImplementedError(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=normalizeArray(args.kernelSize,rank,"kernelSize"),this.strides=normalizeArray(args.strides==null?1:args.strides,rank,"strides"),this.padding=args.padding==null?"valid":args.padding,checkPaddingMode(this.padding),this.dataFormat=args.dataFormat==null?"channelsLast":args.dataFormat,checkDataFormat(this.dataFormat),this.activation=getActivation(args.activation),this.useBias=args.useBias==null?!0:args.useBias,this.biasInitializer=getInitializer(args.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=getConstraint(args.biasConstraint),this.biasRegularizer=getRegularizer(args.biasRegularizer),this.activityRegularizer=getRegularizer(args.activityRegularizer),this.dilationRate=normalizeArray(args.dilationRate==null?1:args.dilationRate,rank,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new ValueError(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new ValueError(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new ValueError(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(args){if(assert2("kernelSize"in args,"required key 'kernelSize' not in config"),typeof args.kernelSize!="number"&&!checkArrayTypeAndLength(args.kernelSize,"number",1,3))throw new ValueError(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(args.kernelSize)}.`)}getConfig(){let config={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:serializeActivation(this.activation),useBias:this.useBias,biasInitializer:serializeInitializer(this.biasInitializer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),biasConstraint:serializeConstraint(this.biasConstraint)},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}},Conv=class extends BaseConv{constructor(rank,args){super(rank,args);this.kernel=null,Conv.verifyArgs(args),this.filters=args.filters,assertPositiveInteger(this.filters,"filters"),this.kernelInitializer=getInitializer(args.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=getConstraint(args.kernelConstraint),this.kernelRegularizer=getRegularizer(args.kernelRegularizer)}build(inputShape){inputShape=getExactlyOneShape(inputShape);let channelAxis=this.dataFormat==="channelsFirst"?1:inputShape.length-1;if(inputShape[channelAxis]==null)throw new ValueError(`The channel dimension of the input should be defined. Found ${inputShape[channelAxis]}`);let inputDim=inputShape[channelAxis],kernelShape=this.kernelSize.concat([inputDim,this.filters]);this.kernel=this.addWeight("kernel",kernelShape,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[channelAxis]:inputDim}}],this.built=!0}call(inputs,kwargs){return tidy(()=>{inputs=getExactlyOneTensor(inputs);let outputs,biasValue=this.bias==null?null:this.bias.read(),fusedActivationName=mapActivationToFusedKernel(this.activation.getClassName());if(fusedActivationName!=null&&this.rank===2)outputs=conv2dWithBiasActivation(inputs,this.kernel.read(),biasValue,this.strides,this.padding,this.dataFormat,this.dilationRate,fusedActivationName);else{if(this.rank===1)outputs=conv1dWithBias(inputs,this.kernel.read(),biasValue,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)outputs=conv2dWithBiasActivation(inputs,this.kernel.read(),biasValue,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)outputs=conv3dWithBias(inputs,this.kernel.read(),biasValue,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new NotImplementedError("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(outputs=this.activation.apply(outputs))}return outputs})}computeOutputShape(inputShape){inputShape=getExactlyOneShape(inputShape);let newSpace=[],space=this.dataFormat==="channelsLast"?inputShape.slice(1,inputShape.length-1):inputShape.slice(2);for(let i=0;i<space.length;++i){let newDim=convOutputLength(space[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);newSpace.push(newDim)}let outputShape=[inputShape[0]];return this.dataFormat==="channelsLast"?(outputShape=outputShape.concat(newSpace),outputShape.push(this.filters)):(outputShape.push(this.filters),outputShape=outputShape.concat(newSpace)),outputShape}getConfig(){let config={filters:this.filters,kernelInitializer:serializeInitializer(this.kernelInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint)},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}static verifyArgs(args){if(!("filters"in args)||typeof args.filters!="number"||args.filters<1)throw new ValueError(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(args.filters)}`)}},Conv2D2=class extends Conv{constructor(args){super(2,args);Conv2D2.verifyArgs(args)}getConfig(){let config=super.getConfig();return delete config.rank,config}static verifyArgs(args){if(typeof args.kernelSize!="number"&&!checkArrayTypeAndLength(args.kernelSize,"number",1,2))throw new ValueError(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(args.kernelSize)}.`)}};Conv2D2.className="Conv2D";serialization_exports.registerClass(Conv2D2);var Conv3D2=class extends Conv{constructor(args){super(3,args);Conv3D2.verifyArgs(args)}getConfig(){let config=super.getConfig();return delete config.rank,config}static verifyArgs(args){if(typeof args.kernelSize!="number"&&!(Array.isArray(args.kernelSize)&&(args.kernelSize.length===1||args.kernelSize.length===3)))throw new ValueError(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(args.kernelSize)}.`)}};Conv3D2.className="Conv3D";serialization_exports.registerClass(Conv3D2);var Conv2DTranspose=class extends Conv2D2{constructor(args){super(args);if(this.inputSpec=[new InputSpec({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new ValueError(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(inputShape){if(inputShape=getExactlyOneShape(inputShape),inputShape.length!==4)throw new ValueError("Input should have rank 4; Received input shape: "+JSON.stringify(inputShape));let channelAxis=this.dataFormat==="channelsFirst"?1:inputShape.length-1;if(inputShape[channelAxis]==null)throw new ValueError("The channel dimension of the inputs should be defined. Found `None`.");let inputDim=inputShape[channelAxis],kernelShape=this.kernelSize.concat([this.filters,inputDim]);this.kernel=this.addWeight("kernel",kernelShape,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new InputSpec({ndim:4,axes:{[channelAxis]:inputDim}})],this.built=!0}call(inputs,kwargs){return tidy(()=>{let input2=getExactlyOneTensor(inputs);if(input2.shape.length!==4)throw new ValueError(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${input2.shape.length}`);let inputShape=input2.shape,batchSize=inputShape[0],hAxis,wAxis;this.dataFormat==="channelsFirst"?(hAxis=2,wAxis=3):(hAxis=1,wAxis=2);let height=inputShape[hAxis],width=inputShape[wAxis],kernelH=this.kernelSize[0],kernelW=this.kernelSize[1],strideH=this.strides[0],strideW=this.strides[1],outHeight=deconvLength(height,strideH,kernelH,this.padding),outWidth=deconvLength(width,strideW,kernelW,this.padding),outputShape=[batchSize,outHeight,outWidth,this.filters];this.dataFormat!=="channelsLast"&&(input2=transpose(input2,[0,2,3,1]));let outputs=conv2dTranspose(input2,this.kernel.read(),outputShape,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(outputs=transpose(outputs,[0,3,1,2])),this.bias!=null&&(outputs=biasAdd(outputs,this.bias.read(),this.dataFormat)),this.activation!=null&&(outputs=this.activation.apply(outputs)),outputs})}computeOutputShape(inputShape){inputShape=getExactlyOneShape(inputShape);let outputShape=inputShape.slice(),channelAxis,heightAxis,widthAxis;this.dataFormat==="channelsFirst"?(channelAxis=1,heightAxis=2,widthAxis=3):(channelAxis=3,heightAxis=1,widthAxis=2);let kernelH=this.kernelSize[0],kernelW=this.kernelSize[1],strideH=this.strides[0],strideW=this.strides[1];return outputShape[channelAxis]=this.filters,outputShape[heightAxis]=deconvLength(outputShape[heightAxis],strideH,kernelH,this.padding),outputShape[widthAxis]=deconvLength(outputShape[widthAxis],strideW,kernelW,this.padding),outputShape}getConfig(){let config=super.getConfig();return delete config.dilationRate,config}};Conv2DTranspose.className="Conv2DTranspose";serialization_exports.registerClass(Conv2DTranspose);var SeparableConv=class extends Conv{constructor(rank,config){super(rank,config);if(this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,config.filters==null)throw new ValueError("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(config.kernelInitializer!=null||config.kernelRegularizer!=null||config.kernelConstraint!=null)throw new ValueError("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(config.padding!=null&&config.padding!=="same"&&config.padding!=="valid")throw new ValueError(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(config.padding)}`);this.depthMultiplier=config.depthMultiplier==null?1:config.depthMultiplier,this.depthwiseInitializer=getInitializer(config.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=getRegularizer(config.depthwiseRegularizer),this.depthwiseConstraint=getConstraint(config.depthwiseConstraint),this.pointwiseInitializer=getInitializer(config.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=getRegularizer(config.pointwiseRegularizer),this.pointwiseConstraint=getConstraint(config.pointwiseConstraint)}build(inputShape){if(inputShape=getExactlyOneShape(inputShape),inputShape.length<this.rank+2)throw new ValueError(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(inputShape)}`);let channelAxis=this.dataFormat==="channelsFirst"?1:inputShape.length-1;if(inputShape[channelAxis]==null||inputShape[channelAxis]<0)throw new ValueError(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(inputShape[channelAxis])}`);let inputDim=inputShape[channelAxis],depthwiseKernelShape=this.kernelSize.concat([inputDim,this.depthMultiplier]),pointwiseKernelShape=[];for(let i=0;i<this.rank;++i)pointwiseKernelShape.push(1);pointwiseKernelShape.push(inputDim*this.depthMultiplier,this.filters);let trainable=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",depthwiseKernelShape,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,trainable,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",pointwiseKernelShape,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,trainable,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,trainable,this.biasConstraint):this.bias=null,this.inputSpec=[new InputSpec({ndim:this.rank+2,axes:{[channelAxis]:inputDim}})],this.built=!0}call(inputs,kwargs){return tidy(()=>{inputs=getExactlyOneTensor(inputs);let output;if(this.rank===1)throw new NotImplementedError("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(inputs=transpose(inputs,[0,2,3,1])),output=separableConv2d(inputs,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(output=biasAdd(output,this.bias.read(),this.dataFormat)),this.activation!=null&&(output=this.activation.apply(output)),this.dataFormat==="channelsFirst"&&(output=transpose(output,[0,3,1,2])),output})}getConfig(){let config=super.getConfig();return delete config.rank,delete config.kernelInitializer,delete config.kernelRegularizer,delete config.kernelConstraint,config.depthwiseInitializer=serializeInitializer(this.depthwiseInitializer),config.pointwiseInitializer=serializeInitializer(this.pointwiseInitializer),config.depthwiseRegularizer=serializeRegularizer(this.depthwiseRegularizer),config.pointwiseRegularizer=serializeRegularizer(this.pointwiseRegularizer),config.depthwiseConstraint=serializeConstraint(this.depthwiseConstraint),config.pointwiseConstraint=serializeConstraint(this.pointwiseConstraint),config}};SeparableConv.className="SeparableConv";var SeparableConv2D=class extends SeparableConv{constructor(args){super(2,args)}};SeparableConv2D.className="SeparableConv2D";serialization_exports.registerClass(SeparableConv2D);var Conv1D=class extends Conv{constructor(args){super(1,args);Conv1D.verifyArgs(args),this.inputSpec=[{ndim:3}]}getConfig(){let config=super.getConfig();return delete config.rank,delete config.dataFormat,config}static verifyArgs(args){if(typeof args.kernelSize!="number"&&!checkArrayTypeAndLength(args.kernelSize,"number",1,1))throw new ValueError(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(args.kernelSize)}.`)}};Conv1D.className="Conv1D";serialization_exports.registerClass(Conv1D);var Cropping2D=class extends Layer{constructor(args){super(args);typeof args.cropping=="number"?this.cropping=[[args.cropping,args.cropping],[args.cropping,args.cropping]]:typeof args.cropping[0]=="number"?this.cropping=[[args.cropping[0],args.cropping[0]],[args.cropping[1],args.cropping[1]]]:this.cropping=args.cropping,this.dataFormat=args.dataFormat===void 0?"channelsLast":args.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(inputShape){return this.dataFormat==="channelsFirst"?[inputShape[0],inputShape[1],inputShape[2]-this.cropping[0][0]-this.cropping[0][1],inputShape[3]-this.cropping[1][0]-this.cropping[1][1]]:[inputShape[0],inputShape[1]-this.cropping[0][0]-this.cropping[0][1],inputShape[2]-this.cropping[1][0]-this.cropping[1][1],inputShape[3]]}call(inputs,kwargs){return tidy(()=>{if(inputs=getExactlyOneTensor(inputs),this.dataFormat==="channelsLast"){let hSliced=sliceAlongAxis(inputs,this.cropping[0][0],inputs.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return sliceAlongAxis(hSliced,this.cropping[1][0],inputs.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let hSliced=sliceAlongAxis(inputs,this.cropping[0][0],inputs.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return sliceAlongAxis(hSliced,this.cropping[1][0],inputs.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let config={cropping:this.cropping,dataFormat:this.dataFormat},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}};Cropping2D.className="Cropping2D";serialization_exports.registerClass(Cropping2D);var UpSampling2D=class extends Layer{constructor(args){super(args);this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=args.size==null?this.DEFAULT_SIZE:args.size,this.dataFormat=args.dataFormat==null?"channelsLast":args.dataFormat}computeOutputShape(inputShape){if(this.dataFormat==="channelsFirst"){let height=inputShape[2]==null?null:this.size[0]*inputShape[2],width=inputShape[3]==null?null:this.size[1]*inputShape[3];return[inputShape[0],inputShape[1],height,width]}else{let height=inputShape[1]==null?null:this.size[0]*inputShape[1],width=inputShape[2]==null?null:this.size[1]*inputShape[2];return[inputShape[0],height,width,inputShape[3]]}}call(inputs,kwargs){return tidy(()=>{let input2=getExactlyOneTensor(inputs),inputShape=input2.shape;if(this.dataFormat==="channelsFirst"){input2=transpose(input2,[0,2,3,1]);let height=this.size[0]*inputShape[2],width=this.size[1]*inputShape[3],resized=input2.resizeNearestNeighbor([height,width]);return transpose(resized,[0,3,1,2])}else{let height=this.size[0]*inputShape[1],width=this.size[1]*inputShape[2];return input2.resizeNearestNeighbor([height,width])}})}getConfig(){let config={size:this.size,dataFormat:this.dataFormat},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}};UpSampling2D.className="UpSampling2D";serialization_exports.registerClass(UpSampling2D);function depthwiseConv2d3(x,depthwiseKernel,strides=[1,1],padding2="valid",dataFormat,dilationRate){return tidy(()=>{dataFormat==null&&(dataFormat=imageDataFormat()),checkDataFormat(dataFormat);let y=preprocessConv2DInput(x,dataFormat);if(x.rank!==4)throw new ValueError(`Input for depthwiseConv2d is required to be 4-D, but is instead ${x.rank}-D`);if(depthwiseKernel.rank!==4)throw new ValueError(`depthwiseKernel is required to be 4-D, but is instead ${depthwiseKernel.rank}-D`);return y=depthwiseConv2d(y,depthwiseKernel,strides,padding2==="same"?"same":"valid","NHWC",dilationRate),dataFormat==="channelsFirst"&&(y=transpose(y,[0,3,1,2])),y})}var DepthwiseConv2D=class extends BaseConv{constructor(args){super(2,args);this.depthwiseKernel=null,this.depthMultiplier=args.depthMultiplier==null?1:args.depthMultiplier,this.depthwiseInitializer=getInitializer(args.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=getConstraint(args.depthwiseConstraint),this.depthwiseRegularizer=getRegularizer(args.depthwiseRegularizer)}build(inputShape){if(inputShape=getExactlyOneShape(inputShape),inputShape.length<4)throw new ValueError(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(inputShape)}.`);let channelAxis=this.dataFormat==="channelsFirst"?1:3;if(inputShape[channelAxis]==null||inputShape[channelAxis]<0)throw new ValueError(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${inputShape[channelAxis]}).`);let inputDim=inputShape[channelAxis],depthwiseKernelShape=[this.kernelSize[0],this.kernelSize[1],inputDim,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",depthwiseKernelShape,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[inputDim*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(inputs,kwargs){return tidy(()=>{inputs=getExactlyOneTensor(inputs);let outputs=depthwiseConv2d3(inputs,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(outputs=biasAdd(outputs,this.bias.read(),this.dataFormat)),this.activation!=null&&(outputs=this.activation.apply(outputs)),outputs})}computeOutputShape(inputShape){inputShape=getExactlyOneShape(inputShape);let rows=this.dataFormat==="channelsFirst"?inputShape[2]:inputShape[1],cols=this.dataFormat==="channelsFirst"?inputShape[3]:inputShape[2],outFilters=this.dataFormat==="channelsFirst"?inputShape[1]*this.depthMultiplier:inputShape[3]*this.depthMultiplier,outRows=convOutputLength(rows,this.kernelSize[0],this.padding,this.strides[0]),outCols=convOutputLength(cols,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[inputShape[0],outFilters,outRows,outCols]:[inputShape[0],outRows,outCols,outFilters]}getConfig(){let config=super.getConfig();return config.depthMultiplier=this.depthMultiplier,config.depthwiseInitializer=serializeInitializer(this.depthwiseInitializer),config.depthwiseRegularizer=serializeRegularizer(this.depthwiseRegularizer),config.depthwiseConstraint=serializeConstraint(this.depthwiseRegularizer),config}};DepthwiseConv2D.className="DepthwiseConv2D";serialization_exports.registerClass(DepthwiseConv2D);function standardizeArgs(inputs,initialState,constants,numConstants){if(Array.isArray(inputs)){if(initialState!=null||constants!=null)throw new ValueError("When inputs is an array, neither initialState or constants should be provided");numConstants!=null&&(constants=inputs.slice(inputs.length-numConstants,inputs.length),inputs=inputs.slice(0,inputs.length-numConstants)),inputs.length>1&&(initialState=inputs.slice(1,inputs.length)),inputs=inputs[0]}function toListOrNull(x){return x==null||Array.isArray(x)?x:[x]}return initialState=toListOrNull(initialState),constants=toListOrNull(constants),{inputs,initialState,constants}}function rnn(stepFunction,inputs,initialStates,goBackwards=!1,mask,constants,unroll=!1,needPerStepOutputs=!1){return tidy(()=>{let ndim=inputs.shape.length;if(ndim<3)throw new ValueError(`Input should be at least 3D, but is ${ndim}D.`);let axes=[1,0].concat(range4(2,ndim));if(inputs=transpose(inputs,axes),constants!=null)throw new NotImplementedError("The rnn() functoin of the deeplearn.js backend does not support constants yet.");unroll&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),mask!=null&&(mask=mask.asType("bool").asType("float32"),mask.rank===ndim-1&&(mask=expandDims(mask,-1)),mask=transpose(mask,axes)),goBackwards&&(inputs=reverse(inputs,0),mask!=null&&(mask=reverse(mask,0)));let perStepOutputs=[],lastOutput,states=initialStates,timeSteps=inputs.shape[0],perStepInputs=unstack(inputs),perStepMasks;mask!=null&&(perStepMasks=unstack(mask));for(let t=0;t<timeSteps;++t){let currentInput=perStepInputs[t],stepOutputs=tidy(()=>stepFunction(currentInput,states));if(mask==null)lastOutput=stepOutputs[0],states=stepOutputs[1];else{let maskedOutputs=tidy(()=>{let stepMask=perStepMasks[t],negStepMask=onesLike(stepMask).sub(stepMask),output=stepOutputs[0].mul(stepMask).add(states[0].mul(negStepMask)),newStates=states.map((state6,i)=>stepOutputs[1][i].mul(stepMask).add(state6.mul(negStepMask)));return{output,newStates}});lastOutput=maskedOutputs.output,states=maskedOutputs.newStates}needPerStepOutputs&&perStepOutputs.push(lastOutput)}let outputs;if(needPerStepOutputs){let axis=1;outputs=stack(perStepOutputs,axis)}return[lastOutput,outputs,states]})}var RNN=class extends Layer{constructor(args){super(args);let cell;if(args.cell==null)throw new ValueError("cell property is missing for the constructor of RNN.");if(Array.isArray(args.cell)?cell=new StackedRNNCells({cells:args.cell}):cell=args.cell,cell.stateSize==null)throw new ValueError("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=cell,this.returnSequences=args.returnSequences==null?!1:args.returnSequences,this.returnState=args.returnState==null?!1:args.returnState,this.goBackwards=args.goBackwards==null?!1:args.goBackwards,this._stateful=args.stateful==null?!1:args.stateful,this.unroll=args.unroll==null?!1:args.unroll,this.supportsMasking=!0,this.inputSpec=[new InputSpec({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let numStates=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return range4(0,numStates).map(x=>null)}else return this.states_}setStates(states){this.states_=states}computeOutputShape(inputShape){isArrayOfShapes(inputShape)&&(inputShape=inputShape[0]),inputShape=inputShape;let stateSize=this.cell.stateSize;Array.isArray(stateSize)||(stateSize=[stateSize]);let outputDim=stateSize[0],outputShape;if(this.returnSequences?outputShape=[inputShape[0],inputShape[1],outputDim]:outputShape=[inputShape[0],outputDim],this.returnState){let stateShape=[];for(let dim of stateSize)stateShape.push([inputShape[0],dim]);return[outputShape].concat(stateShape)}else return outputShape}computeMask(inputs,mask){return tidy(()=>{Array.isArray(mask)&&(mask=mask[0]);let outputMask=this.returnSequences?mask:null;if(this.returnState){let stateMask=this.states.map(s=>null);return[outputMask].concat(stateMask)}else return outputMask})}get states(){if(this.states_==null){let numStates=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,output=[];for(let i=0;i<numStates;++i)output.push(null);return output}else return this.states_}set states(s){this.states_=s}build(inputShape){let constantShape=null;if(this.numConstants!=null)throw new NotImplementedError("Constants support is not implemented in RNN yet.");isArrayOfShapes(inputShape)&&(inputShape=inputShape[0]),inputShape=inputShape;let batchSize=this.stateful?inputShape[0]:null,inputDim=inputShape.slice(2);this.inputSpec[0]=new InputSpec({shape:[batchSize,null,...inputDim]});let stepInputShape=[inputShape[0]].concat(inputShape.slice(2));if(constantShape!=null)throw new NotImplementedError("Constants support is not implemented in RNN yet.");this.cell.build(stepInputShape);let stateSize;if(Array.isArray(this.cell.stateSize)?stateSize=this.cell.stateSize:stateSize=[this.cell.stateSize],this.stateSpec!=null){if(!util_exports.arraysEqual(this.stateSpec.map(spec=>spec.shape[spec.shape.length-1]),stateSize))throw new ValueError(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=stateSize.map(dim=>new InputSpec({shape:[null,dim]}));this.stateful&&this.resetStates()}resetStates(states,training5=!1){tidy(()=>{if(!this.stateful)throw new AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");let batchSize=this.inputSpec[0].shape[0];if(batchSize==null)throw new ValueError("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(dim=>zeros([batchSize,dim])):this.states_=[zeros([batchSize,this.cell.stateSize])];else if(states==null)dispose(this.states_),this.keptStates!=null&&(dispose(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(dim=>zeros([batchSize,dim])):this.states_[0]=zeros([batchSize,this.cell.stateSize]);else{if(Array.isArray(states)||(states=[states]),states.length!==this.states_.length)throw new ValueError(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${states.length} state value(s). Input received: ${states}`);training5===!0?this.keptStates.push(this.states_.slice()):dispose(this.states_);for(let index=0;index<this.states_.length;++index){let value=states[index],dim=Array.isArray(this.cell.stateSize)?this.cell.stateSize[index]:this.cell.stateSize,expectedShape=[batchSize,dim];if(!util_exports.arraysEqual(value.shape,expectedShape))throw new ValueError(`State ${index} is incompatible with layer ${this.name}: expected shape=${expectedShape}, received shape=${value.shape}`);this.states_[index]=value}}this.states_=this.states_.map(state6=>keep(state6.clone()))})}apply(inputs,kwargs){let initialState=kwargs==null?null:kwargs.initialState,constants=kwargs==null?null:kwargs.constants;kwargs==null&&(kwargs={});let standardized=standardizeArgs(inputs,initialState,constants,this.numConstants);inputs=standardized.inputs,initialState=standardized.initialState,constants=standardized.constants;let additionalInputs=[],additionalSpecs=[];if(initialState!=null){kwargs.initialState=initialState,additionalInputs=additionalInputs.concat(initialState),this.stateSpec=[];for(let state6 of initialState)this.stateSpec.push(new InputSpec({shape:state6.shape}));additionalSpecs=additionalSpecs.concat(this.stateSpec)}constants!=null&&(kwargs.constants=constants,additionalInputs=additionalInputs.concat(constants),this.numConstants=constants.length);let isTensor=additionalInputs[0]instanceof SymbolicTensor;if(isTensor){let fullInput=[inputs].concat(additionalInputs),fullInputSpec=this.inputSpec.concat(additionalSpecs),originalInputSpec=this.inputSpec;this.inputSpec=fullInputSpec;let output=super.apply(fullInput,kwargs);return this.inputSpec=originalInputSpec,output}else return super.apply(inputs,kwargs)}call(inputs,kwargs){return tidy(()=>{let mask=kwargs==null?null:kwargs.mask,training5=kwargs==null?null:kwargs.training,initialState=kwargs==null?null:kwargs.initialState;inputs=getExactlyOneTensor(inputs),initialState==null&&(this.stateful?initialState=this.states_:initialState=this.getInitialState(inputs));let numStates=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(initialState.length!==numStates)throw new ValueError(`RNN Layer has ${numStates} state(s) but was passed ${initialState.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let cellCallKwargs={training:training5},step9=(inputs2,states2)=>{let outputs2=this.cell.call([inputs2].concat(states2),cellCallKwargs);return[outputs2[0],outputs2.slice(1)]},rnnOutputs=rnn(step9,inputs,initialState,this.goBackwards,mask,null,this.unroll,this.returnSequences),lastOutput=rnnOutputs[0],outputs=rnnOutputs[1],states=rnnOutputs[2];this.stateful&&this.resetStates(states,training5);let output=this.returnSequences?outputs:lastOutput;return this.returnState?[output].concat(states):output})}getInitialState(inputs){return tidy(()=>{let initialState=zeros(inputs.shape);return initialState=sum2(initialState,[1,2]),initialState=expandDims2(initialState),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(dim=>dim>1?tile8(initialState,[1,dim]):initialState):this.cell.stateSize>1?[tile8(initialState,[1,this.cell.stateSize])]:[initialState]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(value){super.setFastWeightInitDuringBuild(value),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(value)}getConfig(){let baseConfig=super.getConfig(),config={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(config.numConstants=this.numConstants);let cellConfig=this.cell.getConfig();return this.getClassName()===RNN.className&&(config.cell={className:this.cell.getClassName(),config:cellConfig}),Object.assign({},cellConfig,baseConfig,config)}static fromConfig(cls,config,customObjects={}){let cellConfig=config.cell,cell=deserialize(cellConfig,customObjects);return new cls(Object.assign(config,{cell}))}};RNN.className="RNN";serialization_exports.registerClass(RNN);var RNNCell=class extends Layer{},SimpleRNNCell=class extends RNNCell{constructor(args){super(args);this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=args.units,assertPositiveInteger(this.units,"units"),this.activation=getActivation(args.activation==null?this.DEFAULT_ACTIVATION:args.activation),this.useBias=args.useBias==null?!0:args.useBias,this.kernelInitializer=getInitializer(args.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=getInitializer(args.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=getInitializer(args.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=getRegularizer(args.kernelRegularizer),this.recurrentRegularizer=getRegularizer(args.recurrentRegularizer),this.biasRegularizer=getRegularizer(args.biasRegularizer),this.kernelConstraint=getConstraint(args.kernelConstraint),this.recurrentConstraint=getConstraint(args.recurrentConstraint),this.biasConstraint=getConstraint(args.biasConstraint),this.dropout=min6([1,max8([0,args.dropout==null?0:args.dropout])]),this.recurrentDropout=min6([1,max8([0,args.recurrentDropout==null?0:args.recurrentDropout])]),this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(inputShape){inputShape=getExactlyOneShape(inputShape),this.kernel=this.addWeight("kernel",[inputShape[inputShape.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(inputs,kwargs){return tidy(()=>{if(inputs=inputs,inputs.length!==2)throw new ValueError(`SimpleRNNCell expects 2 input Tensors, got ${inputs.length}.`);let prevOutput=inputs[1];inputs=inputs[0];let training5=kwargs.training==null?!1:kwargs.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=generateDropoutMask({ones:()=>onesLike(inputs),rate:this.dropout,training:training5})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=generateDropoutMask({ones:()=>onesLike(prevOutput),rate:this.recurrentDropout,training:training5}));let h,dpMask=this.dropoutMask,recDpMask=this.recurrentDropoutMask;dpMask!=null?h=dot5(mul(inputs,dpMask),this.kernel.read()):h=dot5(inputs,this.kernel.read()),this.bias!=null&&(h=biasAdd(h,this.bias.read())),recDpMask!=null&&(prevOutput=mul(prevOutput,recDpMask));let output=add2(h,dot5(prevOutput,this.recurrentKernel.read()));return this.activation!=null&&(output=this.activation.apply(output)),[output,output]})}getConfig(){let baseConfig=super.getConfig(),config={units:this.units,activation:serializeActivation(this.activation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},baseConfig,config)}};SimpleRNNCell.className="SimpleRNNCell";serialization_exports.registerClass(SimpleRNNCell);var SimpleRNN=class extends RNN{constructor(args){args.cell=new SimpleRNNCell(args),super(args)}call(inputs,kwargs){return tidy(()=>{this.cell.dropoutMask!=null&&(dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let mask=kwargs==null?null:kwargs.mask,training5=kwargs==null?null:kwargs.training,initialState=kwargs==null?null:kwargs.initialState;return super.call(inputs,{mask,training:training5,initialState})})}static fromConfig(cls,config){return new cls(config)}};SimpleRNN.className="SimpleRNN";serialization_exports.registerClass(SimpleRNN);var GRUCell=class extends RNNCell{constructor(args){super(args);if(this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",args.resetAfter)throw new ValueError("GRUCell does not support reset_after parameter set to true.");this.units=args.units,assertPositiveInteger(this.units,"units"),this.activation=getActivation(args.activation===void 0?this.DEFAULT_ACTIVATION:args.activation),this.recurrentActivation=getActivation(args.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:args.recurrentActivation),this.useBias=args.useBias==null?!0:args.useBias,this.kernelInitializer=getInitializer(args.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=getInitializer(args.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=getInitializer(args.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=getRegularizer(args.kernelRegularizer),this.recurrentRegularizer=getRegularizer(args.recurrentRegularizer),this.biasRegularizer=getRegularizer(args.biasRegularizer),this.kernelConstraint=getConstraint(args.kernelConstraint),this.recurrentConstraint=getConstraint(args.recurrentConstraint),this.biasConstraint=getConstraint(args.biasConstraint),this.dropout=min6([1,max8([0,args.dropout==null?0:args.dropout])]),this.recurrentDropout=min6([1,max8([0,args.recurrentDropout==null?0:args.recurrentDropout])]),this.implementation=args.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(inputShape){inputShape=getExactlyOneShape(inputShape);let inputDim=inputShape[inputShape.length-1];this.kernel=this.addWeight("kernel",[inputDim,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(inputs,kwargs){return tidy(()=>{if(inputs=inputs,inputs.length!==2)throw new ValueError(`GRUCell expects 2 input Tensors (inputs, h, c), got ${inputs.length}.`);let training5=kwargs.training==null?!1:kwargs.training,hTMinus1=inputs[1];inputs=inputs[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=generateDropoutMask({ones:()=>onesLike(inputs),rate:this.dropout,training:training5,count:3})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=generateDropoutMask({ones:()=>onesLike(hTMinus1),rate:this.recurrentDropout,training:training5,count:3}));let dpMask=this.dropoutMask,recDpMask=this.recurrentDropoutMask,z,r,hh;0<this.dropout&&this.dropout<1&&(inputs=mul(inputs,dpMask[0]));let matrixX=dot5(inputs,this.kernel.read());this.useBias&&(matrixX=biasAdd(matrixX,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(hTMinus1=mul(hTMinus1,recDpMask[0]));let recurrentKernelValue=this.recurrentKernel.read(),[rk1,rk2]=split(recurrentKernelValue,[2*this.units,this.units],recurrentKernelValue.rank-1),matrixInner=dot5(hTMinus1,rk1),[xZ,xR,xH]=split(matrixX,3,matrixX.rank-1),[recurrentZ,recurrentR]=split(matrixInner,2,matrixInner.rank-1);z=this.recurrentActivation.apply(add2(xZ,recurrentZ)),r=this.recurrentActivation.apply(add2(xR,recurrentR));let recurrentH=dot5(mul(r,hTMinus1),rk2);hh=this.activation.apply(add2(xH,recurrentH));let h=add2(mul(z,hTMinus1),mul(add2(1,neg(z)),hh));return[h,h]})}getConfig(){let baseConfig=super.getConfig(),config={units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},baseConfig,config)}};GRUCell.className="GRUCell";serialization_exports.registerClass(GRUCell);var GRU=class extends RNN{constructor(args){args.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),args.cell=new GRUCell(args),super(args)}call(inputs,kwargs){return tidy(()=>{this.cell.dropoutMask!=null&&(dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let mask=kwargs==null?null:kwargs.mask,training5=kwargs==null?null:kwargs.training,initialState=kwargs==null?null:kwargs.initialState;return super.call(inputs,{mask,training:training5,initialState})})}static fromConfig(cls,config){return config.implmentation===0&&(config.implementation=1),new cls(config)}};GRU.className="GRU";serialization_exports.registerClass(GRU);var LSTMCell=class extends RNNCell{constructor(args){super(args);this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=args.units,assertPositiveInteger(this.units,"units"),this.activation=getActivation(args.activation===void 0?this.DEFAULT_ACTIVATION:args.activation),this.recurrentActivation=getActivation(args.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:args.recurrentActivation),this.useBias=args.useBias==null?!0:args.useBias,this.kernelInitializer=getInitializer(args.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=getInitializer(args.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=getInitializer(args.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=args.unitForgetBias,this.kernelRegularizer=getRegularizer(args.kernelRegularizer),this.recurrentRegularizer=getRegularizer(args.recurrentRegularizer),this.biasRegularizer=getRegularizer(args.biasRegularizer),this.kernelConstraint=getConstraint(args.kernelConstraint),this.recurrentConstraint=getConstraint(args.recurrentConstraint),this.biasConstraint=getConstraint(args.biasConstraint),this.dropout=min6([1,max8([0,args.dropout==null?0:args.dropout])]),this.recurrentDropout=min6([1,max8([0,args.recurrentDropout==null?0:args.recurrentDropout])]),this.implementation=args.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(inputShape){var _a;inputShape=getExactlyOneShape(inputShape);let inputDim=inputShape[inputShape.length-1];this.kernel=this.addWeight("kernel",[inputDim,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let biasInitializer;if(this.useBias){if(this.unitForgetBias){let capturedBiasInit=this.biasInitializer,capturedUnits=this.units;biasInitializer=new(_a=class extends Initializer{apply(shape,dtype){let bI=capturedBiasInit.apply([capturedUnits]),bF=new Ones().apply([capturedUnits]),bCAndH=capturedBiasInit.apply([capturedUnits*2]);return concatAlongFirstAxis(concatAlongFirstAxis(bI,bF),bCAndH)}},_a.className="CustomInit",_a)}else biasInitializer=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,biasInitializer,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(inputs,kwargs){return tidy(()=>{let training5=kwargs.training==null?!1:kwargs.training;if(inputs=inputs,inputs.length!==3)throw new ValueError(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${inputs.length}.`);let hTMinus1=inputs[1],cTMinus1=inputs[2];inputs=inputs[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=generateDropoutMask({ones:()=>onesLike(inputs),rate:this.dropout,training:training5,count:4})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=generateDropoutMask({ones:()=>onesLike(hTMinus1),rate:this.recurrentDropout,training:training5,count:4}));let dpMask=this.dropoutMask,recDpMask=this.recurrentDropoutMask,i,f,c,o;0<this.dropout&&this.dropout<1&&(inputs=mul(inputs,dpMask[0]));let z=dot5(inputs,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(hTMinus1=mul(hTMinus1,recDpMask[0])),z=add2(z,dot5(hTMinus1,this.recurrentKernel.read())),this.useBias&&(z=biasAdd(z,this.bias.read()));let[z0,z1,z2,z3]=split(z,4,z.rank-1);i=this.recurrentActivation.apply(z0),f=this.recurrentActivation.apply(z1),c=add2(mul(f,cTMinus1),mul(i,this.activation.apply(z2))),o=this.recurrentActivation.apply(z3);let h=mul(o,this.activation.apply(c));return[h,h,c]})}getConfig(){let baseConfig=super.getConfig(),config={units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},baseConfig,config)}};LSTMCell.className="LSTMCell";serialization_exports.registerClass(LSTMCell);var LSTM=class extends RNN{constructor(args){args.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),args.cell=new LSTMCell(args),super(args)}call(inputs,kwargs){return tidy(()=>{this.cell.dropoutMask!=null&&(dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let mask=kwargs==null?null:kwargs.mask,training5=kwargs==null?null:kwargs.training,initialState=kwargs==null?null:kwargs.initialState;return super.call(inputs,{mask,training:training5,initialState})})}static fromConfig(cls,config){return config.implmentation===0&&(config.implementation=1),new cls(config)}};LSTM.className="LSTM";serialization_exports.registerClass(LSTM);var StackedRNNCells=class extends RNNCell{constructor(args){super(args);this.cells=args.cells}get stateSize(){let stateSize=[];for(let cell of this.cells.slice().reverse())Array.isArray(cell.stateSize)?stateSize.push(...cell.stateSize):stateSize.push(cell.stateSize);return stateSize}call(inputs,kwargs){return tidy(()=>{inputs=inputs;let states=inputs.slice(1),nestedStates=[];for(let cell of this.cells.slice().reverse())Array.isArray(cell.stateSize)?nestedStates.push(states.splice(0,cell.stateSize.length)):nestedStates.push(states.splice(0,1));nestedStates.reverse();let newNestedStates=[],callInputs;for(let i=0;i<this.cells.length;++i){let cell=this.cells[i];states=nestedStates[i],i===0?callInputs=[inputs[0]].concat(states):callInputs=[callInputs[0]].concat(states),callInputs=cell.call(callInputs,kwargs),newNestedStates.push(callInputs.slice(1))}states=[];for(let cellStates of newNestedStates.slice().reverse())states.push(...cellStates);return[callInputs[0]].concat(states)})}build(inputShape){isArrayOfShapes(inputShape)&&(inputShape=inputShape[0]),inputShape=inputShape;let outputDim;this.cells.forEach((cell,i)=>{nameScope(`RNNCell_${i}`,()=>{cell.build(inputShape),Array.isArray(cell.stateSize)?outputDim=cell.stateSize[0]:outputDim=cell.stateSize,inputShape=[inputShape[0],outputDim]})}),this.built=!0}getConfig(){let baseConfig=super.getConfig(),getCellConfig=cell=>({className:cell.getClassName(),config:cell.getConfig()}),cellConfigs=this.cells.map(getCellConfig),config={cells:cellConfigs};return Object.assign({},baseConfig,config)}static fromConfig(cls,config,customObjects={}){let cells=[];for(let cellConfig of config.cells)cells.push(deserialize(cellConfig,customObjects));return new cls({cells})}get trainableWeights(){if(!this.trainable)return[];let weights=[];for(let cell of this.cells)weights.push(...cell.trainableWeights);return weights}get nonTrainableWeights(){let weights=[];for(let cell of this.cells)weights.push(...cell.nonTrainableWeights);if(!this.trainable){let trainableWeights=[];for(let cell of this.cells)trainableWeights.push(...cell.trainableWeights);return trainableWeights.concat(weights)}return weights}getWeights(){let weights=[];for(let cell of this.cells)weights.push(...cell.weights);return batchGetValue(weights)}setWeights(weights){let tuples=[];for(let cell of this.cells){let numParams=cell.weights.length,inputWeights=weights.splice(numParams);for(let i=0;i<cell.weights.length;++i)tuples.push([cell.weights[i],inputWeights[i]])}batchSetValue(tuples)}};StackedRNNCells.className="StackedRNNCells";serialization_exports.registerClass(StackedRNNCells);function generateDropoutMask(args){let{ones:ones8,rate,training:training5=!1,count:count2=1}=args,droppedInputs=()=>dropout2(ones8(),rate),createMask=()=>inTrainPhase(droppedInputs,ones8,training5);if(!count2||count2<=1)return keep(createMask().clone());let masks=Array(count2).fill(void 0).map(createMask);return masks.map(m=>keep(m.clone()))}var __rest=function(s,e){var t={};for(var p2 in s)Object.prototype.hasOwnProperty.call(s,p2)&&e.indexOf(p2)<0&&(t[p2]=s[p2]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var i=0,p2=Object.getOwnPropertySymbols(s);i<p2.length;i++)e.indexOf(p2[i])<0&&Object.prototype.propertyIsEnumerable.call(s,p2[i])&&(t[p2[i]]=s[p2[i]]);return t},ConvRNN2DCell=class extends RNNCell{},ConvRNN2D=class extends RNN{constructor(args){if(args.unroll)throw new NotImplementedError("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(args.cell))throw new NotImplementedError("It is not possible at the moment to stack convolutional cells.");super(args);this.inputSpec=[new InputSpec({ndim:5})]}call(inputs,kwargs){return tidy(()=>{if(this.cell.dropoutMask!=null&&(dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),kwargs&&kwargs.constants)throw new ValueError("ConvRNN2D cell does not support constants");let mask=kwargs==null?null:kwargs.mask,training5=kwargs==null?null:kwargs.training,initialState=kwargs==null?null:kwargs.initialState;return super.call(inputs,{mask,training:training5,initialState})})}computeOutputShape(inputShape){let outShape=this.computeSingleOutputShape(inputShape);return this.returnSequences||(outShape=[outShape[0],...outShape.slice(2)]),this.returnState&&(outShape=[outShape,...Array(2).fill([inputShape[0],...outShape.slice(-3)])]),outShape}getInitialState(inputs){return tidy(()=>{let{stateSize}=this.cell,inputShape=inputs.shape,outputShape=this.computeSingleOutputShape(inputShape),stateShape=[outputShape[0],...outputShape.slice(2)],initialState=zeros(stateShape);return Array.isArray(stateSize)?Array(stateSize.length).fill(initialState):[initialState]})}resetStates(states,training5=!1){tidy(()=>{if(!this.stateful)throw new AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");let inputShape=this.inputSpec[0].shape,outputShape=this.computeSingleOutputShape(inputShape),stateShape=[outputShape[0],...outputShape.slice(2)],batchSize=inputShape[0];if(batchSize==null)throw new ValueError("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>zeros(stateShape)):this.states_=[zeros(stateShape)];else if(states==null)dispose(this.states_),this.keptStates!=null&&(dispose(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>zeros(stateShape)):this.states_[0]=zeros(stateShape);else{if(Array.isArray(states)||(states=[states]),states.length!==this.states_.length)throw new ValueError(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${states.length} state value(s). Input received: ${states}`);training5?this.keptStates.push(this.states_.slice()):dispose(this.states_);for(let index=0;index<this.states_.length;++index){let value=states[index],expectedShape=stateShape;if(!util_exports.arraysEqual(value.shape,expectedShape))throw new ValueError(`State ${index} is incompatible with layer ${this.name}: expected shape=${expectedShape}, received shape=${value.shape}`);this.states_[index]=value}}this.states_=this.states_.map(state6=>keep(state6.clone()))})}computeSingleOutputShape(inputShape){let{dataFormat,filters,kernelSize,padding:padding2,strides,dilationRate}=this.cell,isChannelsFirst=dataFormat==="channelsFirst",h=inputShape[isChannelsFirst?3:2],w=inputShape[isChannelsFirst?4:3],hOut=convOutputLength(h,kernelSize[0],padding2,strides[0],dilationRate[0]),wOut=convOutputLength(w,kernelSize[1],padding2,strides[1],dilationRate[1]),outShape=[...inputShape.slice(0,2),...isChannelsFirst?[filters,hOut,wOut]:[hOut,wOut,filters]];return outShape}};ConvRNN2D.className="ConvRNN2D";var ConvLSTM2DCell=class extends LSTMCell{constructor(args){let{filters,kernelSize,strides,padding:padding2,dataFormat,dilationRate}=args;super(Object.assign({},args,{units:filters}));this.filters=filters,assertPositiveInteger(this.filters,"filters"),this.kernelSize=normalizeArray(kernelSize,2,"kernelSize"),this.kernelSize.forEach(size=>assertPositiveInteger(size,"kernelSize")),this.strides=normalizeArray(strides||1,2,"strides"),this.strides.forEach(stride=>assertPositiveInteger(stride,"strides")),this.padding=padding2||"valid",checkPaddingMode(this.padding),this.dataFormat=dataFormat||"channelsLast",checkDataFormat(this.dataFormat),this.dilationRate=normalizeArray(dilationRate||1,2,"dilationRate"),this.dilationRate.forEach(rate=>assertPositiveInteger(rate,"dilationRate"))}build(inputShape){var _a;inputShape=getExactlyOneShape(inputShape);let channelAxis=this.dataFormat==="channelsFirst"?1:inputShape.length-1;if(inputShape[channelAxis]==null)throw new ValueError(`The channel dimension of the input should be defined. Found ${inputShape[channelAxis]}`);let inputDim=inputShape[channelAxis],numOfKernels=4,kernelShape=this.kernelSize.concat([inputDim,this.filters*numOfKernels]);this.kernel=this.addWeight("kernel",kernelShape,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let recurrentKernelShape=this.kernelSize.concat([this.filters,this.filters*numOfKernels]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",recurrentKernelShape,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let biasInitializer;if(this.unitForgetBias){let init=this.biasInitializer,filters=this.filters;biasInitializer=new(_a=class extends Initializer{apply(shape,dtype){let biasI=init.apply([filters]),biasF=ones2([filters]),biasCAndO=init.apply([filters*2]);return concatenate([biasI,biasF,biasCAndO])}},_a.className="CustomInit",_a)}else biasInitializer=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*numOfKernels],null,biasInitializer,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(inputs,kwargs){return tidy(()=>{if(inputs.length!==3)throw new ValueError(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${inputs.length}.`);let training5=kwargs.training||!1,x=inputs[0],hTMinus1=inputs[1],cTMinus1=inputs[2],numOfKernels=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=generateDropoutMask({ones:()=>onesLike(x),rate:this.dropout,training:training5,count:numOfKernels}));let dropoutMask=this.dropoutMask,applyDropout=(x2,mask,index)=>!mask||!mask[index]?x2:mul(mask[index],x2),xI=applyDropout(x,dropoutMask,0),xF=applyDropout(x,dropoutMask,1),xC=applyDropout(x,dropoutMask,2),xO=applyDropout(x,dropoutMask,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=generateDropoutMask({ones:()=>onesLike(hTMinus1),rate:this.recurrentDropout,training:training5,count:numOfKernels}));let recDropoutMask=this.recurrentDropoutMask,hI=applyDropout(hTMinus1,recDropoutMask,0),hF=applyDropout(hTMinus1,recDropoutMask,1),hC=applyDropout(hTMinus1,recDropoutMask,2),hO=applyDropout(hTMinus1,recDropoutMask,3),kernelChannelAxis=3,[kernelI,kernelF,kernelC,kernelO]=split(this.kernel.read(),numOfKernels,kernelChannelAxis),[biasI,biasF,biasC,biasO]=this.useBias?split(this.bias.read(),numOfKernels):[null,null,null,null];xI=this.inputConv(xI,kernelI,biasI,this.padding),xF=this.inputConv(xF,kernelF,biasF,this.padding),xC=this.inputConv(xC,kernelC,biasC,this.padding),xO=this.inputConv(xO,kernelO,biasO,this.padding);let[recKernelI,recKernelF,recKernelC,recKernelO]=split(this.recurrentKernel.read(),numOfKernels,kernelChannelAxis);hI=this.recurrentConv(hI,recKernelI),hF=this.recurrentConv(hF,recKernelF),hC=this.recurrentConv(hC,recKernelC),hO=this.recurrentConv(hO,recKernelO);let i=this.recurrentActivation.apply(add2(xI,hI)),f=this.recurrentActivation.apply(add2(xF,hF)),c=add2(mul(f,cTMinus1),mul(i,this.activation.apply(add2(xC,hC)))),h=mul(this.recurrentActivation.apply(add2(xO,hO)),this.activation.apply(c));return[h,h,c]})}getConfig(){let _a=super.getConfig(),{units:_}=_a,baseConfig=__rest(_a,["units"]),config={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},baseConfig,config)}inputConv(x,w,b,padding2){let out=conv2d(x,w,this.strides,padding2||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return b?biasAdd(out,b,this.dataFormat):out}recurrentConv(x,w){let strides=1;return conv2d(x,w,strides,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};ConvLSTM2DCell.className="ConvLSTM2DCell";serialization_exports.registerClass(ConvLSTM2DCell);var ConvLSTM2D=class extends ConvRNN2D{constructor(args){let cell=new ConvLSTM2DCell(args);super(Object.assign({},args,{cell}))}static fromConfig(cls,config){return new cls(config)}};ConvLSTM2D.className="ConvLSTM2D";serialization_exports.registerClass(ConvLSTM2D);var Dropout=class extends Layer{constructor(args){super(args);this.rate=Math.max(Math.min(args.rate,1),0),this.noiseShape=args.noiseShape,this.seed=args.seed,this.supportsMasking=!0}getNoiseShape(input2){if(this.noiseShape==null)return this.noiseShape;let inputShape=input2.shape,noiseShape=[];for(let i=0;i<this.noiseShape.length;++i)noiseShape.push(this.noiseShape[i]==null?inputShape[i]:this.noiseShape[i]);return noiseShape}call(inputs,kwargs){return tidy(()=>{this.invokeCallHook(inputs,kwargs);let input2=getExactlyOneTensor(inputs);if(0<this.rate&&this.rate<1){let training5=kwargs.training==null?!1:kwargs.training,noiseShape=this.getNoiseShape(input2),output=inTrainPhase(()=>dropout2(input2,this.rate,noiseShape,this.seed),()=>input2,training5);return output}return inputs})}getConfig(){let config={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}dispose(){return super.dispose()}};Dropout.className="Dropout";serialization_exports.registerClass(Dropout);var SpatialDropout1D=class extends Dropout{constructor(args){super(args);this.inputSpec=[{ndim:3}]}getNoiseShape(input2){let inputShape=input2.shape;return[inputShape[0],1,inputShape[2]]}};SpatialDropout1D.className="SpatialDropout1D";serialization_exports.registerClass(SpatialDropout1D);var Dense=class extends Layer{constructor(args){super(args);if(this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",args.batchInputShape==null&&args.inputShape==null&&args.inputDim!=null){let batchSize=null;args.batchSize!=null&&(batchSize=args.batchSize),this.batchInputShape=[batchSize,args.inputDim]}this.units=args.units,assertPositiveInteger(this.units,"units"),this.activation=getActivation(args.activation),args.useBias!=null&&(this.useBias=args.useBias),this.kernelInitializer=getInitializer(args.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=getInitializer(args.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=getConstraint(args.kernelConstraint),this.biasConstraint=getConstraint(args.biasConstraint),this.kernelRegularizer=getRegularizer(args.kernelRegularizer),this.biasRegularizer=getRegularizer(args.biasRegularizer),this.activityRegularizer=getRegularizer(args.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(inputShape){inputShape=getExactlyOneShape(inputShape);let inputLastDim=inputShape[inputShape.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[inputLastDim,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:inputLastDim}}],this.built=!0}computeOutputShape(inputShape){inputShape=getExactlyOneShape(inputShape);let outputShape=inputShape.slice();return outputShape[outputShape.length-1]=this.units,outputShape}call(inputs,kwargs){return tidy(()=>{this.invokeCallHook(inputs,kwargs);let input2=getExactlyOneTensor(inputs),fusedActivationName=mapActivationToFusedKernel(this.activation.getClassName()),output;return fusedActivationName!=null?output=dot5(input2,this.kernel.read(),fusedActivationName,this.bias?this.bias.read():null):(output=dot5(input2,this.kernel.read()),this.bias!=null&&(output=biasAdd(output,this.bias.read())),this.activation!=null&&(output=this.activation.apply(output))),output})}getConfig(){let config={units:this.units,activation:serializeActivation(this.activation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),biasConstraint:serializeConstraint(this.biasConstraint)},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}};Dense.className="Dense";serialization_exports.registerClass(Dense);var Flatten=class extends Layer{constructor(args){args=args||{},super(args),this.inputSpec=[{minNDim:3}],this.dataFormat=args.dataFormat}computeOutputShape(inputShape){inputShape=getExactlyOneShape(inputShape);for(let dim of inputShape.slice(1))if(dim==null)throw new ValueError(`The shape of the input to "Flatten" is not fully defined (got ${inputShape.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[inputShape[0],arrayProd(inputShape,1)]}call(inputs,kwargs){return tidy(()=>{this.invokeCallHook(inputs,kwargs);let input2=getExactlyOneTensor(inputs);if(this.dataFormat==="channelsFirst"&&input2.rank>1){let permutation=[0];for(let i=2;i<input2.rank;++i)permutation.push(i);permutation.push(1),input2=input2.transpose(permutation)}return batchFlatten(input2)})}getConfig(){let config={};this.dataFormat!=null&&(config.dataFormat=this.dataFormat);let baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}};Flatten.className="Flatten";serialization_exports.registerClass(Flatten);var Activation2=class extends Layer{constructor(args){super(args);this.supportsMasking=!0,this.activation=getActivation(args.activation)}call(inputs,kwargs){return tidy(()=>{this.invokeCallHook(inputs,kwargs);let input2=getExactlyOneTensor(inputs);return this.activation.apply(input2)})}getConfig(){let config={activation:serializeActivation(this.activation)},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}};Activation2.className="Activation";serialization_exports.registerClass(Activation2);var RepeatVector=class extends Layer{constructor(args){super(args);this.n=args.n,this.inputSpec=[{ndim:2}]}computeOutputShape(inputShape){return[inputShape[0],this.n,inputShape[1]]}call(inputs,kwargs){return tidy(()=>(inputs=getExactlyOneTensor(inputs),repeat(inputs,this.n)))}getConfig(){let config={n:this.n},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}};RepeatVector.className="RepeatVector";serialization_exports.registerClass(RepeatVector);var Reshape2=class extends Layer{constructor(args){super(args);this.targetShape=args.targetShape;for(let i=0;i<this.targetShape.length;++i)this.isUnknown(this.targetShape[i])&&(this.targetShape[i]=null)}isUnknown(dim){return dim<0||dim==null}fixUnknownDimension(inputShape,outputShape){let errorMsg="Total size of new array must be unchanged.",finalShape=outputShape.slice(),known=1,unknown=null;for(let i=0;i<finalShape.length;++i){let dim=finalShape[i];if(this.isUnknown(dim))if(unknown===null)unknown=i;else throw new ValueError("Can only specifiy one unknown dimension.");else known*=dim}let originalSize=arrayProd(inputShape);if(unknown!==null){if(known===0||originalSize%known!==0)throw new ValueError(errorMsg);finalShape[unknown]=originalSize/known}else if(originalSize!==known)throw new ValueError(errorMsg);return finalShape}computeOutputShape(inputShape){let anyUnknownDims=!1;for(let i=0;i<inputShape.length;++i)if(this.isUnknown(inputShape[i])){anyUnknownDims=!0;break}return anyUnknownDims?inputShape.slice(0,1).concat(this.targetShape):inputShape.slice(0,1).concat(this.fixUnknownDimension(inputShape.slice(1),this.targetShape))}call(inputs,kwargs){return tidy(()=>{this.invokeCallHook(inputs,kwargs);let input2=getExactlyOneTensor(inputs),inputShape=input2.shape,outputShape=inputShape.slice(0,1).concat(this.fixUnknownDimension(inputShape.slice(1),this.targetShape));return input2.reshape(outputShape)})}getConfig(){let config={targetShape:this.targetShape},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}};Reshape2.className="Reshape";serialization_exports.registerClass(Reshape2);var Permute=class extends Layer{constructor(args){super(args);if(args.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(args.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${args.dims} instead.`);let expectedSortedIndices=range4(1,args.dims.length+1);if(!util_exports.arraysEqual(args.dims.slice().sort(),expectedSortedIndices))throw new Error("Invalid permutation `dims`: "+JSON.stringify(args.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=args.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new InputSpec({ndim:this.dims.length+1})]}computeOutputShape(inputShape){inputShape=getExactlyOneShape(inputShape);let outputShape=inputShape.slice();return this.dims.forEach((dim,i)=>{outputShape[i+1]=inputShape[dim]}),outputShape}call(inputs,kwargs){return transpose(getExactlyOneTensor(inputs),this.dimsIncludingBatch)}getConfig(){let config={dims:this.dims},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}};Permute.className="Permute";serialization_exports.registerClass(Permute);var Masking=class extends Layer{constructor(args){super(args==null?{}:args);this.supportsMasking=!0,args!=null?this.maskValue=args.maskValue==null?0:args.maskValue:this.maskValue=0}computeOutputShape(inputShape){return inputShape}getConfig(){let baseConfig=super.getConfig(),config={maskValue:this.maskValue};return Object.assign(config,baseConfig),config}computeMask(inputs,mask){let input2=getExactlyOneTensor(inputs),axis=-1;return any(notEqual(input2,this.maskValue),axis)}call(inputs,kwargs){return tidy(()=>{this.invokeCallHook(inputs,kwargs);let input2=getExactlyOneTensor(inputs),axis=-1,keepDims=!0,booleanMask=any(notEqual(input2,this.maskValue),axis,keepDims),output=input2.mul(booleanMask.asType(input2.dtype));return output})}};Masking.className="Masking";serialization_exports.registerClass(Masking);var Embedding=class extends Layer{constructor(args){super(args);if(this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",args.batchInputShape==null&&args.inputShape==null){let batchSize=null;args.batchSize!=null&&(batchSize=args.batchSize),args.inputLength==null?this.batchInputShape=[batchSize,null]:this.batchInputShape=[batchSize].concat(toList(args.inputLength))}this.inputDim=args.inputDim,assertPositiveInteger(this.inputDim,"inputDim"),this.outputDim=args.outputDim,assertPositiveInteger(this.outputDim,"outputDim"),this.embeddingsInitializer=getInitializer(args.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=getRegularizer(args.embeddingsRegularizer),this.activityRegularizer=getRegularizer(args.activityRegularizer),this.embeddingsConstraint=getConstraint(args.embeddingsConstraint),this.maskZero=args.maskZero,this.supportsMasking=args.maskZero,this.inputLength=args.inputLength}build(inputShape){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(inputShape){}computeMask(inputs,mask){return tidy(()=>this.maskZero?(inputs=getExactlyOneTensor(inputs),notEqual(inputs,zerosLike(inputs))):null)}computeOutputShape(inputShape){if(inputShape=getExactlyOneShape(inputShape),this.inputLength==null)return[...inputShape,this.outputDim];let inLens=toList(this.inputLength);if(inLens.length!==inputShape.length-1)throw new ValueError(`"inputLength" is ${this.inputLength}, but received input shape has shape ${inputShape}`);{let i=0;for(let k=0;k<inLens.length;++k){let s1=inLens[k],s2=inputShape[k+1];if(s1!=null&&s2!=null&&s1!==s2)throw new ValueError(`"inputLength" is ${this.inputLength}, but received input shape has shape ${inputShape}`);s1==null&&(inLens[i]=s2),i++}}return[inputShape[0],...inLens,this.outputDim]}call(inputs,kwargs){return tidy(()=>{this.invokeCallHook(inputs,kwargs);let input2=getExactlyOneTensor(inputs);input2.dtype!=="int32"&&(input2=cast47(input2,"int32"));let output=gather6(this.embeddings.read(),input2.as1D());return output.reshape(getExactlyOneShape(this.computeOutputShape(input2.shape)))})}getConfig(){let config={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:serializeInitializer(this.embeddingsInitializer),embeddingsRegularizer:serializeRegularizer(this.embeddingsRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),embeddingsConstraint:serializeConstraint(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}};Embedding.className="Embedding";serialization_exports.registerClass(Embedding);var Merge=class extends Layer{constructor(args){super(args||{});this.supportsMasking=!0}mergeFunction(inputs){throw new NotImplementedError}computeElementwiseOpOutputShape(shape1,shape2){if(shape1==null||shape2==null)return null;if(shape1.length<shape2.length)return this.computeElementwiseOpOutputShape(shape2,shape1);if(shape2.length===0)return shape1;let outputShape=shape1.slice(0,shape1.length-shape2.length);for(let k=0;k<shape2.length;++k){let i=shape1[shape1.length-shape2.length+k],j=shape2[k];if(i==null||j==null||i<0||j<0)outputShape.push(null);else if(i===1)outputShape.push(j);else if(j===1)outputShape.push(i);else{if(i!==j)throw new ValueError("Operands could not be broadcast together with shapes "+JSON.stringify(shape1)+" "+JSON.stringify(shape2));outputShape.push(i)}}return outputShape}build(inputShape){if(Array.isArray(inputShape)&&!Array.isArray(inputShape[0])&&(inputShape=[getExactlyOneShape(inputShape)]),inputShape=inputShape,inputShape.length<2)throw new ValueError(`A merge layer should be called on an Array of at least 2 inputs. Got ${inputShape.length} input(s).`);let batchSizes=[];for(let shape of inputShape)shape!=null&&shape[0]!==null&&batchSizes.push(shape[0]);if(batchSizes=unique5(batchSizes),batchSizes.length>1)throw new ValueError(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(inputShape)}.`);let outputShape=inputShape[0]==null?null:inputShape[0].slice(1);for(let i=1;i<inputShape.length;++i){let shape=inputShape[i]==null?null:inputShape[i].slice(1);outputShape=this.computeElementwiseOpOutputShape(outputShape,shape)}let allRanks=inputShape.map(shape=>shape.length);inputShape.indexOf(null)===-1&&unique5(allRanks).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(inputs,kwargs){return tidy(()=>{if(inputs=inputs,this.reshapeRequired){let reshapedInputs=[],inputDims=inputs.map(input2=>input2.rank);if(inputDims.indexOf(null)===-1){let maxNDim=max8(inputDims);for(let x of inputs){let xNDim=x.rank;for(let k=0;k<maxNDim-xNDim;++k)x=expandDims2(x,1);reshapedInputs.push(x)}return this.mergeFunction(reshapedInputs)}else{let transposed=!1;for(let x of inputs){let xNDim=x.rank;if(xNDim==null){let xShape=x.shape,batchSize=xShape[0],newShape=xShape.slice(1).concat([batchSize]),xTransposed=x.reshape([batchSize].concat(arrayProd(xShape.slice(1))));xTransposed=transpose(xTransposed,[1,0]),xTransposed=xTransposed.reshape(newShape),reshapedInputs.push(xTransposed),transposed=!0}else if(xNDim>1){let dims=range4(1,xNDim).concat([0]);reshapedInputs.push(transpose(x,dims)),transposed=!0}else reshapedInputs.push(x)}let y=this.mergeFunction(reshapedInputs),yNDim=y.rank;if(transposed){if(yNDim==null){let yShape=y.shape,yNDim2=yShape.length,batchSize=yShape[yNDim2-1],newShape=[batchSize].concat(yShape.slice(0,yShape.length-1));y=transpose(y.reshape([-1,batchSize]),[1,0]).reshape(newShape)}else if(yNDim>1){let dims=[yNDim-1].concat(range4(0,yNDim-1));y=transpose(y,dims)}}return y}}else return this.mergeFunction(inputs)})}computeOutputShape(inputShape){inputShape=inputShape;let outputShape;inputShape[0]==null?outputShape=null:outputShape=inputShape[0].slice(1);for(let i=1;i<inputShape.length;++i){let shape=inputShape[i]==null?null:inputShape[i].slice(1);outputShape=this.computeElementwiseOpOutputShape(outputShape,shape)}let batchSizes=[];for(let shape of inputShape)shape!=null&&shape[0]!==null&&batchSizes.push(shape[0]);return batchSizes=unique5(batchSizes),batchSizes.length===1?outputShape=batchSizes.concat(outputShape):outputShape=[null].concat(outputShape),outputShape}computeMask(inputs,mask){return tidy(()=>{if(mask==null)return null;if(!Array.isArray(mask))throw new ValueError("`mask` should be an Array");if(!Array.isArray(inputs))throw new ValueError("`inputs` should be an Array");if(mask.length!==inputs.length)throw new ValueError(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${inputs.length} vs ${mask.length})`);if(mask.every(m=>m==null))return null;mask=mask.map(m=>m==null?m:expandDims(m,0));let output=mask[0];for(let i=1;i<mask.length-1;++i)output=logicalAnd(output,mask[i]);return output})}},Add2=class extends Merge{constructor(args){super(args)}mergeFunction(inputs){return tidy(()=>{let output=inputs[0].clone();for(let i=1;i<inputs.length;++i)output=add2(output,inputs[i]);return output})}};Add2.className="Add";serialization_exports.registerClass(Add2);var Multiply2=class extends Merge{constructor(args){super(args)}mergeFunction(inputs){return tidy(()=>{let output=inputs[0].clone();for(let i=1;i<inputs.length;++i)output=mul(output,inputs[i]);return output})}};Multiply2.className="Multiply";serialization_exports.registerClass(Multiply2);var Average=class extends Merge{constructor(args){super(args)}mergeFunction(inputs){return tidy(()=>{let output=inputs[0].clone();for(let i=1;i<inputs.length;++i)output=add2(output,inputs[i]);return mul(1/inputs.length,output)})}};Average.className="Average";serialization_exports.registerClass(Average);var Maximum2=class extends Merge{constructor(args){super(args)}mergeFunction(inputs){return tidy(()=>{let output=inputs[0];for(let i=1;i<inputs.length;++i)output=maximum(output,inputs[i]);return output})}};Maximum2.className="Maximum";serialization_exports.registerClass(Maximum2);var Minimum2=class extends Merge{constructor(args){super(args)}mergeFunction(inputs){return tidy(()=>{let output=inputs[0];for(let i=1;i<inputs.length;++i)output=minimum(output,inputs[i]);return output})}};Minimum2.className="Minimum";serialization_exports.registerClass(Minimum2);var Concatenate=class extends Merge{constructor(args){super(args);this.DEFAULT_AXIS=-1,args==null&&(args={}),this.axis=args.axis==null?this.DEFAULT_AXIS:args.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(inputShape){if(!(Array.isArray(inputShape)&&Array.isArray(inputShape[0]))||inputShape.length===1)throw new ValueError("A `Concatenate` layer should be called on a list of at least 2 inputs");inputShape=inputShape;let allNoneShape=!0;for(let shape of inputShape)if(shape!=null){allNoneShape=!1;break}if(allNoneShape)return;let shapeSet=[];for(let i=0;i<inputShape.length;++i){let shapeWithoutConcatAxis=inputShape[i].slice();shapeWithoutConcatAxis.splice(this.axis,1);let exists=!1;for(let shape of shapeSet)if(util_exports.arraysEqual(shape,shapeWithoutConcatAxis)){exists=!0;break}exists||shapeSet.push(shapeWithoutConcatAxis)}if(shapeSet.length>1)throw new ValueError("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(inputShape))}mergeFunction(inputs){return tidy(()=>concatenate(inputs,this.axis))}computeOutputShape(inputShape){if(!(Array.isArray(inputShape)&&Array.isArray(inputShape[0])))throw new ValueError("A `Concatenate` layer should be called on a list of inputs.");let inputShapes=inputShape,outputShape=inputShapes[0].slice(),axis=this.axis<0?outputShape.length+this.axis:this.axis;for(let shape of inputShapes.slice(1)){if(outputShape[axis]==null||shape[axis]==null){outputShape[axis]=null;break}outputShape[axis]+=shape[axis]}return outputShape}computeMask(inputs,mask){if(mask==null)return null;if(!Array.isArray(mask))throw new ValueError("`mask` should be an array for Concatenate");if(!Array.isArray(inputs))throw new ValueError("`inputs` should be an array for Concatenate");if(mask.length!==inputs.length)throw new ValueError(`Mismatch in the length of mask (${mask.length}) and the legnth of inputs (${inputs.length})`);return tidy(()=>{let allNullMasks=!0;if(mask.forEach(m=>{if(m!=null){allNullMasks=!1;return}}),allNullMasks)return null;let outputMasks=[];for(let i=0;i<inputs.length;++i)mask[i]==null?outputMasks.push(onesLike(inputs[i]).asType("bool")):mask[i].rank<inputs[i].rank?outputMasks.push(expandDims(mask[i],-1)):outputMasks.push(mask[i]);let concatenatedMasks=concat(outputMasks,this.axis);return all(concatenatedMasks,-1,!1)})}getConfig(){let config={axis:this.axis},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}};Concatenate.className="Concatenate";serialization_exports.registerClass(Concatenate);function interpretAxis(axis,dim){for(;axis<0;)axis+=dim;return axis}function batchDot(x,y,axes){if(x.shape.length>3||y.shape.length>3)throw new NotImplementedError("batchDot is not implemented for tensors of 4D or higher rank yet");if(util_exports.assert(x.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${x.shape.length}`),util_exports.assert(x.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${y.shape.length}`),typeof axes=="number"&&(axes=[axes,axes]),x.dtype==="complex64"||y.dtype==="complex64")throw new NotImplementedError("batchDot is not implemented for complex64-type Tensors yet.");let xNDim=x.shape.length,yNDim=y.shape.length;axes==null&&(axes=[xNDim-1,yNDim-2]);let axesArray=axes;return tidy(()=>{let diff;if(xNDim>yNDim){diff=xNDim-yNDim;let diffShape=[];for(let i=0;i<diff;++i)diffShape.push(1);y=y.reshape(y.shape.concat(diffShape))}else if(yNDim>xNDim){diff=yNDim-xNDim;let diffShape=[];for(let i=0;i<diff;++i)diffShape.push(1);x=x.reshape(x.shape.concat(diffShape))}else diff=0;let out;if(x.shape.length===2&&y.shape.length===2)axesArray[0]===axesArray[1]?out=x.mul(y).sum(axesArray[0]):out=x.transpose([1,0]).mul(y).sum(axesArray[1]);else{let adjX=axesArray[0]!==x.shape.length-1,adjY=axesArray[1]===y.shape.length-1;out=x.matMul(y,adjX,adjY)}if(diff>0){let idx;xNDim>yNDim?idx=xNDim+yNDim-3:idx=xNDim-1;let squeezeAxes=[];for(let i=idx;i<idx+diff;++i)squeezeAxes.push(i);out=out.squeeze(squeezeAxes)}return out.shape.length===1&&(out=out.expandDims(1)),out})}var Dot=class extends Merge{constructor(args){super(args);this.axes=args.axes,this.normalize=args.normalize==null?!1:args.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(inputShape){util_exports.assert(Array.isArray(inputShape)&&inputShape.length===2&&Array.isArray(inputShape[0])&&Array.isArray(inputShape[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let shape1=inputShape[0],shape2=inputShape[1];if(shape1.length>3||shape2.length>3)throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");let axes=this.interpretAxes(shape1,shape2);if(shape1[axes[0]]!==shape2[axes[1]])throw new ValueError(`Dimension incompatibility: ${shape1[axes[0]]} !== ${shape2[axes[1]]}`)}mergeFunction(inputs){if(inputs.length!==2)throw new ValueError(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${inputs.length} input(s).`);let x1=inputs[0],x2=inputs[1],axes;return Array.isArray(this.axes)?axes=this.axes.map((axis,i)=>interpretAxis(axis,inputs[i].shape.length)):axes=[interpretAxis(this.axes,x1.shape.length),interpretAxis(this.axes,x2.shape.length)],this.normalize&&(x1=l2Normalize(x1,axes[0]),x2=l2Normalize(x2,axes[1])),batchDot(x1,x2,axes)}interpretAxes(shape1,shape2){let axes;return Array.isArray(this.axes)?axes=this.axes:axes=[interpretAxis(this.axes,shape1.length),interpretAxis(this.axes,shape2.length)],axes}computeOutputShape(inputShape){util_exports.assert(Array.isArray(inputShape)&&inputShape.length===2&&Array.isArray(inputShape[0])&&Array.isArray(inputShape[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let shape1=inputShape[0].slice(),shape2=inputShape[1].slice();if(shape1.length>3||shape2.length>3)throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");let axes=this.interpretAxes(shape1,shape2);shape1.splice(axes[0],1),shape2.splice(axes[1],1),shape2.splice(0,1);let outputShape=shape1.concat(shape2);return outputShape.length===1&&outputShape.push(1),outputShape}computeMask(inputs,mask){return null}getConfig(){let config={axes:this.axes,normalize:this.normalize},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}};Dot.className="Dot";serialization_exports.registerClass(Dot);var GaussianNoise=class extends Layer{constructor(args){super(args);this.supportsMasking=!0,this.stddev=args.stddev}computeOutputShape(inputShape){return inputShape}getConfig(){let baseConfig=super.getConfig(),config={stddev:this.stddev};return Object.assign(config,baseConfig),config}call(inputs,kwargs){return tidy(()=>{this.invokeCallHook(inputs,kwargs);let input2=getExactlyOneTensor(inputs),noised=()=>randomNormal2(input2.shape,0,this.stddev).add(input2),output=inTrainPhase(noised,()=>input2,kwargs.training||!1);return output})}};GaussianNoise.className="GaussianNoise";serialization_exports.registerClass(GaussianNoise);var GaussianDropout=class extends Layer{constructor(args){super(args);this.supportsMasking=!0,this.rate=args.rate}computeOutputShape(inputShape){return inputShape}getConfig(){let baseConfig=super.getConfig(),config={rate:this.rate};return Object.assign(config,baseConfig),config}call(inputs,kwargs){return tidy(()=>{this.invokeCallHook(inputs,kwargs);let input2=getExactlyOneTensor(inputs);if(this.rate>0&&this.rate<1){let noised=()=>{let stddev=Math.sqrt(this.rate/(1-this.rate));return input2.mul(randomNormal2(input2.shape,1,stddev))};return inTrainPhase(noised,()=>input2,kwargs.training||!1)}return input2})}};GaussianDropout.className="GaussianDropout";serialization_exports.registerClass(GaussianDropout);var AlphaDropout=class extends Layer{constructor(args){super(args);this.supportsMasking=!0,this.rate=args.rate,this.noiseShape=args.noiseShape}_getNoiseShape(inputs){return this.noiseShape||getExactlyOneTensor(inputs).shape}computeOutputShape(inputShape){return inputShape}getConfig(){let baseConfig=super.getConfig(),config={rate:this.rate};return Object.assign(config,baseConfig),config}call(inputs,kwargs){return tidy(()=>{if(this.rate<1&&this.rate>0){let noiseShape=this._getNoiseShape(inputs),droppedInputs=()=>{let input2=getExactlyOneTensor(inputs),alpha=1.6732632423543772,scale2=1.0507009873554805,alphaP=-alpha*scale2,keptIdx=greaterEqual(randomUniform(noiseShape),this.rate);keptIdx=cast47(keptIdx,"float32");let a=((1-this.rate)*(1+this.rate*alphaP**2))**-.5,b=-a*alphaP*this.rate,x=input2.mul(keptIdx).add(keptIdx.add(-1).mul(alphaP));return x.mul(a).add(b)};return inTrainPhase(droppedInputs,()=>getExactlyOneTensor(inputs),kwargs.training||!1)}return inputs})}};AlphaDropout.className="AlphaDropout";serialization_exports.registerClass(AlphaDropout);function batchNormalization(x,mean7,variance,beta,gamma,epsilon3=.001){let out;if(x.rank===2)out=batchNorm2d(x,mean7,variance,beta,gamma,epsilon3);else if(x.rank===3)out=batchNorm3d(x,mean7,variance,beta,gamma,epsilon3);else if(x.rank===4)out=batchNorm4d(x,mean7,variance,beta,gamma,epsilon3);else throw new NotImplementedError(`batchNormalization is not implemented for array of rank ${x.rank} yet`);return out}function regularNormalizeBatchInTraining(x,gamma,beta,reductionAxes,epsilon3=.001){return tidy(()=>{let meanAndVariance=moments(x,reductionAxes),mean7=meanAndVariance.mean,variance=meanAndVariance.variance,normed=batchNormalization(x,mean7,variance,beta,gamma,epsilon3);return[normed,mean7,variance]})}function broadcastNormalizeBatchInTraining(x,gamma,beta,reductionAxes,epsilon3=.001){return tidy(()=>{let meanAndVariance=moments(x,reductionAxes),mean7=meanAndVariance.mean,variance=meanAndVariance.variance,targetShape=[];for(let axis of range4(0,x.rank))reductionAxes.indexOf(axis)!==-1?targetShape.push(1):targetShape.push(x.shape[axis]);let broadcastMean=mean7.reshape(targetShape),broadcastVariance=variance.reshape(targetShape),broadcastGamma=gamma==null?null:gamma.reshape(targetShape),broadcastBeta=beta==null?null:beta.reshape(targetShape),normed=batchNormalization(x,broadcastMean,broadcastVariance,broadcastBeta,broadcastGamma,epsilon3);return[normed,mean7,variance]})}function normalizeBatchInTraining(x,gamma,beta,reductionAxes,epsilon3=.001){return util_exports.arraysEqual(reductionAxes.slice().sort(),range4(0,x.rank-1))?regularNormalizeBatchInTraining(x,gamma,beta,reductionAxes,epsilon3):broadcastNormalizeBatchInTraining(x,gamma,beta,reductionAxes,epsilon3)}var BatchNormalization=class extends Layer{constructor(args){args==null&&(args={}),super(args),this.supportsMasking=!0,this.axis=args.axis==null?-1:args.axis,this.momentum=args.momentum==null?.99:args.momentum,this.epsilon=args.epsilon==null?.001:args.epsilon,this.center=args.center==null?!0:args.center,this.scale=args.scale==null?!0:args.scale,this.betaInitializer=getInitializer(args.betaInitializer||"zeros"),this.gammaInitializer=getInitializer(args.gammaInitializer||"ones"),this.movingMeanInitializer=getInitializer(args.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=getInitializer(args.movingVarianceInitializer||"ones"),this.betaConstraint=getConstraint(args.betaConstraint),this.gammaConstraint=getConstraint(args.gammaConstraint),this.betaRegularizer=getRegularizer(args.betaRegularizer),this.gammaRegularizer=getRegularizer(args.gammaRegularizer)}build(inputShape){inputShape=getExactlyOneShape(inputShape);let axis=this.axis>=0?this.axis:this.axis+inputShape.length,dim=inputShape[axis];if(dim==null)throw new ValueError(`Axis ${axis} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(inputShape)}.`);this.inputSpec=[new InputSpec({ndim:inputShape.length,axes:{[axis]:dim}})];let shape=[dim];this.scale&&(this.gamma=this.addWeight("gamma",shape,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",shape,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",shape,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",shape,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(inputs,kwargs){return tidy(()=>{let training5=kwargs.training==null?!1:kwargs.training,input2=getExactlyOneTensor(inputs),inputShape=input2.shape,ndim=inputShape.length,reductionAxes=range4(0,ndim),axis=this.axis>=0?this.axis:this.axis+ndim;reductionAxes.splice(axis,1);let broadcastShape=pyListRepeat(1,ndim);broadcastShape[axis]=inputShape[axis];let sortedReductionAxes=reductionAxes.slice();sortedReductionAxes.sort();let needsBroadcasting=!util_exports.arraysEqual(sortedReductionAxes,range4(0,ndim).slice(0,ndim-1)),normalizeInference=()=>{if(needsBroadcasting){let broadcastMovingMean=this.movingMean.read().reshape(broadcastShape),broadcastMovingVariance=this.movingVariance.read().reshape(broadcastShape),broadcastBeta=this.center?this.beta.read().reshape(broadcastShape):null,broadcastGamma=this.scale?this.gamma.read().reshape(broadcastShape):null;return batchNormalization(input2,broadcastMovingMean,broadcastMovingVariance,broadcastBeta,broadcastGamma,this.epsilon)}else return batchNormalization(input2,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!training5)return normalizeInference();let[normedTraining,mean7,variance]=normalizeBatchInTraining(input2,this.gamma.read(),this.beta.read(),reductionAxes,this.epsilon),doMovingAverage=(variable3,value,momentum)=>{tidy(()=>{let decay=1-momentum,origValue=variable3.read(),updateDelta=origValue.sub(value).mul(decay);variable3.write(origValue.sub(updateDelta))})},updateMovingMeanAndVariance=()=>{doMovingAverage(this.movingMean,mean7,this.momentum),doMovingAverage(this.movingVariance,variance,this.momentum)};return updateMovingMeanAndVariance(),normedTraining})}getConfig(){let config={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:serializeInitializer(this.betaInitializer),gammaInitializer:serializeInitializer(this.gammaInitializer),movingMeanInitializer:serializeInitializer(this.movingMeanInitializer),movingVarianceInitializer:serializeInitializer(this.movingVarianceInitializer),betaRegularizer:serializeRegularizer(this.betaRegularizer),gammaRegularizer:serializeRegularizer(this.gammaRegularizer),betaConstraint:serializeConstraint(this.betaConstraint),gammaConstraint:serializeConstraint(this.gammaConstraint)},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}};BatchNormalization.className="BatchNormalization";serialization_exports.registerClass(BatchNormalization);var LayerNormalization=class extends Layer{constructor(args){if(args==null&&(args={}),super(args),this.axis=args.axis==null?-1:args.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let axis of this.axis)if(!Number.isInteger(axis))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=args.epsilon==null?.001:args.epsilon,this.center=args.center==null?!0:args.center,this.scale=args.scale==null?!0:args.scale,this.betaInitializer=getInitializer(args.betaInitializer||"zeros"),this.gammaInitializer=getInitializer(args.gammaInitializer||"ones"),this.betaRegularizer=getRegularizer(args.betaRegularizer),this.gammaRegularizer=getRegularizer(args.gammaRegularizer),this.supportsMasking=!0}build(inputShape){inputShape=getExactlyOneShape(inputShape);let nDims=inputShape.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=nDims);for(let axis of this.axis)if(axis<0||axis>=nDims)throw new Error(`Invalid axis: ${axis}`);if(this.axis.length!==unique5(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let paramShape=this.axis.map(axis=>inputShape[axis]),trainable=!0;this.scale?this.gamma=this.addWeight("gamma",paramShape,"float32",this.gammaInitializer,this.gammaRegularizer,trainable):this.gamma=null,this.center?this.beta=this.addWeight("beta",paramShape,"float32",this.betaInitializer,this.betaRegularizer,trainable):this.beta=null,this.built=!0}call(inputs,kwargs){let input2=getExactlyOneTensor(inputs),inputShape=input2.shape,nDims=inputShape.length;return tidy(()=>{let keepDims=!0,{mean:mean7,variance}=moments(input2,this.axis,keepDims),broadcastShape=pyListRepeat(1,nDims);for(let dim of this.axis)broadcastShape[dim]=inputShape[dim];let broadcast=v=>v!=null&&v.shape.length!==nDims&&this.axis!==[nDims-1]?v.reshape(broadcastShape):v,scale2=broadcast(this.gamma.read()),offset=broadcast(this.beta.read()),momentsTiling=[],scaleOffsetTiling=[];for(let i=0;i<nDims;++i)this.axis.indexOf(i)!==-1?(momentsTiling.push(inputShape[i]),scaleOffsetTiling.push(1)):(momentsTiling.push(1),scaleOffsetTiling.push(inputShape[i]));return mean7=mean7.tile(momentsTiling),variance=variance.tile(momentsTiling),scale2=scale2.tile(scaleOffsetTiling),offset=offset.tile(scaleOffsetTiling),batchNormalization(input2,mean7,variance,offset,scale2,this.epsilon)})}getConfig(){let config={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:serializeInitializer(this.betaInitializer),gammaInitializer:serializeInitializer(this.gammaInitializer),betaRegularizer:serializeRegularizer(this.betaRegularizer),gammaRegularizer:serializeRegularizer(this.gammaRegularizer)},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}};LayerNormalization.className="LayerNormalization";serialization_exports.registerClass(LayerNormalization);function spatial2dPadding(x,padding2,dataFormat){return tidy(()=>{if(x.rank!==4)throw new ValueError(`temporalPadding expects input tensor to be 4-D, but received a ${x.rank}-D tensor.`);if(padding2==null&&(padding2=[[1,1],[1,1]]),padding2.length!==2||padding2[0].length!==2||padding2[1].length!==2)throw new ValueError("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(dataFormat==null&&(dataFormat=imageDataFormat()),dataFormat!=="channelsLast"&&dataFormat!=="channelsFirst")throw new ValueError(`Unknown data format: ${dataFormat}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let pattern;return dataFormat==="channelsFirst"?pattern=[[0,0],[0,0],padding2[0],padding2[1]]:pattern=[[0,0],padding2[0],padding2[1],[0,0]],pad(x,pattern)})}var ZeroPadding2D=class extends Layer{constructor(args){if(args==null&&(args={}),super(args),this.dataFormat=args.dataFormat==null?imageDataFormat():args.dataFormat,args.padding==null)this.padding=[[1,1],[1,1]];else if(typeof args.padding=="number")this.padding=[[args.padding,args.padding],[args.padding,args.padding]];else{if(args.padding=args.padding,args.padding.length!==2)throw new ValueError(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${args.padding.length} array.`);let heightPadding,widthPadding;if(typeof args.padding[0]=="number")heightPadding=[args.padding[0],args.padding[0]],widthPadding=[args.padding[1],args.padding[1]];else{if(args.padding=args.padding,args.padding[0].length!==2)throw new ValueError(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${args.padding[0].length} array.`);if(heightPadding=args.padding[0],args.padding[1].length!==2)throw new ValueError(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${args.padding[1].length} array.`);widthPadding=args.padding[1]}this.padding=[heightPadding,widthPadding]}this.inputSpec=[new InputSpec({ndim:4})]}computeOutputShape(inputShape){inputShape=getExactlyOneShape(inputShape);let rows,cols;return this.dataFormat==="channelsFirst"?(inputShape[2]!=null&&inputShape[2]>=0?rows=inputShape[2]+this.padding[0][0]+this.padding[0][1]:rows=null,inputShape[3]!=null&&inputShape[3]>=0?cols=inputShape[3]+this.padding[1][0]+this.padding[1][1]:cols=null,[inputShape[0],inputShape[1],rows,cols]):(inputShape[1]!=null&&inputShape[1]>=0?rows=inputShape[1]+this.padding[0][0]+this.padding[0][1]:rows=null,inputShape[2]!=null&&inputShape[2]>=0?cols=inputShape[2]+this.padding[1][0]+this.padding[1][1]:cols=null,[inputShape[0],rows,cols,inputShape[3]])}call(inputs,kwargs){return tidy(()=>spatial2dPadding(getExactlyOneTensor(inputs),this.padding,this.dataFormat))}getConfig(){let config={padding:this.padding,dataFormat:this.dataFormat},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}};ZeroPadding2D.className="ZeroPadding2D";serialization_exports.registerClass(ZeroPadding2D);function pool2d(x,poolSize,strides,padding2,dataFormat,poolMode){return tidy(()=>{checkDataFormat(dataFormat),checkPoolMode(poolMode),checkPaddingMode(padding2),strides==null&&(strides=[1,1]),padding2==null&&(padding2="valid"),dataFormat==null&&(dataFormat=imageDataFormat()),poolMode==null&&(poolMode="max"),x=preprocessConv2DInput(x,dataFormat);let y,paddingString=padding2==="same"?"same":"valid";return poolMode==="max"?y=maxPool(x,poolSize,strides,paddingString):y=avgPool(x,poolSize,strides,paddingString),dataFormat==="channelsFirst"&&(y=transpose(y,[0,3,1,2])),y})}function pool3d(x,poolSize,strides,padding2,dataFormat,poolMode){return tidy(()=>{checkDataFormat(dataFormat),checkPoolMode(poolMode),checkPaddingMode(padding2),strides==null&&(strides=[1,1,1]),padding2==null&&(padding2="valid"),dataFormat==null&&(dataFormat=imageDataFormat()),poolMode==null&&(poolMode="max"),x=preprocessConv3DInput(x,dataFormat);let y,paddingString=padding2==="same"?"same":"valid";return poolMode==="max"?y=maxPool3d(x,poolSize,strides,paddingString):y=avgPool3d(x,poolSize,strides,paddingString),dataFormat==="channelsFirst"&&(y=transpose(y,[0,4,1,2,3])),y})}var Pooling1D=class extends Layer{constructor(args){if(args.poolSize==null&&(args.poolSize=2),super(args),typeof args.poolSize=="number")this.poolSize=[args.poolSize];else if(Array.isArray(args.poolSize)&&args.poolSize.length===1&&typeof args.poolSize[0]=="number")this.poolSize=args.poolSize;else throw new ValueError(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(args.poolSize)}`);if(assertPositiveInteger(this.poolSize,"poolSize"),args.strides==null)this.strides=this.poolSize;else if(typeof args.strides=="number")this.strides=[args.strides];else if(Array.isArray(args.strides)&&args.strides.length===1&&typeof args.strides[0]=="number")this.strides=args.strides;else throw new ValueError(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(args.strides)}`);assertPositiveInteger(this.strides,"strides"),this.padding=args.padding==null?"valid":args.padding,checkPaddingMode(this.padding),this.inputSpec=[new InputSpec({ndim:3})]}computeOutputShape(inputShape){inputShape=getExactlyOneShape(inputShape);let length=convOutputLength(inputShape[1],this.poolSize[0],this.padding,this.strides[0]);return[inputShape[0],length,inputShape[2]]}call(inputs,kwargs){return tidy(()=>{this.invokeCallHook(inputs,kwargs),inputs=expandDims2(getExactlyOneTensor(inputs),2);let output=this.poolingFunction(getExactlyOneTensor(inputs),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return squeeze(output,[2])})}getConfig(){let config={poolSize:this.poolSize,padding:this.padding,strides:this.strides},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}},MaxPooling1D=class extends Pooling1D{constructor(args){super(args)}poolingFunction(inputs,poolSize,strides,padding2,dataFormat){return checkDataFormat(dataFormat),checkPaddingMode(padding2),pool2d(inputs,poolSize,strides,padding2,dataFormat,"max")}};MaxPooling1D.className="MaxPooling1D";serialization_exports.registerClass(MaxPooling1D);var AveragePooling1D=class extends Pooling1D{constructor(args){super(args)}poolingFunction(inputs,poolSize,strides,padding2,dataFormat){return checkDataFormat(dataFormat),checkPaddingMode(padding2),pool2d(inputs,poolSize,strides,padding2,dataFormat,"avg")}};AveragePooling1D.className="AveragePooling1D";serialization_exports.registerClass(AveragePooling1D);var Pooling2D=class extends Layer{constructor(args){if(args.poolSize==null&&(args.poolSize=[2,2]),super(args),this.poolSize=Array.isArray(args.poolSize)?args.poolSize:[args.poolSize,args.poolSize],args.strides==null)this.strides=this.poolSize;else if(Array.isArray(args.strides)){if(args.strides.length!==2)throw new ValueError(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${args.strides.length}.`);this.strides=args.strides}else this.strides=[args.strides,args.strides];assertPositiveInteger(this.poolSize,"poolSize"),assertPositiveInteger(this.strides,"strides"),this.padding=args.padding==null?"valid":args.padding,this.dataFormat=args.dataFormat==null?"channelsLast":args.dataFormat,checkDataFormat(this.dataFormat),checkPaddingMode(this.padding),this.inputSpec=[new InputSpec({ndim:4})]}computeOutputShape(inputShape){inputShape=getExactlyOneShape(inputShape);let rows=this.dataFormat==="channelsFirst"?inputShape[2]:inputShape[1],cols=this.dataFormat==="channelsFirst"?inputShape[3]:inputShape[2];return rows=convOutputLength(rows,this.poolSize[0],this.padding,this.strides[0]),cols=convOutputLength(cols,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[inputShape[0],inputShape[1],rows,cols]:[inputShape[0],rows,cols,inputShape[3]]}call(inputs,kwargs){return tidy(()=>(this.invokeCallHook(inputs,kwargs),this.poolingFunction(getExactlyOneTensor(inputs),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let config={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}},MaxPooling2D=class extends Pooling2D{constructor(args){super(args)}poolingFunction(inputs,poolSize,strides,padding2,dataFormat){return checkDataFormat(dataFormat),checkPaddingMode(padding2),pool2d(inputs,poolSize,strides,padding2,dataFormat,"max")}};MaxPooling2D.className="MaxPooling2D";serialization_exports.registerClass(MaxPooling2D);var AveragePooling2D=class extends Pooling2D{constructor(args){super(args)}poolingFunction(inputs,poolSize,strides,padding2,dataFormat){return checkDataFormat(dataFormat),checkPaddingMode(padding2),pool2d(inputs,poolSize,strides,padding2,dataFormat,"avg")}};AveragePooling2D.className="AveragePooling2D";serialization_exports.registerClass(AveragePooling2D);var Pooling3D=class extends Layer{constructor(args){if(args.poolSize==null&&(args.poolSize=[2,2,2]),super(args),this.poolSize=Array.isArray(args.poolSize)?args.poolSize:[args.poolSize,args.poolSize,args.poolSize],args.strides==null)this.strides=this.poolSize;else if(Array.isArray(args.strides)){if(args.strides.length!==3)throw new ValueError(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${args.strides.length}.`);this.strides=args.strides}else this.strides=[args.strides,args.strides,args.strides];assertPositiveInteger(this.poolSize,"poolSize"),assertPositiveInteger(this.strides,"strides"),this.padding=args.padding==null?"valid":args.padding,this.dataFormat=args.dataFormat==null?"channelsLast":args.dataFormat,checkDataFormat(this.dataFormat),checkPaddingMode(this.padding),this.inputSpec=[new InputSpec({ndim:5})]}computeOutputShape(inputShape){inputShape=getExactlyOneShape(inputShape);let depths=this.dataFormat==="channelsFirst"?inputShape[2]:inputShape[1],rows=this.dataFormat==="channelsFirst"?inputShape[3]:inputShape[2],cols=this.dataFormat==="channelsFirst"?inputShape[4]:inputShape[3];return depths=convOutputLength(depths,this.poolSize[0],this.padding,this.strides[0]),rows=convOutputLength(rows,this.poolSize[1],this.padding,this.strides[1]),cols=convOutputLength(cols,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[inputShape[0],inputShape[1],depths,rows,cols]:[inputShape[0],depths,rows,cols,inputShape[4]]}call(inputs,kwargs){return tidy(()=>(this.invokeCallHook(inputs,kwargs),this.poolingFunction(getExactlyOneTensor(inputs),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let config={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}},MaxPooling3D=class extends Pooling3D{constructor(args){super(args)}poolingFunction(inputs,poolSize,strides,padding2,dataFormat){return checkDataFormat(dataFormat),checkPaddingMode(padding2),pool3d(inputs,poolSize,strides,padding2,dataFormat,"max")}};MaxPooling3D.className="MaxPooling3D";serialization_exports.registerClass(MaxPooling3D);var AveragePooling3D=class extends Pooling3D{constructor(args){super(args)}poolingFunction(inputs,poolSize,strides,padding2,dataFormat){return checkDataFormat(dataFormat),checkPaddingMode(padding2),pool3d(inputs,poolSize,strides,padding2,dataFormat,"avg")}};AveragePooling3D.className="AveragePooling3D";serialization_exports.registerClass(AveragePooling3D);var GlobalPooling1D=class extends Layer{constructor(args){super(args);this.inputSpec=[new InputSpec({ndim:3})]}computeOutputShape(inputShape){return[inputShape[0],inputShape[2]]}call(inputs,kwargs){throw new NotImplementedError}},GlobalAveragePooling1D=class extends GlobalPooling1D{constructor(args){super(args||{})}call(inputs,kwargs){return tidy(()=>{let input2=getExactlyOneTensor(inputs);return mean(input2,1)})}};GlobalAveragePooling1D.className="GlobalAveragePooling1D";serialization_exports.registerClass(GlobalAveragePooling1D);var GlobalMaxPooling1D=class extends GlobalPooling1D{constructor(args){super(args||{})}call(inputs,kwargs){return tidy(()=>{let input2=getExactlyOneTensor(inputs);return max(input2,1)})}};GlobalMaxPooling1D.className="GlobalMaxPooling1D";serialization_exports.registerClass(GlobalMaxPooling1D);var GlobalPooling2D=class extends Layer{constructor(args){super(args);this.dataFormat=args.dataFormat==null?"channelsLast":args.dataFormat,checkDataFormat(this.dataFormat),this.inputSpec=[new InputSpec({ndim:4})]}computeOutputShape(inputShape){return inputShape=inputShape,this.dataFormat==="channelsLast"?[inputShape[0],inputShape[3]]:[inputShape[0],inputShape[1]]}call(inputs,kwargs){throw new NotImplementedError}getConfig(){let config={dataFormat:this.dataFormat},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}},GlobalAveragePooling2D=class extends GlobalPooling2D{call(inputs,kwargs){return tidy(()=>{let input2=getExactlyOneTensor(inputs);return this.dataFormat==="channelsLast"?mean(input2,[1,2]):mean(input2,[2,3])})}};GlobalAveragePooling2D.className="GlobalAveragePooling2D";serialization_exports.registerClass(GlobalAveragePooling2D);var GlobalMaxPooling2D=class extends GlobalPooling2D{call(inputs,kwargs){return tidy(()=>{let input2=getExactlyOneTensor(inputs);return this.dataFormat==="channelsLast"?max(input2,[1,2]):max(input2,[2,3])})}};GlobalMaxPooling2D.className="GlobalMaxPooling2D";serialization_exports.registerClass(GlobalMaxPooling2D);var Wrapper=class extends Layer{constructor(args){super(args);this.layer=args.layer}build(inputShape){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(value){this.layer!=null&&(this.layer.trainable=value)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(weights){this.layer.setWeights(weights)}getConfig(){let config={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}setFastWeightInitDuringBuild(value){super.setFastWeightInitDuringBuild(value),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(value)}static fromConfig(cls,config,customObjects={}){let layerConfig=config.layer,layer=deserialize(layerConfig,customObjects);delete config.layer;let newConfig={layer};return Object.assign(newConfig,config),new cls(newConfig)}},TimeDistributed=class extends Wrapper{constructor(args){super(args);this.supportsMasking=!0}build(inputShape){if(inputShape=getExactlyOneShape(inputShape),inputShape.length<3)throw new ValueError(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(inputShape)}`);this.inputSpec=[{shape:inputShape}];let childInputShape=[inputShape[0]].concat(inputShape.slice(2));this.layer.built||(this.layer.build(childInputShape),this.layer.built=!0),super.build(inputShape)}computeOutputShape(inputShape){inputShape=getExactlyOneShape(inputShape);let childInputShape=[inputShape[0]].concat(inputShape.slice(2)),childOutputShape=this.layer.computeOutputShape(childInputShape),timesteps=inputShape[1];return[childOutputShape[0],timesteps].concat(childOutputShape.slice(1))}call(inputs,kwargs){return tidy(()=>{inputs=getExactlyOneTensor(inputs);let step9=(inputs2,states)=>{let output=getExactlyOneTensor(this.layer.call(inputs2,kwargs));return[output,[]]},rnnOutputs=rnn(step9,inputs,[],!1,null,null,!1,!0),y=rnnOutputs[1];return y})}};TimeDistributed.className="TimeDistributed";serialization_exports.registerClass(TimeDistributed);function checkBidirectionalMergeMode(value){checkStringTypeUnionValue(VALID_BIDIRECTIONAL_MERGE_MODES,"BidirectionalMergeMode",value)}var DEFAULT_BIDIRECTIONAL_MERGE_MODE="concat",Bidirectional=class extends Wrapper{constructor(args){super(args);let layerConfig=args.layer.getConfig(),forwDict={};forwDict.className=args.layer.getClassName(),forwDict.config=layerConfig,this.forwardLayer=deserialize(forwDict),layerConfig.goBackwards=!(layerConfig.goBackwards===!0);let backDict={};if(backDict.className=args.layer.getClassName(),backDict.config=layerConfig,this.backwardLayer=deserialize(backDict),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=args.mergeMode===void 0?DEFAULT_BIDIRECTIONAL_MERGE_MODE:args.mergeMode,checkBidirectionalMergeMode(this.mergeMode),args.weights)throw new NotImplementedError("weights support is not implemented for Bidirectional layer yet.");this._stateful=args.layer.stateful,this.returnSequences=args.layer.returnSequences,this.returnState=args.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=args.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(value){this._trainable=value,this.forwardLayer!=null&&(this.forwardLayer.trainable=value),this.backwardLayer!=null&&(this.backwardLayer.trainable=value)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(weights){let numWeights=weights.length,numeightsOver2=Math.floor(numWeights/2);this.forwardLayer.setWeights(weights.slice(0,numeightsOver2)),this.backwardLayer.setWeights(weights.slice(numeightsOver2))}computeOutputShape(inputShape){let layerShapes=this.forwardLayer.computeOutputShape(inputShape);Array.isArray(layerShapes)&&Array.isArray(layerShapes[0])||(layerShapes=[layerShapes]),layerShapes=layerShapes;let outputShape,outputShapes,stateShape;return this.returnState&&(stateShape=layerShapes.slice(1)),outputShape=layerShapes[0],outputShape=outputShape,this.mergeMode==="concat"?(outputShape[outputShape.length-1]*=2,outputShapes=[outputShape]):this.mergeMode==null?outputShapes=[outputShape,outputShape.slice()]:outputShapes=[outputShape],this.returnState?this.mergeMode==null?outputShapes.concat(stateShape).concat(stateShape.slice()):[outputShape].concat(stateShape).concat(stateShape.slice()):singletonOrArray(outputShapes)}apply(inputs,kwargs){let initialState=kwargs==null?null:kwargs.initialState,constants=kwargs==null?null:kwargs.constants;kwargs==null&&(kwargs={});let standardized=standardizeArgs(inputs,initialState,constants,this.numConstants);if(inputs=standardized.inputs,initialState=standardized.initialState,constants=standardized.constants,Array.isArray(inputs)&&(initialState=inputs.slice(1),inputs=inputs[0]),(initialState==null||initialState.length===0)&&constants==null)return super.apply(inputs,kwargs);let additionalInputs=[],additionalSpecs=[];if(initialState!=null){let numStates=initialState.length;if(numStates%2>0)throw new ValueError("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");kwargs.initialState=initialState,additionalInputs.push(...initialState);let stateSpecs=initialState.map(state6=>new InputSpec({shape:state6.shape}));this.forwardLayer.stateSpec=stateSpecs.slice(0,numStates/2),this.backwardLayer.stateSpec=stateSpecs.slice(numStates/2),additionalSpecs.push(...stateSpecs)}if(constants!=null)throw new NotImplementedError("Support for constants in Bidirectional layers is not implemented yet.");let isSymbolicTensor=additionalInputs[0]instanceof SymbolicTensor;for(let tensor166 of additionalInputs)if(tensor166 instanceof SymbolicTensor!==isSymbolicTensor)throw new ValueError("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(isSymbolicTensor){let fullInput=[inputs].concat(additionalInputs),fullInputSpec=this.inputSpec.concat(additionalSpecs),originalInputSpec=this.inputSpec;this.inputSpec=fullInputSpec;let output=super.apply(fullInput,kwargs);return this.inputSpec=originalInputSpec,output}else return super.apply(inputs,kwargs)}call(inputs,kwargs){return tidy(()=>{let initialState=kwargs.initialState,y,yRev;if(initialState==null)y=this.forwardLayer.call(inputs,kwargs),yRev=this.backwardLayer.call(inputs,kwargs);else{let forwardState=initialState.slice(0,initialState.length/2),backwardState=initialState.slice(initialState.length/2);y=this.forwardLayer.call(inputs,Object.assign(kwargs,{initialState:forwardState})),yRev=this.backwardLayer.call(inputs,Object.assign(kwargs,{initialState:backwardState}))}let states;this.returnState&&(Array.isArray(y)&&(states=y.slice(1).concat(yRev.slice(1))),y=y[0],yRev=yRev[0]),this.returnSequences&&(yRev=reverse(yRev,1));let output;return this.mergeMode==="concat"?output=concatenate([y,yRev]):this.mergeMode==="sum"?output=add2(y,yRev):this.mergeMode==="ave"?output=mul(.5,add2(y,yRev)):this.mergeMode==="mul"?output=mul(y,yRev):this.mergeMode==null&&(output=[y,yRev]),this.returnState?this.mergeMode==null?output.concat(states):[output].concat(states):output})}resetStates(states){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(inputShape){nameScope(this.forwardLayer.name,()=>{this.forwardLayer.build(inputShape)}),nameScope(this.backwardLayer.name,()=>{this.backwardLayer.build(inputShape)}),this.built=!0}computeMask(inputs,mask){Array.isArray(mask)&&(mask=mask[0]);let outputMask;if(this.returnSequences?this.mergeMode==null?outputMask=[mask,mask]:outputMask=mask:this.mergeMode==null?outputMask=[null,null]:outputMask=null,this.returnState){let states=this.forwardLayer.states,stateMask=states.map(state6=>null);return Array.isArray(outputMask)?outputMask.concat(stateMask).concat(stateMask):[outputMask].concat(stateMask).concat(stateMask)}else return outputMask}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(value){super.setFastWeightInitDuringBuild(value),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(value),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(value)}getConfig(){let config={mergeMode:this.mergeMode},baseConfig=super.getConfig();return Object.assign(config,baseConfig),config}static fromConfig(cls,config){let rnnLayer=deserialize(config.layer);if(delete config.layer,config.numConstants!=null)throw new NotImplementedError("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let newConfig=config;return newConfig.layer=rnnLayer,new cls(newConfig)}};Bidirectional.className="Bidirectional";serialization_exports.registerClass(Bidirectional);var Callback=class extends BaseCallback{constructor(){super(...arguments);this.model=null}setModel(model2){if(!(model2 instanceof LayersModel))throw new Error("model must be a LayersModel, not some other Container");this.model=model2}};var DataType;(function(DataType2){DataType2[DataType2.DT_INVALID=0]="DT_INVALID",DataType2[DataType2.DT_FLOAT=1]="DT_FLOAT",DataType2[DataType2.DT_DOUBLE=2]="DT_DOUBLE",DataType2[DataType2.DT_INT32=3]="DT_INT32",DataType2[DataType2.DT_UINT8=4]="DT_UINT8",DataType2[DataType2.DT_INT16=5]="DT_INT16",DataType2[DataType2.DT_INT8=6]="DT_INT8",DataType2[DataType2.DT_STRING=7]="DT_STRING",DataType2[DataType2.DT_COMPLEX64=8]="DT_COMPLEX64",DataType2[DataType2.DT_INT64=9]="DT_INT64",DataType2[DataType2.DT_BOOL=10]="DT_BOOL",DataType2[DataType2.DT_QINT8=11]="DT_QINT8",DataType2[DataType2.DT_QUINT8=12]="DT_QUINT8",DataType2[DataType2.DT_QINT32=13]="DT_QINT32",DataType2[DataType2.DT_BFLOAT16=14]="DT_BFLOAT16",DataType2[DataType2.DT_FLOAT_REF=101]="DT_FLOAT_REF",DataType2[DataType2.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",DataType2[DataType2.DT_INT32_REF=103]="DT_INT32_REF",DataType2[DataType2.DT_UINT8_REF=104]="DT_UINT8_REF",DataType2[DataType2.DT_INT16_REF=105]="DT_INT16_REF",DataType2[DataType2.DT_INT8_REF=106]="DT_INT8_REF",DataType2[DataType2.DT_STRING_REF=107]="DT_STRING_REF",DataType2[DataType2.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",DataType2[DataType2.DT_INT64_REF=109]="DT_INT64_REF",DataType2[DataType2.DT_BOOL_REF=110]="DT_BOOL_REF",DataType2[DataType2.DT_QINT8_REF=111]="DT_QINT8_REF",DataType2[DataType2.DT_QUINT8_REF=112]="DT_QUINT8_REF",DataType2[DataType2.DT_QINT32_REF=113]="DT_QINT32_REF",DataType2[DataType2.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"})(DataType||(DataType={}));var SaverDef;(function(SaverDef2){let CheckpointFormatVersion;(function(CheckpointFormatVersion2){CheckpointFormatVersion2[CheckpointFormatVersion2.LEGACY=0]="LEGACY",CheckpointFormatVersion2[CheckpointFormatVersion2.V1=1]="V1",CheckpointFormatVersion2[CheckpointFormatVersion2.V2=2]="V2"})(CheckpointFormatVersion=SaverDef2.CheckpointFormatVersion||(SaverDef2.CheckpointFormatVersion={}))})(SaverDef||(SaverDef={}));var version6="2.7.0";var seedrandom3=__toModule(require_seedrandom4()),seedrandom2=__toModule(require_seedrandom4());function deepMap(input2,mapFn){return deepMapInternal(input2,mapFn)}function deepMapInternal(input2,mapFn,seen=new Map,containedIn=new Set){if(input2==null)return null;if(containedIn.has(input2))throw new Error("Circular references are not supported.");if(seen.has(input2))return seen.get(input2);let result=mapFn(input2);if(result.recurse&&result.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(result.recurse)if(isIterable2(input2)){let mappedIterable=Array.isArray(input2)?[]:{};containedIn.add(input2);for(let k in input2){let child=input2[k],childResult=deepMapInternal(child,mapFn,seen,containedIn);mappedIterable[k]=childResult}return containedIn.delete(input2),mappedIterable}else throw new Error(`Can't recurse into non-iterable type: ${input2}`);else return seen.set(input2,result.value),result.value}function deepZip(inputs,zipFn=zipToList){return deepZipInternal(inputs,zipFn)}function deepZipInternal(inputs,zipFn,containedIn=new Set){let input2=inputs[0];if(containedIn.has(input2))throw new Error("Circular references are not supported.");let result=zipFn(inputs);if(result.recurse&&result.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(result.recurse)if(isIterable2(input2)){let mappedIterable=Array.isArray(input2)?[]:{};containedIn.add(input2);for(let k in input2){let children=inputs.map(x=>x[k]),childResult=deepZipInternal(children,zipFn,containedIn);mappedIterable[k]=childResult}return containedIn.delete(input2),mappedIterable}else throw new Error(`Can't recurse into non-iterable type: ${input2}`);else return result.value}function zipToList(x){return x===null?null:isIterable2(x[0])?{value:null,recurse:!0}:{value:x,recurse:!1}}function isIterable2(obj){return obj!=null&&!ArrayBuffer.isView(obj)&&(Array.isArray(obj)||typeof obj=="object"&&!(obj instanceof Tensor))}function canTensorify(obj){return obj==null||isPrimitive(obj)||Array.isArray(obj)||typeof obj=="object"&&obj instanceof Tensor||util_exports.isTypedArray(obj)}function isPrimitive(value){return value===null||typeof value!="object"&&typeof value!="function"}function deepClone(container2){return deepMap(container2,cloneIfTensor)}function cloneIfTensor(item){return item instanceof Tensor?{value:item.clone(),recurse:!1}:isIterable2(item)?{value:null,recurse:!0}:{value:item,recurse:!1}}var RingBuffer=class{constructor(capacity){if(this.capacity=capacity,this.begin=0,this.end=0,capacity==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(capacity<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(capacity),this.doubledCapacity=2*capacity}wrap(index){for(;index<0;)index+=this.doubledCapacity;return index%this.doubledCapacity}get(index){if(index<0)throw new RangeError("Can't get item at a negative index.");return this.data[index%this.capacity]}set(index,value){if(index<0)throw new RangeError("Can't set item at a negative index.");this.data[index%this.capacity]=value}length(){let length=this.end-this.begin;return length<0&&(length=this.doubledCapacity+length),length}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(value){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,value),this.end=this.wrap(this.end+1)}pushAll(values){for(let value of values)this.push(value)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let result=this.get(this.end);return this.set(this.end,void 0),result}unshift(value){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,value)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let result=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),result}shuffleExcise(relativeIndex){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let index=this.wrap(this.begin+relativeIndex),result=this.get(index);return this.set(index,this.pop()),result}};var GrowingRingBuffer=class extends RingBuffer{constructor(){super(GrowingRingBuffer.INITIAL_CAPACITY)}isFull(){return!1}push(value){super.isFull()&&this.expand(),super.push(value)}unshift(value){super.isFull()&&this.expand(),super.unshift(value)}expand(){let newCapacity=this.capacity*2,newData=new Array(newCapacity),len=this.length();for(let i=0;i<len;i++)newData[i]=this.get(this.wrap(this.begin+i));this.data=newData,this.capacity=newCapacity,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=len}};GrowingRingBuffer.INITIAL_CAPACITY=32;function iteratorFromItems(items){return new ArrayIterator(items)}function iteratorFromFunction(func2){return new FunctionCallIterator(func2)}function iteratorFromConcatenated(baseIterators,baseErrorHandler){return new ChainedIterator(baseIterators,baseErrorHandler)}var LazyIterator=class{async toArray(){let result=[],x=await this.next();for(;!x.done;)result.push(x.value),x=await this.next();return result}async toArrayForTest(){let stream=this.prefetch(100),result=[],x=await stream.next();for(;!x.done;)result.push(x.value),x=await stream.next();return result}async resolveFully(){let x=await this.next();for(;!x.done;)x=await this.next()}async resolveWhile(predicate){let x=await this.next(),shouldContinue=predicate(x.value);for(;!x.done&&shouldContinue;)x=await this.next(),shouldContinue=predicate(x.value)}handleErrors(handler){return new ErrorHandlingLazyIterator(this,handler)}filter(predicate){return new FilterIterator(this,predicate)}map(transform){return new MapIterator(this,transform)}mapAsync(transform){return new AsyncMapIterator(this,transform)}serialMapAsync(transform){return new AsyncMapIterator(this,transform).serial()}flatmap(transform){return new FlatmapIterator(this,transform)}async forEachAsync(f){return this.map(f).resolveFully()}async serialForEach(f){return this.serialMapAsync(f).resolveWhile(x=>x===!0)}rowMajorBatch(batchSize,smallLastBatch=!0){return new RowMajorBatchIterator(this,batchSize,smallLastBatch)}columnMajorBatch(batchSize,smallLastBatch=!0,zipFn=zipToList){let rowBatches=this.rowMajorBatch(batchSize,smallLastBatch);return rowBatches.map(x=>deepZip(x,zipFn))}concatenate(iterator,baseErrorHandler){return new ChainedIterator(iteratorFromItems([this,iterator]),baseErrorHandler)}take(count2){return count2<0||count2==null?this:new TakeIterator(this,count2)}skip(count2){return count2<0||count2==null?this:new SkipIterator(this,count2)}prefetch(bufferSize){return new PrefetchIterator(this,bufferSize)}shuffle(windowSize,seed){return new ShuffleIterator(this,windowSize,seed)}serial(){return new SerialIterator(this)}},ArrayIterator=class extends LazyIterator{constructor(items){super();this.items=items,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let item=this.items[this.trav];return this.trav++,{value:deepClone(item),done:!1}}},FunctionCallIterator=class extends LazyIterator{constructor(nextFn){super();this.nextFn=nextFn}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},SerialIterator=class extends LazyIterator{constructor(upstream){super();this.upstream=upstream,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},SkipIterator=class extends LazyIterator{constructor(upstream,maxCount){super();this.upstream=upstream,this.maxCount=maxCount,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let skipped=await this.upstream.next();if(skipped.done)return skipped;dispose(skipped.value)}return this.upstream.next()}},TakeIterator=class extends LazyIterator{constructor(upstream,maxCount){super();this.upstream=upstream,this.maxCount=maxCount,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},RowMajorBatchIterator=class extends LazyIterator{constructor(upstream,batchSize,enableSmallLastBatch=!0){super();this.upstream=upstream,this.batchSize=batchSize,this.enableSmallLastBatch=enableSmallLastBatch,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let batch=[];for(;batch.length<this.batchSize;){let item=await this.upstream.next();if(item.done)return this.enableSmallLastBatch&&batch.length>0?{value:batch,done:!1}:{value:null,done:!0};batch.push(item.value)}return{value:batch,done:!1}}},FilterIterator=class extends LazyIterator{constructor(upstream,predicate){super();this.upstream=upstream,this.predicate=predicate,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let item=await this.upstream.next();if(item.done||this.predicate(item.value))return item;dispose(item.value)}}},MapIterator=class extends LazyIterator{constructor(upstream,transform){super();this.upstream=upstream,this.transform=transform}summary(){return`${this.upstream.summary()} -> Map`}async next(){let item=await this.upstream.next();if(item.done)return{value:null,done:!0};let inputTensors=tensor_util_exports.getTensorsInContainer(item.value),mapped=this.transform(item.value),outputTensors=tensor_util_exports.getTensorsInContainer(mapped);for(let t of inputTensors)tensor_util_exports.isTensorInList(t,outputTensors)||t.dispose();return{value:mapped,done:!1}}},ErrorHandlingLazyIterator=class extends LazyIterator{constructor(upstream,handler){super();this.upstream=upstream,this.handler=handler,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},AsyncMapIterator=class extends LazyIterator{constructor(upstream,transform){super();this.upstream=upstream,this.transform=transform}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let item=await this.upstream.next();if(item.done)return{value:null,done:!0};let inputTensors=tensor_util_exports.getTensorsInContainer(item.value),mapped=await this.transform(item.value),outputTensors=tensor_util_exports.getTensorsInContainer(mapped);for(let t of inputTensors)tensor_util_exports.isTensorInList(t,outputTensors)||t.dispose();return{value:mapped,done:!1}}},OneToManyIterator=class extends LazyIterator{constructor(){super();this.outputQueue=new GrowingRingBuffer,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},FlatmapIterator=class extends OneToManyIterator{constructor(upstream,transform){super();this.upstream=upstream,this.transform=transform}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let item=await this.upstream.next();if(item.done)return!1;let inputTensors=tensor_util_exports.getTensorsInContainer(item.value),mappedArray=this.transform(item.value),outputTensors=tensor_util_exports.getTensorsInContainer(mappedArray);this.outputQueue.pushAll(mappedArray);for(let t of inputTensors)tensor_util_exports.isTensorInList(t,outputTensors)||t.dispose();return!0}},ChainedIterator=class extends LazyIterator{constructor(iterators,baseErrorHandler){super();this.baseErrorHandler=baseErrorHandler,this.lastRead=null,this.iterator=null,this.moreIterators=iterators}summary(){let upstreamSummaries="TODO: fill in upstream of chained summaries";return`${upstreamSummaries} -> Chained`}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(lastRead){if(await lastRead,this.iterator==null){let iteratorResult=await this.moreIterators.next();if(iteratorResult.done)return{value:null,done:!0};this.iterator=iteratorResult.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let itemResult=await this.iterator.next();return itemResult.done?(this.iterator=null,this.readFromChain(lastRead)):itemResult}},ZipMismatchMode;(function(ZipMismatchMode2){ZipMismatchMode2[ZipMismatchMode2.FAIL=0]="FAIL",ZipMismatchMode2[ZipMismatchMode2.SHORTEST=1]="SHORTEST",ZipMismatchMode2[ZipMismatchMode2.LONGEST=2]="LONGEST"})(ZipMismatchMode||(ZipMismatchMode={}));var PrefetchIterator=class extends LazyIterator{constructor(upstream,bufferSize){super();this.upstream=upstream,this.bufferSize=bufferSize,this.buffer=new RingBuffer(bufferSize)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let v=this.upstream.next();this.buffer.push(v)}}next(){return this.refill(),this.buffer.shift()}},ShuffleIterator=class extends PrefetchIterator{constructor(upstream,windowSize,seed){super(upstream,windowSize);this.upstream=upstream,this.windowSize=windowSize,this.upstreamExhausted=!1,this.random=seedrandom2.alea(seed||util_exports.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(max9){return Math.floor(this.random()*max9)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let chosenIndex=this.chooseIndex(),result=await this.buffer.shuffleExcise(chosenIndex);if(result.done)this.upstreamExhausted=!0;else return this.refill(),result}return{value:null,done:!0}}};var Dataset=class{constructor(){this.size=null}batch(batchSize,smallLastBatch=!0){let base2=this;util_exports.assert(batchSize>0,()=>`batchSize needs to be positive, but it is
      ${batchSize}`);let size;return this.size===Infinity||this.size==null?size=this.size:smallLastBatch?size=Math.ceil(this.size/batchSize):size=Math.floor(this.size/batchSize),datasetFromIteratorFn(async()=>(await base2.iterator()).columnMajorBatch(batchSize,smallLastBatch,deepBatchConcat),size)}concatenate(dataset5){let base2=this,size;return this.size===Infinity||dataset5.size===Infinity?size=Infinity:this.size!=null&&dataset5.size!=null?size=this.size+dataset5.size:size=null,datasetFromIteratorFn(async()=>(await base2.iterator()).concatenate(await dataset5.iterator()),size)}filter(predicate){let base2=this,size;return this.size===Infinity?size=Infinity:size=null,datasetFromIteratorFn(async()=>(await base2.iterator()).filter(x=>tidy(()=>predicate(x))),size)}async forEachAsync(f){return(await this.iterator()).forEachAsync(f)}map(transform){let base2=this;return datasetFromIteratorFn(async()=>(await base2.iterator()).map(x=>tidy(()=>transform(x))),this.size)}mapAsync(transform){let base2=this;return datasetFromIteratorFn(async()=>(await base2.iterator()).mapAsync(transform),this.size)}prefetch(bufferSize){if(bufferSize==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let base2=this;return datasetFromIteratorFn(async()=>(await base2.iterator()).prefetch(bufferSize),this.size)}repeat(count2){let base2=this,size;return this.size!=null&&count2>0?size=this.size*count2:count2===0?size=0:this.size!=null&&(count2===void 0||count2<0)?size=Infinity:size=null,datasetFromIteratorFn(async()=>{let iteratorIterator=iteratorFromFunction(async()=>({value:await base2.iterator(),done:!1}));return iteratorFromConcatenated(iteratorIterator.take(count2))},size)}skip(count2){let base2=this,size;return this.size!=null&&count2>=0&&this.size>=count2?size=this.size-count2:this.size!=null&&(this.size<count2||count2===void 0||count2<0)?size=0:size=null,datasetFromIteratorFn(async()=>(await base2.iterator()).skip(count2),size)}shuffle(bufferSize,seed,reshuffleEachIteration=!0){if(bufferSize==null||bufferSize<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let base2=this,random=seedrandom3.alea(seed||util_exports.now().toString());return datasetFromIteratorFn(async()=>{let seed2=random.int32();return reshuffleEachIteration&&(seed2+=random.int32()),(await base2.iterator()).shuffle(bufferSize,seed2.toString())},this.size)}take(count2){let base2=this,size;return this.size!=null&&this.size>count2?size=count2:this.size!=null&&this.size<=count2?size=this.size:size=null,datasetFromIteratorFn(async()=>(await base2.iterator()).take(count2),size)}async toArray(){if(this.size===Infinity)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===Infinity)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};Dataset.MAX_BUFFER_SIZE=1e4;function datasetFromIteratorFn(iteratorFn,size=null){return new class extends Dataset{constructor(){super(...arguments);this.size=size}async iterator(){return iteratorFn()}}}function deepBatchConcat(rows){if(rows===null)return null;let exampleRow=rows[0];if(canTensorify(exampleRow)){let value=batchConcat(rows);return{value,recurse:!1}}return{value:null,recurse:!0}}function batchConcat(arrays){if(arrays.length===0)throw new Error("Can't make a batch of zero elements.");return arrays[0]instanceof Tensor?stack(arrays):tensor4(arrays)}var TextLineDataset=class extends Dataset{constructor(input2){super();this.input=input2}async iterator(){let inputIterator=await this.input.iterator(),utf8Iterator=inputIterator.decodeUTF8(),lineIterator=utf8Iterator.split(`
`).map(line=>(line.endsWith("\r")&&(line=line.slice(0,-1)),line));return lineIterator}};var CODE_QUOTE='"',STATE_OUT=Symbol("out"),STATE_FIELD=Symbol("field"),STATE_QUOTE=Symbol("quote"),STATE_QUOTE_AFTER_QUOTE=Symbol("quoteafterquote"),STATE_WITHIN_QUOTE_IN_QUOTE=Symbol("quoteinquote"),CSVDataset=class extends Dataset{constructor(input2,csvConfig){super();this.input=input2,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new TextLineDataset(input2),csvConfig||(csvConfig={}),this.hasHeader=!(csvConfig.hasHeader===!1),this.fullColumnNames=csvConfig.columnNames,this.columnConfigs=csvConfig.columnConfigs,this.configuredColumnsOnly=csvConfig.configuredColumnsOnly,csvConfig.delimWhitespace?(util_exports.assert(csvConfig.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=csvConfig.delimiter?csvConfig.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let columnNamesFromFile=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!columnNamesFromFile)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&columnNamesFromFile&&util_exports.assert(columnNamesFromFile.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+columnNamesFromFile.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=columnNamesFromFile);let counts=this.fullColumnNames.reduce((countAcc,name)=>(countAcc[name]=countAcc[name]+1||1,countAcc),{}),duplicateNames=Object.keys(counts).filter(name=>counts[name]>1);if(util_exports.assert(duplicateNames.length===0,()=>"Duplicate column names found: "+duplicateNames.toString()),this.columnConfigs)for(let key of Object.keys(this.columnConfigs)){let index=this.fullColumnNames.indexOf(key);if(index===-1)throw new Error('The key "'+key+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let iter=await this.base.iterator(),firstElement=await iter.next();if(firstElement.done)throw new Error("No data was found for CSV parsing.");let firstLine=firstElement.value,headers=this.parseRow(firstLine,!1);return headers}else return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let lines=await this.base.iterator();return this.hasHeader&&(lines=lines.skip(1)),lines.map(x=>this.makeDataElement(x))}makeDataElement(line){let values=this.parseRow(line),features={},labels={};for(let i=0;i<this.fullColumnNames.length;i++){let key=this.fullColumnNames[i],config=this.columnConfigs?this.columnConfigs[key]:null;if(this.configuredColumnsOnly&&!config)continue;{let value=values[i],parsedValue=null;if(value==="")if(config&&config.default!==void 0)parsedValue=config.default;else{if(config&&(config.required||config.isLabel))throw new Error(`Required column ${key} is empty in this line: ${line}`);parsedValue=void 0}else{let valueAsNum=Number(value);if(isNaN(valueAsNum))config&&config.dtype==="bool"?parsedValue=this.getBoolean(value):parsedValue=value;else if(!config||!config.dtype)parsedValue=valueAsNum;else switch(config.dtype){case"float32":parsedValue=valueAsNum;break;case"int32":parsedValue=Math.floor(valueAsNum);break;case"bool":parsedValue=this.getBoolean(value);break;default:parsedValue=valueAsNum}}config&&config.isLabel?labels[key]=parsedValue:features[key]=parsedValue}}return Object.keys(labels).length===0?features:{xs:features,ys:labels}}getBoolean(value){return value==="1"||value.toLowerCase()==="true"?1:0}parseRow(line,validateElementCount=!0){let result=[],readOffset=0,readLength=line.length,currentState=STATE_OUT;for(let i=0;i<readLength;i++)switch(currentState){case STATE_OUT:switch(line.charAt(i)){case CODE_QUOTE:readOffset=i+1,currentState=STATE_QUOTE;break;case this.delimiter:if(readOffset=i+1,this.delimiter===" "&&this.delimWhitespace)break;result.push(""),currentState=STATE_OUT;break;default:currentState=STATE_FIELD,readOffset=i;break}break;case STATE_FIELD:switch(line.charAt(i)){case this.delimiter:result.push(line.substring(readOffset,i)),currentState=STATE_OUT,readOffset=i+1;break;default:}break;case STATE_QUOTE:switch(line.charAt(i)){case CODE_QUOTE:currentState=STATE_QUOTE_AFTER_QUOTE;break;default:}break;case STATE_QUOTE_AFTER_QUOTE:switch(line.charAt(i)){case this.delimiter:result.push(line.substring(readOffset,i-1)),currentState=STATE_OUT,readOffset=i+1;break;case CODE_QUOTE:currentState=STATE_QUOTE;break;default:currentState=STATE_WITHIN_QUOTE_IN_QUOTE;break}break;case STATE_WITHIN_QUOTE_IN_QUOTE:switch(line.charAt(i)){case CODE_QUOTE:currentState=STATE_QUOTE;break;default:}break;default:}if(currentState===STATE_QUOTE_AFTER_QUOTE?result.push(line.substring(readOffset,readLength-1)):result.push(line.substring(readOffset)),validateElementCount&&result.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${result}`);return result}};var MicrophoneIterator=class extends LazyIterator{constructor(microphoneConfig){super();this.microphoneConfig=microphoneConfig,this.isClosed=!1,this.fftSize=microphoneConfig.fftSize||1024;let fftSizeLog2=Math.log2(this.fftSize);if(this.fftSize<0||fftSizeLog2<4||fftSizeLog2>14||!Number.isInteger(fftSizeLog2))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=microphoneConfig.numFramesPerSpectrogram||43,this.sampleRateHz=microphoneConfig.sampleRateHz,this.columnTruncateLength=microphoneConfig.columnTruncateLength||this.fftSize,this.audioTrackConstraints=microphoneConfig.audioTrackConstraints,this.smoothingTimeConstant=microphoneConfig.smoothingTimeConstant||0,this.includeSpectrogram=!(microphoneConfig.includeSpectrogram===!1),this.includeWaveform=microphoneConfig.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(microphoneConfig={}){if(env().get("IS_NODE"))throw new Error("microphone API is only supported in browser environment.");let microphoneIterator=new MicrophoneIterator(microphoneConfig);return await microphoneIterator.start(),microphoneIterator}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(e){throw new Error(`Error thrown while initializing video stream: ${e.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let ctxConstructor=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new ctxConstructor,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let streamSource=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,streamSource.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize);return}async next(){if(this.isClosed)return{value:null,done:!0};let spectrogramTensor,waveformTensor,audioDataQueue=await this.getAudioData();if(this.includeSpectrogram){let freqData=this.flattenQueue(audioDataQueue.freqDataQueue);spectrogramTensor=this.getTensorFromAudioDataArray(freqData,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let timeData=this.flattenQueue(audioDataQueue.timeDataQueue);waveformTensor=this.getTensorFromAudioDataArray(timeData,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:spectrogramTensor,waveform:waveformTensor},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let freqDataQueue=[],timeDataQueue=[],currentFrames=0;return new Promise(resolve=>{let intervalID=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-Infinity&&resolve({freqDataQueue,timeDataQueue}),freqDataQueue.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),timeDataQueue.push(this.timeData.slice())),++currentFrames===this.numFrames&&(clearInterval(intervalID),resolve({freqDataQueue,timeDataQueue}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(queue){let frameSize=queue[0].length,freqData=new Float32Array(queue.length*frameSize);return queue.forEach((data,i)=>freqData.set(data,i*frameSize)),freqData}getTensorFromAudioDataArray(freqData,shape){let vals=new Float32Array(util_exports.sizeFromShape(shape));return vals.set(freqData,vals.length-freqData.length),tensor4(vals,shape)}};var WebcamIterator=class extends LazyIterator{constructor(webcamVideoElement,webcamConfig){super();if(this.webcamVideoElement=webcamVideoElement,this.webcamConfig=webcamConfig,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=tensor1d([0],"int32"),this.webcamConfig.centerCrop){let widthCroppingRatio=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,heightCroppingRatio=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,widthCropStart=(1-widthCroppingRatio)/2,heightCropStart=(1-heightCroppingRatio)/2,widthCropEnd=widthCropStart+widthCroppingRatio,heightCropEnd=heightCroppingRatio+heightCropStart;this.cropBox=tensor2d([heightCropStart,widthCropStart,heightCropEnd,widthCropEnd],[1,4])}else this.cropBox=tensor2d([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(webcamVideoElement,webcamConfig={}){if(env().get("IS_NODE"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!webcamVideoElement){if(webcamVideoElement=document.createElement("video"),!webcamConfig.resizeWidth||!webcamConfig.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");webcamVideoElement.width=webcamConfig.resizeWidth,webcamVideoElement.height=webcamConfig.resizeHeight}let webcamIterator=new WebcamIterator(webcamVideoElement,webcamConfig);return await webcamIterator.start(),webcamIterator}async start(){this.webcamConfig.facingMode&&util_exports.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(error){console.log(error),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(resolve=>{this.webcamVideoElement.onloadedmetadata=()=>{resolve()}})}async next(){if(this.isClosed)return{value:null,done:!0};let img;try{img=browser_exports.fromPixels(this.webcamVideoElement)}catch(e){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(img),done:!1}}catch(e){throw new Error(`Error thrown cropping the video: ${e.message}`)}finally{img.dispose()}else return{value:img,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(img){return tidy(()=>{let expandedImage=img.toFloat().expandDims(0),resizedImage;resizedImage=image.cropAndResize(expandedImage,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let shape=resizedImage.shape;return resizedImage.reshape(shape.slice(1))})}async capture(){return(await this.next()).value}stop(){let tracks=this.stream.getTracks();tracks.forEach(track=>track.stop());try{this.webcamVideoElement.srcObject=null}catch(error){console.log(error),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}};var DataSource=class{};var StringIterator=class extends LazyIterator{split(separator){return new SplitIterator(this,separator)}},SplitIterator=class extends StringIterator{constructor(upstream,separator){super();this.upstream=upstream,this.impl=new SplitIteratorImpl(upstream,separator)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},SplitIteratorImpl=class extends OneToManyIterator{constructor(upstream,separator){super();this.upstream=upstream,this.separator=separator,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let chunkResult=await this.upstream.next();if(chunkResult.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let lines=chunkResult.value.split(this.separator);lines[0]=this.carryover+lines[0];for(let line of lines.slice(0,-1))this.outputQueue.push(line);return this.carryover=lines[lines.length-1],!0}};var ByteChunkIterator=class extends LazyIterator{decodeUTF8(){return new Utf8Iterator(this)}},Utf8Iterator=class extends StringIterator{constructor(upstream){super();this.upstream=upstream,this.impl=new Utf8IteratorImpl(upstream)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},Utf8IteratorImpl=class extends OneToManyIterator{constructor(upstream){super();if(this.upstream=upstream,env().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder}=require_string_decoder();this.decoder=new StringDecoder("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let chunkResult=await this.upstream.next(),chunk;if(chunkResult.done)return!1;chunk=chunkResult.value;let text;return env().get("IS_BROWSER")?text=this.decoder.decode(chunk,{stream:!0}):text=this.decoder.write(Buffer.from(chunk.buffer)),this.outputQueue.push(text),!0}};var FileChunkIterator=class extends ByteChunkIterator{constructor(file,options={}){super();this.file=file,this.options=options,util_exports.assert(file instanceof Uint8Array||(env().get("IS_BROWSER")?file instanceof File||file instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=options.offset||0,this.chunkSize=options.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){if(this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size))return{value:null,done:!0};let chunk=new Promise((resolve,reject)=>{let end=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)resolve(new Uint8Array(this.file.slice(this.offset,end)));else{let fileReader=new FileReader;fileReader.onload=event=>{let data=fileReader.result;if(data instanceof ArrayBuffer&&(data=new Uint8Array(data)),!(data instanceof Uint8Array))return reject(new TypeError("FileReader returned unknown type."));resolve(data)},fileReader.onabort=event=>reject(new Error("Aborted")),fileReader.onerror=event=>reject(new Error(event.type));let slice19=this.file.slice(this.offset,end);fileReader.readAsArrayBuffer(slice19)}this.offset=end});return{value:await chunk,done:!1}}};async function urlChunkIterator(url,options={}){let urlString,requestInit;typeof url=="string"?urlString=url:(urlString=url.url,requestInit=getRequestInitFromRequest(url));let response=await util_exports.fetch(urlString,requestInit);if(response.ok){let uint8Array=new Uint8Array(await response.arrayBuffer());return new FileChunkIterator(uint8Array,options)}else throw new Error(response.statusText)}var getRequestInitFromRequest=request=>{let init={method:request.method,headers:request.headers,body:request.body,mode:request.mode,credentials:request.credentials,cache:request.cache,redirect:request.redirect,referrer:request.referrer,integrity:request.integrity};return init};function isLocalPath(source){return typeof source=="string"&&source.substr(0,7)==="file://"}var FileDataSource=class extends DataSource{constructor(input2,options={}){super();this.input=input2,this.options=options}async iterator(){if(isLocalPath(this.input)&&env().get("IS_NODE")){let fs=require("fs");this.input=fs.readFileSync(this.input.substr(7))}return new FileChunkIterator(this.input,this.options)}};var URLDataSource=class extends DataSource{constructor(url,fileOptions={}){super();this.url=url,this.fileOptions=fileOptions}async iterator(){return isLocalPath(this.url)?new FileDataSource(this.url,this.fileOptions).iterator():urlChunkIterator(this.url,this.fileOptions)}};var version8="2.7.0";var seedrandom4=__toModule(require_seedrandom6());function assertNotComplex(tensor166,opName){Array.isArray(tensor166)||(tensor166=[tensor166]),tensor166.forEach(t=>{t!=null&&util_exports.assert(t.dtype!=="complex64",()=>`${opName} does not support complex64 tensors in the CPU backend.`)})}var nonMaxSuppressionV3Impl2=kernel_impls_exports.nonMaxSuppressionV3Impl,split10=kernel_impls_exports.split,tile9=kernel_impls_exports.tile,topkImpl2=kernel_impls_exports.topkImpl,whereImpl2=kernel_impls_exports.whereImpl,MathBackendCPU=class extends KernelBackend{constructor(){super();this.blockSize=48,this.firstUse=!0,this.data=new DataStorage(this,engine14())}write(values,shape,dtype){this.firstUse&&(this.firstUse=!1,env().get("IS_NODE")&&backend_util_exports.warn(`
============================
Hi there \u{1F44B}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.
============================`));let dataId={};return this.data.set(dataId,{values,dtype,refCount:1}),dataId}makeTensorInfo(shape,dtype,values){let outId;if(dtype==="string"&&values!=null&&values.length>0&&util_exports.isString(values[0])){let encodedValues=values.map(d=>util_exports.encodeString(d));outId=this.write(encodedValues,shape,dtype)}else outId=this.write(values,shape,dtype);return{dataId:outId,shape,dtype}}incRef(dataId){let tensorData=this.data.get(dataId);tensorData.refCount++}decRef(dataId){if(this.data.has(dataId)){let tensorData=this.data.get(dataId);tensorData.refCount--}}move(dataId,values,shape,dtype){this.data.set(dataId,{values,dtype,refCount:1})}numDataIds(){return this.data.numDataIds()}async read(dataId){return this.readSync(dataId)}readSync(dataId){let{dtype,complexTensorInfos}=this.data.get(dataId);if(dtype==="complex64"){let realValues=this.readSync(complexTensorInfos.real.dataId),imagValues=this.readSync(complexTensorInfos.imag.dataId);return backend_util_exports.mergeRealAndImagArrays(realValues,imagValues)}return this.data.get(dataId).values}bufferSync(t){let data=this.readSync(t.dataId),decodedData=data;if(t.dtype==="string")try{decodedData=data.map(d=>util_exports.decodeString(d))}catch(_a){throw new Error("Failed to decode encoded string bytes into utf-8")}return buffer(t.shape,t.dtype,decodedData)}makeOutput(values,shape,dtype){let dataId=this.write(values,shape,dtype);return engine14().makeTensorFromDataId(dataId,shape,dtype,this)}disposeData(dataId){if(this.data.has(dataId)){let{complexTensorInfos}=this.data.get(dataId);complexTensorInfos!=null&&(this.disposeData(complexTensorInfos.real.dataId),this.disposeData(complexTensorInfos.imag.dataId)),this.data.delete(dataId)}}disposeIntermediateTensorInfo(tensorInfo){let dataId=tensorInfo.dataId;if(this.data.has(dataId)){let tensorData=this.data.get(dataId);tensorData.refCount--,tensorData.refCount<1&&this.disposeData(dataId)}}async time(f){let start=util_exports.now();f();let kernelMs=util_exports.now()-start;return{kernelMs}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}stridedSlice(x,begin,end,strides){assertNotComplex(x,"stridedSlice");let outShape=slice_util_exports.computeOutShape(begin,end,strides);if(outShape.some(axis=>axis===0))return tensor4([],outShape);let buffer10=buffer(outShape,x.dtype),xBuf=this.bufferSync(x);for(let i=0;i<buffer10.size;i++){let loc=buffer10.indexToLoc(i),newLoc=new Array(loc.length);for(let j=0;j<newLoc.length;j++)newLoc[j]=loc[j]*strides[j]+begin[j];buffer10.set(xBuf.get(...newLoc),...loc)}return buffer10.toTensor()}diag(x){let xVals=this.readSync(x.dataId),buffer10=buffer([x.size,x.size],x.dtype),vals=buffer10.values;for(let i=0;i<xVals.length;i++)vals[i*x.size+i]=xVals[i];return buffer10.toTensor()}unstack(x,axis){let num=x.shape[axis],outShape=new Array(x.rank-1),outIndex=0;for(let i=0;i<x.rank;i++)i!==axis&&(outShape[outIndex++]=x.shape[i]);let begin=new Array(x.rank).fill(0),size=x.shape.slice();size[axis]=1;let res=new Array(num);for(let i=0;i<res.length;i++)begin[axis]=i,res[i]=slice(x,begin,size).reshape(outShape);return res}reverse(x,axis){assertNotComplex(x,"reverse");let buffer10=buffer(x.shape,x.dtype),xBuf=this.bufferSync(x);for(let i=0;i<buffer10.size;i++){let outLoc=buffer10.indexToLoc(i),inLoc=outLoc.slice();axis.forEach(ax=>inLoc[ax]=x.shape[ax]-1-inLoc[ax]),buffer10.set(xBuf.get(...inLoc),...outLoc)}return buffer10.toTensor()}neg(x){return assertNotComplex(x,"neg"),mul(scalar(-1),x)}addN(tensors){assertNotComplex(tensors,"addN");let vals=tensors.map(t=>this.readSync(t.dataId)),result=buffer(tensors[0].shape,tensors[0].dtype),resultVals=result.values;for(let i=0;i<tensors.length;i++){let currVals=vals[i];for(let j=0;j<resultVals.length;j++)resultVals[j]+=currVals[j]}return result.toTensor()}softmax(logits,dim){let axes=util_exports.parseAxisParam([dim],logits.shape),maxLogit=max(logits,axes),expandedShape=backend_util_exports.expandShapeToKeepDim(maxLogit.shape,axes),a=sub(logits,maxLogit.reshape(expandedShape)),b=exp(a),sumExp=this.sum(b,axes).reshape(expandedShape);return div(b,sumExp)}pow(a,b){return assertNotComplex([a,b],"pow"),this.broadcastedBinaryOp(a,b,a.dtype,(aValue,bValue)=>Math.pow(aValue,bValue))}floorDiv(a,b){assertNotComplex([a,b],"floorDiv");let op2=(a6,b2)=>Math.floor(a6/b2),outputDtype="int32";return this.broadcastedBinaryOp(a,b,outputDtype,op2)}sum(x,axes){assertNotComplex(x,"sum"),backend_util_exports.assertAxesAreInnerMostDims("sum",axes,x.rank);let[outShape,reduceShape]=backend_util_exports.computeOutAndReduceShapes(x.shape,axes),resultDtype=upcastType(x.dtype,"int32"),result=zeros(outShape,resultDtype),reduceSize=util_exports.sizeFromShape(reduceShape),vals=this.readSync(result.dataId),aVals=this.readSync(x.dataId);for(let i=0;i<vals.length;++i){let offset=i*reduceSize,sum28=0;for(let j=0;j<reduceSize;++j)sum28+=aVals[offset+j];vals[i]=sum28}return result}prod(x,axes){assertNotComplex(x,"sum");let[outShape,reduceShape]=backend_util_exports.computeOutAndReduceShapes(x.shape,axes),resultDtype=upcastType(x.dtype,"int32"),result=zeros(outShape,resultDtype),reduceSize=util_exports.sizeFromShape(reduceShape),vals=this.readSync(result.dataId),aVals=this.readSync(x.dataId);for(let i=0;i<vals.length;++i){let offset=i*reduceSize,prod5=1;for(let j=0;j<reduceSize;++j)prod5*=aVals[offset+j];vals[i]=prod5}return result}unsortedSegmentSum(x,segmentIds,numSegments){assertNotComplex(x,"unsortedSegmentSum");let res=[],numIters=x.rank-segmentIds.rank;for(let i=0;i<numIters;++i)segmentIds=segmentIds.expandDims(i+1);for(let i=0;i<numSegments;++i){let segmentId=scalar(i,"int32"),mask=equal(segmentId,segmentIds).asType("float32"),sum28=mask.mul(x).sum(0);res.push(sum28)}return stack(res)}argMin(x,axis){assertNotComplex(x,"argMin");let axes=[axis];backend_util_exports.assertAxesAreInnerMostDims("argMin",axes,x.rank);let[outShape,reduceShape]=backend_util_exports.computeOutAndReduceShapes(x.shape,axes),result=zeros(outShape,"int32"),reduceSize=util_exports.sizeFromShape(reduceShape),vals=this.readSync(result.dataId),aVals=this.readSync(x.dataId);for(let i=0;i<vals.length;++i){let offset=i*reduceSize,min7=aVals[offset],minIndex=0;for(let j=0;j<reduceSize;++j){let value=aVals[offset+j];value<min7&&(min7=value,minIndex=j)}vals[i]=minIndex}return result}argMax(x,axis){assertNotComplex(x,"argMax");let axes=[axis];backend_util_exports.assertAxesAreInnerMostDims("argMax",axes,x.rank);let[outShape,reduceShape]=backend_util_exports.computeOutAndReduceShapes(x.shape,axes),result=zeros(outShape,"int32"),reduceSize=util_exports.sizeFromShape(reduceShape),vals=this.readSync(result.dataId),aVals=this.readSync(x.dataId);for(let i=0;i<vals.length;++i){let offset=i*reduceSize,max9=aVals[offset],maxIndex=0;for(let j=0;j<reduceSize;++j){let value=aVals[offset+j];value>max9&&(max9=value,maxIndex=j)}vals[i]=maxIndex}return result}cumsum(x,axis,exclusive,reverse7){if(assertNotComplex(x,"cumsum"),axis!==x.rank-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${x.rank-1} but got axis=${axis}`);let resultDtype=upcastType(x.dtype,"int32"),result=zeros(x.shape,resultDtype),vals=this.readSync(result.dataId),aVals=this.readSync(x.dataId),finalDim=x.shape[x.rank-1],indexAdjuster=reverse7?(i,j)=>i+finalDim-j-1:(i,j)=>i+j;for(let i=0;i<aVals.length;i+=finalDim)for(let j=0;j<finalDim;j++){let idx=indexAdjuster(i,j);if(j===0)vals[idx]=exclusive?0:aVals[idx];else{let prevIdx=indexAdjuster(i,j-1);vals[idx]=exclusive?aVals[prevIdx]+vals[prevIdx]:aVals[idx]+vals[prevIdx]}}return result}equal(a,b){return assertNotComplex([a,b],"equal"),this.broadcastedBinaryOp(a,b,"bool",(aVal,bVal)=>aVal===bVal?1:0)}notEqual(a,b){return assertNotComplex([a,b],"notEqual"),this.broadcastedBinaryOp(a,b,"bool",(aVal,bVal)=>aVal!==bVal?1:0)}less(a,b){return assertNotComplex([a,b],"less"),this.broadcastedBinaryOp(a,b,"bool",(aVal,bVal)=>aVal<bVal?1:0)}lessEqual(a,b){return assertNotComplex([a,b],"lessEqual"),this.broadcastedBinaryOp(a,b,"bool",(aVal,bVal)=>aVal<=bVal?1:0)}greater(a,b){return assertNotComplex([a,b],"greater"),this.broadcastedBinaryOp(a,b,"bool",(aVal,bVal)=>aVal>bVal?1:0)}greaterEqual(a,b){return assertNotComplex([a,b],"greaterEqual"),this.broadcastedBinaryOp(a,b,"bool",(aVal,bVal)=>aVal>=bVal?1:0)}logicalAnd(a,b){return assertNotComplex([a,b],"logicalAnd"),this.broadcastedBinaryOp(a,b,"bool",(aVal,bVal)=>aVal&&bVal)}logicalOr(a,b){return assertNotComplex([a,b],"logicalOr"),this.broadcastedBinaryOp(a,b,"bool",(aVal,bVal)=>aVal||bVal)}select(condition,a,b){assertNotComplex([condition,a,b],"select");let values=this.readSync(condition.dataId),aValues=this.readSync(a.dataId),bValues=this.readSync(b.dataId),result=zeros(a.shape,upcastType(a.dtype,b.dtype)),newValues=this.readSync(result.dataId),index=0,offset=condition.rank===0||condition.rank>1||a.rank===1?1:util_exports.sizeFromShape(a.shape.slice(1));for(let i=0;i<values.length;i++)for(let j=0;j<offset;j++)values[i]===1?newValues[index++]=aValues[i]:newValues[index++]=bValues[i];return result}where(condition){assertNotComplex([condition],"where");let condVals=this.readSync(condition.dataId);return whereImpl2(condition.shape,condVals)}topk(x,k,sorted){assertNotComplex(x,"topk");let xVals=this.readSync(x.dataId);return topkImpl2(xVals,x.shape,x.dtype,k,sorted)}min(x,axes){assertNotComplex(x,"min"),backend_util_exports.assertAxesAreInnerMostDims("min",axes,x.rank);let[outShape,reduceShape]=backend_util_exports.computeOutAndReduceShapes(x.shape,axes),result=zeros(outShape,x.dtype),reduceSize=util_exports.sizeFromShape(reduceShape),vals=this.readSync(result.dataId),aVals=this.readSync(x.dataId);for(let i=0;i<vals.length;++i){let offset=i*reduceSize,min7=aVals[offset];for(let j=0;j<reduceSize;++j){let value=aVals[offset+j];value<min7&&(min7=value)}vals[i]=min7}return result}minimum(a,b){return assertNotComplex([a,b],"minimum"),this.broadcastedBinaryOp(a,b,a.dtype,(aVal,bVal)=>Math.min(aVal,bVal))}mod(a,b){return assertNotComplex([a,b],"mod"),this.broadcastedBinaryOp(a,b,a.dtype,(aVal,bVal)=>{let rem=aVal%bVal;return aVal<0&&bVal<0||aVal>=0&&bVal>=0?rem:(rem+bVal)%bVal})}maximum(a,b){return assertNotComplex([a,b],"maximum"),this.broadcastedBinaryOp(a,b,a.dtype,(aVal,bVal)=>Math.max(aVal,bVal))}all(x,axes){assertNotComplex(x,"all"),backend_util_exports.assertAxesAreInnerMostDims("all",axes,x.rank);let[outShape,reduceShape]=backend_util_exports.computeOutAndReduceShapes(x.shape,axes),result=zeros(outShape,x.dtype),reduceSize=util_exports.sizeFromShape(reduceShape),vals=this.readSync(result.dataId),aVals=this.readSync(x.dataId);for(let i=0;i<vals.length;++i){let offset=i*reduceSize,all5=aVals[offset];for(let j=0;j<reduceSize;++j){let value=aVals[offset+j];all5=all5&&value}vals[i]=all5}return result}any(x,axes){assertNotComplex(x,"any"),backend_util_exports.assertAxesAreInnerMostDims("any",axes,x.rank);let[outShape,reduceShape]=backend_util_exports.computeOutAndReduceShapes(x.shape,axes),result=zeros(outShape,x.dtype),reduceSize=util_exports.sizeFromShape(reduceShape),vals=this.readSync(result.dataId),aVals=this.readSync(x.dataId);for(let i=0;i<vals.length;++i){let offset=i*reduceSize,anyVal=aVals[offset];for(let j=0;j<reduceSize;++j){let value=aVals[offset+j];anyVal=anyVal||value}vals[i]=anyVal}return result}squaredDifference(a,b){return assertNotComplex([a,b],"squaredDifference"),this.broadcastedBinaryOp(a,b,a.dtype,(aVal,bVal)=>{let diff=aVal-bVal;return diff*diff})}eluDer(dy,y){assertNotComplex([dy,y],"eluDer");let resultValues=new Float32Array(y.size),values=this.readSync(y.dataId),dyValues=this.readSync(dy.dataId);for(let i=0;i<values.length;++i){let v=values[i];v>=1?resultValues[i]=dyValues[i]:resultValues[i]=dyValues[i]*(v+1)}return this.makeOutput(resultValues,y.shape,"float32")}atan2(a,b){return assertNotComplex([a,b],"atan2"),this.broadcastedBinaryOp(a,b,a.dtype,(aValue,bValue)=>Math.atan2(aValue,bValue))}tile(x,reps){return assertNotComplex(x,"tile"),tile9(this.bufferSync(x),reps)}gather(x,indices,axis){assertNotComplex([x,indices],"gather");let newShape=x.shape.slice(),indicesValues=this.readSync(indices.dataId);newShape[axis]=indicesValues.length;let result=buffer(newShape,x.dtype),xBuf=this.bufferSync(x);for(let i=0;i<result.size;++i){let newLoc=result.indexToLoc(i),originalLoc=newLoc.slice();originalLoc[axis]=indicesValues[newLoc[axis]];let originalIndex=xBuf.locToIndex(originalLoc);result.values[i]=xBuf.values[originalIndex]}return result.toTensor()}batchToSpaceND(x,blockShape,crops){assertNotComplex([x],"batchToSpaceND");let prod5=blockShape.reduce((a,b)=>a*b),reshaped=backend_util_exports.getReshaped(x.shape,blockShape,prod5),permuted=backend_util_exports.getPermuted(reshaped.length,blockShape.length),reshapedPermuted=backend_util_exports.getReshapedPermuted(x.shape,blockShape,prod5),sliceBeginCoords=backend_util_exports.getSliceBeginCoords(crops,blockShape.length),sliceSize=backend_util_exports.getSliceSize(reshapedPermuted,crops,blockShape.length);return transpose(x.reshape(reshaped),permuted).reshape(reshapedPermuted).slice(sliceBeginCoords,sliceSize)}pool3d(x,convInfo,poolType){assertNotComplex(x,"pool3d");let strideDepth=convInfo.strideDepth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationDepth=convInfo.dilationDepth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterDepth=convInfo.effectiveFilterDepth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padFront=convInfo.padInfo.front,padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left,initialValue=poolType==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,xValues=this.readSync(x.dataId),output=buffer(convInfo.outShape,x.dtype),outputVals=output.values,outputBatchStrides=convInfo.outShape[1]*convInfo.outShape[2]*convInfo.outShape[3]*convInfo.outShape[4],outputDepthStrides=convInfo.outShape[2]*convInfo.outShape[3]*convInfo.outShape[4],outputRowStrides=convInfo.outShape[3]*convInfo.outShape[4],outputColStrides=convInfo.outShape[4];for(let batch=0;batch<convInfo.batchSize;++batch){let outputBatchOffset=batch*outputBatchStrides,inputBatchOffset=batch*x.strides[0];for(let channel=0;channel<convInfo.inChannels;++channel)for(let yDepth=0;yDepth<convInfo.outDepth;++yDepth){let xDepthCorner=yDepth*strideDepth-padFront,xDepthMin=xDepthCorner;for(;xDepthMin<0;)xDepthMin+=dilationDepth;let xDepthMax=Math.min(convInfo.inDepth,effectiveFilterDepth+xDepthCorner),outputDepthOffset=outputBatchOffset+yDepth*outputDepthStrides;for(let yRow=0;yRow<convInfo.outHeight;++yRow){let xRowCorner=yRow*strideHeight-padTop,xRowMin=xRowCorner;for(;xRowMin<0;)xRowMin+=dilationHeight;let xRowMax=Math.min(convInfo.inHeight,effectiveFilterHeight+xRowCorner),outputRowOffset=outputDepthOffset+yRow*outputRowStrides;for(let yCol=0;yCol<convInfo.outWidth;++yCol){let xColCorner=yCol*strideWidth-padLeft,xColMin=xColCorner;for(;xColMin<0;)xColMin+=dilationWidth;let xColMax=Math.min(convInfo.inWidth,effectiveFilterWidth+xColCorner),outputColOffset=outputRowOffset+yCol*outputColStrides,minMaxValue=initialValue,avgValue=0,count2=0;for(let xDepth=xDepthMin;xDepth<xDepthMax;xDepth+=dilationDepth){let xDepthOffset=inputBatchOffset+xDepth*x.strides[1];for(let xRow=xRowMin;xRow<xRowMax;xRow+=dilationHeight){let xRowOffset=xDepthOffset+xRow*x.strides[2];for(let xCol=xColMin;xCol<xColMax;xCol+=dilationWidth){let xColOffset=xRowOffset+xCol*x.strides[3],pixel=xValues[xColOffset+channel];if(poolType==="max"&&pixel>minMaxValue?minMaxValue=pixel:poolType==="avg"&&(avgValue+=pixel,count2++),isNaN(minMaxValue))break}if(isNaN(minMaxValue))break}if(isNaN(minMaxValue))break}let outputOffset=outputColOffset+channel;outputVals[outputOffset]=poolType==="avg"?avgValue/count2:minMaxValue}}}}return output.toTensor()}avgPool3d(x,convInfo){return assertNotComplex(x,"avgPool3d"),this.pool3d(x,convInfo,"avg").toFloat()}avgPool3dBackprop(dy,x,convInfo){assertNotComplex([dy,x],"avgPool3dBackprop");let strideDepth=convInfo.strideDepth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,filterDepth=convInfo.filterDepth,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,dilationDepth=convInfo.dilationDepth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterDepth=convInfo.effectiveFilterDepth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padFront=effectiveFilterDepth-1-convInfo.padInfo.front,padLeft=effectiveFilterWidth-1-convInfo.padInfo.left,padTop=effectiveFilterHeight-1-convInfo.padInfo.top,dx=buffer(x.shape,"float32"),avgMultiplier=1/(filterDepth*filterHeight*filterWidth),dyBuf=this.bufferSync(dy);for(let batch=0;batch<convInfo.batchSize;++batch)for(let channel=0;channel<convInfo.inChannels;++channel)for(let dxDepth=0;dxDepth<convInfo.inDepth;++dxDepth)for(let dxRow=0;dxRow<convInfo.inHeight;++dxRow)for(let dxCol=0;dxCol<convInfo.inWidth;++dxCol){let dyDepthCorner=dxDepth-padFront,dyRowCorner=dxRow-padTop,dyColCorner=dxCol-padLeft,dotProd=0;for(let wDepth=0;wDepth<effectiveFilterDepth;wDepth+=dilationDepth){let dyDepth=(dyDepthCorner+wDepth)/strideDepth;if(dyDepth<0||dyDepth>=convInfo.outDepth||Math.floor(dyDepth)!==dyDepth)continue;for(let wRow=0;wRow<effectiveFilterHeight;wRow+=dilationHeight){let dyRow=(dyRowCorner+wRow)/strideHeight;if(dyRow<0||dyRow>=convInfo.outHeight||Math.floor(dyRow)!==dyRow)continue;for(let wCol=0;wCol<effectiveFilterWidth;wCol+=dilationWidth){let dyCol=(dyColCorner+wCol)/strideWidth;if(dyCol<0||dyCol>=convInfo.outWidth||Math.floor(dyCol)!==dyCol)continue;let pixel=dyBuf.get(batch,dyDepth,dyRow,dyCol,channel);dotProd+=pixel}}}dx.set(dotProd*avgMultiplier,batch,dxDepth,dxRow,dxCol,channel)}return dx.toTensor()}maxPool3d(x,convInfo){return assertNotComplex(x,"maxPool3d"),this.pool3d(x,convInfo,"max").toFloat()}maxPool3dPositions(x,convInfo){let maxPositions=buffer(convInfo.outShape,"int32"),strideDepth=convInfo.strideDepth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationDepth=convInfo.dilationDepth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterDepth=convInfo.effectiveFilterDepth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padFront=convInfo.padInfo.front,padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left,xBuf=this.bufferSync(x);for(let batch=0;batch<convInfo.batchSize;++batch)for(let channel=0;channel<convInfo.inChannels;++channel)for(let yDepth=0;yDepth<convInfo.outDepth;++yDepth){let xDepthCorner=yDepth*strideDepth-padFront,xDepthMin=xDepthCorner;for(;xDepthMin<0;)xDepthMin+=dilationDepth;let xDepthMax=Math.min(convInfo.inDepth,effectiveFilterDepth+xDepthCorner);for(let yRow=0;yRow<convInfo.outHeight;++yRow){let xRowCorner=yRow*strideHeight-padTop,xRowMin=xRowCorner;for(;xRowMin<0;)xRowMin+=dilationHeight;let xRowMax=Math.min(convInfo.inHeight,effectiveFilterHeight+xRowCorner);for(let yCol=0;yCol<convInfo.outWidth;++yCol){let xColCorner=yCol*strideWidth-padLeft,xColMin=xColCorner;for(;xColMin<0;)xColMin+=dilationWidth;let xColMax=Math.min(convInfo.inWidth,effectiveFilterWidth+xColCorner),maxValue=Number.NEGATIVE_INFINITY,maxPosition=-1;for(let xDepth=xDepthMin;xDepth<xDepthMax;xDepth+=dilationDepth){let wDepth=xDepth-xDepthCorner;for(let xRow=xRowMin;xRow<xRowMax;xRow+=dilationHeight){let wRow=xRow-xRowCorner;for(let xCol=xColMin;xCol<xColMax;xCol+=dilationWidth){let wCol=xCol-xColCorner,pixel=xBuf.get(batch,xDepth,xRow,xCol,channel);pixel>=maxValue&&(maxValue=pixel,maxPosition=wDepth*effectiveFilterHeight*effectiveFilterWidth+wRow*effectiveFilterHeight+wCol)}}}maxPositions.set(maxPosition,batch,yDepth,yRow,yCol,channel)}}}return maxPositions.toTensor()}maxPool3dBackprop(dy,x,y,convInfo){assertNotComplex([x,y],"maxPool3dBackprop");let maxPositions=this.maxPool3dPositions(x,convInfo),strideDepth=convInfo.strideDepth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationDepth=convInfo.dilationDepth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterDepth=convInfo.effectiveFilterDepth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padFront=effectiveFilterDepth-1-convInfo.padInfo.front,padLeft=effectiveFilterWidth-1-convInfo.padInfo.left,padTop=effectiveFilterHeight-1-convInfo.padInfo.top,dx=buffer(x.shape,"float32"),maxPosBuf=this.bufferSync(maxPositions),dyBuf=this.bufferSync(dy);for(let batch=0;batch<convInfo.batchSize;++batch)for(let channel=0;channel<convInfo.inChannels;++channel)for(let dxDepth=0;dxDepth<convInfo.inDepth;++dxDepth)for(let dxRow=0;dxRow<convInfo.inHeight;++dxRow)for(let dxCol=0;dxCol<convInfo.inWidth;++dxCol){let dyDepthCorner=dxDepth-padFront,dyRowCorner=dxRow-padTop,dyColCorner=dxCol-padLeft,dotProd=0;for(let wDepth=0;wDepth<effectiveFilterDepth;wDepth+=dilationDepth){let dyDepth=(dyDepthCorner+wDepth)/strideDepth;if(dyDepth<0||dyDepth>=convInfo.outDepth||Math.floor(dyDepth)!==dyDepth)continue;for(let wRow=0;wRow<effectiveFilterHeight;wRow+=dilationHeight){let dyRow=(dyRowCorner+wRow)/strideHeight;if(dyRow<0||dyRow>=convInfo.outHeight||Math.floor(dyRow)!==dyRow)continue;for(let wCol=0;wCol<effectiveFilterWidth;wCol+=dilationWidth){let dyCol=(dyColCorner+wCol)/strideWidth;if(dyCol<0||dyCol>=convInfo.outWidth||Math.floor(dyCol)!==dyCol)continue;let maxPos=effectiveFilterDepth*effectiveFilterHeight*effectiveFilterWidth-1-maxPosBuf.get(batch,dyDepth,dyRow,dyCol,channel),curPos=wDepth*effectiveFilterHeight*effectiveFilterWidth+wRow*effectiveFilterWidth+wCol,mask=maxPos===curPos?1:0;if(mask===0)continue;let pixel=dyBuf.get(batch,dyDepth,dyRow,dyCol,channel);dotProd+=pixel*mask}}}dx.set(dotProd,batch,dxDepth,dxRow,dxCol,channel)}return dx.toTensor()}resizeBilinear(x,newHeight,newWidth,alignCorners){assertNotComplex(x,"resizeBilinear");let[batch,oldHeight,oldWidth,numChannels]=x.shape,xValues=this.readSync(x.dataId),result=new Float32Array(util_exports.sizeFromShape([batch,newHeight,newWidth,numChannels])),effectiveInputSize=[alignCorners&&newHeight>1?oldHeight-1:oldHeight,alignCorners&&newWidth>1?oldWidth-1:oldWidth],effectiveOutputSize=[alignCorners&&newHeight>1?newHeight-1:newHeight,alignCorners&&newWidth>1?newWidth-1:newWidth],outputIdx=0,effectiveRowSizeRatio=effectiveInputSize[0]/effectiveOutputSize[0],effectiveColSizeRatio=effectiveInputSize[1]/effectiveOutputSize[1];for(let b=0;b<batch;b++)for(let r=0;r<newHeight;r++){let sourceFracRow=effectiveRowSizeRatio*r,sourceRowFloor=Math.floor(sourceFracRow),rowFrac=sourceFracRow-sourceRowFloor,sourceRowCeil=Math.min(oldHeight-1,Math.ceil(sourceFracRow)),topRowOffset=b*x.strides[0]+sourceRowFloor*x.strides[1],botRowOffset=b*x.strides[0]+sourceRowCeil*x.strides[1];for(let c=0;c<newWidth;c++){let sourceFracCol=effectiveColSizeRatio*c,sourceColFloor=Math.floor(sourceFracCol),colFrac=sourceFracCol-sourceColFloor,sourceColCeil=Math.min(oldWidth-1,Math.ceil(sourceFracCol)),topLeftOffest=topRowOffset+sourceColFloor*x.strides[2],botLeftOffset=botRowOffset+sourceColFloor*x.strides[2],topRightOffset=topRowOffset+sourceColCeil*x.strides[2],botRightOffest=botRowOffset+sourceColCeil*x.strides[2];for(let d=0;d<numChannels;d++){let topLeft=xValues[topLeftOffest+d],bottomLeft=xValues[botLeftOffset+d],topRight=xValues[topRightOffset+d],bottomRight=xValues[botRightOffest+d],top=topLeft+(topRight-topLeft)*colFrac,bottom=bottomLeft+(bottomRight-bottomLeft)*colFrac,newValue=top+(bottom-top)*rowFrac;result[outputIdx++]=newValue}}}return tensor4(result,[batch,newHeight,newWidth,numChannels])}resizeBilinearBackprop(dy,x,alignCorners){assertNotComplex([dy,x],"resizeBilinearBackprop");let[batch,xHeight,xWidth,depth]=x.shape,[,yHeight,yWidth]=dy.shape,output=new Float32Array(batch*xHeight*xWidth*depth),effectiveXSize=[alignCorners&&yHeight>1?xHeight-1:xHeight,alignCorners&&yWidth>1?xWidth-1:xWidth],effectiveYSize=[alignCorners&&yHeight>1?yHeight-1:yHeight,alignCorners&&yWidth>1?yWidth-1:yWidth],heightScale=effectiveXSize[0]/effectiveYSize[0],widthScale=effectiveXSize[1]/effectiveYSize[1],dyValues=this.readSync(dy.dataId),offset=0;for(let b=0;b<batch;b++){let bOffset=b*x.strides[0];for(let r=0;r<yHeight;r++){let dxR=r*heightScale,topDxRIndex=Math.floor(dxR),bottomDxRIndex=Math.min(Math.ceil(dxR),xHeight-1),topDxROffset=bOffset+topDxRIndex*x.strides[1],bottomDxROffset=bOffset+bottomDxRIndex*x.strides[1],dxRLerp=dxR-topDxRIndex,inverseDxRLerp=1-dxRLerp;for(let c=0;c<yWidth;c++){let dxC=c*widthScale,leftDxCIndex=Math.floor(dxC),rightDxCIndex=Math.min(Math.ceil(dxC),xWidth-1),dxCLerp=dxC-leftDxCIndex,inverseDxCLerp=1-dxCLerp,topLeftRCOffset=topDxROffset+leftDxCIndex*x.strides[2],topRightRCOffset=topDxROffset+rightDxCIndex*x.strides[2],bottomLeftRCOffset=bottomDxROffset+leftDxCIndex*x.strides[2],bottomRightRCOffset=bottomDxROffset+rightDxCIndex*x.strides[2],inverseDxRLerpTimesInverseDxCLerp=inverseDxRLerp*inverseDxCLerp,inverseDxRLerpTimesDxCLerp=inverseDxRLerp*dxCLerp,dxRLerpTimesInverseDxCLerp=dxRLerp*inverseDxCLerp,dxRLerpTimesDxCLerp=dxRLerp*dxCLerp;for(let d=0;d<depth;d++){let dyVal=dyValues[offset++];output[topLeftRCOffset+d]+=dyVal*inverseDxRLerpTimesInverseDxCLerp,output[topRightRCOffset+d]+=dyVal*inverseDxRLerpTimesDxCLerp,output[bottomLeftRCOffset+d]+=dyVal*dxRLerpTimesInverseDxCLerp,output[bottomRightRCOffset+d]+=dyVal*dxRLerpTimesDxCLerp}}}}return tensor4d(output,[batch,xWidth,xHeight,depth],x.dtype)}resizeNearestNeighbor(x,newHeight,newWidth,alignCorners){assertNotComplex(x,"resizeNearestNeighbor");let[batch,oldHeight,oldWidth,numChannels]=x.shape,xValues=this.readSync(x.dataId),output=new Float32Array(batch*newHeight*newWidth*numChannels),effectiveInputSize=[alignCorners&&newHeight>1?oldHeight-1:oldHeight,alignCorners&&newWidth>1?oldWidth-1:oldWidth],effectiveOutputSize=[alignCorners&&newHeight>1?newHeight-1:newHeight,alignCorners&&newWidth>1?newWidth-1:newWidth],effectiveRowSizeRatio=effectiveInputSize[0]/effectiveOutputSize[0],effectiveColSizeRatio=effectiveInputSize[1]/effectiveOutputSize[1],outputOffset=0;for(let b=0;b<batch;b++){let batchOffset=b*x.strides[0];for(let r=0;r<newHeight;r++){let sourceFracRow=effectiveRowSizeRatio*r,sourceNearestRow=Math.min(oldHeight-1,alignCorners?Math.round(sourceFracRow):Math.floor(sourceFracRow)),rowOffset=batchOffset+sourceNearestRow*x.strides[1];for(let c=0;c<newWidth;c++){let sourceFracCol=effectiveColSizeRatio*c,sourceNearestCol=Math.min(oldWidth-1,alignCorners?Math.round(sourceFracCol):Math.floor(sourceFracCol)),colOffset=rowOffset+sourceNearestCol*x.strides[2];for(let d=0;d<numChannels;d++){let newVal=xValues[colOffset+d];output[outputOffset++]=newVal}}}}return tensor4(output,[batch,newHeight,newWidth,numChannels],x.dtype)}resizeNearestNeighborBackprop(dy,x,alignCorners){assertNotComplex([dy,x],"resizeNearestNeighborBackprop");let[batch,xHeight,xWidth,depth]=x.shape,[,yHeight,yWidth]=dy.shape,output=new Float32Array(batch*xHeight*xWidth*depth),dyValues=this.readSync(dy.dataId),effectiveXSize=[alignCorners&&yHeight>1?xHeight-1:xHeight,alignCorners&&yWidth>1?xWidth-1:xWidth],effectiveYSize=[alignCorners&&yHeight>1?yHeight-1:yHeight,alignCorners&&yWidth>1?yWidth-1:yWidth],heightScale=effectiveXSize[0]/effectiveYSize[0],widthScale=effectiveXSize[1]/effectiveYSize[1],invHeightScale=1/heightScale,invWidthScale=1/widthScale,winHeight=Math.ceil(invHeightScale)*2+2,winWidth=Math.ceil(invWidthScale)*2+2;for(let b=0;b<batch;b++){let batchOffset=b*x.strides[0];for(let r=0;r<xHeight;r++){let rowOffset=batchOffset+r*x.strides[1],startRLerp=Math.floor(r*invHeightScale),startDyR=Math.floor(startRLerp-winHeight/2);for(let c=0;c<xWidth;c++){let colOffset=rowOffset+c*x.strides[2],startCLerp=Math.floor(c*invWidthScale),startDyC=Math.floor(startCLerp-winWidth/2);for(let d=0;d<depth;d++){let accum=0;for(let dyRIndex=0;dyRIndex<winHeight;dyRIndex++){let dyR=dyRIndex+startDyR;if(dyR<0||dyR>=yHeight)continue;let dyROffset=batchOffset+dyR*dy.strides[1],sourceFracRow=dyR*heightScale,sourceNearestRow=Math.min(xHeight-1,alignCorners?Math.round(sourceFracRow):Math.floor(sourceFracRow));if(r!==sourceNearestRow)continue;for(let dyCIndex=0;dyCIndex<winWidth;dyCIndex++){let dyC=dyCIndex+startDyC;if(dyC<0||dyC>=yWidth)continue;let dyCOffset=dyROffset+dyC*dy.strides[2],sourceFracCol=dyC*widthScale,sourceNearestCol=Math.min(xWidth-1,alignCorners?Math.round(sourceFracCol):Math.floor(sourceFracCol));c===sourceNearestCol&&(accum+=dyValues[dyCOffset+d])}}output[colOffset+d]=accum}}}}return tensor4d(output,x.shape,x.dtype)}localResponseNormalization4D(x,depthRadius,bias,alpha,beta){assertNotComplex(x,"localResponseNormalization4D");let channels=x.shape[3],maxD=channels-1,xValues=this.readSync(x.dataId),size=x.size,result=new Float32Array(size);function sumAcrossChannels(offset){let currentChannel=offset%channels,beginSumOffset=offset-currentChannel+Math.max(0,currentChannel-depthRadius),endSumOffset=offset-currentChannel+Math.min(currentChannel+depthRadius,maxD),sum28=0;for(;beginSumOffset<=endSumOffset;beginSumOffset++){let z=xValues[beginSumOffset];sum28+=z*z}return sum28}for(let offset=0;offset<size;offset++){let sum28=sumAcrossChannels(offset),val=xValues[offset]*Math.pow(bias+alpha*sum28,-beta);result[offset]=val}return tensor4d(result,x.shape)}LRNGrad(dy,inputImage,outputImage,depthRadius,bias,alpha,beta){assertNotComplex(dy,"LRNGrad");let channels=dy.shape[3],dyValues=this.readSync(dy.dataId),inputImageValues=this.readSync(inputImage.dataId),outputImageValues=this.readSync(outputImage.dataId),result=new Float32Array(dy.size),size=dy.size;for(let offset=0;offset<size;offset++){let currentChannel=offset%channels,depthBegin=offset-currentChannel+Math.max(0,currentChannel-depthRadius),depthEnd=offset-currentChannel+Math.min(channels,currentChannel+depthRadius+1),norm5=0;for(let k=depthBegin;k<depthEnd;k++)norm5+=Math.pow(inputImageValues[k],2);norm5=alpha*norm5+bias;for(let k=depthBegin;k<depthEnd;k++){let dyi=-2*alpha*beta*inputImageValues[k]*outputImageValues[offset]/norm5;offset===k&&(dyi+=Math.pow(norm5,-beta)),dyi*=dyValues[offset],result[k]+=dyi}}return tensor4d(result,dy.shape)}multinomial(logits,normalized,numSamples,seed){assertNotComplex(logits,"multinomial");let probabilities=normalized?logits:softmax(logits),batchSize=probabilities.shape[0],numEvents=probabilities.shape[1],res=zeros([batchSize,numSamples],"int32"),resVals=this.readSync(res.dataId),probVals=this.readSync(probabilities.dataId);for(let b=0;b<batchSize;++b){let offset=b*numEvents,cdf=new Float32Array(numEvents-1);cdf[0]=probVals[offset];for(let event=1;event<cdf.length;++event)cdf[event]=cdf[event-1]+probVals[offset+event];let random=seedrandom4.alea(seed.toString()),outOffset=b*numSamples;for(let sampleId=0;sampleId<numSamples;++sampleId){let r=random();resVals[outOffset+sampleId]=cdf.length;for(let event=0;event<cdf.length;event++)if(r<cdf[event]){resVals[outOffset+sampleId]=event;break}}}return res}oneHot(indices,depth,onValue,offValue){assertNotComplex(indices,"oneHot");let res=new Float32Array(indices.size*depth);res.fill(offValue);let indicesVal=this.readSync(indices.dataId);for(let event=0;event<indices.size;++event)indicesVal[event]>=0&&indicesVal[event]<depth&&(res[event*depth+indicesVal[event]]=onValue);return tensor2d(res,[indices.size,depth],"int32")}nonMaxSuppression(boxes,scores,maxOutputSize,iouThreshold,scoreThreshold){assertNotComplex(boxes,"nonMaxSuppression");let boxesVals=this.readSync(boxes.dataId),scoresVals=this.readSync(scores.dataId);return nonMaxSuppressionV3Impl2(boxesVals,scoresVals,maxOutputSize,iouThreshold,scoreThreshold)}depthToSpace(x,blockSize,dataFormat){util_exports.assert(dataFormat==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${dataFormat}`),util_exports.assert(blockSize>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);let batchSize=x.shape[0],inputHeight=x.shape[1],inputWidth=x.shape[2],inputDepth=x.shape[3],outputHeight=inputHeight*blockSize,outputWidth=inputWidth*blockSize,outputDepth=inputDepth/(blockSize*blockSize),xValues=this.readSync(x.dataId),result=new Float32Array(batchSize*outputHeight*outputWidth*outputDepth),outputIdx=0;for(let b=0;b<batchSize;++b)for(let h=0;h<outputHeight;++h){let inH=Math.floor(h/blockSize),offsetH=h%blockSize;for(let w=0;w<outputWidth;++w){let inW=Math.floor(w/blockSize),offsetW=w%blockSize,offsetD=(offsetH*blockSize+offsetW)*outputDepth;for(let d=0;d<outputDepth;++d){let inD=d+offsetD,inputIdx=inD+inputDepth*(inW+inputWidth*(inH+inputHeight*b));result[outputIdx++]=xValues[inputIdx]}}}return tensor4d(result,[batchSize,outputHeight,outputWidth,outputDepth])}broadcastedBinaryOp(a,b,dtype,op2){let newShape=backend_util_exports.assertAndGetBroadcastShape(a.shape,b.shape),result=buffer(newShape,dtype),aVals=this.readSync(a.dataId),bVals=this.readSync(b.dataId),aBroadcastDims=backend_util_exports.getBroadcastDims(a.shape,newShape),bBroadcastDims=backend_util_exports.getBroadcastDims(b.shape,newShape),resVals=result.values;if(aBroadcastDims.length+bBroadcastDims.length===0)for(let i=0;i<resVals.length;++i)resVals[i]=op2(aVals[i%aVals.length],bVals[i%bVals.length]);else{let aBuf=this.bufferSync(a),bBuf=this.bufferSync(b);for(let i=0;i<resVals.length;++i){let loc=result.indexToLoc(i),aLoc=loc.slice(-a.rank);aBroadcastDims.forEach(d=>aLoc[d]=0);let aIndex=aBuf.locToIndex(aLoc),bLoc=loc.slice(-b.rank);bBroadcastDims.forEach(d=>bLoc[d]=0);let bIndex=bBuf.locToIndex(bLoc);resVals[i]=op2(aVals[aIndex],bVals[bIndex])}}return result.toTensor()}split(x,sizeSplits,axis){return split10(x,sizeSplits,axis)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}cropAndResize(images,boxes,boxIndex,cropSize,method,extrapolationValue){let[batch,imageHeight,imageWidth,numChannels]=images.shape,numBoxes=boxes.shape[0],[cropHeight,cropWidth]=cropSize,output=buffer([numBoxes,cropHeight,cropWidth,numChannels],"float32"),boxVals=this.readSync(boxes.dataId),boxIndVals=this.readSync(boxIndex.dataId),imageVals=this.readSync(images.dataId),inStride=images.strides,outStride=output.strides;for(let b=0;b<numBoxes;b++){let startInd=b*4,y1=boxVals[startInd],x1=boxVals[startInd+1],y2=boxVals[startInd+2],x2=boxVals[startInd+3],bInd=boxIndVals[b];if(bInd>=batch)continue;let heightScale=cropHeight>1?(y2-y1)*(imageHeight-1)/(cropHeight-1):0,widthScale=cropWidth>1?(x2-x1)*(imageWidth-1)/(cropWidth-1):0;for(let y=0;y<cropHeight;y++){let yInd=cropHeight>1?y1*(imageHeight-1)+y*heightScale:.5*(y1+y2)*(imageHeight-1);if(yInd<0||yInd>imageHeight-1){for(let x=0;x<cropWidth;x++)for(let c=0;c<numChannels;c++){let ind=c+x*outStride[2]+y*outStride[1]+b*outStride[0];output.values[ind]=extrapolationValue}continue}if(method==="bilinear"){let topInd=Math.floor(yInd),bottomInd=Math.ceil(yInd),yLerp=yInd-topInd;for(let x=0;x<cropWidth;x++){let xInd=cropWidth>1?x1*(imageWidth-1)+x*widthScale:.5*(x1+x2)*(imageWidth-1);if(xInd<0||xInd>imageWidth-1){for(let c=0;c<numChannels;c++){let ind=c+x*outStride[2]+y*outStride[1]+b*outStride[0];output.values[ind]=extrapolationValue}continue}let leftInd=Math.floor(xInd),rightInd=Math.ceil(xInd),xLerp=xInd-leftInd;for(let c=0;c<numChannels;c++){let ind=c+leftInd*inStride[2]+topInd*inStride[1]+bInd*inStride[0],topLeft=imageVals[ind];ind=c+rightInd*inStride[2]+topInd*inStride[1]+bInd*inStride[0];let topRight=imageVals[ind];ind=c+leftInd*inStride[2]+bottomInd*inStride[1]+bInd*inStride[0];let bottomLeft=imageVals[ind];ind=c+rightInd*inStride[2]+bottomInd*inStride[1]+bInd*inStride[0];let bottomRight=imageVals[ind],top=topLeft+(topRight-topLeft)*xLerp,bottom=bottomLeft+(bottomRight-bottomLeft)*xLerp;ind=c+x*outStride[2]+y*outStride[1]+b*outStride[0],output.values[ind]=top+(bottom-top)*yLerp}}}else for(let x=0;x<cropWidth;++x){let xInd=cropWidth>1?x1*(imageWidth-1)+x*widthScale:.5*(x1+x2)*(imageWidth-1);if(xInd<0||xInd>imageWidth-1){for(let c=0;c<numChannels;c++){let ind=c+x*outStride[2]+y*outStride[1]+b*outStride[0];output.values[ind]=extrapolationValue}continue}let closestX=Math.round(xInd),closestY=Math.round(yInd);for(let c=0;c<numChannels;c++){let inInd=c+closestX*inStride[2]+closestY*inStride[1]+bInd*inStride[0],outInd=c+x*outStride[2]+y*outStride[1]+b*outStride[0];output.values[outInd]=imageVals[inInd]}}}}return output.toTensor()}sparseToDense(sparseIndices,sparseValues,outputShape,defaultValue){let{sliceRank,numUpdates,sliceSize,strides,outputSize}=backend_util_exports.calculateShapes(sparseValues,sparseIndices,outputShape),sumDupeIndices=!1;return this.scatter(sparseIndices,sparseValues,outputShape,outputSize,sliceSize,numUpdates,sliceRank,strides,defaultValue,sumDupeIndices)}gatherND(x,indices){let indicesShape=indices.shape,sliceRank=indicesShape[indicesShape.length-1],[resultShape,numSlices,sliceSize,strides]=backend_util_exports.prepareAndValidate(x,indices);if(numSlices===0)return tensor4([],resultShape,x.dtype);let buffer10=new TensorBuffer([numSlices,sliceSize],x.dtype),indicesData=this.readSync(indices.dataId),xData=this.readSync(x.dataId);for(let i=0;i<numSlices;i++){let index=[],flattenIndex=0;for(let j=0;j<sliceRank;j++){let dim=indicesData[i*sliceRank+j];flattenIndex+=dim*strides[j],index.push(dim)}if(flattenIndex<0||flattenIndex>=x.size/sliceSize)throw new Error(`Invalid indices: ${index} does not index into ${x.shape}`);for(let k=0;k<sliceSize;k++)buffer10.values[i*sliceSize+k]=xData[flattenIndex*sliceSize+k]}return buffer10.toTensor().reshape(resultShape)}scatterND(indices,updates,shape){let{sliceRank,numUpdates,sliceSize,strides,outputSize}=backend_util_exports.calculateShapes(updates,indices,shape),defaultValue=scalar(0),sumDupeIndices=!0;return this.scatter(indices,updates,shape,outputSize,sliceSize,numUpdates,sliceRank,strides,defaultValue,sumDupeIndices)}onesLike(x){if(x.dtype==="string")throw new Error("onesLike is not supported for string tensors");return fill(x.shape,1,x.dtype)}zerosLike(x){let values=util_exports.getArrayFromDType(x.dtype,util_exports.sizeFromShape(x.shape));return this.makeOutput(values,x.shape,x.dtype)}linspace(start,stop,num){return backend_util_exports.linspaceImpl(start,stop,num)}scatter(indices,updates,shape,outputSize,sliceSize,numUpdates,sliceRank,strides,defaultValue,sumDupeIndices){let flattenShape=[outputSize/sliceSize,sliceSize],indicesData=this.readSync(indices.dataId),updatesData=this.readSync(updates.dataId);if(outputSize===0)return tensor4([],shape,updates.dtype);let buffer10=new TensorBuffer(flattenShape,updates.dtype);buffer10.values.fill(this.readSync(defaultValue.dataId)[0]);for(let i=0;i<numUpdates;i++){let index=[],flattenIndex=0;for(let j=0;j<sliceRank;j++){let dim=indicesData[i*sliceRank+j];index.push(dim),flattenIndex+=dim*strides[j]}if(flattenIndex<0||flattenIndex>=outputSize/sliceSize)throw new Error(`Invalid indices: ${index} does not index into ${shape}`);for(let k=0;k<sliceSize;k++)sumDupeIndices?buffer10.values[flattenIndex*sliceSize+k]+=updatesData[i*sliceSize+k]:buffer10.values[flattenIndex*sliceSize+k]=updates.rank===0?updatesData[0]:updatesData[i*sliceSize+k]}return buffer10.toTensor().reshape(shape)}},shared_exports={};__export(shared_exports,{addImpl:()=>addImpl,ceilImpl:()=>ceilImpl,expImpl:()=>expImpl,expm1Impl:()=>expm1Impl,floorImpl:()=>floorImpl,logImpl:()=>logImpl,maxImpl:()=>maxImpl,multiplyImpl:()=>multiplyImpl,notEqualImpl:()=>notEqualImpl,rsqrtImpl:()=>rsqrtImpl,simpleAbsImpl:()=>simpleAbsImpl,sliceImpl:()=>sliceImpl,squaredDifferenceImpl:()=>squaredDifferenceImpl,subImpl:()=>subImpl,transposeImpl:()=>transposeImpl,uniqueImpl:()=>uniqueImpl});function simpleAbsImpl(vals){let resultValues=new Float32Array(vals.length);for(let i=0;i<vals.length;++i)resultValues[i]=Math.abs(vals[i]);return resultValues}var abs9=args=>{let{x}=args.inputs,cpuBackend=args.backend,resultValues=new Float32Array(util_exports.sizeFromShape(x.shape));if(x.dtype!=="complex64"){let values=cpuBackend.data.get(x.dataId).values;resultValues=simpleAbsImpl(values)}else{let complexVals=cpuBackend.data.get(x.dataId),real8=complexVals.complexTensorInfos.real,imag8=complexVals.complexTensorInfos.imag,realVals=cpuBackend.data.get(real8.dataId).values,imagVals=cpuBackend.data.get(imag8.dataId).values;for(let i=0;i<realVals.length;i++){let real9=realVals[i],imag9=imagVals[i];resultValues[i]=Math.hypot(real9,imag9)}}return cpuBackend.makeOutput(resultValues,x.shape,"float32")},absConfig={kernelName:Abs,backendName:"cpu",kernelFunc:abs9};function createSimpleBinaryKernelImpl(op2){return(aShape,bShape,aVals,bVals,dtype)=>{let newShape=backend_util_exports.assertAndGetBroadcastShape(aShape,bShape),resultRank=newShape.length,resultStrides=util_exports.computeStrides(newShape),resultSize=util_exports.sizeFromShape(newShape),result=util_exports.getTypedArrayFromDType(dtype,resultSize),aRank=aShape.length,bRank=bShape.length,aStrides=util_exports.computeStrides(aShape),bStrides=util_exports.computeStrides(bShape),aBroadcastDims=backend_util_exports.getBroadcastDims(aShape,newShape),bBroadcastDims=backend_util_exports.getBroadcastDims(bShape,newShape);if(aBroadcastDims.length+bBroadcastDims.length===0)for(let i=0;i<result.length;++i)result[i]=op2(aVals[i%aVals.length],bVals[i%bVals.length]);else for(let i=0;i<result.length;++i){let loc=util_exports.indexToLoc(i,resultRank,resultStrides),aLoc=loc.slice(-aRank);aBroadcastDims.forEach(d=>aLoc[d]=0);let aIndex=util_exports.locToIndex(aLoc,aRank,aStrides),bLoc=loc.slice(-bRank);bBroadcastDims.forEach(d=>bLoc[d]=0);let bIndex=util_exports.locToIndex(bLoc,bRank,bStrides);result[i]=op2(aVals[aIndex],bVals[bIndex])}return[result,newShape]}}function complex9(args){let{inputs,backend:backend3}=args,{real:real8,imag:imag8}=inputs,realVals=backend3.data.get(real8.dataId).values,imagVals=backend3.data.get(imag8.dataId).values,complexInfo=backend3.makeTensorInfo(real8.shape,"complex64"),complex11=backend3.data.get(complexInfo.dataId);return complex11.complexTensorInfos={real:backend3.makeTensorInfo(real8.shape,"float32",realVals),imag:backend3.makeTensorInfo(imag8.shape,"float32",imagVals)},complexInfo}var complexConfig={kernelName:Complex,backendName:"cpu",kernelFunc:complex9};function identity(args){let{inputs,backend:backend3}=args,{x}=inputs;return backend3.incRef(x.dataId),{dataId:x.dataId,shape:x.shape,dtype:x.dtype}}var identityConfig={kernelName:Identity,backendName:"cpu",kernelFunc:identity};function real6(args){let{inputs,backend:backend3}=args,{input:input2}=inputs,real8=backend3.data.get(input2.dataId).complexTensorInfos.real,realVal=backend3.data.get(real8.dataId).values;return backend3.makeTensorInfo(real8.shape,real8.dtype,realVal)}var realConfig={kernelName:Real,backendName:"cpu",kernelFunc:real6};function cast48(args){let{inputs,backend:backend3,attrs}=args,{x}=inputs,{dtype}=attrs;if(dtype==="complex64"){if(x.dtype==="complex64")return identity({inputs:{x},backend:backend3});let zerosTensor=zeros(x.shape),floatX=cast48({inputs:{x},backend:backend3,attrs:{dtype:"float32"}}),result=complex9({inputs:{real:floatX,imag:zerosTensor},backend:backend3});return zerosTensor.dispose(),backend3.disposeIntermediateTensorInfo(floatX),result}if(x.dtype==="complex64"){let realPart=real6({inputs:{input:x},backend:backend3}),result=cast48({inputs:{x:realPart},backend:backend3,attrs:{dtype}});return backend3.disposeIntermediateTensorInfo(realPart),result}if(!util_exports.hasEncodingLoss(x.dtype,dtype)){let result=identity({inputs:{x},backend:backend3});return{dataId:result.dataId,shape:result.shape,dtype}}if(dtype==="int32"){let values=backend3.data.get(x.dataId).values,resultValues=Int32Array.from(values);return backend3.makeTensorInfo(x.shape,"int32",resultValues)}if(dtype==="bool"){let xVals=backend3.data.get(x.dataId).values,zero=util_exports.toTypedArray([0],x.dtype),[resultData,resultShape]=createSimpleBinaryKernelImpl((a,b)=>a!==b?1:0)(x.shape,[],xVals,zero,"bool");return backend3.makeTensorInfo(resultShape,"bool",resultData)}throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`)}var castConfig={kernelName:Cast,backendName:"cpu",kernelFunc:cast48};function binaryKernelFunc(name,simpleImpl,complexImpl,dtype){return complexImpl==null?({inputs,backend:backend3})=>{let{a,b}=inputs,cpuBackend=backend3;assertNotComplex([a,b],name);let aVals=cpuBackend.data.get(a.dataId).values,bVals=cpuBackend.data.get(b.dataId).values,$dtype=dtype||a.dtype,[resultData,resultShape]=simpleImpl(a.shape,b.shape,aVals,bVals,$dtype);return cpuBackend.makeTensorInfo(resultShape,$dtype,resultData)}:({inputs,backend:backend3})=>{let{a,b}=inputs,cpuBackend=backend3;if(a.dtype==="complex64"||b.dtype==="complex64"){let $aComplex=cast48({inputs:{x:a},backend:cpuBackend,attrs:{dtype:"complex64"}}),$aComplexVals=cpuBackend.data.get($aComplex.dataId),aReal=$aComplexVals.complexTensorInfos.real,aImag=$aComplexVals.complexTensorInfos.imag,aRealVals=cpuBackend.data.get(aReal.dataId).values,aImagVals=cpuBackend.data.get(aImag.dataId).values,$bComplex=cast48({inputs:{x:b},backend:cpuBackend,attrs:{dtype:"complex64"}}),$bComplexVals=cpuBackend.data.get($bComplex.dataId),bReal=$bComplexVals.complexTensorInfos.real,bImag=$bComplexVals.complexTensorInfos.imag,bRealVals=cpuBackend.data.get(bReal.dataId).values,bImagVals=cpuBackend.data.get(bImag.dataId).values,[resultRealData,resultImagData,resultShape]=complexImpl(a.shape,b.shape,aRealVals,aImagVals,bRealVals,bImagVals),resultReal=cpuBackend.makeTensorInfo(resultShape,"float32",resultRealData),resultImag=cpuBackend.makeTensorInfo(resultShape,"float32",resultImagData),result=complex9({inputs:{real:resultReal,imag:resultImag},backend:cpuBackend});return cpuBackend.disposeIntermediateTensorInfo($aComplex),cpuBackend.disposeIntermediateTensorInfo($bComplex),cpuBackend.disposeIntermediateTensorInfo(resultReal),cpuBackend.disposeIntermediateTensorInfo(resultImag),result}else{let aVals=cpuBackend.data.get(a.dataId).values,bVals=cpuBackend.data.get(b.dataId).values,$dtype=dtype||a.dtype,[resultData,resultShape]=simpleImpl(a.shape,b.shape,aVals,bVals,$dtype);return cpuBackend.makeTensorInfo(resultShape,$dtype,resultData)}}}function createComplexBinaryKernelImpl(op2){return(aShape,bShape,aRealVals,aImagVals,bRealVals,bImagVals)=>{let resultShape=backend_util_exports.assertAndGetBroadcastShape(aShape,bShape),resultSize=util_exports.sizeFromShape(resultShape),resultRank=resultShape.length,resultStrides=util_exports.computeStrides(resultShape),resultRealVals=util_exports.getTypedArrayFromDType("float32",resultSize),resultImagVals=util_exports.getTypedArrayFromDType("float32",resultSize),aBroadcastDims=backend_util_exports.getBroadcastDims(aShape,resultShape),bBroadcastDims=backend_util_exports.getBroadcastDims(bShape,resultShape),aVals=backend_util_exports.mergeRealAndImagArrays(aRealVals,aImagVals),bVals=backend_util_exports.mergeRealAndImagArrays(bRealVals,bImagVals),aRank=aShape.length,aStrides=util_exports.computeStrides(aShape),bRank=bShape.length,bStrides=util_exports.computeStrides(bShape);if(aBroadcastDims.length+bBroadcastDims.length===0)for(let i=0;i<resultRealVals.length;i++){let aIdx=i%aVals.length,bIdx=i%bVals.length,result=op2(aVals[aIdx*2],aVals[aIdx*2+1],bVals[bIdx*2],bVals[bIdx*2+1]);resultRealVals[i]=result.real,resultImagVals[i]=result.imag}else for(let i=0;i<resultRealVals.length;i++){let loc=util_exports.indexToLoc(i,resultRank,resultStrides),aLoc=loc.slice(-aRank);aBroadcastDims.forEach(d=>aLoc[d]=0);let aIndex=util_exports.locToIndex(aLoc,aRank,aStrides),bLoc=loc.slice(-bRank);bBroadcastDims.forEach(d=>bLoc[d]=0);let bIndex=util_exports.locToIndex(bLoc,bRank,bStrides),opResult=op2(aVals[aIndex*2],aVals[aIndex*2+1],bVals[bIndex*2],bVals[bIndex*2+1]);resultRealVals[i]=opResult.real,resultImagVals[i]=opResult.imag}return[resultRealVals,resultImagVals,resultShape]}}var addImpl=createSimpleBinaryKernelImpl((a,b)=>a+b),addComplexImpl=createComplexBinaryKernelImpl((aReal,aImag,bReal,bImag)=>({real:aReal+bReal,imag:aImag+bImag})),add29=binaryKernelFunc(Add,addImpl,addComplexImpl),addConfig={kernelName:Add,backendName:"cpu",kernelFunc:add29};function createSimpleUnaryImpl(op2){return(values,dtype,attrs)=>{let newValues=util_exports.getTypedArrayFromDType(dtype,values.length);for(let i=0;i<values.length;++i)newValues[i]=op2(values[i],attrs);return newValues}}function unaryKernelFunc(name,op2,dtype){return({inputs,attrs,backend:backend3})=>{let{x}=inputs;if(assertNotComplex(x,name),x.dtype==="string"||dtype==="string")throw new Error("unaryKernelFunc does not support string input/output");let cpuBackend=backend3,values=cpuBackend.data.get(x.dataId).values,xSize=util_exports.sizeFromShape(x.shape),$dtype=dtype||x.dtype,newValues=util_exports.getArrayFromDType($dtype,xSize);for(let i=0;i<xSize;++i)newValues[i]=op2(values[i],attrs);return cpuBackend.makeTensorInfo(x.shape,$dtype,newValues)}}function unaryKernelFuncFromImpl(name,unaryImpl,dtype){return({inputs,attrs,backend:backend3})=>{let{x}=inputs;if(assertNotComplex(x,name),x.dtype==="string"||dtype==="string")throw new Error("unaryKernelFunc does not support string input/output");let cpuBackend=backend3,values=cpuBackend.data.get(x.dataId).values,$dtype=dtype||x.dtype,newValues=unaryImpl(values,$dtype,attrs);return cpuBackend.makeTensorInfo(x.shape,$dtype,newValues)}}var ceilImpl=createSimpleUnaryImpl(xi=>Math.ceil(xi)),ceil4=unaryKernelFuncFromImpl(Ceil,ceilImpl),ceilConfig={kernelName:Ceil,backendName:"cpu",kernelFunc:ceil4};var expImpl=createSimpleUnaryImpl(xi=>Math.exp(xi)),exp12=unaryKernelFuncFromImpl(Exp,expImpl),expConfig={kernelName:Exp,backendName:"cpu",kernelFunc:exp12};var expm1Impl=createSimpleUnaryImpl(xi=>Math.expm1(xi)),expm14=unaryKernelFuncFromImpl(Expm1,expm1Impl),expm1Config={kernelName:Expm1,backendName:"cpu",kernelFunc:expm14};var floorImpl=createSimpleUnaryImpl(xi=>Math.floor(xi)),floor6=unaryKernelFuncFromImpl(Floor,floorImpl),floorConfig={kernelName:Floor,backendName:"cpu",kernelFunc:floor6};var logImpl=createSimpleUnaryImpl(xi=>Math.log(xi)),log9=unaryKernelFuncFromImpl(Log,logImpl),logConfig={kernelName:Log,backendName:"cpu",kernelFunc:log9};function maxImpl(aVals,reduceSize,outShape,dtype){let vals=util_exports.getTypedArrayFromDType(dtype,util_exports.sizeFromShape(outShape));for(let i=0;i<vals.length;++i){let offset=i*reduceSize,max9=aVals[offset];for(let j=0;j<reduceSize;++j){let value=aVals[offset+j];value>max9&&(max9=value)}vals[i]=max9}return vals}var multiplyImpl=createSimpleBinaryKernelImpl((aValue,bValue)=>aValue*bValue),multiplyComplexImpl=createComplexBinaryKernelImpl((aReal,aImag,bReal,bImag)=>({real:aReal*bReal-aImag*bImag,imag:aReal*bImag+aImag*bReal})),multiply=binaryKernelFunc(Multiply,multiplyImpl,multiplyComplexImpl),multiplyConfig={kernelName:Multiply,backendName:"cpu",kernelFunc:multiply};var notEqualImpl=createSimpleBinaryKernelImpl((a,b)=>a!==b?1:0),notEqual2=binaryKernelFunc(NotEqual,notEqualImpl,null,"bool"),notEqualConfig={kernelName:NotEqual,backendName:"cpu",kernelFunc:notEqual2};var rsqrtImpl=createSimpleUnaryImpl(xi=>1/Math.sqrt(xi)),rsqrt5=unaryKernelFuncFromImpl(Rsqrt,rsqrtImpl),rsqrtConfig={kernelName:Rsqrt,backendName:"cpu",kernelFunc:rsqrt5};function sliceImpl(vals,begin,size,shape,dtype){let isContinous=slice_util_exports.isSliceContinous(shape,begin,size),length=util_exports.sizeFromShape(size),xStrides=util_exports.computeStrides(shape);if(isContinous){let flatOffset=slice_util_exports.computeFlatOffset(begin,xStrides);return vals.subarray(flatOffset,flatOffset+length)}let outVals=util_exports.getTypedArrayFromDType(dtype,length);for(let i=0;i<length;++i){let rank=size.length,strides=util_exports.computeStrides(size),loc=util_exports.indexToLoc(i,rank,strides),xLoc=loc.map((idx,j)=>idx+begin[j]),xIndex=util_exports.locToIndex(xLoc,shape.length,xStrides);outVals[i]=vals[xIndex]}return outVals}function slice18(args){let{inputs,backend:backend3,attrs}=args,{x}=inputs,{begin,size}=attrs;assertNotComplex(x,"slice");let[$begin,$size]=slice_util_exports.parseSliceParams(x,begin,size);slice_util_exports.assertParamsValid(x,$begin,$size);let vals=backend3.data.get(x.dataId).values,outVals=sliceImpl(vals,$begin,$size,x.shape,x.dtype);return backend3.makeTensorInfo($size,x.dtype,outVals)}var sliceConfig={kernelName:Slice,backendName:"cpu",kernelFunc:slice18};var squaredDifferenceImpl=createSimpleBinaryKernelImpl((a,b)=>{let diff=a-b;return diff*diff}),squaredDifference2=binaryKernelFunc(SquaredDifference,squaredDifferenceImpl),squaredDifferenceConfig={kernelName:SquaredDifference,backendName:"cpu",kernelFunc:squaredDifference2};var subImpl=createSimpleBinaryKernelImpl((aValue,bValue)=>aValue-bValue),subComplexImpl=createComplexBinaryKernelImpl((aReal,aImag,bReal,bImag)=>({real:aReal-bReal,imag:aImag-bImag})),sub33=binaryKernelFunc(Sub,subImpl,subComplexImpl),subConfig={kernelName:Sub,backendName:"cpu",kernelFunc:sub33};function transposeImpl(xVals,xShape,dtype,perm,newShape){let xRank=xShape.length,xSize=util_exports.sizeFromShape(xShape),xStrides=util_exports.computeStrides(xShape),newStrides=util_exports.computeStrides(newShape),result=util_exports.getTypedArrayFromDType(dtype,util_exports.sizeFromShape(newShape));for(let i=0;i<xSize;++i){let loc=util_exports.indexToLoc(i,xRank,xStrides),newLoc=new Array(loc.length);for(let i2=0;i2<newLoc.length;i2++)newLoc[i2]=loc[perm[i2]];let newIndex=util_exports.locToIndex(newLoc,xRank,newStrides);result[newIndex]=xVals[i]}return result}function uniqueImpl(values,axis,shape,dtype){let $axis=util_exports.parseAxisParam(axis,shape)[0],newShape=[1,shape[0],1];for(let i=0;i<$axis;i++)newShape[0]*=shape[i];newShape[1]=shape[$axis];for(let i=$axis+1;i<shape.length;i++)newShape[2]*=shape[i];let uniqueElements={},indices=new Int32Array(shape[$axis]),inputBuffer=new TensorBuffer(newShape,dtype,values),uniqueIndices=[],is1DTensor=newShape[0]===1&&newShape[2]===1;for(let i=0;i<shape[$axis];i++){let element;if(is1DTensor)element=values[i].toString();else{let axisValues=[];for(let m=0;m<newShape[0];m++)for(let n=0;n<newShape[2];n++)axisValues.push(inputBuffer.get(m,i,n));element=axisValues.join(",")}if(uniqueElements[element]!==void 0)indices[i]=uniqueElements[element];else{let uniqueIndex=Object.keys(uniqueElements).length;uniqueElements[element]=uniqueIndex,indices[i]=uniqueIndex,uniqueIndices.push(i)}}let outputTmpShape=newShape.slice();outputTmpShape[1]=Object.keys(uniqueElements).length;let outputBuffer=new TensorBuffer(outputTmpShape,dtype);uniqueIndices.forEach((uniqueElementIndex,i)=>{for(let m=0;m<newShape[0];m++)for(let n=0;n<newShape[2];n++)outputBuffer.set(inputBuffer.get(m,uniqueElementIndex,n),m,i,n)});let outputShape=shape.slice();return outputShape[$axis]=outputTmpShape[1],{outputValues:outputBuffer.values,outputShape,indices}}var version10="2.7.0";registerBackend("cpu",()=>new MathBackendCPU,1);var elu7=unaryKernelFunc(Elu,xi=>xi>=0?xi:Math.exp(xi)-1),eluConfig={kernelName:Elu,backendName:"cpu",kernelFunc:elu7};var preluImpl=createSimpleBinaryKernelImpl((xValue,aValue)=>xValue<0?aValue*xValue:xValue);function prelu6(args){let{inputs,backend:backend3}=args,{x,alpha}=inputs;assertNotComplex([x,alpha],"prelu");let aVals=backend3.data.get(x.dataId).values,bVals=backend3.data.get(alpha.dataId).values,[resultData,resultShape]=preluImpl(x.shape,alpha.shape,aVals,bVals,x.dtype);return backend3.makeTensorInfo(resultShape,x.dtype,resultData)}var preluConfig={kernelName:Prelu,backendName:"cpu",kernelFunc:prelu6};var relu9=unaryKernelFunc(Relu,xi=>Math.max(0,xi)),reluConfig={kernelName:Relu,backendName:"cpu",kernelFunc:relu9};var relu66=unaryKernelFunc(Relu6,xi=>Math.min(Math.max(0,xi),6)),relu6Config={kernelName:Relu6,backendName:"cpu",kernelFunc:relu66};function applyActivation2(backend3,x,activation,preluActivationWeights){if(activation==="linear")return identity({inputs:{x},backend:backend3});if(activation==="relu")return relu9({inputs:{x},backend:backend3});if(activation==="elu")return elu7({inputs:{x},backend:backend3});if(activation==="relu6")return relu66({inputs:{x},backend:backend3});if(activation==="prelu")return prelu6({inputs:{x,alpha:preluActivationWeights},backend:backend3});throw new Error(`Activation ${activation} has not been implemented for the CPU backend.`)}function reshape83(args){let{inputs,backend:backend3,attrs}=args,{x}=inputs,{shape}=attrs,xSize=util_exports.sizeFromShape(x.shape),$shape=util_exports.inferFromImplicitShape(shape,xSize),$xSize=util_exports.sizeFromShape($shape);util_exports.assert(xSize===$xSize,()=>`The new shape (${$shape}) has ${$xSize} elements and the old shape (${x.shape}) has ${xSize} elements. The new shape and old shape must have the same number of elements.`),backend3.incRef(x.dataId);let xData=backend3.data.get(x.dataId);if(xData.complexTensorInfos!=null){let real8=xData.complexTensorInfos.real,imag8=xData.complexTensorInfos.imag;real8.shape=$shape,imag8.shape=$shape}return{dataId:x.dataId,shape:$shape,dtype:x.dtype}}var reshapeConfig={kernelName:Reshape,backendName:"cpu",kernelFunc:reshape83};function batchMatMul(args){let{inputs,backend:backend3,attrs}=args,{a,b}=inputs,{transposeA,transposeB}=attrs;assertNotComplex([a,b],"matMul");let aRank=a.shape.length,bRank=b.shape.length,innerShapeA=transposeA?a.shape[aRank-2]:a.shape[aRank-1],innerShapeB=transposeB?b.shape[bRank-1]:b.shape[bRank-2],outerShapeA=transposeA?a.shape[aRank-1]:a.shape[aRank-2],outerShapeB=transposeB?b.shape[bRank-2]:b.shape[bRank-1],outerDimsA=a.shape.slice(0,-2),outerDimsB=b.shape.slice(0,-2),batchDimA=util_exports.sizeFromShape(outerDimsA),batchDimB=util_exports.sizeFromShape(outerDimsB),batchDimsCompatible=batchDimA===batchDimB||batchDimA===1||batchDimB===1;util_exports.assert(aRank>=2&&bRank>=2&&batchDimsCompatible,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${outerDimsA}) and (${outerDimsB}).`);let outShapeOuterDims=batchDimA>batchDimB?a.shape.slice(0,-2):b.shape.slice(0,-2),outShape=outShapeOuterDims.concat([outerShapeA,outerShapeB]);util_exports.assert(innerShapeA===innerShapeB,()=>`Error in matMul: inner shapes (${innerShapeA}) and (${innerShapeB}) of Tensors with shapes ${a.shape} and ${b.shape} and transposeA=${transposeA} and transposeB=${transposeB} must match.`);let a3dShape=transposeA?[batchDimA,innerShapeA,outerShapeA]:[batchDimA,outerShapeA,innerShapeA],b3dShape=transposeB?[batchDimB,outerShapeB,innerShapeB]:[batchDimB,innerShapeB,outerShapeB],a3d=reshape83({inputs:{x:a},backend:backend3,attrs:{shape:a3dShape}}),b3d=reshape83({inputs:{x:b},backend:backend3,attrs:{shape:b3dShape}}),sharedDim=transposeA?a3d.shape[1]:a3d.shape[2],leftDim=transposeA?a3d.shape[2]:a3d.shape[1],rightDim=transposeB?b3d.shape[1]:b3d.shape[2],batchDim=Math.max(batchDimA,batchDimB),a3dValues=backend3.data.get(a3d.dataId).values,b3dValues=backend3.data.get(b3d.dataId).values,a3dStrides=util_exports.computeStrides(a3d.shape),b3dStrides=util_exports.computeStrides(b3d.shape),[aBatch,aOuterStep,aInnerStep]=transposeA?[a3dStrides[0],1,a3dStrides[1]]:[a3dStrides[0],a3dStrides[1],1],[bInnerStep,bOuterStep,bBatch]=transposeB?[1,b3dStrides[1],b3dStrides[0]]:[b3dStrides[1],1,b3dStrides[0]],size=leftDim*rightDim,result=buffer([batchDim,leftDim,rightDim],a3d.dtype),resVals=result.values,blockSize=backend3.blockSize;for(let bi=0;bi<batchDim;bi++)for(let i0=0;i0<leftDim;i0+=blockSize)for(let j0=0;j0<rightDim;j0+=blockSize)for(let k0=0;k0<sharedDim;k0+=blockSize){let iBlock=Math.min(i0+blockSize,leftDim),jBlock=Math.min(j0+blockSize,rightDim),kBlock=Math.min(k0+blockSize,sharedDim);for(let i=i0;i<iBlock;i++)for(let j=j0;j<jBlock;j++){let sum28=0;for(let k=k0;k<kBlock;k++){let batchOffsetA=Math.min(bi,batchDimA-1)*aBatch,batchOffsetB=Math.min(bi,batchDimB-1)*bBatch,aVal=a3dValues[batchOffsetA+i*aOuterStep+k*aInnerStep],bVal=b3dValues[k*bInnerStep+j*bOuterStep+batchOffsetB];sum28+=aVal*bVal}resVals[bi*size+(i*rightDim+j)]+=sum28}}return backend3.disposeIntermediateTensorInfo(a3d),backend3.disposeIntermediateTensorInfo(b3d),backend3.makeTensorInfo(outShape,result.dtype,result.values)}var batchMatMulConfig={kernelName:BatchMatMul,backendName:"cpu",kernelFunc:batchMatMul};function _fusedMatMul(args){let{inputs,backend:backend3,attrs}=args,{a,b,bias,preluActivationWeights}=inputs,{transposeA,transposeB,activation}=attrs,current,addRes,activationRes,intermediates=[],matMulRes=batchMatMul({inputs:{a,b},attrs:{transposeA,transposeB},backend:backend3});current=matMulRes,bias&&(addRes=add29({inputs:{a:current,b:bias},backend:backend3}),intermediates.push(current),current=addRes),activation&&(activationRes=applyActivation2(backend3,current,activation,preluActivationWeights),intermediates.push(current),current=activationRes);for(let i of intermediates)backend3.disposeIntermediateTensorInfo(i);return current}var _fusedMatMulConfig={kernelName:_FusedMatMul,backendName:"cpu",kernelFunc:_fusedMatMul};var acos4=unaryKernelFunc(Acos,xi=>Math.acos(xi)),acosConfig={kernelName:Acos,backendName:"cpu",kernelFunc:acos4};var acosh4=unaryKernelFunc(Acosh,xi=>Math.acosh(xi)),acoshConfig={kernelName:Acosh,backendName:"cpu",kernelFunc:acosh4};var asin4=unaryKernelFunc(Asin,xi=>Math.asin(xi)),asinConfig={kernelName:Asin,backendName:"cpu",kernelFunc:asin4};var asinh4=unaryKernelFunc(Asinh,xi=>Math.asinh(xi)),asinhConfig={kernelName:Asinh,backendName:"cpu",kernelFunc:asinh4};var atan5=unaryKernelFunc(Atan,xi=>Math.atan(xi)),atanConfig={kernelName:Atan,backendName:"cpu",kernelFunc:atan5};var atanh4=unaryKernelFunc(Atanh,xi=>Math.atanh(xi)),atanhConfig={kernelName:Atanh,backendName:"cpu",kernelFunc:atanh4};function pool5(xValues,xShape,dtype,strides,convInfo,poolType){let strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left,initialValue=poolType==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,output=buffer(convInfo.outShape,dtype),outputVals=output.values,outputBatchStrides=convInfo.outShape[1]*convInfo.outShape[2]*convInfo.outShape[3],outputRowStrides=convInfo.outShape[2]*convInfo.outShape[3],outputColStrides=convInfo.outShape[3];for(let b=0;b<convInfo.batchSize;++b){let outputBatchOffset=b*outputBatchStrides,inputBatchOffset=b*strides[0];for(let d=0;d<convInfo.inChannels;++d)for(let yR=0;yR<convInfo.outHeight;++yR){let xRCorner=yR*strideHeight-padTop,xRMin=Math.max(0,xRCorner),xRMax=Math.min(convInfo.inHeight,effectiveFilterHeight+xRCorner),outputRowOffset=outputBatchOffset+yR*outputRowStrides;for(let yC=0;yC<convInfo.outWidth;++yC){let xCCorner=yC*strideWidth-padLeft,xCMin=Math.max(0,xCCorner),xCMax=Math.min(convInfo.inWidth,effectiveFilterWidth+xCCorner),minMaxValue=initialValue,avgValue=0,count2=0;for(let xR=xRMin;xR<xRMax;xR+=dilationHeight){let xROffset=inputBatchOffset+xR*strides[1];for(let xC=xCMin;xC<xCMax;xC+=dilationWidth){let xCOffset=xROffset+xC*strides[2],pixel=xValues[xCOffset+d];poolType==="max"&&pixel>minMaxValue?minMaxValue=pixel:poolType==="avg"&&(avgValue+=pixel,count2++)}if(isNaN(minMaxValue))break}let outputOffset=outputRowOffset+yC*outputColStrides+d;outputVals[outputOffset]=poolType==="avg"?avgValue/count2:minMaxValue}}}return output}function maxPoolPositions(xValues,xShape,dtype,convInfo,flattenPositions=!1,includeBatchInIndex=!1){let maxPositions=buffer(convInfo.outShape,"int32"),strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left,xBuf=buffer(xShape,dtype,xValues);for(let b=0;b<convInfo.batchSize;++b)for(let d=0;d<convInfo.inChannels;++d)for(let yR=0;yR<convInfo.outHeight;++yR){let xRCorner=yR*strideHeight-padTop,xRMin=xRCorner;for(;xRMin<0;)xRMin+=dilationHeight;let xRMax=Math.min(convInfo.inHeight,effectiveFilterHeight+xRCorner);for(let yC=0;yC<convInfo.outWidth;++yC){let xCCorner=yC*strideWidth-padLeft,xCMin=xCCorner;for(;xCMin<0;)xCMin+=dilationWidth;let xCMax=Math.min(convInfo.inWidth,effectiveFilterWidth+xCCorner),maxValue=Number.NEGATIVE_INFINITY,maxPosition=-1;for(let xR=xRMin;xR<xRMax;xR+=dilationHeight){let wR=xR-xRCorner;for(let xC=xCMin;xC<xCMax;xC+=dilationWidth){let wC=xC-xCCorner,pixel=xBuf.get(b,xR,xC,d);pixel>maxValue&&(maxValue=pixel,flattenPositions?maxPosition=includeBatchInIndex?((b*convInfo.inHeight+xR)*convInfo.inWidth+xC)*convInfo.inChannels+d:(xR*convInfo.inWidth+xC)*convInfo.inChannels+d:maxPosition=wR*effectiveFilterWidth+wC)}}maxPositions.set(maxPosition,b,yR,yC,d)}}return maxPositions}function avgPool2(args){let{inputs,backend:backend3,attrs}=args,{x}=inputs;assertNotComplex(x,"avgPool");let{filterSize,strides,pad:pad6,dimRoundingMode}=attrs,dilations=1;util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides,dilations),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);let convInfo=backend_util_exports.computePool2DInfo(x.shape,filterSize,strides,dilations,pad6,dimRoundingMode),res;if(convInfo.filterWidth===1&&convInfo.filterHeight===1&&util_exports.arraysEqual(convInfo.inShape,convInfo.outShape))res=identity({inputs:{x},backend:backend3});else{let xValues=backend3.data.get(x.dataId).values,strides2=util_exports.computeStrides(x.shape),buffer10=pool5(xValues,x.shape,x.dtype,strides2,convInfo,"avg");res=backend3.makeTensorInfo(convInfo.outShape,x.dtype,buffer10.values)}return res}var avgPoolConfig={kernelName:AvgPool,backendName:"cpu",kernelFunc:avgPool2};function avgPoolBackprop2(args){let{inputs,backend:backend3,attrs}=args,{dy,input:input2}=inputs,x=input2;assertNotComplex([dy,input2],"avgPoolBackprop");let{filterSize,strides,pad:pad6}=attrs,convInfo=backend_util_exports.computePool2DInfo(x.shape,filterSize,strides,1,pad6),strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padLeft=effectiveFilterWidth-1-convInfo.padInfo.left,padTop=effectiveFilterHeight-1-convInfo.padInfo.top,dx=buffer(x.shape,"float32"),avgMultiplier=1/(filterHeight*filterWidth),dyData=backend3.data.get(dy.dataId).values,dyBuf=buffer(dy.shape,"float32",dyData);for(let b=0;b<convInfo.batchSize;++b)for(let d=0;d<convInfo.inChannels;++d)for(let dxR=0;dxR<convInfo.inHeight;++dxR)for(let dxC=0;dxC<convInfo.inWidth;++dxC){let dyRCorner=dxR-padTop,dyCCorner=dxC-padLeft,dotProd=0;for(let wR=0;wR<effectiveFilterHeight;wR+=dilationHeight){let dyR=(dyRCorner+wR)/strideHeight;if(dyR<0||dyR>=convInfo.outHeight||Math.floor(dyR)!==dyR)continue;for(let wC=0;wC<effectiveFilterWidth;wC+=dilationWidth){let dyC=(dyCCorner+wC)/strideWidth;if(dyC<0||dyC>=convInfo.outWidth||Math.floor(dyC)!==dyC)continue;let pixel=dyBuf.get(b,dyR,dyC,d);dotProd+=pixel}}dx.set(dotProd*avgMultiplier,b,dxR,dxC,d)}return backend3.makeTensorInfo(dx.shape,dx.dtype,dx.values)}var avgPoolBackpropConfig={kernelName:AvgPoolBackprop,backendName:"cpu",kernelFunc:avgPoolBackprop2};function batchNorm2(args){let{inputs,backend:backend3,attrs}=args,{x,scale:scale2,offset,mean:mean7,variance}=inputs;util_exports.assert(mean7.shape.length===variance.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),util_exports.assert(offset==null||mean7.shape.length===offset.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),util_exports.assert(scale2==null||mean7.shape.length===scale2.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),assertNotComplex([x,mean7,variance,scale2,offset],"batchNorm");let{varianceEpsilon}=attrs;varianceEpsilon==null&&(varianceEpsilon=.001);let xVals=backend3.data.get(x.dataId).values,mVals=backend3.data.get(mean7.dataId).values,varVals=backend3.data.get(variance.dataId).values,sVals=scale2?backend3.data.get(scale2.dataId).values:new Float32Array([1]),offVals=offset?backend3.data.get(offset.dataId).values:new Float32Array([0]),outVals=new Float32Array(xVals.length),offValsLength=offVals.length,sValsLength=sVals.length,varValsLength=varVals.length,mValsLength=mVals.length,offi=0,mi=0,si=0,vi=0;for(let i=0;i<xVals.length;++i)outVals[i]=offVals[offi++]+(xVals[i]-mVals[mi++])*sVals[si++]/Math.sqrt(varVals[vi++]+varianceEpsilon),offi>=offValsLength&&(offi=0),mi>=mValsLength&&(mi=0),si>=sValsLength&&(si=0),vi>=varValsLength&&(vi=0);return backend3.makeTensorInfo(x.shape,x.dtype,outVals)}var batchNormConfig={kernelName:FusedBatchNorm,backendName:"cpu",kernelFunc:batchNorm2};var clip=unaryKernelFunc(ClipByValue,(xi,attrs)=>{let clipAttrs=attrs;return xi>clipAttrs.clipValueMax?clipAttrs.clipValueMax:xi<clipAttrs.clipValueMin?clipAttrs.clipValueMin:xi}),clipConfig={kernelName:ClipByValue,backendName:"cpu",kernelFunc:clip};function imag6(args){let{inputs,backend:backend3}=args,{input:input2}=inputs,imag8=backend3.data.get(input2.dataId).complexTensorInfos.imag,imagVal=backend3.data.get(imag8.dataId).values;return backend3.makeTensorInfo(imag8.shape,imag8.dtype,imagVal)}var imagConfig={kernelName:Imag,backendName:"cpu",kernelFunc:imag6};function concat16(args){let{inputs,backend:backend3,attrs}=args,{axis}=attrs,$axis=util_exports.parseAxisParam(axis,inputs[0].shape)[0],outShape=backend_util_exports.computeOutShape(inputs.map(t=>t.shape),$axis);if(util_exports.sizeFromShape(outShape)===0)return backend3.makeTensorInfo(outShape,inputs[0].dtype,[]);let $inputs=inputs.filter(t=>util_exports.sizeFromShape(t.shape)>0);if($inputs.length===1)return $inputs[0];let shapes=$inputs.map(t=>t.shape);if(backend_util_exports.assertParamsConsistent(shapes,$axis),$inputs[0].dtype==="complex64"){let reals=$inputs.map(t=>real6({inputs:{input:t},backend:backend3})),imags=$inputs.map(t=>imag6({inputs:{input:t},backend:backend3})),realConcated=concat16({inputs:reals,backend:backend3,attrs:{axis:$axis}}),imagConcated=concat16({inputs:imags,backend:backend3,attrs:{axis:$axis}}),result=complex9({inputs:{real:realConcated,imag:imagConcated},backend:backend3});return reals.forEach(r=>backend3.disposeIntermediateTensorInfo(r)),imags.forEach(i=>backend3.disposeIntermediateTensorInfo(i)),backend3.disposeIntermediateTensorInfo(realConcated),backend3.disposeIntermediateTensorInfo(imagConcated),result}let inputs2D=$inputs.map(t=>{let innerSize=util_exports.sizeFromShape(t.shape.slice($axis)),shape=[-1,innerSize];return reshape83({inputs:{x:t},backend:backend3,attrs:{shape}})});outShape=backend_util_exports.computeOutShape(inputs2D.map(t=>t.shape),1);let outVals=util_exports.getTypedArrayFromDType($inputs[0].dtype,util_exports.sizeFromShape(outShape));if(inputs2D[0].shape[0]===1){let offset=0;inputs2D.forEach(t=>{let val=backend3.data.get(t.dataId).values,size=util_exports.sizeFromShape(t.shape);outVals.set(val,offset),offset+=size})}else{let colOffset=0;inputs2D.forEach(t=>{let tVals=backend3.data.get(t.dataId).values,tIdx=0;for(let row=0;row<t.shape[0];++row){let resIdx=row*outShape[1]+colOffset;for(let col=0;col<t.shape[1];++col)outVals[resIdx+col]=tVals[tIdx++]}colOffset+=t.shape[1]})}let finalOutShape=backend_util_exports.computeOutShape($inputs.map(t=>t.shape),$axis),outInfo=backend3.makeTensorInfo(finalOutShape,inputs[0].dtype,outVals);return inputs2D.forEach(t=>backend3.disposeIntermediateTensorInfo(t)),outInfo}var concatConfig={kernelName:Concat,backendName:"cpu",kernelFunc:concat16};function conv2D(args){let{inputs,backend:backend3,attrs}=args,{x,filter}=inputs,{strides,pad:pad6,dataFormat,dilations,dimRoundingMode}=attrs;assertNotComplex([x,filter],"conv2d");let $dataFormat=backend_util_exports.convertConv2DDataFormat(dataFormat),convInfo=backend_util_exports.computeConv2DInfo(x.shape,filter.shape,strides,dilations,pad6,dimRoundingMode,!1,$dataFormat),filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,padLeft=convInfo.padInfo.left,padTop=convInfo.padInfo.top,isChannelsLast=convInfo.dataFormat==="channelsLast",y=new TensorBuffer(convInfo.outShape,x.dtype),xStrides=util_exports.computeStrides(x.shape),filterStrides=util_exports.computeStrides(filter.shape),xBatchStride=xStrides[0],xRowStride=isChannelsLast?xStrides[1]:xStrides[2],xColStride=isChannelsLast?xStrides[2]:1,xChannelStride=isChannelsLast?1:xStrides[1],yBatchStride=y.strides[0],yRowStride=isChannelsLast?y.strides[1]:y.strides[2],yColStride=isChannelsLast?y.strides[2]:1,yChannelStride=isChannelsLast?1:y.strides[1],xVals=backend3.data.get(x.dataId).values,wVals=backend3.data.get(filter.dataId).values,yVals=y.values;for(let b=0;b<convInfo.batchSize;++b){let xOffset1=b*xBatchStride,yOffset1=b*yBatchStride;for(let yR=0;yR<convInfo.outHeight;++yR){let yOffset2=yOffset1+yR*yRowStride,xRCorner=yR*convInfo.strideHeight-padTop;for(let wR=0;wR<filterHeight;++wR){let xR=xRCorner+wR*dilationHeight;if(xR<0||xR>=convInfo.inHeight)continue;let wOffset1=wR*filterStrides[0],xOffset2=xOffset1+xR*xRowStride;for(let yC=0;yC<convInfo.outWidth;++yC){let yOffset3=yOffset2+yC*yColStride,xCCorner=yC*convInfo.strideWidth-padLeft;for(let wC=0;wC<filterWidth;++wC){let xC=xCCorner+wC*dilationWidth;if(xC<0||xC>=convInfo.inWidth)continue;let wOffset2=wOffset1+wC*filterStrides[1],xOffset3=xOffset2+xC*xColStride,wOffset3=wOffset2;for(let d1=0;d1<convInfo.inChannels;++d1){let xVal=xVals[xOffset3+d1*xChannelStride];for(let d2=0;d2<convInfo.outChannels;++d2)yVals[yOffset3+d2*yChannelStride]+=xVal*wVals[wOffset3+d2];wOffset3+=convInfo.outChannels}}}}}}return backend3.makeTensorInfo(y.shape,y.dtype,yVals)}var conv2DConfig={kernelName:Conv2D,backendName:"cpu",kernelFunc:conv2D};function conv2DBackpropFilter2(args){let{inputs,backend:backend3,attrs}=args,{x,dy}=inputs,{strides,pad:pad6,dataFormat,dimRoundingMode,filterShape}=attrs;assertNotComplex([x,dy],"conv2dBackpropFilter");let $dataFormat=backend_util_exports.convertConv2DDataFormat(dataFormat),convInfo=backend_util_exports.computeConv2DInfo(x.shape,filterShape,strides,1,pad6,dimRoundingMode,!1,$dataFormat),{strideHeight,strideWidth,filterHeight,filterWidth}=convInfo,isChannelsLast=convInfo.dataFormat==="channelsLast",dW=new TensorBuffer(convInfo.filterShape,"float32"),leftPad=convInfo.padInfo.left,topPad=convInfo.padInfo.top,xVals=backend3.data.get(x.dataId).values,dyVals=backend3.data.get(dy.dataId).values,xBuf=new TensorBuffer(x.shape,x.dtype,xVals),dyBuf=new TensorBuffer(dy.shape,dy.dtype,dyVals);for(let wR=0;wR<filterHeight;++wR){let yRMin=Math.max(0,Math.ceil((topPad-wR)/strideHeight)),yRMax=Math.min(convInfo.outHeight,(convInfo.inHeight+topPad-wR)/strideHeight);for(let wC=0;wC<filterWidth;++wC){let yCMin=Math.max(0,Math.ceil((leftPad-wC)/strideWidth)),yCMax=Math.min(convInfo.outWidth,(convInfo.inWidth+leftPad-wC)/strideWidth);for(let d1=0;d1<convInfo.inChannels;++d1)for(let d2=0;d2<convInfo.outChannels;++d2){let dotProd=0;for(let b=0;b<convInfo.batchSize;++b)for(let yR=yRMin;yR<yRMax;++yR){let xR=wR+yR*strideHeight-topPad;for(let yC=yCMin;yC<yCMax;++yC){let xC=wC+yC*strideWidth-leftPad;isChannelsLast?dotProd+=xBuf.get(b,xR,xC,d1)*dyBuf.get(b,yR,yC,d2):dotProd+=xBuf.get(b,d1,xR,xC)*dyBuf.get(b,d2,yR,yC)}}dW.set(dotProd,wR,wC,d1,d2)}}}return backend3.makeTensorInfo(dW.shape,dW.dtype,dW.values)}var conv2DBackpropFilterConfig={kernelName:Conv2DBackpropFilter,backendName:"cpu",kernelFunc:conv2DBackpropFilter2};function conv2DBackpropInput2(args){let{inputs,backend:backend3,attrs}=args,{dy,filter}=inputs,{inputShape,strides,pad:pad6,dataFormat,dimRoundingMode}=attrs;assertNotComplex([dy,filter],"conv2dBackpropInput");let filterStrides=util_exports.computeStrides(filter.shape),dyStrides=util_exports.computeStrides(dy.shape),$dataFormat=backend_util_exports.convertConv2DDataFormat(dataFormat),convInfo=backend_util_exports.computeConv2DInfo(inputShape,filter.shape,strides,1,pad6,dimRoundingMode,!1,$dataFormat),dx=new TensorBuffer(convInfo.inShape,"float32"),dxValues=dx.values,dyValues=backend3.data.get(dy.dataId).values,fltValues=backend3.data.get(filter.dataId).values,[fltS0,fltS1,fltS2]=filterStrides,{batchSize,filterHeight,filterWidth,inChannels,inHeight,inWidth,outChannels,outHeight,outWidth,strideHeight,strideWidth}=convInfo;$dataFormat=convInfo.dataFormat;let topPad=filterHeight-1-convInfo.padInfo.top,leftPad=filterWidth-1-convInfo.padInfo.left,isChannelsLast=$dataFormat==="channelsLast",xBatchStride=dx.strides[0],xRowStride=isChannelsLast?dx.strides[1]:dx.strides[2],xColStride=isChannelsLast?dx.strides[2]:1,xChannelStride=isChannelsLast?1:dx.strides[1],yBatchStride=dyStrides[0],yRowStride=isChannelsLast?dyStrides[1]:dyStrides[2],yColStride=isChannelsLast?dyStrides[2]:1,yChannelStride=isChannelsLast?1:dyStrides[1];for(let b=0;b<batchSize;++b)for(let d1=0;d1<inChannels;++d1)for(let xR=0;xR<inHeight;++xR){let xRCorner=xR-topPad,xRMin=Math.max(0,Math.ceil(xRCorner/strideHeight)),yRMax=Math.min(outHeight,(filterHeight+xRCorner)/strideHeight);for(let xC=0;xC<inWidth;++xC){let xCCorner=xC-leftPad,xCMin=Math.max(0,Math.ceil(xCCorner/strideWidth)),yCMax=Math.min(outWidth,(filterWidth+xCCorner)/strideWidth),dotProd=0;for(let yR=xRMin;yR<yRMax;++yR){let wR=yR*strideHeight-xRCorner;for(let yC=xCMin;yC<yCMax;++yC){let wC=yC*strideWidth-xCCorner,dyOffset=yBatchStride*b+yRowStride*yR+yColStride*yC,fltOffset=fltS0*(filterHeight-1-wR)+fltS1*(filterWidth-1-wC)+fltS2*d1;for(let d2=0;d2<outChannels;++d2){let pixel=dyValues[dyOffset+yChannelStride*d2],weight=fltValues[fltOffset+d2];dotProd+=pixel*weight}}}let dxOffset=xBatchStride*b+xRowStride*xR+xColStride*xC+xChannelStride*d1;dxValues[dxOffset]=dotProd}}return backend3.makeTensorInfo(dx.shape,dx.dtype,dx.values)}var conv2DBackpropInputConfig={kernelName:Conv2DBackpropInput,backendName:"cpu",kernelFunc:conv2DBackpropInput2};function conv3D(args){let{inputs,backend:backend3,attrs}=args,{x,filter}=inputs,{strides,pad:pad6,dilations}=attrs;assertNotComplex([x,filter],"conv3d");let convInfo=backend_util_exports.computeConv3DInfo(x.shape,filter.shape,strides,dilations,pad6),{filterDepth,filterHeight,filterWidth,dilationDepth,dilationHeight,dilationWidth,padInfo}=convInfo,padFront=padInfo.front,padLeft=padInfo.left,padTop=padInfo.top,y=new TensorBuffer(convInfo.outShape,x.dtype),xVals=backend3.data.get(x.dataId).values,wVals=backend3.data.get(filter.dataId).values,yVals=y.values,xStrides=util_exports.computeStrides(x.shape),filterStrides=util_exports.computeStrides(filter.shape);for(let b=0;b<convInfo.batchSize;++b){let xOffset1=b*xStrides[0],yOffset1=b*y.strides[0];for(let yF=0;yF<convInfo.outDepth;++yF){let yOffset2=yOffset1+yF*y.strides[1],xFCorner=yF*convInfo.strideDepth-padFront;for(let wF=0;wF<filterDepth;++wF){let xF=xFCorner+wF*dilationDepth;if(xF<0||xF>=convInfo.inDepth)continue;let wOffset1=wF*filterStrides[0],xOffset2=xOffset1+xF*xStrides[1];for(let yR=0;yR<convInfo.outHeight;++yR){let yOffset3=yOffset2+yR*y.strides[2],xRCorner=yR*convInfo.strideHeight-padTop;for(let wR=0;wR<filterHeight;++wR){let xR=xRCorner+wR*dilationHeight;if(xR<0||xR>=convInfo.inHeight)continue;let wOffset2=wOffset1+wR*filterStrides[1],xOffset3=xOffset2+xR*xStrides[2];for(let yC=0;yC<convInfo.outWidth;++yC){let yOffset4=yOffset3+yC*convInfo.outChannels,xCCorner=yC*convInfo.strideWidth-padLeft;for(let wC=0;wC<filterWidth;++wC){let xC=xCCorner+wC*dilationWidth;if(xC<0||xC>=convInfo.inWidth)continue;let wOffset3=wOffset2+wC*filterStrides[2],xOffset4=xOffset3+xC*convInfo.inChannels,wOffset4=wOffset3;for(let d1=0;d1<convInfo.inChannels;++d1){let xVal=xVals[xOffset4+d1];for(let d2=0;d2<convInfo.outChannels;++d2)yVals[yOffset4+d2]+=xVal*wVals[wOffset4+d2];wOffset4+=convInfo.outChannels}}}}}}}}return backend3.makeTensorInfo(y.shape,y.dtype,y.values)}var conv3DConfig={kernelName:Conv3D,backendName:"cpu",kernelFunc:conv3D};function conv3DBackpropFilterV2(args){let{inputs,backend:backend3,attrs}=args,{x,dy}=inputs,{strides,pad:pad6,filterShape}=attrs;assertNotComplex([x,dy],"conv3dBackpropFilterV2");let xStrides=util_exports.computeStrides(x.shape),dyStrides=util_exports.computeStrides(dy.shape),convInfo=backend_util_exports.computeConv3DInfo(x.shape,filterShape,strides,1,pad6),strideDepth=convInfo.strideDepth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,filterDepth=convInfo.filterDepth,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,dw=new TensorBuffer(convInfo.filterShape,"float32"),dwValues=dw.values,[dwS0,dwS1,dwS2,dwS3]=dw.strides,dyValues=backend3.data.get(dy.dataId).values,[dyS0,dyS1,dyS2,dyS3]=dyStrides,xValues=backend3.data.get(x.dataId).values,[xS0,xS1,xS2,xS3]=xStrides,frontPad=convInfo.padInfo.front,leftPad=convInfo.padInfo.left,topPad=convInfo.padInfo.top;for(let wF=0;wF<filterDepth;++wF){let yFMin=Math.max(0,Math.ceil((frontPad-wF)/strideDepth)),yFMax=Math.min(convInfo.outDepth,(convInfo.inDepth+frontPad-wF)/strideDepth),wOffset1=wF*dwS0;for(let wR=0;wR<filterHeight;++wR){let yRMin=Math.max(0,Math.ceil((topPad-wR)/strideHeight)),yRMax=Math.min(convInfo.outHeight,(convInfo.inHeight+topPad-wR)/strideHeight),wOffset2=wR*dwS1+wOffset1;for(let wC=0;wC<filterWidth;++wC){let yCMin=Math.max(0,Math.ceil((leftPad-wC)/strideWidth)),yCMax=Math.min(convInfo.outWidth,(convInfo.inWidth+leftPad-wC)/strideWidth),wOffset3=wC*dwS2+wOffset2;for(let d1=0;d1<convInfo.inChannels;++d1){let wOffset4=d1*dwS3+wOffset3;for(let d2=0;d2<convInfo.outChannels;++d2){let dotProd=0;for(let b=0;b<convInfo.batchSize;++b){let xOffset1=b*xS0,yOffset1=b*dyS0;for(let yF=yFMin;yF<yFMax;++yF){let xF=wF+yF*strideDepth-frontPad,xOffset2=xF*xS1+xOffset1,yOffset2=yF*dyS1+yOffset1;for(let yR=yRMin;yR<yRMax;++yR){let xR=wR+yR*strideHeight-topPad,xOffset3=xR*xS2+xOffset2,yOffset3=yR*dyS2+yOffset2;for(let yC=yCMin;yC<yCMax;++yC){let xC=wC+yC*strideWidth-leftPad,xOffset4=xC*xS3+xOffset3,yOffset4=yC*dyS3+yOffset3;dotProd+=xValues[xOffset4+d1]*dyValues[yOffset4+d2]}}}}dwValues[wOffset4+d2]=dotProd}}}}}return backend3.makeTensorInfo(dw.shape,dw.dtype,dw.values)}var conv3DBackpropFilterV2Config={kernelName:Conv3DBackpropFilterV2,backendName:"cpu",kernelFunc:conv3DBackpropFilterV2};function conv3DBackpropInputV2(args){let{inputs,backend:backend3,attrs}=args,{dy,filter}=inputs,{pad:pad6,strides,inputShape}=attrs;assertNotComplex([dy],"conv3dBackpropInputV2");let dyStrides=util_exports.computeStrides(dy.shape),filterStrides=util_exports.computeStrides(filter.shape),convInfo=backend_util_exports.computeConv3DInfo(inputShape,filter.shape,strides,1,pad6),dx=new TensorBuffer(convInfo.inShape,"float32"),dxValues=dx.values,[dxS0,dxS1,dxS2,dxS3]=dx.strides,dyValues=backend3.data.get(dy.dataId).values,[dyS0,dyS1,dyS2,dyS3]=dyStrides,fltValues=backend3.data.get(filter.dataId).values,[fltS0,fltS1,fltS2,fltS3]=filterStrides,{batchSize,filterDepth,filterHeight,filterWidth,inChannels,inDepth,inHeight,inWidth,outChannels,outDepth,outHeight,outWidth,strideDepth,strideHeight,strideWidth}=convInfo,frontPad=filterDepth-1-convInfo.padInfo.front,topPad=filterHeight-1-convInfo.padInfo.top,leftPad=filterWidth-1-convInfo.padInfo.left;for(let b=0;b<batchSize;++b)for(let d1=0;d1<inChannels;++d1)for(let xF=0;xF<inDepth;++xF){let xFCorner=xF-frontPad,xFMin=Math.max(0,Math.ceil(xFCorner/strideDepth)),yFMax=Math.min(outDepth,(filterDepth+xFCorner)/strideDepth);for(let xR=0;xR<inHeight;++xR){let xRCorner=xR-topPad,xRMin=Math.max(0,Math.ceil(xRCorner/strideHeight)),yRMax=Math.min(outHeight,(filterHeight+xRCorner)/strideHeight);for(let xC=0;xC<inWidth;++xC){let xCCorner=xC-leftPad,xCMin=Math.max(0,Math.ceil(xCCorner/strideWidth)),yCMax=Math.min(outWidth,(filterWidth+xCCorner)/strideWidth),dotProd=0;for(let yF=xFMin;yF<yFMax;++yF){let wF=yF*strideDepth-xFCorner;for(let yR=xRMin;yR<yRMax;++yR){let wR=yR*strideHeight-xRCorner;for(let yC=xCMin;yC<yCMax;++yC){let wC=yC*strideWidth-xCCorner,dyOffset=dyS0*b+dyS1*yF+dyS2*yR+dyS3*yC,fltOffset=fltS0*(filterDepth-1-wF)+fltS1*(filterHeight-1-wR)+fltS2*(filterWidth-1-wC)+fltS3*d1;for(let d2=0;d2<outChannels;++d2){let pixel=dyValues[dyOffset+d2],weight=fltValues[fltOffset+d2];dotProd+=pixel*weight}}}}dxValues[dxS0*b+dxS1*xF+dxS2*xR+dxS3*xC+d1]=dotProd}}}return backend3.makeTensorInfo(dx.shape,dx.dtype,dx.values)}var conv3DBackpropInputV2Config={kernelName:Conv3DBackpropInputV2,backendName:"cpu",kernelFunc:conv3DBackpropInputV2};var cos6=unaryKernelFunc(Cos,xi=>Math.cos(xi)),cosConfig={kernelName:Cos,backendName:"cpu",kernelFunc:cos6};var cosh5=unaryKernelFunc(Cosh,xi=>Math.cosh(xi)),coshConfig={kernelName:Cosh,backendName:"cpu",kernelFunc:cosh5};function depthwiseConv2dNative(args){let{inputs,backend:backend3,attrs}=args,{x,filter}=inputs,{strides,pad:pad6,dilations,dimRoundingMode}=attrs;assertNotComplex([x,filter],"depthwiseConv2DNative");let xStrides=util_exports.computeStrides(x.shape),filterStrides=util_exports.computeStrides(filter.shape),$dilations=dilations;$dilations==null&&($dilations=[1,1]),util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides,$dilations),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${$dilations}'`);let convInfo=backend_util_exports.computeConv2DInfo(x.shape,filter.shape,strides,$dilations,pad6,dimRoundingMode,!0),{filterHeight,filterWidth,dilationHeight,dilationWidth,padInfo}=convInfo,padLeft=padInfo.left,padTop=padInfo.top,chMul=convInfo.outChannels/convInfo.inChannels,y=new TensorBuffer(convInfo.outShape,x.dtype),xVals=backend3.data.get(x.dataId).values,wVals=backend3.data.get(filter.dataId).values,yVals=y.values;for(let b=0;b<convInfo.batchSize;++b){let xOffset1=b*xStrides[0],yOffset1=b*y.strides[0];for(let yR=0;yR<convInfo.outHeight;++yR){let yOffset2=yOffset1+yR*y.strides[1],xRCorner=yR*convInfo.strideHeight-padLeft;for(let wR=0;wR<filterHeight;++wR){let xR=xRCorner+wR*dilationHeight;if(xR<0||xR>=convInfo.inHeight)continue;let wOffset1=wR*filterStrides[0],xOffset2=xOffset1+xR*xStrides[1];for(let yC=0;yC<convInfo.outWidth;++yC){let yOffset3=yOffset2+yC*y.strides[2],xCCorner=yC*convInfo.strideWidth-padTop;for(let wC=0;wC<filterWidth;++wC){let xC=xCCorner+wC*dilationWidth;if(xC<0||xC>=convInfo.inWidth)continue;let wOffset2=wOffset1+wC*filterStrides[1],xOffset3=xOffset2+xC*convInfo.inChannels,yOffset4=yOffset3,wOffset3=wOffset2;for(let d1=0;d1<convInfo.inChannels;++d1){let xVal=xVals[xOffset3+d1];for(let q=0;q<chMul;++q)yVals[yOffset4+q]+=xVal*wVals[wOffset3+q];yOffset4+=chMul,wOffset3+=chMul}}}}}}return backend3.makeTensorInfo(y.shape,y.dtype,y.values)}var depthwiseConv2dNativeConfig={kernelName:DepthwiseConv2dNative,backendName:"cpu",kernelFunc:depthwiseConv2dNative};function depthwiseConv2dNativeBackpropFilter2(args){let{inputs,backend:backend3,attrs}=args,{x,dy}=inputs,{strides,dilations,pad:pad6,dimRoundingMode,filterShape}=attrs;assertNotComplex([x,dy],"depthwiseConv2dNativeBackpropFilter");let convInfo=backend_util_exports.computeConv2DInfo(x.shape,filterShape,strides,dilations,pad6,dimRoundingMode,!0),{strideHeight,strideWidth,filterHeight,filterWidth}=convInfo,dW=new TensorBuffer(convInfo.filterShape,"float32"),leftPad=convInfo.padInfo.left,topPad=convInfo.padInfo.top,chMul=convInfo.outChannels/convInfo.inChannels,xVals=backend3.data.get(x.dataId).values,xBuf=new TensorBuffer(x.shape,x.dtype,xVals),dyVals=backend3.data.get(dy.dataId).values,dyBuf=new TensorBuffer(dy.shape,dy.dtype,dyVals);for(let wR=0;wR<filterHeight;++wR){let yRMin=Math.max(0,Math.ceil((topPad-wR)/strideHeight)),yRMax=Math.min(convInfo.outHeight,(convInfo.inHeight+topPad-wR)/strideHeight);for(let wC=0;wC<filterWidth;++wC){let yCMin=Math.max(0,Math.ceil((leftPad-wC)/strideWidth)),yCMax=Math.min(convInfo.outWidth,(convInfo.inWidth+leftPad-wC)/strideWidth);for(let d2=0;d2<convInfo.outChannels;++d2){let d1=Math.trunc(d2/chMul),dm=d2%chMul,dotProd=0;for(let b=0;b<convInfo.batchSize;++b)for(let yR=yRMin;yR<yRMax;++yR){let xR=wR+yR*strideHeight-topPad;for(let yC=yCMin;yC<yCMax;++yC){let xC=wC+yC*strideWidth-leftPad;dotProd+=xBuf.get(b,xR,xC,d1)*dyBuf.get(b,yR,yC,d2)}}dW.set(dotProd,wR,wC,d1,dm)}}}return backend3.makeTensorInfo(dW.shape,dW.dtype,dW.values)}var depthwiseConv2dNativeBackpropFilterConfig={kernelName:DepthwiseConv2dNativeBackpropFilter,backendName:"cpu",kernelFunc:depthwiseConv2dNativeBackpropFilter2};function depthwiseConv2dNativeBackpropInput2(args){let{inputs,backend:backend3,attrs}=args,{dy,filter}=inputs,{strides,dilations,pad:pad6,dimRoundingMode,inputShape}=attrs;assertNotComplex([dy,filter],"depthwiseConv2DNativeBackpropInput");let dyStrides=util_exports.computeStrides(dy.shape),filterStrides=util_exports.computeStrides(filter.shape),convInfo=backend_util_exports.computeConv2DInfo(inputShape,filter.shape,strides,dilations,pad6,dimRoundingMode,!0),dx=new TensorBuffer(convInfo.inShape,"float32"),dxValues=dx.values,[dxS0,dxS1,dxS2]=dx.strides,dyValues=backend3.data.get(dy.dataId).values,[dyS0,dyS1,dyS2]=dyStrides,fltValues=backend3.data.get(filter.dataId).values,[fltS0,fltS1,fltS2]=filterStrides,{batchSize,filterHeight,filterWidth,inChannels,inHeight,inWidth,outChannels,outHeight,outWidth,strideHeight,strideWidth}=convInfo,topPad=filterHeight-1-convInfo.padInfo.top,leftPad=filterWidth-1-convInfo.padInfo.left,chMul=outChannels/inChannels;for(let b=0;b<batchSize;++b)for(let d1=0;d1<inChannels;++d1)for(let xR=0;xR<inHeight;++xR){let xRCorner=xR-topPad,xRMin=Math.max(0,Math.ceil(xRCorner/strideHeight)),yRMax=Math.min(outHeight,(filterHeight+xRCorner)/strideHeight);for(let xC=0;xC<inWidth;++xC){let xCCorner=xC-leftPad,xCMin=Math.max(0,Math.ceil(xCCorner/strideWidth)),yCMax=Math.min(outWidth,(filterWidth+xCCorner)/strideWidth),dotProd=0;for(let yR=xRMin;yR<yRMax;++yR){let wR=yR*strideHeight-xRCorner;for(let yC=xCMin;yC<yCMax;++yC){let wC=yC*strideWidth-xCCorner,dyOffset=dyS0*b+dyS1*yR+dyS2*yC,fltOffset=fltS0*(filterHeight-1-wR)+fltS1*(filterWidth-1-wC)+fltS2*d1;for(let dm=0;dm<chMul;++dm){let d2=d1*chMul+dm,pixel=dyValues[dyOffset+d2],weight=fltValues[fltOffset+dm];dotProd+=pixel*weight}}}dxValues[dxS0*b+dxS1*xR+dxS2*xC+d1]=dotProd}}return backend3.makeTensorInfo(dx.shape,dx.dtype,dx.values)}var depthwiseConv2dNativeBackpropInputConfig={kernelName:DepthwiseConv2dNativeBackpropInput,backendName:"cpu",kernelFunc:depthwiseConv2dNativeBackpropInput2};var dilation2dConfig={kernelName:Dilation2D,backendName:"cpu",kernelFunc:({inputs,backend:backend3,attrs})=>{let{x,filter}=inputs,{strides,pad:pad6,dilations}=attrs,cpuBackend=backend3,xVals=cpuBackend.data.get(x.dataId).values,xRank=x.shape.length,filterVals=cpuBackend.data.get(filter.dataId).values,filterRank=filter.shape.length,{batchSize,inHeight,inWidth,inChannels,outHeight,outWidth,padInfo,strideHeight,strideWidth,filterHeight,filterWidth,dilationHeight,dilationWidth,outShape}=backend_util_exports.computeDilation2DInfo(x.shape,filter.shape,strides,pad6,"NHWC",dilations),outSize=util_exports.sizeFromShape(outShape),outRank=outShape.length,outputVals=util_exports.getArrayFromDType(x.dtype,outSize);for(let b=0;b<batchSize;++b)for(let hOut=0;hOut<outHeight;++hOut){let hBeg=hOut*strideHeight-padInfo.top;for(let wOut=0;wOut<outWidth;++wOut){let wBeg=wOut*strideWidth-padInfo.left;for(let d=0;d<inChannels;++d){let curVal=Number.MIN_SAFE_INTEGER;for(let h=0;h<filterHeight;++h){let hIn=hBeg+h*dilationHeight;if(hIn>=0&&hIn<inHeight)for(let w=0;w<filterWidth;++w){let wIn=wBeg+w*dilationWidth;if(wIn>=0&&wIn<inWidth){let xIndex=util_exports.locToIndex([b,hIn,wIn,d],xRank,util_exports.computeStrides(x.shape)),filterIndex=util_exports.locToIndex([h,w,d],filterRank,util_exports.computeStrides(filter.shape)),val=xVals[xIndex]+filterVals[filterIndex];val>curVal&&(curVal=val)}}}let outputIndex=util_exports.locToIndex([b,hOut,wOut,d],outRank,util_exports.computeStrides(outShape));outputVals[outputIndex]=curVal}}}let dataId=cpuBackend.write(util_exports.toTypedArray(outputVals,x.dtype),outShape,x.dtype);return{dataId,shape:outShape,dtype:x.dtype}}};var dilation2dBackpropFilterConfig={kernelName:Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:({inputs,backend:backend3,attrs})=>{let{x,filter,dy}=inputs,{strides,pad:pad6,dilations}=attrs,cpuBackend=backend3,$x=util_exports.toNestedArray(x.shape,cpuBackend.data.get(x.dataId).values),$filter=util_exports.toNestedArray(filter.shape,cpuBackend.data.get(filter.dataId).values),{batchSize,inHeight,inWidth,inChannels,outHeight,outWidth,padInfo,strideHeight,strideWidth,filterHeight,filterWidth,dilationHeight,dilationWidth,outShape}=backend_util_exports.computeDilation2DInfo(x.shape,filter.shape,strides,pad6,"NHWC",dilations);util_exports.assert(dy.rank===outShape.length,()=>`Error in ${Dilation2DBackpropFilter}, dy must have the same rank as output ${outShape.length}, but got ${dy.rank}`);let $dy=util_exports.toNestedArray(outShape,cpuBackend.data.get(dy.dataId).values),gradients8=util_exports.makeZerosNestedTypedArray(filter.shape,filter.dtype);for(let b=0;b<batchSize;++b)for(let hOut=0;hOut<outHeight;++hOut){let hBeg=hOut*strideHeight-padInfo.top;for(let wOut=0;wOut<outWidth;++wOut){let wBeg=wOut*strideWidth-padInfo.left;for(let d=0;d<inChannels;++d){let curVal=Number.MIN_SAFE_INTEGER,hMax=0,wMax=0;for(let h=0;h<filterHeight;++h){let hIn=hBeg+h*dilationHeight;if(hIn>=0&&hIn<inHeight)for(let w=0;w<filterWidth;++w){let wIn=wBeg+w*dilationWidth;if(wIn>=0&&wIn<inWidth){let val=$x[b][hIn][wIn][d]+$filter[h][w][d];val>curVal&&(curVal=val,hMax=h,wMax=w)}}}gradients8[hMax][wMax][d]+=$dy[b][hOut][wOut][d]}}}let dataId=cpuBackend.write(util_exports.toTypedArray(gradients8,x.dtype),filter.shape,filter.dtype);return{dataId,shape:filter.shape,dtype:filter.dtype}}};var dilation2dBackpropInputConfig={kernelName:Dilation2DBackpropInput,backendName:"cpu",kernelFunc:({inputs,backend:backend3,attrs})=>{let{x,filter,dy}=inputs,{strides,pad:pad6,dilations}=attrs,cpuBackend=backend3,$x=util_exports.toNestedArray(x.shape,cpuBackend.data.get(x.dataId).values),$filter=util_exports.toNestedArray(filter.shape,cpuBackend.data.get(filter.dataId).values),{batchSize,inHeight,inWidth,inChannels,outHeight,outWidth,padInfo,strideHeight,strideWidth,filterHeight,filterWidth,dilationHeight,dilationWidth,outShape}=backend_util_exports.computeDilation2DInfo(x.shape,filter.shape,strides,pad6,"NHWC",dilations);util_exports.assert(dy.rank===outShape.length,()=>`Error in ${Dilation2DBackpropInput}, dy must have the same rank as output ${outShape.length}, but got ${dy.rank}`);let $dy=util_exports.toNestedArray(outShape,cpuBackend.data.get(dy.dataId).values),gradients8=util_exports.makeZerosNestedTypedArray(x.shape,x.dtype);for(let b=0;b<batchSize;++b)for(let hOut=0;hOut<outHeight;++hOut){let hBeg=hOut*strideHeight-padInfo.top;for(let wOut=0;wOut<outWidth;++wOut){let wBeg=wOut*strideWidth-padInfo.left;for(let d=0;d<inChannels;++d){let curVal=Number.MIN_SAFE_INTEGER,hInMax=hBeg<0?0:hBeg,wInMax=wBeg<0?0:wBeg;for(let h=0;h<filterHeight;++h){let hIn=hBeg+h*dilationHeight;if(hIn>=0&&hIn<inHeight)for(let w=0;w<filterWidth;++w){let wIn=wBeg+w*dilationWidth;if(wIn>=0&&wIn<inWidth){let val=$x[b][hIn][wIn][d]+$filter[h][w][d];val>curVal&&(curVal=val,hInMax=hIn,wInMax=wIn)}}}gradients8[b][hInMax][wInMax][d]+=$dy[b][hOut][wOut][d]}}}let dataId=cpuBackend.write(util_exports.toTypedArray(gradients8,x.dtype),x.shape,x.dtype);return{dataId,shape:x.shape,dtype:x.dtype}}};var divImpl=createSimpleBinaryKernelImpl((a,b)=>a/b),div34=binaryKernelFunc(Div,divImpl),divConfig={kernelName:Div,backendName:"cpu",kernelFunc:div34};var p=backend_util_exports.ERF_P,a1=backend_util_exports.ERF_A1,a2=backend_util_exports.ERF_A2,a3=backend_util_exports.ERF_A3,a4=backend_util_exports.ERF_A4,a5=backend_util_exports.ERF_A5,erf4=unaryKernelFunc(Erf,xi=>{let sign5=Math.sign(xi),v=Math.abs(xi),t=1/(1+p*v);return sign5*(1-((((a5*t+a4)*t+a3)*t+a2)*t+a1)*t*Math.exp(-v*v))}),erfConfig={kernelName:Erf,backendName:"cpu",kernelFunc:erf4};function fftBatch(input2,inverse,cpuBackend){let inputShape=input2.shape,batch=inputShape[0],innerDim=inputShape[1],inputVals=cpuBackend.data.get(input2.dataId),real2D=inputVals.complexTensorInfos.real,imag2D=inputVals.complexTensorInfos.imag,resultShape=[batch,innerDim],resultSize=util_exports.sizeFromShape(resultShape),resultReal=util_exports.getTypedArrayFromDType("float32",resultSize),resultImag=util_exports.getTypedArrayFromDType("float32",resultSize);for(let b=0;b<batch;b++){let r=slice18({inputs:{x:real2D},backend:cpuBackend,attrs:{begin:[b,0],size:[1,innerDim]}}),i=slice18({inputs:{x:imag2D},backend:cpuBackend,attrs:{begin:[b,0],size:[1,innerDim]}}),input3=complex9({inputs:{real:r,imag:i},backend:cpuBackend}),{real:real8,imag:imag8}=fftImpl(input3,inverse,cpuBackend),res=backend_util_exports.mergeRealAndImagArrays(real8,imag8);for(let d=0;d<innerDim;d++){let c=backend_util_exports.getComplexWithIndex(res,d);resultReal[b*innerDim+d]=c.real,resultImag[b*innerDim+d]=c.imag}cpuBackend.disposeIntermediateTensorInfo(r),cpuBackend.disposeIntermediateTensorInfo(i),cpuBackend.disposeIntermediateTensorInfo(input3)}let $realInfo=cpuBackend.makeTensorInfo(resultShape,"float32",resultReal),$imagInfo=cpuBackend.makeTensorInfo(resultShape,"float32",resultImag),result=complex9({inputs:{real:$realInfo,imag:$imagInfo},backend:cpuBackend});return cpuBackend.disposeIntermediateTensorInfo($realInfo),cpuBackend.disposeIntermediateTensorInfo($imagInfo),result}function fftImpl(input2,inverse,cpuBackend){let inputSize=util_exports.sizeFromShape(input2.shape),inputVals=cpuBackend.data.get(input2.dataId),realVals=cpuBackend.data.get(inputVals.complexTensorInfos.real.dataId).values,imagVals=cpuBackend.data.get(inputVals.complexTensorInfos.imag.dataId).values;if(isExponentOf2(inputSize)){let result=fftRadix2(realVals,imagVals,inputSize,inverse,cpuBackend),resultShape=[input2.shape[0],input2.shape[1]];if(inverse){let realInfo=cpuBackend.makeTensorInfo(resultShape,"float32",result.real),imagInfo=cpuBackend.makeTensorInfo(resultShape,"float32",result.imag),sizeInfo=cpuBackend.makeTensorInfo([],"float32",util_exports.createScalarValue(inputSize,"float32")),sizeInfoCopy=identity({inputs:{x:sizeInfo},backend:cpuBackend}),divRealInfo=divConfig.kernelFunc({inputs:{a:realInfo,b:sizeInfo},backend:cpuBackend}),divImagInfo=divConfig.kernelFunc({inputs:{a:imagInfo,b:sizeInfoCopy},backend:cpuBackend}),divRealVals=cpuBackend.data.get(divRealInfo.dataId).values,divImagVals=cpuBackend.data.get(divImagInfo.dataId).values;return cpuBackend.disposeIntermediateTensorInfo(realInfo),cpuBackend.disposeIntermediateTensorInfo(imagInfo),cpuBackend.disposeIntermediateTensorInfo(sizeInfo),cpuBackend.disposeIntermediateTensorInfo(sizeInfoCopy),cpuBackend.disposeIntermediateTensorInfo(divRealInfo),cpuBackend.disposeIntermediateTensorInfo(divImagInfo),{real:divRealVals,imag:divImagVals}}return result}else{let data=backend_util_exports.mergeRealAndImagArrays(realVals,imagVals),rawOutput=fourierTransformByMatmul(data,inputSize,inverse);return backend_util_exports.splitRealAndImagArrays(rawOutput)}}function isExponentOf2(size){return(size&size-1)===0}function fftRadix2(realVals,imagVals,size,inverse,cpuBackend){if(size===1)return{real:realVals,imag:imagVals};let data=backend_util_exports.mergeRealAndImagArrays(realVals,imagVals),half=size/2,evenComplex=backend_util_exports.complexWithEvenIndex(data),evenRealVals=evenComplex.real,evenImagVals=evenComplex.imag,evenShape=[evenRealVals.length],evenRealInfo=cpuBackend.makeTensorInfo(evenShape,"float32",evenRealVals),evenImagInfo=cpuBackend.makeTensorInfo(evenShape,"float32",evenImagVals),evenTensorInfo=complex9({inputs:{real:evenRealInfo,imag:evenImagInfo},backend:cpuBackend}),oddComplex=backend_util_exports.complexWithOddIndex(data),oddRealVals=oddComplex.real,oddImagVals=oddComplex.imag,oddShape=[oddRealVals.length],oddRealInfo=cpuBackend.makeTensorInfo(oddShape,"float32",oddRealVals),oddImagInfo=cpuBackend.makeTensorInfo(oddShape,"float32",oddImagVals),oddTensorInfo=complex9({inputs:{real:oddRealInfo,imag:oddImagInfo},backend:cpuBackend}),$evenComplex=fftRadix2(evenRealVals,evenImagVals,half,inverse,cpuBackend),$evenRealVals=$evenComplex.real,$evenImagVals=$evenComplex.imag,$evenShape=[$evenRealVals.length],$evenRealInfo=cpuBackend.makeTensorInfo($evenShape,"float32",$evenRealVals),$evenImagInfo=cpuBackend.makeTensorInfo($evenShape,"float32",$evenImagVals),$evenTensorInfo=complex9({inputs:{real:$evenRealInfo,imag:$evenImagInfo},backend:cpuBackend}),$oddComplex=fftRadix2(oddRealVals,oddImagVals,half,inverse,cpuBackend),$oddRealVals=$oddComplex.real,$oddImagVals=$oddComplex.imag,$oddShape=[$oddRealVals.length],$oddRealInfo=cpuBackend.makeTensorInfo($oddShape,"float32",$oddRealVals),$oddImagInfo=cpuBackend.makeTensorInfo($oddShape,"float32",$oddImagVals),$oddTensorInfo=complex9({inputs:{real:$oddRealInfo,imag:$oddImagInfo},backend:cpuBackend}),e=backend_util_exports.exponents(size,inverse),eShape=[e.real.length],eRealInfo=cpuBackend.makeTensorInfo(eShape,"float32",e.real),eImagInfo=cpuBackend.makeTensorInfo(eShape,"float32",e.imag),complexInfo=complex9({inputs:{real:eRealInfo,imag:eImagInfo},backend:cpuBackend}),exponentInfo=multiply({inputs:{a:complexInfo,b:$oddTensorInfo},backend:cpuBackend}),addPart=add29({inputs:{a:$evenTensorInfo,b:exponentInfo},backend:cpuBackend}),subPart=sub33({inputs:{a:$evenTensorInfo,b:exponentInfo},backend:cpuBackend}),addPartReal=real6({inputs:{input:addPart},backend:cpuBackend}),subPartReal=real6({inputs:{input:subPart},backend:cpuBackend}),addPartImag=imag6({inputs:{input:addPart},backend:cpuBackend}),subPartImag=imag6({inputs:{input:subPart},backend:cpuBackend}),$real=concat16({inputs:[addPartReal,subPartReal],backend:cpuBackend,attrs:{axis:0}}),$imag=concat16({inputs:[addPartImag,subPartImag],backend:cpuBackend,attrs:{axis:0}}),$realVals=cpuBackend.data.get($real.dataId).values,$imagVals=cpuBackend.data.get($imag.dataId).values;return cpuBackend.disposeIntermediateTensorInfo(evenRealInfo),cpuBackend.disposeIntermediateTensorInfo(evenImagInfo),cpuBackend.disposeIntermediateTensorInfo(evenTensorInfo),cpuBackend.disposeIntermediateTensorInfo(oddRealInfo),cpuBackend.disposeIntermediateTensorInfo(oddImagInfo),cpuBackend.disposeIntermediateTensorInfo(oddTensorInfo),cpuBackend.disposeIntermediateTensorInfo($evenRealInfo),cpuBackend.disposeIntermediateTensorInfo($evenImagInfo),cpuBackend.disposeIntermediateTensorInfo($evenTensorInfo),cpuBackend.disposeIntermediateTensorInfo($oddRealInfo),cpuBackend.disposeIntermediateTensorInfo($oddImagInfo),cpuBackend.disposeIntermediateTensorInfo($oddTensorInfo),cpuBackend.disposeIntermediateTensorInfo(eRealInfo),cpuBackend.disposeIntermediateTensorInfo(eImagInfo),cpuBackend.disposeIntermediateTensorInfo(complexInfo),cpuBackend.disposeIntermediateTensorInfo(exponentInfo),cpuBackend.disposeIntermediateTensorInfo(addPart),cpuBackend.disposeIntermediateTensorInfo(subPart),cpuBackend.disposeIntermediateTensorInfo(addPartReal),cpuBackend.disposeIntermediateTensorInfo(addPartImag),cpuBackend.disposeIntermediateTensorInfo(subPartReal),cpuBackend.disposeIntermediateTensorInfo(subPartImag),cpuBackend.disposeIntermediateTensorInfo($real),cpuBackend.disposeIntermediateTensorInfo($imag),{real:$realVals,imag:$imagVals}}function fourierTransformByMatmul(data,size,inverse){let ret=new Float32Array(size*2);for(let r=0;r<size;r++){let real8=0,imag8=0;for(let c=0;c<size;c++){let e=backend_util_exports.exponent(r*c,size,inverse),term=backend_util_exports.getComplexWithIndex(data,c);real8+=term.real*e.real-term.imag*e.imag,imag8+=term.real*e.imag+term.imag*e.real}inverse&&(real8/=size,imag8/=size),backend_util_exports.assignToTypedArray(ret,real8,imag8,r)}return ret}function fft6(args){let{inputs,backend:backend3}=args,{input:input2}=inputs,inputSize=util_exports.sizeFromShape(input2.shape),innerDimensionSize=input2.shape[input2.shape.length-1],batch=inputSize/innerDimensionSize,input2D=reshape83({inputs:{x:input2},backend:backend3,attrs:{shape:[batch,innerDimensionSize]}}),result=fftBatch(input2D,!1,backend3),resultReshaped=reshape83({inputs:{x:result},backend:backend3,attrs:{shape:input2.shape}});return backend3.disposeIntermediateTensorInfo(input2D),backend3.disposeIntermediateTensorInfo(result),resultReshaped}var fftConfig={kernelName:FFT,backendName:"cpu",kernelFunc:fft6};function fill5(args){let{backend:backend3,attrs}=args,{shape,value,dtype}=attrs,$dtype=dtype||util_exports.inferDtype(value),values=util_exports.getArrayFromDType($dtype,util_exports.sizeFromShape(shape));return fillValues(values,value,$dtype),backend3.makeTensorInfo(shape,$dtype,values)}var fillConfig={kernelName:Fill,backendName:"cpu",kernelFunc:fill5};function fillValues(values,value,dtype){dtype==="string",values.fill(value)}var flipLeftRightConfig={kernelName:FlipLeftRight,backendName:"cpu",kernelFunc:({inputs,attrs,backend:backend3})=>{let{image:image3}=inputs,cpuBackend=backend3,output=util_exports.getTypedArrayFromDType(image3.dtype,util_exports.sizeFromShape(image3.shape)),[batch,imageHeight,imageWidth,numChannels]=image3.shape,imageVals=cpuBackend.data.get(image3.dataId).values;for(let batchIdx=0;batchIdx<batch;batchIdx++){let batchOffset=batchIdx*imageWidth*imageHeight*numChannels;for(let row=0;row<imageHeight;row++){let rowOffset=row*(imageWidth*numChannels);for(let col=0;col<imageWidth;col++){let colOffset=col*numChannels;for(let channel=0;channel<numChannels;channel++){let coords2=[batch,row,col,channel],x=coords2[2],coordX=Math.round(imageWidth-x),outIdx=batchOffset+rowOffset+colOffset+channel,outputValue=imageVals[outIdx];if(coordX>=0&&coordX<imageWidth){let rotatedColOffset=coordX*numChannels,imageIdx=batchOffset+rowOffset+rotatedColOffset+channel;outputValue=imageVals[imageIdx]}output[outIdx]=outputValue}}}}let dataId=cpuBackend.write(output,image3.shape,image3.dtype);return{dataId,shape:image3.shape,dtype:image3.dtype}}};function fusedConv2D(args){let{inputs,backend:backend3,attrs}=args,{x,filter,bias,preluActivationWeights}=inputs,{strides,pad:pad6,dataFormat,dilations,dimRoundingMode,activation}=attrs,result=conv2D({inputs:{x,filter},backend:backend3,attrs:{strides,pad:pad6,dataFormat,dilations,dimRoundingMode}});if(bias){let resultOld=result;result=add29({inputs:{a:result,b:bias},backend:backend3}),backend3.disposeIntermediateTensorInfo(resultOld)}if(activation){let resultOld=result;result=applyActivation2(backend3,result,activation,preluActivationWeights),backend3.disposeIntermediateTensorInfo(resultOld)}return result}var fusedConv2DConfig={kernelName:FusedConv2D,backendName:"cpu",kernelFunc:fusedConv2D};function fusedDepthwiseConv2D(args){let{inputs,backend:backend3,attrs}=args,{x,filter,bias,preluActivationWeights}=inputs,{strides,pad:pad6,dataFormat,dilations,dimRoundingMode,activation}=attrs,result=depthwiseConv2dNative({inputs:{x,filter},backend:backend3,attrs:{strides,pad:pad6,dataFormat,dilations,dimRoundingMode}});if(bias){let oldResult=result;result=add29({inputs:{a:result,b:bias},backend:backend3}),backend3.disposeIntermediateTensorInfo(oldResult)}if(activation){let oldResult=result;result=applyActivation2(backend3,result,activation,preluActivationWeights),backend3.disposeIntermediateTensorInfo(oldResult)}return result}var fusedDepthwiseConv2DConfig={kernelName:FusedDepthwiseConv2D,backendName:"cpu",kernelFunc:fusedDepthwiseConv2D};function ifft6(args){let{inputs,backend:backend3}=args,{input:input2}=inputs,inputSize=util_exports.sizeFromShape(input2.shape),innerDimensionSize=input2.shape[input2.shape.length-1],batch=inputSize/innerDimensionSize,input2D=reshape83({inputs:{x:input2},backend:backend3,attrs:{shape:[batch,innerDimensionSize]}}),result=fftBatch(input2D,!0,backend3),resultReshaped=reshape83({inputs:{x:result},backend:backend3,attrs:{shape:input2.shape}});return backend3.disposeIntermediateTensorInfo(input2D),backend3.disposeIntermediateTensorInfo(result),resultReshaped}var ifftConfig={kernelName:IFFT,backendName:"cpu",kernelFunc:ifft6};var isFinite3=unaryKernelFunc(IsFinite,xi=>Number.isFinite(xi)?1:0,"bool"),isFiniteConfig={kernelName:IsFinite,backendName:"cpu",kernelFunc:isFinite3};var isInf2=unaryKernelFunc(IsInf,xi=>Math.abs(xi)===Infinity?1:0,"bool"),isInfConfig={kernelName:IsInf,backendName:"cpu",kernelFunc:isInf2};var isNaN3=unaryKernelFunc(IsNan,xi=>Number.isNaN(xi)?1:0,"bool"),isNaNConfig={kernelName:IsNan,backendName:"cpu",kernelFunc:isNaN3};var log1p5=unaryKernelFunc(Log1p,xi=>Math.log1p(xi)),log1pConfig={kernelName:Log1p,backendName:"cpu",kernelFunc:log1p5};var logicalNot2=unaryKernelFunc(LogicalNot,xi=>xi?0:1,"bool"),logicalNotConfig={kernelName:LogicalNot,backendName:"cpu",kernelFunc:logicalNot2};var maxConfig={kernelName:Max,backendName:"cpu",kernelFunc:({inputs,attrs,backend:backend3})=>{let{x}=inputs,{reductionIndices,keepDims}=attrs,cpuBackend=backend3,xShape=x.shape,xRank=xShape.length,origAxes=util_exports.parseAxisParam(reductionIndices,xShape),axes=origAxes,permutedAxes=backend_util_exports.getAxesPermutation(axes,xRank),xVals=cpuBackend.data.get(x.dataId).values;if(permutedAxes!=null){let newShape=new Array(xRank);for(let i=0;i<newShape.length;i++)newShape[i]=xShape[permutedAxes[i]];xVals=transposeImpl(xVals,xShape,x.dtype,permutedAxes,newShape),axes=backend_util_exports.getInnerMostAxes(axes.length,xRank),xShape=newShape}assertNotComplex(x,"max"),backend_util_exports.assertAxesAreInnerMostDims("max",axes,xRank);let[maxOutShape,reduceShape]=backend_util_exports.computeOutAndReduceShapes(xShape,axes),reduceSize=util_exports.sizeFromShape(reduceShape),result=maxImpl(xVals,reduceSize,maxOutShape,x.dtype),dataId=cpuBackend.write(result,maxOutShape,x.dtype),outShape=maxOutShape;if(keepDims){let newShape=backend_util_exports.expandShapeToKeepDim(maxOutShape,origAxes);outShape=newShape}return{dataId,shape:outShape,dtype:x.dtype}}};function maxPool2(args){let{inputs,backend:backend3,attrs}=args,{x}=inputs;assertNotComplex(x,"maxPool");let{filterSize,strides,pad:pad6,dimRoundingMode}=attrs,dilations=1;util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides,dilations),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);let convInfo=backend_util_exports.computePool2DInfo(x.shape,filterSize,strides,dilations,pad6,dimRoundingMode),res;if(convInfo.filterWidth===1&&convInfo.filterHeight===1&&util_exports.arraysEqual(convInfo.inShape,convInfo.outShape))res=identity({inputs:{x},backend:backend3});else{let xValues=backend3.data.get(x.dataId).values,strides2=util_exports.computeStrides(x.shape),buffer10=pool5(xValues,x.shape,x.dtype,strides2,convInfo,"max");res=backend3.makeTensorInfo(convInfo.outShape,x.dtype,buffer10.values)}return res}var maxPoolConfig={kernelName:MaxPool,backendName:"cpu",kernelFunc:maxPool2};function maxPoolBackprop2(args){let{inputs,backend:backend3,attrs}=args,{dy,input:input2,output}=inputs,x=input2;assertNotComplex([input2,output],"maxPoolBackprop");let{filterSize,strides,pad:pad6,dimRoundingMode}=attrs,convInfo=backend_util_exports.computePool2DInfo(x.shape,filterSize,strides,1,pad6,dimRoundingMode),xValues=backend3.data.get(x.dataId).values,maxPosBuf=buffer(convInfo.outShape,x.dtype,maxPoolPositions(xValues,x.shape,x.dtype,convInfo).values),strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padLeft=effectiveFilterWidth-1-convInfo.padInfo.left,padTop=effectiveFilterHeight-1-convInfo.padInfo.top,dx=buffer(x.shape,"float32"),dyData=backend3.data.get(dy.dataId).values,dyBuf=buffer(dy.shape,"float32",dyData);for(let b=0;b<convInfo.batchSize;++b)for(let d=0;d<convInfo.inChannels;++d)for(let dxR=0;dxR<convInfo.inHeight;++dxR)for(let dxC=0;dxC<convInfo.inWidth;++dxC){let dyRCorner=dxR-padTop,dyCCorner=dxC-padLeft,dotProd=0;for(let wR=0;wR<effectiveFilterHeight;wR+=dilationHeight){let dyR=(dyRCorner+wR)/strideHeight;if(dyR<0||dyR>=convInfo.outHeight||Math.floor(dyR)!==dyR)continue;for(let wC=0;wC<effectiveFilterWidth;wC+=dilationWidth){let dyC=(dyCCorner+wC)/strideWidth;if(dyC<0||dyC>=convInfo.outWidth||Math.floor(dyC)!==dyC)continue;let maxPos=effectiveFilterHeight*effectiveFilterWidth-1-maxPosBuf.get(b,dyR,dyC,d),curPos=wR*effectiveFilterWidth+wC,mask=maxPos===curPos?1:0;if(mask===0)continue;let pixel=dyBuf.get(b,dyR,dyC,d);dotProd+=pixel*mask}}dx.set(dotProd,b,dxR,dxC,d)}return backend3.makeTensorInfo(dx.shape,dx.dtype,dx.values)}var maxPoolBackpropConfig={kernelName:MaxPoolBackprop,backendName:"cpu",kernelFunc:maxPoolBackprop2};function maxPoolWithArgmaxImpl(xValues,xShape,dtype,includeBatchInIndex,convInfo){let strides=util_exports.computeStrides(xShape),maxPools=pool5(xValues,xShape,dtype,strides,convInfo,"max"),maxPositions=maxPoolPositions(xValues,xShape,dtype,convInfo,!0,includeBatchInIndex);return[maxPools.values,maxPositions.values]}var maxPoolWithArgmaxConfig={kernelName:MaxPoolWithArgmax,backendName:"cpu",kernelFunc:({inputs,attrs,backend:backend3})=>{let{x}=inputs,{filterSize,strides,pad:pad6,includeBatchInIndex}=attrs,cpuBackend=backend3;assertNotComplex(x,"MaxPoolWithArgmax");let values=cpuBackend.data.get(x.dataId).values,convInfo=backend_util_exports.computePool2DInfo(x.shape,filterSize,strides,[1,1],pad6),[pooled,indexes]=maxPoolWithArgmaxImpl(values,x.shape,x.dtype,includeBatchInIndex,convInfo),pooledDataId=cpuBackend.write(pooled,convInfo.outShape,x.dtype),indexesDataId=cpuBackend.write(indexes,convInfo.outShape,x.dtype);return[{dataId:pooledDataId,shape:convInfo.outShape,dtype:x.dtype},{dataId:indexesDataId,shape:convInfo.outShape,dtype:"int32"}]}};function mirrorPad2(args){let{inputs,backend:backend3,attrs}=args,{x}=inputs,{paddings,mode}=attrs;assertNotComplex(x,"mirrorPad");let outShape=paddings.map((p2,i)=>p2[0]+x.shape[i]+p2[1]),start=paddings.map(p2=>p2[0]),end=paddings.map((p2,i)=>p2[0]+x.shape[i]),offset=mode==="reflect"?0:1,xVals=backend3.data.get(x.dataId).values,xRank=x.shape.length,xStrides=util_exports.computeStrides(x.shape),resultSize=util_exports.sizeFromShape(outShape),resultRank=outShape.length,resultStrides=util_exports.computeStrides(outShape),resVals=util_exports.getTypedArrayFromDType(x.dtype,resultSize);for(let i=0;i<resultSize;i++){let coords2=util_exports.indexToLoc(i,resultRank,resultStrides);for(let i2=0;i2<resultRank;i2++)coords2[i2]<start[i2]?coords2[i2]=start[i2]*2-coords2[i2]-offset:coords2[i2]>=end[i2]&&(coords2[i2]=(end[i2]-1)*2-coords2[i2]+offset);coords2=coords2.map((c,i2)=>c-start[i2]);let inIndex=util_exports.locToIndex(coords2,xRank,xStrides);resVals[i]=xVals[inIndex]}let outId=backend3.write(resVals,outShape,x.dtype);return{dataId:outId,shape:outShape,dtype:x.dtype}}var mirrorPadConfig={kernelName:MirrorPad,backendName:"cpu",kernelFunc:mirrorPad2};var nonMaxSuppressionV4Impl2=kernel_impls_exports.nonMaxSuppressionV4Impl,nonMaxSuppressionV4Config={kernelName:NonMaxSuppressionV4,backendName:"cpu",kernelFunc:({inputs,backend:backend3,attrs})=>{let{boxes,scores}=inputs,{maxOutputSize,iouThreshold,scoreThreshold,padToMaxOutputSize}=attrs,cpuBackend=backend3;assertNotComplex(boxes,"NonMaxSuppressionPadded");let boxesVals=cpuBackend.data.get(boxes.dataId).values,scoresVals=cpuBackend.data.get(scores.dataId).values,{selectedIndices,validOutputs}=nonMaxSuppressionV4Impl2(boxesVals,scoresVals,maxOutputSize,iouThreshold,scoreThreshold,padToMaxOutputSize);return[selectedIndices,validOutputs]}};var nonMaxSuppressionV5Impl2=kernel_impls_exports.nonMaxSuppressionV5Impl,nonMaxSuppressionV5Config={kernelName:NonMaxSuppressionV5,backendName:"cpu",kernelFunc:({inputs,backend:backend3,attrs})=>{let{boxes,scores}=inputs,{maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma}=attrs,cpuBackend=backend3;assertNotComplex(boxes,"NonMaxSuppressionWithScore");let boxesVals=cpuBackend.data.get(boxes.dataId).values,scoresVals=cpuBackend.data.get(scores.dataId).values,maxOutputSizeVal=maxOutputSize,iouThresholdVal=iouThreshold,scoreThresholdVal=scoreThreshold,softNmsSigmaVal=softNmsSigma,{selectedIndices,selectedScores}=nonMaxSuppressionV5Impl2(boxesVals,scoresVals,maxOutputSizeVal,iouThresholdVal,scoreThresholdVal,softNmsSigmaVal);return[selectedIndices,selectedScores]}};function padV2(args){let{inputs,backend:backend3,attrs}=args,{x}=inputs,{paddings,constantValue}=attrs;assertNotComplex(x,"pad");let outShape=paddings.map((p2,i)=>p2[0]+x.shape[i]+p2[1]),start=paddings.map(p2=>p2[0]),xVals=backend3.data.get(x.dataId).values,xSize=util_exports.sizeFromShape(x.shape),xRank=x.shape.length,xStrides=util_exports.computeStrides(x.shape),resultSize=util_exports.sizeFromShape(outShape),resultRank=outShape.length,resultStrides=util_exports.computeStrides(outShape),resVals=util_exports.getTypedArrayFromDType(x.dtype,resultSize);constantValue!==0&&resVals.fill(constantValue);for(let i=0;i<xSize;i++){let coords2=util_exports.indexToLoc(i,xRank,xStrides),outCoords=coords2.map((c,i2)=>c+start[i2]),outIndex=util_exports.locToIndex(outCoords,resultRank,resultStrides);resVals[outIndex]=xVals[i]}let outId=backend3.write(resVals,outShape,x.dtype);return{dataId:outId,shape:outShape,dtype:x.dtype}}var padV2Config={kernelName:PadV2,backendName:"cpu",kernelFunc:padV2};var reciprocal4=unaryKernelFunc(Reciprocal,xi=>1/xi),reciprocalConfig={kernelName:Reciprocal,backendName:"cpu",kernelFunc:reciprocal4};var rotateWithOffsetConfig={kernelName:RotateWithOffset,backendName:"cpu",kernelFunc:({inputs,attrs,backend:backend3})=>{let{image:image3}=inputs,{radians,fillValue,center}=attrs,cpuBackend=backend3,output=util_exports.getTypedArrayFromDType(image3.dtype,util_exports.sizeFromShape(image3.shape)),[batch,imageHeight,imageWidth,numChannels]=image3.shape,[centerX,centerY]=backend_util_exports.getImageCenter(center,imageHeight,imageWidth),fullOpacityValue=255,sinFactor=Math.sin(radians),cosFactor=Math.cos(radians),imageVals=cpuBackend.data.get(image3.dataId).values;for(let batchIdx=0;batchIdx<batch;batchIdx++){let batchOffset=batchIdx*imageWidth*imageHeight*numChannels;for(let row=0;row<imageHeight;row++){let rowOffset=row*(imageWidth*numChannels);for(let col=0;col<imageWidth;col++){let colOffset=col*numChannels;for(let channel=0;channel<numChannels;channel++){let coords2=[batch,row,col,channel],x=coords2[2],y=coords2[1],coordX=(x-centerX)*cosFactor-(y-centerY)*sinFactor,coordY=(x-centerX)*sinFactor+(y-centerY)*cosFactor;coordX=Math.round(coordX+centerX),coordY=Math.round(coordY+centerY);let outputValue=fillValue;if(typeof fillValue!="number"&&(channel===3?outputValue=fullOpacityValue:outputValue=fillValue[channel]),coordX>=0&&coordX<imageWidth&&coordY>=0&&coordY<imageHeight){let rotatedRowOffset=coordY*(imageWidth*numChannels),rotatedColOffset=coordX*numChannels,imageIdx=batchOffset+rotatedRowOffset+rotatedColOffset+channel;outputValue=imageVals[imageIdx]}let outIdx=batchOffset+rowOffset+colOffset+channel;output[outIdx]=outputValue}}}}let dataId=cpuBackend.write(output,image3.shape,image3.dtype);return{dataId,shape:image3.shape,dtype:image3.dtype}}};var round4=unaryKernelFunc(Round,xi=>{let base2=Math.floor(xi);return xi-base2<.5?Math.floor(xi):xi-base2>.5?Math.ceil(xi):base2%2===0?base2:base2+1}),roundConfig={kernelName:Round,backendName:"cpu",kernelFunc:round4};var scaleAlpha=backend_util_exports.SELU_SCALEALPHA,scale=backend_util_exports.SELU_SCALE,selu5=unaryKernelFunc(Selu,xi=>xi>=0?scale*xi:scaleAlpha*(Math.exp(xi)-1)),seluConfig={kernelName:Selu,backendName:"cpu",kernelFunc:selu5};var sigmoid6=unaryKernelFunc(Sigmoid,xi=>1/(1+Math.exp(-xi))),sigmoidConfig={kernelName:Sigmoid,backendName:"cpu",kernelFunc:sigmoid6};var sign4=unaryKernelFunc(Sign,xi=>xi<0?-1:xi>0?1:0),signConfig={kernelName:Sign,backendName:"cpu",kernelFunc:sign4};var sin5=unaryKernelFunc(Sin,xi=>Math.sin(xi)),sinConfig={kernelName:Sin,backendName:"cpu",kernelFunc:sin5};var sinh5=unaryKernelFunc(Sinh,xi=>Math.sinh(xi)),sinhConfig={kernelName:Sinh,backendName:"cpu",kernelFunc:sinh5};var epsilon2=11920928955078125e-23,threshold=Math.log(epsilon2)+2,softplus5=unaryKernelFunc(Softplus,xi=>{let tooLarge=xi>-threshold,tooSmall=xi<threshold,expX=Math.exp(xi),result;return tooSmall?result=expX:tooLarge?result=xi:result=Math.log(1+expX),result}),softplusConfig={kernelName:Softplus,backendName:"cpu",kernelFunc:softplus5};function transpose17(args){let{inputs,attrs,backend:backend3}=args,{x}=inputs,{perm}=attrs;assertNotComplex(x,"transpose");let xRank=x.shape.length,newShape=new Array(xRank);for(let i=0;i<newShape.length;i++)newShape[i]=x.shape[perm[i]];let values=backend3.data.get(x.dataId).values,result=transposeImpl(values,x.shape,x.dtype,perm,newShape),dataId=backend3.write(result,newShape,x.dtype);return{dataId,shape:newShape,dtype:x.dtype}}var transposeConfig={kernelName:Transpose,backendName:"cpu",kernelFunc:transpose17};function spaceToBatchND2(args){let{inputs,backend:backend3,attrs}=args,{x}=inputs,{blockShape,paddings}=attrs;assertNotComplex([x],"spaceToBatchND");let prod5=util_exports.sizeFromShape(blockShape),completePaddings=[[0,0]];completePaddings.push(...paddings);for(let i=1+blockShape.length;i<x.shape.length;++i)completePaddings.push([0,0]);let paddedX=padV2Config.kernelFunc({inputs:{x},backend:backend3,attrs:{paddings:completePaddings,constantValue:0}}),reshapedPaddedShape=backend_util_exports.getReshaped(paddedX.shape,blockShape,prod5,!1),permutedReshapedPaddedPermutation=backend_util_exports.getPermuted(reshapedPaddedShape.length,blockShape.length,!1),flattenShape=backend_util_exports.getReshapedPermuted(paddedX.shape,blockShape,prod5,!1),reshapeInputs={x:paddedX},reshapeAttrs={shape:reshapedPaddedShape},paddedXReshaped=reshape83({inputs:reshapeInputs,backend:backend3,attrs:reshapeAttrs}),transposeInputs={x:paddedXReshaped},transposeAttrs={perm:permutedReshapedPaddedPermutation},paddedXT=transpose17({inputs:transposeInputs,backend:backend3,attrs:transposeAttrs}),resultReshapeInputs={x:paddedXT},resultReshapeAttrs={shape:flattenShape},result=reshape83({inputs:resultReshapeInputs,backend:backend3,attrs:resultReshapeAttrs});return backend3.disposeIntermediateTensorInfo(paddedX),backend3.disposeIntermediateTensorInfo(paddedXReshaped),backend3.disposeIntermediateTensorInfo(paddedXT),result}var spaceToBatchNDConfig={kernelName:SpaceToBatchND,backendName:"cpu",kernelFunc:spaceToBatchND2};var sqrt13=unaryKernelFunc(Sqrt,xi=>Math.sqrt(xi)),sqrtConfig={kernelName:Sqrt,backendName:"cpu",kernelFunc:sqrt13};var squareConfig={kernelName:Square,backendName:"cpu",kernelFunc:({inputs,backend:backend3})=>{let{x}=inputs,cpuBackend=backend3;assertNotComplex(x,"square");let values=cpuBackend.data.get(x.dataId).values,newValues=new Float32Array(values.length);for(let i=0;i<values.length;++i){let value=values[i];newValues[i]=value*value}let dataId=cpuBackend.write(newValues,x.shape,x.dtype);return{dataId,shape:x.shape,dtype:x.dtype}}};var step8=unaryKernelFunc(Step,(xi,attrs)=>{let stepAttrs=attrs;return isNaN(xi)?NaN:xi>0?1:stepAttrs.alpha}),stepConfig={kernelName:Step,backendName:"cpu",kernelFunc:step8};var tan4=unaryKernelFunc(Tan,xi=>Math.tan(xi)),tanConfig={kernelName:Tan,backendName:"cpu",kernelFunc:tan4};var tanh5=unaryKernelFunc(Tanh,xi=>Math.tanh(xi)),tanhConfig={kernelName:Tanh,backendName:"cpu",kernelFunc:tanh5};function unique6(args){let{inputs,attrs,backend:backend3}=args,{axis}=attrs,{x}=inputs;assertNotComplex(x,"unique");let values=backend3.data.get(x.dataId).values,{outputValues,outputShape,indices}=uniqueImpl(values,axis,x.shape,x.dtype);return[backend3.makeTensorInfo(outputShape,x.dtype,outputValues),backend3.makeTensorInfo([indices.length],"int32",indices)]}var uniqueConfig={kernelName:Unique,backendName:"cpu",kernelFunc:unique6};var kernelConfigs=[_fusedMatMulConfig,absConfig,acosConfig,acoshConfig,addConfig,asinConfig,asinhConfig,atanConfig,atanhConfig,avgPoolConfig,avgPoolBackpropConfig,batchMatMulConfig,batchNormConfig,castConfig,ceilConfig,clipConfig,complexConfig,concatConfig,conv2DBackpropFilterConfig,conv2DBackpropInputConfig,conv2DConfig,conv3DBackpropFilterV2Config,conv3DBackpropInputV2Config,conv3DConfig,cosConfig,coshConfig,depthwiseConv2dNativeConfig,depthwiseConv2dNativeBackpropFilterConfig,depthwiseConv2dNativeBackpropInputConfig,dilation2dConfig,dilation2dBackpropInputConfig,dilation2dBackpropFilterConfig,divConfig,eluConfig,erfConfig,expConfig,expm1Config,fftConfig,fillConfig,flipLeftRightConfig,floorConfig,fusedConv2DConfig,fusedDepthwiseConv2DConfig,identityConfig,ifftConfig,imagConfig,isFiniteConfig,isInfConfig,isNaNConfig,logConfig,log1pConfig,logicalNotConfig,maxPoolConfig,maxPoolBackpropConfig,maxPoolWithArgmaxConfig,maxConfig,mirrorPadConfig,multiplyConfig,nonMaxSuppressionV4Config,nonMaxSuppressionV5Config,notEqualConfig,padV2Config,preluConfig,realConfig,reciprocalConfig,reluConfig,relu6Config,reshapeConfig,rotateWithOffsetConfig,roundConfig,rsqrtConfig,seluConfig,sigmoidConfig,signConfig,sinConfig,sinhConfig,sliceConfig,softplusConfig,spaceToBatchNDConfig,sqrtConfig,squareConfig,squaredDifferenceConfig,stepConfig,subConfig,tanConfig,tanhConfig,transposeConfig,uniqueConfig];for(let kernelConfig of kernelConfigs)registerKernel(kernelConfig);var contexts={},WEBGL_ATTRIBUTES={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function setWebGLContext(webGLVersion,gl){contexts[webGLVersion]=gl}function getWebGLContext(webGLVersion){if(!(webGLVersion in contexts)){let newCtx=getWebGLRenderingContext(webGLVersion);if(newCtx!==null)contexts[webGLVersion]=newCtx;else return console.log("Could not get context for WebGL version",webGLVersion),null}let gl=contexts[webGLVersion];return gl.isContextLost()?(delete contexts[webGLVersion],getWebGLContext(webGLVersion)):(gl.disable(gl.DEPTH_TEST),gl.disable(gl.STENCIL_TEST),gl.disable(gl.BLEND),gl.disable(gl.DITHER),gl.disable(gl.POLYGON_OFFSET_FILL),gl.disable(gl.SAMPLE_COVERAGE),gl.enable(gl.SCISSOR_TEST),gl.enable(gl.CULL_FACE),gl.cullFace(gl.BACK),contexts[webGLVersion])}function createCanvas(webGLVersion){if(typeof OffscreenCanvas!="undefined"&&webGLVersion===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function getWebGLRenderingContext(webGLVersion){if(webGLVersion!==1&&webGLVersion!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let canvas=createCanvas(webGLVersion);return canvas.addEventListener("webglcontextlost",ev=>{ev.preventDefault(),delete contexts[webGLVersion]},!1),webGLVersion===1?canvas.getContext("webgl",WEBGL_ATTRIBUTES)||canvas.getContext("experimental-webgl",WEBGL_ATTRIBUTES):canvas.getContext("webgl2",WEBGL_ATTRIBUTES)}var PackingScheme;(function(PackingScheme2){PackingScheme2[PackingScheme2.DENSE=0]="DENSE",PackingScheme2[PackingScheme2.SHARED_BATCH=1]="SHARED_BATCH"})(PackingScheme||(PackingScheme={}));var TextureUsage;(function(TextureUsage2){TextureUsage2[TextureUsage2.RENDER=0]="RENDER",TextureUsage2[TextureUsage2.UPLOAD=1]="UPLOAD",TextureUsage2[TextureUsage2.PIXELS=2]="PIXELS",TextureUsage2[TextureUsage2.DOWNLOAD=3]="DOWNLOAD"})(TextureUsage||(TextureUsage={}));var PhysicalTextureType;(function(PhysicalTextureType2){PhysicalTextureType2[PhysicalTextureType2.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",PhysicalTextureType2[PhysicalTextureType2.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",PhysicalTextureType2[PhysicalTextureType2.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",PhysicalTextureType2[PhysicalTextureType2.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",PhysicalTextureType2[PhysicalTextureType2.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(PhysicalTextureType||(PhysicalTextureType={}));function getUnpackedMatrixTextureShapeWidthHeight(rows,columns){return[columns,rows]}function getUnpackedArraySizeFromMatrixSize(matrixSize,channelsPerTexture){return matrixSize*channelsPerTexture}function getDenseTexShape(shape){let size=util_exports.sizeFromShape(shape),texelsNeeded=Math.ceil(size/4);return util_exports.sizeToSquarishShape(texelsNeeded)}function getPackedMatrixTextureShapeWidthHeight(rows,columns){return[Math.max(1,Math.ceil(columns/2)),Math.max(1,Math.ceil(rows/2))]}function getPackedRGBAArraySizeFromMatrixShape(rows,columns){let[w,h]=getPackedMatrixTextureShapeWidthHeight(rows,columns);return w*h*4}function getTextureConfig(gl,textureHalfFloatExtension){let glany=gl,internalFormatFloat,internalFormatHalfFloat,internalFormatPackedHalfFloat,internalFormatPackedFloat,textureFormatFloat,downloadTextureFormat,downloadUnpackNumChannels,defaultNumChannels,textureTypeHalfFloat,textureTypeFloat;return env().getNumber("WEBGL_VERSION")===2?(internalFormatFloat=glany.R32F,internalFormatHalfFloat=glany.R16F,internalFormatPackedHalfFloat=glany.RGBA16F,internalFormatPackedFloat=glany.RGBA32F,textureFormatFloat=glany.RED,downloadUnpackNumChannels=4,defaultNumChannels=1,textureTypeHalfFloat=glany.HALF_FLOAT,textureTypeFloat=glany.FLOAT):(internalFormatFloat=gl.RGBA,internalFormatHalfFloat=gl.RGBA,internalFormatPackedHalfFloat=gl.RGBA,internalFormatPackedFloat=glany.RGBA,textureFormatFloat=gl.RGBA,downloadUnpackNumChannels=4,defaultNumChannels=4,textureTypeHalfFloat=textureHalfFloatExtension!=null?textureHalfFloatExtension.HALF_FLOAT_OES:null,textureTypeFloat=gl.FLOAT),downloadTextureFormat=gl.RGBA,{internalFormatFloat,internalFormatHalfFloat,internalFormatPackedHalfFloat,internalFormatPackedFloat,textureFormatFloat,downloadTextureFormat,downloadUnpackNumChannels,defaultNumChannels,textureTypeHalfFloat,textureTypeFloat}}function callAndCheck(gl,func2){let returnValue=func2();return env().getBool("DEBUG")&&checkWebGLError(gl),returnValue}function checkWebGLError(gl){let error=gl.getError();if(error!==gl.NO_ERROR)throw new Error("WebGL Error: "+getWebGLErrorMessage(gl,error))}var MIN_FLOAT16=596e-10,MAX_FLOAT16=65504;function canBeRepresented(num){return!!(env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||num===0||MIN_FLOAT16<Math.abs(num)&&Math.abs(num)<MAX_FLOAT16)}function getWebGLErrorMessage(gl,status){switch(status){case gl.NO_ERROR:return"NO_ERROR";case gl.INVALID_ENUM:return"INVALID_ENUM";case gl.INVALID_VALUE:return"INVALID_VALUE";case gl.INVALID_OPERATION:return"INVALID_OPERATION";case gl.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case gl.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case gl.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${status}`}}function getExtensionOrThrow(gl,extensionName){return throwIfNull(gl,()=>gl.getExtension(extensionName),'Extension "'+extensionName+'" not supported on this browser.')}function createVertexShader(gl,vertexShaderSource){let vertexShader=throwIfNull(gl,()=>gl.createShader(gl.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(callAndCheck(gl,()=>gl.shaderSource(vertexShader,vertexShaderSource)),callAndCheck(gl,()=>gl.compileShader(vertexShader)),gl.getShaderParameter(vertexShader,gl.COMPILE_STATUS)===!1)throw console.log(gl.getShaderInfoLog(vertexShader)),new Error("Failed to compile vertex shader.");return vertexShader}function createFragmentShader(gl,fragmentShaderSource){let fragmentShader=throwIfNull(gl,()=>gl.createShader(gl.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(callAndCheck(gl,()=>gl.shaderSource(fragmentShader,fragmentShaderSource)),callAndCheck(gl,()=>gl.compileShader(fragmentShader)),gl.getShaderParameter(fragmentShader,gl.COMPILE_STATUS)===!1)throw logShaderSourceAndInfoLog(fragmentShaderSource,gl.getShaderInfoLog(fragmentShader)),new Error("Failed to compile fragment shader.");return fragmentShader}var lineNumberRegex=/ERROR: [0-9]+:([0-9]+):/g;function logShaderSourceAndInfoLog(shaderSource,shaderInfoLog){let lineNumberRegexResult=lineNumberRegex.exec(shaderInfoLog);if(lineNumberRegexResult==null){console.log(`Couldn't parse line number in error: ${shaderInfoLog}`),console.log(shaderSource);return}let lineNumber=+lineNumberRegexResult[1],shaderLines=shaderSource.split(`
`),pad6=shaderLines.length.toString().length+2,linesWithLineNumbers=shaderLines.map((line,lineNumber2)=>util_exports.rightPad((lineNumber2+1).toString(),pad6)+line),maxLineLength=0;for(let i=0;i<linesWithLineNumbers.length;i++)maxLineLength=Math.max(linesWithLineNumbers[i].length,maxLineLength);let beforeErrorLines=linesWithLineNumbers.slice(0,lineNumber-1),errorLine=linesWithLineNumbers.slice(lineNumber-1,lineNumber),afterErrorLines=linesWithLineNumbers.slice(lineNumber);console.log(beforeErrorLines.join(`
`)),console.log(shaderInfoLog.split(`
`)[0]),console.log(`%c ${util_exports.rightPad(errorLine[0],maxLineLength)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(afterErrorLines.join(`
`))}function createProgram(gl){return throwIfNull(gl,()=>gl.createProgram(),"Unable to create WebGLProgram.")}function linkProgram(gl,program){if(callAndCheck(gl,()=>gl.linkProgram(program)),gl.getProgramParameter(program,gl.LINK_STATUS)===!1)throw console.log(gl.getProgramInfoLog(program)),new Error("Failed to link vertex and fragment shaders.")}function validateProgram(gl,program){if(callAndCheck(gl,()=>gl.validateProgram(program)),gl.getProgramParameter(program,gl.VALIDATE_STATUS)===!1)throw console.log(gl.getProgramInfoLog(program)),new Error("Shader program validation failed.")}function createStaticVertexBuffer(gl,data){let buffer10=throwIfNull(gl,()=>gl.createBuffer(),"Unable to create WebGLBuffer");return callAndCheck(gl,()=>gl.bindBuffer(gl.ARRAY_BUFFER,buffer10)),callAndCheck(gl,()=>gl.bufferData(gl.ARRAY_BUFFER,data,gl.STATIC_DRAW)),buffer10}function createStaticIndexBuffer(gl,data){let buffer10=throwIfNull(gl,()=>gl.createBuffer(),"Unable to create WebGLBuffer");return callAndCheck(gl,()=>gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,buffer10)),callAndCheck(gl,()=>gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,data,gl.STATIC_DRAW)),buffer10}function createTexture(gl){return throwIfNull(gl,()=>gl.createTexture(),"Unable to create WebGLTexture.")}function validateTextureSize(width,height){let maxTextureSize=env().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(width<=0||height<=0){let requested=`[${width}x${height}]`;throw new Error("Requested texture size "+requested+" is invalid.")}if(width>maxTextureSize||height>maxTextureSize){let requested=`[${width}x${height}]`,max9=`[${maxTextureSize}x${maxTextureSize}]`;throw new Error("Requested texture size "+requested+" greater than WebGL maximum on this browser / GPU "+max9+".")}}function createFramebuffer(gl){return throwIfNull(gl,()=>gl.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function bindVertexBufferToProgramAttribute(gl,program,attribute,buffer10,arrayEntriesPerItem,itemStrideInBytes,itemOffsetInBytes){let loc=gl.getAttribLocation(program,attribute);return loc===-1?!1:(callAndCheck(gl,()=>gl.bindBuffer(gl.ARRAY_BUFFER,buffer10)),callAndCheck(gl,()=>gl.vertexAttribPointer(loc,arrayEntriesPerItem,gl.FLOAT,!1,itemStrideInBytes,itemOffsetInBytes)),callAndCheck(gl,()=>gl.enableVertexAttribArray(loc)),!0)}function bindTextureUnit(gl,texture,textureUnit){validateTextureUnit(gl,textureUnit),callAndCheck(gl,()=>gl.activeTexture(gl.TEXTURE0+textureUnit)),callAndCheck(gl,()=>gl.bindTexture(gl.TEXTURE_2D,texture))}function getProgramUniformLocationOrThrow(gl,program,uniformName){return throwIfNull(gl,()=>gl.getUniformLocation(program,uniformName),'uniform "'+uniformName+'" not present in program.')}function getProgramUniformLocation(gl,program,uniformName){return gl.getUniformLocation(program,uniformName)}function bindTextureToProgramUniformSampler(gl,texture,uniformSamplerLocation,textureUnit){callAndCheck(gl,()=>bindTextureUnit(gl,texture,textureUnit)),callAndCheck(gl,()=>gl.uniform1i(uniformSamplerLocation,textureUnit))}function bindColorTextureToFramebuffer(gl,texture,framebuffer){callAndCheck(gl,()=>gl.bindFramebuffer(gl.FRAMEBUFFER,framebuffer)),callAndCheck(gl,()=>gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,texture,0))}function unbindColorTextureFromFramebuffer(gl,framebuffer){callAndCheck(gl,()=>gl.bindFramebuffer(gl.FRAMEBUFFER,framebuffer)),callAndCheck(gl,()=>gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,null,0))}function validateFramebuffer(gl){let status=gl.checkFramebufferStatus(gl.FRAMEBUFFER);if(status!==gl.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+getFramebufferErrorMessage(gl,status))}function getFramebufferErrorMessage(gl,status){switch(status){case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case gl.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${status}`}}function throwIfNull(gl,returnTOrNull,failureMessage){let tOrNull=callAndCheck(gl,()=>returnTOrNull());if(tOrNull==null)throw new Error(failureMessage);return tOrNull}function validateTextureUnit(gl,textureUnit){let maxTextureUnit=gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,glTextureUnit=textureUnit+gl.TEXTURE0;if(glTextureUnit<gl.TEXTURE0||glTextureUnit>maxTextureUnit){let textureUnitRange=`[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;throw new Error(`textureUnit must be in ${textureUnitRange}.`)}}function getBatchDim(shape,dimsToSkip=2){return util_exports.sizeFromShape(shape.slice(0,shape.length-dimsToSkip))}function getRowsCols(shape){if(shape.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[shape.length>1?shape[shape.length-2]:1,shape[shape.length-1]]}function getShapeAs3D(shape){let shapeAs3D=[1,1,1],isScalar=shape.length===0||shape.length===1&&shape[0]===1;return isScalar||(shapeAs3D=[getBatchDim(shape),...getRowsCols(shape)]),shapeAs3D}function getTextureShapeFromLogicalShape(logShape,isPacked=!1){let maxTexSize=env().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(isPacked&&(maxTexSize=maxTexSize*2,logShape=logShape.map((d,i)=>i>=logShape.length-2?util_exports.nearestLargerEven(logShape[i]):logShape[i]),logShape.length===1&&(logShape=[2,logShape[0]])),logShape.length!==2){let squeezeResult=util_exports.squeezeShape(logShape);logShape=squeezeResult.newShape}let size=util_exports.sizeFromShape(logShape);if(logShape.length<=1&&size<=maxTexSize)return[1,size];if(logShape.length===2&&logShape[0]<=maxTexSize&&logShape[1]<=maxTexSize)return logShape;if(logShape.length===3&&logShape[0]*logShape[1]<=maxTexSize&&logShape[2]<=maxTexSize)return[logShape[0]*logShape[1],logShape[2]];if(logShape.length===3&&logShape[0]<=maxTexSize&&logShape[1]*logShape[2]<=maxTexSize)return[logShape[0],logShape[1]*logShape[2]];if(logShape.length===4&&logShape[0]*logShape[1]*logShape[2]<=maxTexSize&&logShape[3]<=maxTexSize)return[logShape[0]*logShape[1]*logShape[2],logShape[3]];if(logShape.length===4&&logShape[0]<=maxTexSize&&logShape[1]*logShape[2]*logShape[3]<=maxTexSize)return[logShape[0],logShape[1]*logShape[2]*logShape[3]];if(isPacked){let batchDim=getBatchDim(logShape),rows=2,cols=2;return logShape.length&&([rows,cols]=getRowsCols(logShape)),size=batchDim*(rows/2)*(cols/2),util_exports.sizeToSquarishShape(size).map(d=>d*2)}return util_exports.sizeToSquarishShape(size)}function isEven(n){return n%2===0}function isReshapeFree(shape1,shape2){if(shape1=shape1.slice(-2),shape2=shape2.slice(-2),util_exports.arraysEqual(shape1,shape2))return!0;if(!shape1.length||!shape2.length)return!0;if(shape1[0]===0||shape1[1]===0||shape2[0]===0||shape2[1]===0)return!0;if(shape1.length!==shape2.length){let shape1Cols=shape1.slice(-1)[0],shape2Cols=shape2.slice(-1)[0];if(shape1Cols===shape2Cols)return!0;if(isEven(shape1Cols)&&isEven(shape2Cols)&&(shape1[0]===1||shape2[0]===1))return!0}return shape1[1]===shape2[1]&&isEven(shape1[0])&&isEven(shape2[0])}var MAX_TEXTURE_SIZE,MAX_TEXTURES_IN_SHADER;function getWebGLMaxTextureSize(webGLVersion){if(MAX_TEXTURE_SIZE==null){let gl=getWebGLContext(webGLVersion);MAX_TEXTURE_SIZE=gl.getParameter(gl.MAX_TEXTURE_SIZE)}return MAX_TEXTURE_SIZE}function getMaxTexturesInShader(webGLVersion){if(MAX_TEXTURES_IN_SHADER==null){let gl=getWebGLContext(webGLVersion);MAX_TEXTURES_IN_SHADER=gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,MAX_TEXTURES_IN_SHADER)}function getWebGLDisjointQueryTimerVersion(webGLVersion){if(webGLVersion===0)return 0;let queryTimerVersion,gl=getWebGLContext(webGLVersion);return hasExtension(gl,"EXT_disjoint_timer_query_webgl2")&&webGLVersion===2?queryTimerVersion=2:hasExtension(gl,"EXT_disjoint_timer_query")?queryTimerVersion=1:queryTimerVersion=0,queryTimerVersion}function hasExtension(gl,extensionName){let ext=gl.getExtension(extensionName);return ext!=null}function isWebGLVersionEnabled(webGLVersion){try{let gl=getWebGLContext(webGLVersion);if(gl!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function isCapableOfRenderingToFloatTexture(webGLVersion){if(webGLVersion===0)return!1;let gl=getWebGLContext(webGLVersion);if(webGLVersion===1){if(!hasExtension(gl,"OES_texture_float"))return!1}else if(!hasExtension(gl,"EXT_color_buffer_float"))return!1;let isFrameBufferComplete=createFloatTextureAndBindToFramebuffer(gl);return isFrameBufferComplete}function isDownloadFloatTextureEnabled(webGLVersion){if(webGLVersion===0)return!1;let gl=getWebGLContext(webGLVersion);if(webGLVersion===1){if(!hasExtension(gl,"OES_texture_float"))return!1;if(!hasExtension(gl,"WEBGL_color_buffer_float"))return!1}else{if(hasExtension(gl,"EXT_color_buffer_float"))return createFloatTextureAndBindToFramebuffer(gl);let COLOR_BUFFER_HALF_FLOAT="EXT_color_buffer_half_float";if(hasExtension(gl,COLOR_BUFFER_HALF_FLOAT)){let textureHalfFloatExtension=gl.getExtension(COLOR_BUFFER_HALF_FLOAT);return createHalfFloatTextureAndBindToFramebuffer(gl,textureHalfFloatExtension)}return!1}let isFrameBufferComplete=createFloatTextureAndBindToFramebuffer(gl);return isFrameBufferComplete}function createFloatTextureAndBindToFramebuffer(gl){let texConfig=getTextureConfig(gl),texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);let width=1,height=1;gl.texImage2D(gl.TEXTURE_2D,0,texConfig.internalFormatFloat,width,height,0,texConfig.textureFormatFloat,texConfig.textureTypeFloat,null);let frameBuffer=gl.createFramebuffer();gl.bindFramebuffer(gl.FRAMEBUFFER,frameBuffer),gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,texture,0);let isFrameBufferComplete=gl.checkFramebufferStatus(gl.FRAMEBUFFER)===gl.FRAMEBUFFER_COMPLETE;return gl.bindTexture(gl.TEXTURE_2D,null),gl.bindFramebuffer(gl.FRAMEBUFFER,null),gl.deleteTexture(texture),gl.deleteFramebuffer(frameBuffer),isFrameBufferComplete}function createHalfFloatTextureAndBindToFramebuffer(gl,textureHalfFloatExtension){let texConfig=getTextureConfig(gl,textureHalfFloatExtension),texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);let width=1,height=1;gl.texImage2D(gl.TEXTURE_2D,0,texConfig.internalFormatHalfFloat,width,height,0,texConfig.textureFormatFloat,texConfig.textureTypeHalfFloat,null);let frameBuffer=gl.createFramebuffer();gl.bindFramebuffer(gl.FRAMEBUFFER,frameBuffer),gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,texture,0);let isFrameBufferComplete=gl.checkFramebufferStatus(gl.FRAMEBUFFER)===gl.FRAMEBUFFER_COMPLETE;return gl.bindTexture(gl.TEXTURE_2D,null),gl.bindFramebuffer(gl.FRAMEBUFFER,null),gl.deleteTexture(texture),gl.deleteFramebuffer(frameBuffer),isFrameBufferComplete}function isWebGLFenceEnabled(webGLVersion){if(webGLVersion!==2)return!1;let gl=getWebGLContext(webGLVersion),isEnabled=gl.fenceSync!=null;return isEnabled}function assertNotComplex2(tensor166,opName){Array.isArray(tensor166)||(tensor166=[tensor166]),tensor166.forEach(t=>{t!=null&&util_exports.assert(t.dtype!=="complex64",()=>`${opName} does not support complex64 tensors in the WebGL backend.`)})}var ENV3=env();ENV3.registerFlag("HAS_WEBGL",()=>ENV3.getNumber("WEBGL_VERSION")>0);ENV3.registerFlag("WEBGL_VERSION",()=>isWebGLVersionEnabled(2)?2:isWebGLVersionEnabled(1)?1:0);ENV3.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);ENV3.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>ENV3.get("WEBGL_VERSION")===2);ENV3.registerFlag("WEBGL_CPU_FORWARD",()=>!0);ENV3.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);ENV3.registerFlag("WEBGL_PACK",()=>ENV3.getBool("HAS_WEBGL"));ENV3.registerFlag("WEBGL_PACK_NORMALIZATION",()=>ENV3.getBool("WEBGL_PACK"));ENV3.registerFlag("WEBGL_PACK_CLIP",()=>ENV3.getBool("WEBGL_PACK"));ENV3.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>!1);ENV3.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>ENV3.getBool("WEBGL_PACK"));ENV3.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>ENV3.getBool("WEBGL_PACK"));ENV3.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>ENV3.getBool("WEBGL_PACK"));ENV3.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>ENV3.getBool("WEBGL_PACK"));ENV3.registerFlag("WEBGL_PACK_REDUCE",()=>ENV3.getBool("WEBGL_PACK"));ENV3.registerFlag("WEBGL_LAZILY_UNPACK",()=>ENV3.getBool("WEBGL_PACK"));ENV3.registerFlag("WEBGL_CONV_IM2COL",()=>ENV3.getBool("WEBGL_PACK"));ENV3.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>getWebGLMaxTextureSize(ENV3.getNumber("WEBGL_VERSION")));ENV3.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>getMaxTexturesInShader(ENV3.getNumber("WEBGL_VERSION")));ENV3.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let webGLVersion=ENV3.getNumber("WEBGL_VERSION");return webGLVersion===0?0:getWebGLDisjointQueryTimerVersion(webGLVersion)});ENV3.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>ENV3.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!device_util_exports.isMobile());ENV3.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>isCapableOfRenderingToFloatTexture(ENV3.getNumber("WEBGL_VERSION")));ENV3.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>ENV3.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:ENV3.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));ENV3.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>isDownloadFloatTextureEnabled(ENV3.getNumber("WEBGL_VERSION")));ENV3.registerFlag("WEBGL_FENCE_API_ENABLED",()=>isWebGLFenceEnabled(ENV3.getNumber("WEBGL_VERSION")));ENV3.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>{let useUniforms=ENV3.getBool("WEBGL_RENDER_FLOAT32_ENABLED");return useUniforms?4:0});ENV3.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,threshold2=>{if(threshold2<0&&threshold2!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${threshold2}.`)});var{simpleAbsImpl:simpleAbsImplCPU,addImpl:addImplCPU,ceilImpl:ceilImplCPU,expImpl:expImplCPU,expm1Impl:expm1ImplCPU,floorImpl:floorImplCPU,logImpl:logImplCPU,maxImpl:maxImplCPU,multiplyImpl:multiplyImplCPU,rsqrtImpl:rsqrtImplCPU,sliceImpl:sliceImplCPU,subImpl:subImplCPU,transposeImpl:transposeImplCPU,uniqueImpl:uniqueImplCPU}=shared_exports;var AddNProgram=class{constructor(outputShape,shapes){this.outputShape=[],this.outputShape=outputShape,this.variableNames=shapes.map((_,i)=>`T${i}`);let snippets=[];this.variableNames.forEach(variable3=>{snippets.push(`float v${variable3} = get${variable3}AtOutCoords();`)});let operation188=this.variableNames.map(variable3=>`v${variable3}`).join(" + ");this.userCode=`
      void main() {
        ${snippets.join(`
        `)}

        float result = ${operation188};
        setOutput(result);
      }
    `}};var AddNPackedProgram=class{constructor(outputShape,shapes){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=outputShape,this.variableNames=shapes.map((_,i)=>`T${i}`);let snippets=[];this.variableNames.forEach(variable3=>{snippets.push(`vec4 v${variable3} = get${variable3}AtOutCoords();`)});let operation188=this.variableNames.map(variable3=>`v${variable3}`).join(" + ");this.userCode=`
      void main() {
        ${snippets.join(`
        `)}

        vec4 result = ${operation188};
        setOutput(result);
      }
    `}};var ArgMinMaxProgram=class{constructor(reduceInfo,op2,firstPass){this.variableNames=["A"];let{windowSize,batchSize,outSize}=reduceInfo;firstPass||this.variableNames.push("bestIndicesA"),this.outputShape=[batchSize,outSize];let compOp=op2==="max"?">":"<",indexSnippet=firstPass?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${windowSize}; i++) {
          int inIdx = ${indexSnippet};
          float candidate = getA(batch, inIdx);
          if (candidate ${compOp} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};function getVecChannels(name,rank){return["x","y","z","w","u","v"].slice(0,rank).map(d=>`${name}.${d}`)}function getChannels(name,rank){return rank===1?[name]:getVecChannels(name,rank)}function getSourceCoords(rank,dims){if(rank===1)return"rc";let coords2="";for(let i=0;i<rank;i++)coords2+=dims[i],i<rank-1&&(coords2+=",");return coords2}function getGlslDifferences(){let version17,attribute,varyingVs,varyingFs,texture2D,output,defineOutput,defineSpecialNaN,defineSpecialInf,defineRound;return env().getNumber("WEBGL_VERSION")===2?(version17="#version 300 es",attribute="in",varyingVs="out",varyingFs="in",texture2D="texture",output="outputColor",defineOutput="out vec4 outputColor;",defineSpecialNaN=`
      bool isnan_custom(float val) {
        return (val > 0.0 || val < 0.0) ? false : val != 0.0;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,defineSpecialInf="",defineRound=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(version17="",attribute="attribute",varyingVs="varying",varyingFs="varying",texture2D="texture2D",output="gl_FragColor",defineOutput="",defineSpecialNaN=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,defineSpecialInf=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,defineRound=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:version17,attribute,varyingVs,varyingFs,texture2D,output,defineOutput,defineSpecialNaN,defineSpecialInf,defineRound}}function getLogicalCoordinatesFromFlatIndex(coords2,shape,index="index"){let strides=util_exports.computeStrides(shape);return strides.map((stride,i)=>{let line1=`int ${coords2[i]} = ${index} / ${stride}`,line2=i===strides.length-1?`int ${coords2[i+1]} = ${index} - ${coords2[i]} * ${stride}`:`index -= ${coords2[i]} * ${stride}`;return`${line1}; ${line2};`}).join("")}function getFlatIndexFrom3D(shape){let strides=util_exports.computeStrides(shape).map(d=>d.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${strides[0]} + coords.y * ${strides[1]} + coords.z;
  }
`}var ENCODE_FLOAT_SNIPPET=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;var{getBroadcastDims:getBroadcastDims2}=backend_util_exports;function makeShader(inputsInfo,outputShape,userCode,usesPackedTextures){let prefixSnippets=[];inputsInfo.forEach(x=>{let size=util_exports.sizeFromShape(x.shapeInfo.logicalShape);x.shapeInfo.isUniform?prefixSnippets.push(`uniform float ${x.name}${size>1?`[${size}]`:""};`):(prefixSnippets.push(`uniform sampler2D ${x.name};`),prefixSnippets.push(`uniform int offset${x.name};`))});let inputPrefixSnippet=prefixSnippets.join(`
`),inputSamplingSnippet=inputsInfo.map(x=>getInputSamplingSnippet(x,outputShape,usesPackedTextures)).join(`
`),outTexShape=outputShape.texShape,glsl=getGlslDifferences(),floatTextureSampleSnippet=getFloatTextureSampleSnippet(glsl),outputSamplingSnippet,floatTextureSetOutputSnippet,shaderPrefix=getShaderPrefix(glsl);outputShape.isPacked?(outputSamplingSnippet=getPackedOutputSamplingSnippet(outputShape.logicalShape,outTexShape),floatTextureSetOutputSnippet=getFloatTextureSetRGBASnippet(glsl)):(outputSamplingSnippet=getOutputSamplingSnippet(outputShape.logicalShape,outTexShape),floatTextureSetOutputSnippet=getFloatTextureSetRSnippet(glsl)),usesPackedTextures&&(shaderPrefix+=SHADER_PACKED_PREFIX);let source=[shaderPrefix,floatTextureSampleSnippet,floatTextureSetOutputSnippet,inputPrefixSnippet,outputSamplingSnippet,inputSamplingSnippet,userCode].join(`
`);return source}function getSamplerFromInInfo(inInfo){let shape=inInfo.shapeInfo.logicalShape;switch(shape.length){case 0:return getSamplerScalar(inInfo);case 1:return getSampler1D(inInfo);case 2:return getSampler2D(inInfo);case 3:return getSampler3D(inInfo);case 4:return getSampler4D(inInfo);case 5:return getSampler5D(inInfo);case 6:return getSampler6D(inInfo);default:throw new Error(`${shape.length}-D input sampling is not yet supported`)}}function getPackedSamplerFromInInfo(inInfo){let shape=inInfo.shapeInfo.logicalShape;switch(shape.length){case 0:return getPackedSamplerScalar(inInfo);case 1:return getPackedSampler1D(inInfo);case 2:return getPackedSampler2D(inInfo);case 3:return getPackedSampler3D(inInfo);default:return getPackedSamplerND(inInfo)}}function getInputSamplingSnippet(inInfo,outShapeInfo,usesPackedTextures=!1){let res="";usesPackedTextures?res+=getPackedSamplerFromInInfo(inInfo):res+=getSamplerFromInInfo(inInfo);let inShape=inInfo.shapeInfo.logicalShape,outShape=outShapeInfo.logicalShape;return inShape.length<=outShape.length&&(usesPackedTextures?res+=getPackedSamplerAtOutputCoords(inInfo,outShapeInfo):res+=getSamplerAtOutputCoords(inInfo,outShapeInfo)),res}function getPackedOutputSamplingSnippet(outShape,outTexShape){switch(outShape.length){case 0:return getOutputScalarCoords();case 1:return getOutputPacked1DCoords(outShape,outTexShape);case 2:return getOutputPacked2DCoords(outShape,outTexShape);case 3:return getOutputPacked3DCoords(outShape,outTexShape);default:return getOutputPackedNDCoords(outShape,outTexShape)}}function getOutputSamplingSnippet(outShape,outTexShape){switch(outShape.length){case 0:return getOutputScalarCoords();case 1:return getOutput1DCoords(outShape,outTexShape);case 2:return getOutput2DCoords(outShape,outTexShape);case 3:return getOutput3DCoords(outShape,outTexShape);case 4:return getOutput4DCoords(outShape,outTexShape);case 5:return getOutput5DCoords(outShape,outTexShape);case 6:return getOutput6DCoords(outShape,outTexShape);default:throw new Error(`${outShape.length}-D output sampling is not yet supported`)}}function getFloatTextureSampleSnippet(glsl){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${glsl.texture2D}(textureSampler, uv).r;
    }
  `}function getFloatTextureSetRSnippet(glsl){return`
    void setOutput(float val) {
      ${glsl.output} = vec4(val, 0, 0, 0);
    }
  `}function getFloatTextureSetRGBASnippet(glsl){return`
    void setOutput(vec4 val) {
      ${glsl.output} = val;
    }
  `}function getShaderPrefix(glsl){let SHADER_PREFIX=`${glsl.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${glsl.varyingFs} vec2 resultUV;
    ${glsl.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${glsl.defineSpecialNaN}
    ${glsl.defineSpecialInf}
    ${glsl.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${SAMPLE_1D_SNIPPET}
    ${SAMPLE_2D_SNIPPET}
    ${SAMPLE_3D_SNIPPET}
  `;return SHADER_PREFIX}var SAMPLE_1D_SNIPPET=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,SAMPLE_2D_SNIPPET=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,SAMPLE_3D_SNIPPET=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,SHADER_PACKED_PREFIX=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function getOutputScalarCoords(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function getOutputPacked1DCoords(shape,texShape){let packedTexShape=[Math.ceil(texShape[0]/2),Math.ceil(texShape[1]/2)];return packedTexShape[0]===1?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${packedTexShape[1]}.0);
      }
    `:packedTexShape[1]===1?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${packedTexShape[0]}.0);
      }
    `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      return 2 * (resTexRC.x * ${packedTexShape[1]} + resTexRC.y);
    }
  `}function getOutput1DCoords(shape,texShape){return texShape[0]===1?`
      int getOutputCoords() {
        return int(resultUV.x * ${texShape[1]}.0);
      }
    `:texShape[1]===1?`
      int getOutputCoords() {
        return int(resultUV.y * ${texShape[0]}.0);
      }
    `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      return resTexRC.x * ${texShape[1]} + resTexRC.y;
    }
  `}function getOutputPacked3DCoords(shape,texShape){let packedTexShape=[Math.ceil(texShape[0]/2),Math.ceil(texShape[1]/2)],texelsInLogicalRow=Math.ceil(shape[2]/2),texelsInBatch=texelsInLogicalRow*Math.ceil(shape[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;

      int b = index / ${texelsInBatch};
      index -= b * ${texelsInBatch};

      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec3(b, r, c);
    }
  `}function getOutput3DCoords(shape,texShape){let coordsFromIndexSnippet=getLogicalCoordinatesFromFlatIndex(["r","c","d"],shape);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      ${coordsFromIndexSnippet}
      return ivec3(r, c, d);
    }
  `}function getOutputPackedNDCoords(shape,texShape){let packedTexShape=[Math.ceil(texShape[0]/2),Math.ceil(texShape[1]/2)],texelsInLogicalRow=Math.ceil(shape[shape.length-1]/2),texelsInBatch=texelsInLogicalRow*Math.ceil(shape[shape.length-2]/2),texelsInBatchN=texelsInBatch,batches="",coords2="b, r, c";for(let b=2;b<shape.length-1;b++)texelsInBatchN*=shape[shape.length-b-1],batches=`
      int b${b} = index / ${texelsInBatchN};
      index -= b${b} * ${texelsInBatchN};
    `+batches,coords2=`b${b}, `+coords2;return`
    ivec${shape.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;

      ${batches}

      int b = index / ${texelsInBatch};
      index -= b * ${texelsInBatch};

      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec${shape.length}(${coords2});
    }
  `}function getOutput4DCoords(shape,texShape){let coordsFromIndexSnippet=getLogicalCoordinatesFromFlatIndex(["r","c","d","d2"],shape);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      ${coordsFromIndexSnippet}
      return ivec4(r, c, d, d2);
    }
  `}function getOutput5DCoords(shape,texShape){let coordsFromIndexSnippet=getLogicalCoordinatesFromFlatIndex(["r","c","d","d2","d3"],shape);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${texShape[0]},
                             ${texShape[1]}));

      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;

      ${coordsFromIndexSnippet}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function getOutput6DCoords(shape,texShape){let coordsFromIndexSnippet=getLogicalCoordinatesFromFlatIndex(["r","c","d","d2","d3","d4"],shape);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;

      ${coordsFromIndexSnippet}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function getOutputPacked2DCoords(shape,texShape){let packedTexShape=[Math.ceil(texShape[0]/2),Math.ceil(texShape[1]/2)];if(util_exports.arraysEqual(shape,texShape))return`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      }
    `;let texelsInLogicalRow=Math.ceil(shape[1]/2);return`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));

      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;
      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec2(r, c);
    }
  `}function getOutput2DCoords(shape,texShape){return util_exports.arraysEqual(shape,texShape)?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${texShape[0]}, ${texShape[1]}));
      }
    `:shape[1]===1?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${texShape[0]}, ${texShape[1]}));
        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:shape[0]===1?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${texShape[0]}, ${texShape[1]}));
        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      int r = index / ${shape[1]};
      int c = index - r * ${shape[1]};
      return ivec2(r, c);
    }
  `}function getFlatOffsetUniformName(texName){return`offset${texName}`}function getPackedSamplerScalar(inputInfo){let texName=inputInfo.name,funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1),glsl=getGlslDifferences();return`
    vec4 ${funcName}() {
      return ${glsl.texture2D}(${texName}, halfCR);
    }
  `}function getSamplerScalar(inputInfo){let texName=inputInfo.name,funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1);if(inputInfo.shapeInfo.isUniform)return`float ${funcName}() {return ${texName};}`;let[texNumR,texNumC]=inputInfo.shapeInfo.texShape;if(texNumR===1&&texNumC===1)return`
      float ${funcName}() {
        return sampleTexture(${texName}, halfCR);
      }
    `;let[tNumR,tNumC]=inputInfo.shapeInfo.texShape,offset=getFlatOffsetUniformName(texName);return`
    float ${funcName}() {
      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, ${offset});
      return sampleTexture(${texName}, uv);
    }
  `}function getPackedSampler1D(inputInfo){let texName=inputInfo.name,funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1),texShape=inputInfo.shapeInfo.texShape,packedTexShape=[Math.ceil(texShape[0]/2),Math.ceil(texShape[1]/2)],glsl=getGlslDifferences();return`
    vec4 ${funcName}(int index) {
      vec2 uv = packedUVfrom1D(
        ${packedTexShape[0]}, ${packedTexShape[1]}, index);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `}function getSampler1D(inputInfo){let texName=inputInfo.name,funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1);if(inputInfo.shapeInfo.isUniform)return`
      float ${funcName}(int index) {
        ${getUniformSampler(inputInfo)}
      }
    `;let texShape=inputInfo.shapeInfo.texShape,tNumR=texShape[0],tNumC=texShape[1];if(tNumC===1&&tNumR===1)return`
      float ${funcName}(int index) {
        return sampleTexture(${texName}, halfCR);
      }
    `;let offset=getFlatOffsetUniformName(texName);return tNumC===1?`
      float ${funcName}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${offset}) + 0.5) / ${tNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `:tNumR===1?`
      float ${funcName}(int index) {
        vec2 uv = vec2((float(index + ${offset}) + 0.5) / ${tNumC}.0, 0.5);
        return sampleTexture(${texName}, uv);
      }
    `:`
    float ${funcName}(int index) {
      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `}function getPackedSampler2D(inputInfo){let shape=inputInfo.shapeInfo.logicalShape,texName=inputInfo.name,funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1),texShape=inputInfo.shapeInfo.texShape,texNumR=texShape[0],texNumC=texShape[1],glsl=getGlslDifferences();if(texShape!=null&&util_exports.arraysEqual(shape,texShape))return`
      vec4 ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);

        return ${glsl.texture2D}(${texName}, uv);
      }
    `;let packedTexShape=[Math.ceil(texShape[0]/2),Math.ceil(texShape[1]/2)],valuesPerRow=Math.ceil(shape[1]/2);return`
    vec4 ${funcName}(int row, int col) {
      vec2 uv = packedUVfrom2D(${valuesPerRow}, ${packedTexShape[0]}, ${packedTexShape[1]}, row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `}function getSampler2D(inputInfo){let shape=inputInfo.shapeInfo.logicalShape,texName=inputInfo.name,funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1),texShape=inputInfo.shapeInfo.texShape;if(texShape!=null&&util_exports.arraysEqual(shape,texShape)){let texNumR2=texShape[0],texNumC2=texShape[1];return`
    float ${funcName}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC2}.0, ${texNumR2}.0);
      return sampleTexture(${texName}, uv);
    }
  `}let{newShape,keptDims}=util_exports.squeezeShape(shape),squeezedShape=newShape;if(squeezedShape.length<shape.length){let newInputInfo=squeezeInputInfo(inputInfo,squeezedShape),params=["row","col"];return`
      ${getSamplerFromInInfo(newInputInfo)}
      float ${funcName}(int row, int col) {
        return ${funcName}(${getSqueezedParams(params,keptDims)});
      }
    `}if(inputInfo.shapeInfo.isUniform)return`
      float ${funcName}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${shape[1]}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;let texNumR=texShape[0],texNumC=texShape[1],offset=getFlatOffsetUniformName(texName);return texNumC===1?`
    float ${funcName}(int row, int col) {
      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);
      return sampleTexture(${texName}, uv);
    }
  `:texNumR===1?`
    float ${funcName}(int row, int col) {
      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);
      return sampleTexture(${texName}, uv);
    }
  `:`
  float ${funcName}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${shape[1]} + col + ${offset};
    vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
    return sampleTexture(${texName}, uv);
  }
`}function getPackedSampler3D(inputInfo){let shape=inputInfo.shapeInfo.logicalShape,texName=inputInfo.name,funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1),texShape=inputInfo.shapeInfo.texShape,packedTexShape=[Math.ceil(texShape[0]/2),Math.ceil(texShape[1]/2)];if(shape[0]===1){let squeezedShape=shape.slice(1),keptDims=[1,2],newInputInfo=squeezeInputInfo(inputInfo,squeezedShape),params=["b","row","col"];return`
        ${getPackedSamplerFromInInfo(newInputInfo)}
        vec4 ${funcName}(int b, int row, int col) {
          return ${funcName}(${getSqueezedParams(params,keptDims)});
        }
      `}let texNumR=packedTexShape[0],texNumC=packedTexShape[1],valuesPerRow=Math.ceil(shape[2]/2),texelsInBatch=valuesPerRow*Math.ceil(shape[1]/2),glsl=getGlslDifferences();return`
    vec4 ${funcName}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${texNumR}, ${texNumC}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `}function getSampler3D(inputInfo){let shape=inputInfo.shapeInfo.logicalShape,texName=inputInfo.name,funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1),stride0=shape[1]*shape[2],stride1=shape[2],{newShape,keptDims}=util_exports.squeezeShape(shape),squeezedShape=newShape;if(squeezedShape.length<shape.length){let newInputInfo=squeezeInputInfo(inputInfo,squeezedShape),params=["row","col","depth"];return`
        ${getSamplerFromInInfo(newInputInfo)}
        float ${funcName}(int row, int col, int depth) {
          return ${funcName}(${getSqueezedParams(params,keptDims)});
        }
      `}if(inputInfo.shapeInfo.isUniform)return`
      float ${funcName}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${stride0}, ${stride1}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;let texShape=inputInfo.shapeInfo.texShape,texNumR=texShape[0],texNumC=texShape[1],flatOffset=inputInfo.shapeInfo.flatOffset;if(texNumC===stride0&&flatOffset==null)return`
        float ${funcName}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${stride1}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${texNumC}.0, ${texNumR}.0);
          return sampleTexture(${texName}, uv);
        }
      `;if(texNumC===stride1&&flatOffset==null)return`
    float ${funcName}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${shape[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);
      return sampleTexture(${texName}, uv);
    }
  `;let offset=getFlatOffsetUniformName(texName);return`
      float ${funcName}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${stride0} + col * ${stride1} + depth + ${offset};
        vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
        return sampleTexture(${texName}, uv);
      }
  `}function getPackedSamplerND(inputInfo){let shape=inputInfo.shapeInfo.logicalShape,rank=shape.length,texName=inputInfo.name,funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1),texShape=inputInfo.shapeInfo.texShape,packedTexShape=[Math.ceil(texShape[0]/2),Math.ceil(texShape[1]/2)],texNumR=packedTexShape[0],texNumC=packedTexShape[1],valuesPerRow=Math.ceil(shape[rank-1]/2),texelsInBatch=valuesPerRow*Math.ceil(shape[rank-2]/2),params="int b, int row, int col",index=`b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;for(let b=2;b<rank-1;b++)params=`int b${b}, `+params,texelsInBatch*=shape[rank-b-1],index=`b${b} * ${texelsInBatch} + `+index;let glsl=getGlslDifferences();return`
    vec4 ${funcName}(${params}) {
      int index = ${index};
      int texR = index / ${texNumC};
      int texC = index - texR * ${texNumC};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});
      return ${glsl.texture2D}(${texName}, uv);
    }
  `}function getSampler4D(inputInfo){let shape=inputInfo.shapeInfo.logicalShape,texName=inputInfo.name,funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1),stride2=shape[3],stride1=shape[2]*stride2,stride0=shape[1]*stride1,{newShape,keptDims}=util_exports.squeezeShape(shape);if(newShape.length<shape.length){let newInputInfo=squeezeInputInfo(inputInfo,newShape),params=["row","col","depth","depth2"];return`
      ${getSamplerFromInInfo(newInputInfo)}
      float ${funcName}(int row, int col, int depth, int depth2) {
        return ${funcName}(${getSqueezedParams(params,keptDims)});
      }
    `}if(inputInfo.shapeInfo.isUniform)return`
      float ${funcName}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${stride0}, ${stride1}, ${stride2}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;let flatOffset=inputInfo.shapeInfo.flatOffset,texShape=inputInfo.shapeInfo.texShape,texNumR=texShape[0],texNumC=texShape[1];if(texNumC===stride0&&flatOffset==null)return`
      float ${funcName}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${stride1}, ${stride2}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;if(texNumC===stride2&&flatOffset==null)return`
      float ${funcName}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${shape[1]*shape[2]}, ${shape[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;let offset=getFlatOffsetUniformName(texName);return`
    float ${funcName}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} +
          depth * ${stride2} + depth2;
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `}function getSampler5D(inputInfo){let shape=inputInfo.shapeInfo.logicalShape,texName=inputInfo.name,funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1),stride3=shape[4],stride2=shape[3]*stride3,stride1=shape[2]*stride2,stride0=shape[1]*stride1,{newShape,keptDims}=util_exports.squeezeShape(shape);if(newShape.length<shape.length){let newInputInfo=squeezeInputInfo(inputInfo,newShape),params=["row","col","depth","depth2","depth3"];return`
      ${getSamplerFromInInfo(newInputInfo)}
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        return ${funcName}(${getSqueezedParams(params,keptDims)});
      }
    `}if(inputInfo.shapeInfo.isUniform)return`
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +
          depth3;
        ${getUniformSampler(inputInfo)}
      }
    `;let flatOffset=inputInfo.shapeInfo.flatOffset,texShape=inputInfo.shapeInfo.texShape,texNumR=texShape[0],texNumC=texShape[1];if(texNumC===stride0&&flatOffset==null)return`
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${stride1}, ${stride2}, ${stride3}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;if(texNumC===stride3&&flatOffset==null)return`
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${shape[1]*shape[2]*shape[3]},
               ${shape[2]*shape[3]}, ${shape[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;let offset=getFlatOffsetUniformName(texName);return`
    float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
          depth2 * ${stride3} + depth3 + ${offset};
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
      return sampleTexture(${texName}, uv);
    }
  `}function getSampler6D(inputInfo){let shape=inputInfo.shapeInfo.logicalShape,texName=inputInfo.name,funcName="get"+texName.charAt(0).toUpperCase()+texName.slice(1),{newShape,keptDims}=util_exports.squeezeShape(shape);if(newShape.length<shape.length){let newInputInfo=squeezeInputInfo(inputInfo,newShape),params=["row","col","depth","depth2","depth3","depth4"];return`
      ${getSamplerFromInInfo(newInputInfo)}
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${funcName}(${getSqueezedParams(params,keptDims)});
      }
    `}let stride4=shape[5],stride3=shape[4]*stride4,stride2=shape[3]*stride3,stride1=shape[2]*stride2,stride0=shape[1]*stride1;if(inputInfo.shapeInfo.isUniform)return`
      float ${funcName}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +
          dot(
            vec2(depth3, depth4),
            vec2(${stride4}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;let flatOffset=inputInfo.shapeInfo.flatOffset,texShape=inputInfo.shapeInfo.texShape,texNumR=texShape[0],texNumC=texShape[1];if(texNumC===stride0&&flatOffset==null)return`
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${stride1}, ${stride2}, ${stride3}, ${stride4})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;if(texNumC===stride4&&flatOffset==null)return`
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${shape[1]*shape[2]*shape[3]*shape[4]},
               ${shape[2]*shape[3]*shape[4]},
               ${shape[3]*shape[4]},
               ${shape[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;let offset=getFlatOffsetUniformName(texName);return`
    float ${funcName}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
          depth2 * ${stride3} + depth3 * ${stride4} + depth4 + ${offset};
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
      return sampleTexture(${texName}, uv);
    }
  `}function getUniformSampler(inputInfo){let texName=inputInfo.name,inSize=util_exports.sizeFromShape(inputInfo.shapeInfo.logicalShape);return inSize<2?`return ${texName};`:`
    for (int i = 0; i < ${inSize}; i++) {
      if (i == index) {
        return ${texName}[i];
      }
    }
  `}function getPackedSamplerAtOutputCoords(inputInfo,outShapeInfo){let texName=inputInfo.name,texFuncSnippet=texName.charAt(0).toUpperCase()+texName.slice(1),funcName="get"+texFuncSnippet+"AtOutCoords",inRank=inputInfo.shapeInfo.logicalShape.length,outRank=outShapeInfo.logicalShape.length,broadcastDims=getBroadcastDims2(inputInfo.shapeInfo.logicalShape,outShapeInfo.logicalShape),type=getCoordsDataType(outRank),rankDiff=outRank-inRank,coordsSnippet,fields=["x","y","z","w","u","v"];inRank===0?coordsSnippet="":outRank<2&&broadcastDims.length>=1?coordsSnippet="coords = 0;":coordsSnippet=broadcastDims.map(d=>`coords.${fields[d+rankDiff]} = 0;`).join(`
`);let unpackedCoordsSnippet="";outRank<2&&inRank>0?unpackedCoordsSnippet="coords":unpackedCoordsSnippet=inputInfo.shapeInfo.logicalShape.map((s,i)=>`coords.${fields[i+rankDiff]}`).join(", ");let output="return outputValue;",inSize=util_exports.sizeFromShape(inputInfo.shapeInfo.logicalShape),isInputScalar=inSize===1,outSize=util_exports.sizeFromShape(outShapeInfo.logicalShape),isOutputScalar=outSize===1;if(inRank===1&&!isInputScalar&&!isOutputScalar)output=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(isInputScalar&&!isOutputScalar)outRank===1?output=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:output=`
        return vec4(outputValue.x);
      `;else if(broadcastDims.length){let rows=inRank-2,cols=inRank-1;broadcastDims.indexOf(rows)>-1&&broadcastDims.indexOf(cols)>-1?output="return vec4(outputValue.x);":broadcastDims.indexOf(rows)>-1?output="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":broadcastDims.indexOf(cols)>-1&&(output="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${funcName}() {
      ${type} coords = getOutputCoords();
      ${coordsSnippet}
      vec4 outputValue = get${texFuncSnippet}(${unpackedCoordsSnippet});
      ${output}
    }
  `}function getSamplerAtOutputCoords(inputInfo,outShapeInfo){let texName=inputInfo.name,texFuncSnippet=texName.charAt(0).toUpperCase()+texName.slice(1),funcName="get"+texFuncSnippet+"AtOutCoords",outTexShape=outShapeInfo.texShape,inTexShape=inputInfo.shapeInfo.texShape,inRank=inputInfo.shapeInfo.logicalShape.length,outRank=outShapeInfo.logicalShape.length;if(!inputInfo.shapeInfo.isUniform&&inRank===outRank&&inputInfo.shapeInfo.flatOffset==null&&util_exports.arraysEqual(inTexShape,outTexShape))return`
      float ${funcName}() {
        return sampleTexture(${texName}, resultUV);
      }
    `;let type=getCoordsDataType(outRank),broadcastDims=getBroadcastDims2(inputInfo.shapeInfo.logicalShape,outShapeInfo.logicalShape),rankDiff=outRank-inRank,coordsSnippet,fields=["x","y","z","w","u","v"];inRank===0?coordsSnippet="":outRank<2&&broadcastDims.length>=1?coordsSnippet="coords = 0;":coordsSnippet=broadcastDims.map(d=>`coords.${fields[d+rankDiff]} = 0;`).join(`
`);let unpackedCoordsSnippet="";return outRank<2&&inRank>0?unpackedCoordsSnippet="coords":unpackedCoordsSnippet=inputInfo.shapeInfo.logicalShape.map((s,i)=>`coords.${fields[i+rankDiff]}`).join(", "),`
    float ${funcName}() {
      ${type} coords = getOutputCoords();
      ${coordsSnippet}
      return get${texFuncSnippet}(${unpackedCoordsSnippet});
    }
  `}function getCoordsDataType(rank){if(rank<=1)return"int";if(rank===2)return"ivec2";if(rank===3)return"ivec3";if(rank===4)return"ivec4";if(rank===5)return"ivec5";if(rank===6)return"ivec6";throw Error(`GPU for rank ${rank} is not yet supported`)}function squeezeInputInfo(inInfo,squeezedShape){let newInputInfo=JSON.parse(JSON.stringify(inInfo));return newInputInfo.shapeInfo.logicalShape=squeezedShape,newInputInfo}function getSqueezedParams(params,keptDims){return keptDims.map(d=>params[d]).join(", ")}var ArgMinMaxPackedProgram=class{constructor(shape,windowSize,op2,firstPass){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,util_exports.assert(shape.length>2,()=>`Packed arg${op2.charAt(0).toUpperCase()+op2.slice(1)} supports only inputs with rank above 2.`);let inSize=shape[shape.length-1],outSize=Math.ceil(inSize/windowSize);this.outputShape=shape.slice(0,-1),outSize>1&&this.outputShape.push(outSize),firstPass||this.variableNames.push("bestIndicesA");let outShape=this.outputShape,rank=outShape.length,dtype=getCoordsDataType(rank),coords2=getChannels("coords",rank),sourceLocSetup,sourceRank;if(outSize===1){sourceRank=rank+1;let sourceLocDType=getCoordsDataType(sourceRank);sourceLocSetup=`
        ${sourceLocDType} sourceLocR = ${sourceLocDType}(${coords2.join()}, 0);
        ++${coords2[rank-1]};
        ${sourceLocDType} sourceLocG = ${sourceLocDType}(${coords2.join()}, 0);
        ++${coords2[rank-2]};
        ${sourceLocDType} sourceLocA = ${sourceLocDType}(${coords2.join()}, 0);
        --${coords2[rank-1]};
        ${sourceLocDType} sourceLocB = ${sourceLocDType}(${coords2.join()}, 0);
        --${coords2[rank-2]};`}else sourceRank=rank,sourceLocSetup=`
        ${dtype} sourceLocR = coords;
        ++${coords2[rank-1]};
        ${dtype} sourceLocG = coords;
        ++${coords2[rank-2]};
        ${dtype} sourceLocA = coords;
        --${coords2[rank-1]};
        ${dtype} sourceLocB = coords;
        --${coords2[rank-2]};`;let channels=["x","y","z","w","u","v"].slice(0,sourceRank),inChannel="."+channels[sourceRank-1],intChannels=channels.map(x=>"int "+x),srcRCoords=getChannels("sourceLocR",sourceRank-1).concat("inIdx.r"),srcGCoords=getChannels("sourceLocG",sourceRank-1).concat("inIdx.g"),srcBCoords=getChannels("sourceLocB",sourceRank-1).concat("inIdx.b"),srcACoords=getChannels("sourceLocA",sourceRank-1).concat("inIdx.a"),compOp=op2==="max"?"greaterThan":"lessThan",fetchCandidateIdx=firstPass?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${srcRCoords.join()}),
                             getBestIndicesAChannel(${srcGCoords.join()}),
                             getBestIndicesAChannel(${srcBCoords.join()}),
                             getBestIndicesAChannel(${srcACoords.join()})));`,fetchValue=`vec4(
            getAChannel(${srcRCoords.join()}),
            hasNextCol ? getAChannel(${srcGCoords.join()}) : 0.,
            hasNextRow ? getAChannel(${srcBCoords.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${srcACoords.join()}) : 0.)`,getBestIndicesAChannelSnippet=firstPass?"":`
      float getBestIndicesAChannel(${intChannels.join()}) {
        return getChannel(getBestIndicesA(${channels.join()}),
                                          vec2(${channels.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${intChannels.join()}) {
        return getChannel(getA(${channels.join()}),
                               vec2(${channels.slice(-2).join()}));
      }
      ${getBestIndicesAChannelSnippet}
      void main() {
        ${dtype} coords = getOutputCoords();
        bool hasNextCol = ${coords2[rank-1]} < ${outShape[rank-1]-1};
        bool hasNextRow = ${coords2[rank-2]} < ${outShape[rank-2]-1};
        ${sourceLocSetup}
        ivec4 srcIdx = ivec4(sourceLocR${inChannel}, sourceLocG${inChannel},
          sourceLocB${inChannel}, sourceLocA${inChannel}) * ${windowSize};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${fetchValue};

        for (int i = 0; i < ${windowSize}; i++) {
          inIdx = srcIdx;
          ${fetchCandidateIdx}
          vec4 candidate = ${fetchValue};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${compOp}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};var AvgPool2DBackpropProgram=class{constructor(convInfo){this.variableNames=["dy"],this.outputShape=convInfo.inShape;let filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padTop=effectiveFilterHeight-1-convInfo.padInfo.top,padLeft=effectiveFilterWidth-1-convInfo.padInfo.left,avgMultiplier=1/(filterHeight*filterWidth);this.userCode=`
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float avgMultiplier = float(${avgMultiplier});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${effectiveFilterWidth};
            wC+= ${dilationWidth}) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},AvgPool3DBackpropProgram=class{constructor(convInfo){this.variableNames=["dy"],this.outputShape=convInfo.inShape;let filterDepth=convInfo.filterDepth,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,strideDepth=convInfo.strideDepth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationDepth=convInfo.dilationDepth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterDepth=convInfo.effectiveFilterDepth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padFront=effectiveFilterDepth-1-convInfo.padInfo.front,padTop=effectiveFilterHeight-1-convInfo.padInfo.top,padLeft=effectiveFilterWidth-1-convInfo.padInfo.left,avgMultiplier=1/(filterDepth*filterHeight*filterWidth);this.userCode=`
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});
      const float avgMultiplier = float(${avgMultiplier});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
            wD += ${dilationDepth}) {
          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;

          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var CHECK_NAN_SNIPPET=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,INT_DIV=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,POW=`
if(a < 0.0 && floor(b) < b){
  return NAN;
}
if (b == 0.0) {
  return 1.0;
}
return (round(mod(b, 2.0)) != 1) ?
    pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,EQUAL="return float(a == b);",LESS="return float(a < b);",LESS_EQUAL="return float(a <= b);",GREATER="return float(a > b);",GREATER_EQUAL="return float(a >= b);",LOGICAL_AND="return float(a >= 1.0 && b >= 1.0);",LOGICAL_OR="return float(a >= 1.0 || b >= 1.0);",MAX=CHECK_NAN_SNIPPET+`
  return max(a, b);
`,MIN=CHECK_NAN_SNIPPET+`
  return min(a, b);
`,MOD=`if (b == 0.0) return NAN;
  return mod(a, b);`,ELU_DER="return (b >= 1.0) ? a : a * (b + 1.0);",PRELU="return (a < 0.) ? b * a : a;",BinaryOpProgram=class{constructor(op2,aShape,bShape){this.variableNames=["A","B"],this.outputShape=backend_util_exports.assertAndGetBroadcastShape(aShape,bShape),this.userCode=`
      float binaryOperation(float a, float b) {
        ${op2}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};var CHECK_NAN_SNIPPET2=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`,INT_DIV2=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,POW2=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  `+CHECK_NAN_SNIPPET2+`
  return result;
`,PRELU2=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`,ELU_DER2=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,EQUAL2=`
  return vec4(equal(a, b));
`,LESS2=`
  return vec4(lessThan(a, b));
`,LESS_EQUAL2=`
  return vec4(lessThanEqual(a, b));
`,GREATER2=`
  return vec4(greaterThan(a, b));
`,GREATER_EQUAL2=`
  return vec4(greaterThanEqual(a, b));
`,LOGICAL_AND2=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,LOGICAL_OR2=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,MAX2=`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+CHECK_NAN_SNIPPET2+`
  return result;
`,MIN2=`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+CHECK_NAN_SNIPPET2+`
  return result;
`,MOD2=`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  `+CHECK_NAN_SNIPPET2+`
  return result;
`,BinaryOpPackedProgram=class{constructor(op2,aShape,bShape,checkOutOfBounds=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=backend_util_exports.assertAndGetBroadcastShape(aShape,bShape);let rank=this.outputShape.length,checkOutOfBoundsString="";if(checkOutOfBounds)if(rank===0||util_exports.sizeFromShape(this.outputShape)===1)checkOutOfBoundsString=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else{let dtype=getCoordsDataType(rank);if(checkOutOfBoundsString=`
          ${dtype} coords = getOutputCoords();
        `,rank===1)checkOutOfBoundsString+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let channels=getChannels("coords",rank);checkOutOfBoundsString+=`
            bool nextRowOutOfBounds =
              (${channels[rank-2]} + 1) >= ${this.outputShape[rank-2]};
            bool nextColOutOfBounds =
              (${channels[rank-1]} + 1) >= ${this.outputShape[rank-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${op2}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${checkOutOfBoundsString}

        setOutput(result);
      }
    `}};var ClipProgram=class{constructor(aShape){this.variableNames=["A"],this.outputShape=aShape,this.userCode=`
      uniform float minVal;
      uniform float maxVal;

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}getCustomSetupFunc(min7,max9){return(gpgpu,webGLProgram)=>{this.minLoc==null&&(this.minLoc=gpgpu.getUniformLocationNoThrow(webGLProgram,"minVal"),this.maxLoc=gpgpu.getUniformLocationNoThrow(webGLProgram,"maxVal")),gpgpu.gl.uniform1f(this.minLoc,min7),gpgpu.gl.uniform1f(this.maxLoc,max9)}}};var ClipPackedProgram=class{constructor(aShape){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=aShape,this.userCode=`
      uniform float minVal;
      uniform float maxVal;

      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}getCustomSetupFunc(min7,max9){return(gpgpu,webGLProgram)=>{this.minLoc==null&&(this.minLoc=gpgpu.getUniformLocationNoThrow(webGLProgram,"minVal"),this.maxLoc=gpgpu.getUniformLocationNoThrow(webGLProgram,"maxVal")),gpgpu.gl.uniform1f(this.minLoc,min7),gpgpu.gl.uniform1f(this.maxLoc,max9)}}};var ComplexAbsProgram=class{constructor(shape){this.variableNames=["real","imag"],this.outputShape=shape,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};var Conv2DDerFilterProgram=class{constructor(convInfo){this.variableNames=["x","dy"],this.outputShape=convInfo.filterShape;let strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left,isChannelsLast=convInfo.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
            int xR = wR + yR * ${strideHeight} - ${padTop};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
              int xC = wC + yC * ${strideWidth} - ${padLeft};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              if (${isChannelsLast}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Conv2DDerInputProgram=class{constructor(convInfo){this.variableNames=["dy","W"],this.outputShape=convInfo.inShape;let filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,isChannelsLast=convInfo.dataFormat==="channelsLast",padTop=filterHeight-1-convInfo.padInfo.top,padLeft=filterWidth-1-convInfo.padInfo.left,rowDim=isChannelsLast?1:2,colDim=isChannelsLast?2:3,channelDim=isChannelsLast?3:1;this.userCode=`
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${channelDim}];

        ivec2 dyCorner = ivec2(coords[${rowDim}], coords[${colDim}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${filterHeight} - 1 - wR;

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${filterWidth} - 1 - wC;

            for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {

              if (${isChannelsLast}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Conv3DDerFilterProgram=class{constructor(convInfo){this.variableNames=["x","dy"],this.outputShape=convInfo.filterShape;let strideDepth=convInfo.strideDepth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,padFront=convInfo.padInfo.front,padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yF = 0; yF < ${convInfo.outDepth}; yF++) {
            int xF = wF + yF * ${strideDepth} - ${padFront};

            if (xF < 0 || xF >= ${convInfo.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
              int xR = wR + yR * ${strideHeight} - ${padTop};

              if (xR < 0 || xR >= ${convInfo.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
                int xC = wC + yC * ${strideWidth} - ${padLeft};

                if (xC < 0 || xC >= ${convInfo.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Conv3DDerInputProgram=class{constructor(convInfo){this.variableNames=["dy","W"],this.outputShape=convInfo.inShape;let filterDepth=convInfo.filterDepth,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,strideDepth=convInfo.strideDepth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,padFront=filterDepth-1-convInfo.padInfo.front,padTop=filterHeight-1-convInfo.padInfo.top,padLeft=filterWidth-1-convInfo.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${filterDepth}; wF++) {
          float dyF = float(dyFCorner + wF) / ${strideDepth}.0;

          if (dyF < 0.0 || dyF >= ${convInfo.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${filterDepth} - 1 - wF;

          for (int wR = 0; wR < ${filterHeight}; wR++) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${filterHeight} - 1 - wR;

            for (int wC = 0; wC < ${filterWidth}; wC++) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${filterWidth} - 1 - wC;

              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var DepthwiseConv2DDerFilterProgram=class{constructor(convInfo){this.variableNames=["x","dy"],this.outputShape=convInfo.filterShape;let strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left,channelMul=convInfo.outChannels/convInfo.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${channelMul} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
            int xR = wR + yR * ${strideHeight} - ${padTop};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
              int xC = wC + yC * ${strideWidth} - ${padLeft};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},DepthwiseConv2DDerInputProgram=class{constructor(convInfo){this.variableNames=["dy","W"],this.outputShape=convInfo.inShape;let filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,padTop=filterHeight-1-convInfo.padInfo.top,padLeft=filterWidth-1-convInfo.padInfo.left,channelMul=convInfo.outChannels/convInfo.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${filterHeight}; wR++) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${filterHeight} - 1 - wR;

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${filterWidth} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${channelMul}; dm++) {
              int d2 = d1 * ${channelMul} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var Conv2DProgram=class{constructor(convInfo,addBias=!1,activation=null,hasPreluActivationWeights=!1){this.variableNames=["x","W"],this.outputShape=convInfo.outShape;let padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,inputDepthNearestVec4=Math.floor(convInfo.inChannels/4)*4,inputDepthVec4Remainder=convInfo.inChannels%4,isChannelsLast=convInfo.dataFormat==="channelsLast",rowDim=isChannelsLast?1:2,colDim=isChannelsLast?2:3,channelDim=isChannelsLast?3:1,activationSnippet="",applyActivationSnippet="";activation&&(hasPreluActivationWeights?activationSnippet=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${activation}
        }`:activationSnippet=`
          float activation(float x) {
            ${activation}
          }
        `,applyActivationSnippet="result = activation(result);");let addBiasSnippet=addBias?"result += getBiasAtOutCoords();":"";addBias&&this.variableNames.push("bias"),hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.userCode=`
      ${activationSnippet}

      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${channelDim}];

        ivec2 xRCCorner =
            ivec2(coords[${rowDim}], coords[${colDim}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          int xR = xRCorner + wR * ${dilationHeight};

          if (xR < 0 || xR >= ${convInfo.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            int xC = xCCorner + wC * ${dilationWidth};

            if (xC < 0 || xC >= ${convInfo.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${isChannelsLast}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${inputDepthVec4Remainder===1}) {

              if (${isChannelsLast}) {
                dotProd +=
                    getX(batch, xR, xC, ${inputDepthNearestVec4}) *
                    getW(wR, wC, ${inputDepthNearestVec4}, d2);
              } else {
                dotProd +=
                    getX(batch, ${inputDepthNearestVec4}, xR, xC) *
                    getW(wR, wC, ${inputDepthNearestVec4}, d2);
              }

            } else if (${inputDepthVec4Remainder===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${inputDepthNearestVec4}, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2)
              );

              if (${isChannelsLast}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${inputDepthNearestVec4}, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${inputDepthVec4Remainder===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${inputDepthNearestVec4}, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 2, d2)
              );

              if (${isChannelsLast}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${inputDepthNearestVec4}, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `}},Conv3DProgram=class{constructor(convInfo){this.variableNames=["x","W"],this.outputShape=convInfo.outShape;let padFront=convInfo.padInfo.front,padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left,strideDepth=convInfo.strideDepth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationDepth=convInfo.dilationDepth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,filterDepth=convInfo.filterDepth,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,inputDepthNearestVec4=Math.floor(convInfo.inChannels/4)*4,inputDepthVec4Remainder=convInfo.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${filterDepth}; wF++) {
          int xF = xFCorner + wF * ${dilationDepth};

          if (xF < 0 || xF >= ${convInfo.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${filterHeight}; wR++) {
            int xR = xRCorner + wR * ${dilationHeight};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${filterWidth}; wC++) {
              int xC = xCCorner + wC * ${dilationWidth};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${inputDepthVec4Remainder===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}) *
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2);
              } else if (${inputDepthVec4Remainder===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${inputDepthVec4Remainder===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var DepthwiseConv2DProgram=class{constructor(convInfo,addBias=!1,activation=null,hasPreluActivation=!1){this.variableNames=["x","W"],this.outputShape=convInfo.outShape;let xNumRows=convInfo.inHeight,xNumCols=convInfo.inWidth,padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,channelMul=convInfo.outChannels/convInfo.inChannels,activationSnippet="",applyActivationSnippet="";activation&&(hasPreluActivation?activationSnippet=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${activation}
        }`:activationSnippet=`
          float activation(float x) {
            ${activation}
          }
        `,applyActivationSnippet="result = activation(result);");let addBiasSnippet=addBias?"result += getBiasAtOutCoords();":"";addBias&&this.variableNames.push("bias"),hasPreluActivation&&this.variableNames.push("preluActivationWeights"),this.userCode=`
      ${activationSnippet}

      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${channelMul};
        int q = d2 - d1 * ${channelMul};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          int xR = xRCorner + wR * ${dilationHeight};

          if (xR < 0 || xR >= ${xNumRows}) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            int xC = xCCorner + wC * ${dilationWidth};

            if (xC < 0 || xC >= ${xNumCols}) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `}};var DepthwiseConvPacked2DProgram=class{constructor(convInfo,addBias=!1,activation=null,hasPreluActivation=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=convInfo.outShape;let xNumRows=convInfo.inHeight,xNumCols=convInfo.inWidth,padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,filterHeight=convInfo.filterHeight,filterWidth=convInfo.filterWidth,texelsAcross=filterWidth,mainLoop="int xR; int xC; int xCOffset;";for(let r=0;r<filterHeight;r++)for(let c=0;c<filterWidth;c++)mainLoop+=`
          vec4 xTexelR${r}C${c*2} = vec4(0.);
          vec4 wR${r}C${c} = vec4(0.);
          vec4 xR${r}C${c} = vec4(0.);`;for(let r=0;r<filterHeight;r++)for(let texelC=0;texelC<texelsAcross;texelC++){let c=texelC*2;if(mainLoop+=`
          xR = xRCorner + ${r*dilationHeight};
          xC = xCCorner + ${c*dilationWidth};
        `,strideWidth===1){if(c<filterWidth&&(padLeft%2===1?mainLoop+=`
                xCOffset = xC + 1;
                if(xR >= 0 && xR < ${xNumRows} && xCOffset >= 0 && xCOffset < ${xNumCols}) {
                  xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if(xCOffset + 1 >= ${xNumCols}) {
                    xTexelR${r}C${c}.zw = vec2(0.);
                  }
                } else {
                  xTexelR${r}C${c} = vec4(0.);
                }

                xCOffset = xC + 1 - 2;
                if(xR >= 0 && xR < ${xNumRows} && xCOffset >= 0 && xCOffset < ${xNumCols}) {
                  vec4 previous = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if(xCOffset + 1 >= ${xNumCols}) {
                    previous.zw = vec2(0.);
                  }

                  xR${r}C${c} = vec4(previous.zw, xTexelR${r}C${c}.xy);
                } else {
                  xR${r}C${c} = vec4(0, 0, xTexelR${r}C${c}.xy);
                }
              `:mainLoop+=`
                if(xR >= 0 && xR < ${xNumRows} && xC >= 0 && xC < ${xNumCols}) {
                  xTexelR${r}C${c} = getX(batch, xR, xC, d1);
                } else {
                  xTexelR${r}C${c} = vec4(0.);
                }

                xR${r}C${c} = xTexelR${r}C${c};
              `,c+1<filterWidth)){let nextTexelOffset=padLeft%2===0?util_exports.nearestLargerEven(dilationWidth):dilationWidth;dilationWidth%2===0&&padLeft%2===1||dilationWidth%2!==0&&padLeft%2!==1?(mainLoop+=`
                  xCOffset = xC + ${padLeft%2} + ${nextTexelOffset};

                  if(xR >= 0 && xR < ${xNumRows} &&
                    xCOffset >= 0 && xCOffset < ${xNumCols}) {
                    xTexelR${r}C${c+2} = getX(batch, xR, xCOffset, d1);
                  }
                `,dilationWidth>1&&(mainLoop+=`
                    xCOffset -= 2;
                    if(xR >= 0 && xR < ${xNumRows} &&
                      xCOffset >= 0 && xCOffset < ${xNumCols}) {
                      xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);
                    } else {
                      xTexelR${r}C${c} = vec4(0.);
                    }
                  `),mainLoop+=`
                  xR${r}C${c+1} = vec4(
                    xTexelR${r}C${c}.zw, xTexelR${r}C${c+2}.xy);
                `):mainLoop+=`
                  xCOffset = xC + ${nextTexelOffset};

                  if(xR >= 0 && xR < ${xNumRows} &&
                    xCOffset >= 0 && xCOffset < ${xNumCols}) {
                    xTexelR${r}C${c+2} = getX(batch, xR, xCOffset, d1);
                  }

                  xR${r}C${c+1} = xTexelR${r}C${c+2};
                `}}else c<filterWidth&&(mainLoop+=`
              if(xR >= 0 && xR < ${xNumRows}) {
            `,padLeft%2===1?(mainLoop+=`
                xCOffset = xC + 1 - ${strideWidth};
                if(xCOffset >= 0 && xCOffset < ${xNumCols}) {
                  xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);
                } else {
                  xTexelR${r}C${c} = vec4(0.);
                }

                if(xC + 1 >= 0 && xC + 1 < ${xNumCols}) {
                  xTexelR${r}C${c+2} = getX(batch, xR, xC + 1, d1);
                } else {
                  xTexelR${r}C${c+2} = vec4(0.);
                }

                xR${r}C${c} = vec4(
                  xTexelR${r}C${c}.zw, xTexelR${r}C${c+2}.zw);
              `,c+1<filterWidth&&(mainLoop+=`
                  vec4 final = vec4(0.);
                  xCOffset = xC + 1 + ${strideWidth};
                  if(xCOffset >= 0 && xCOffset < ${xNumCols}) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xR${r}C${c+1} = vec4(xTexelR${r}C${c+2}.xy, final.xy);
                `)):(mainLoop+=`
                if(xC >= 0 && xC < ${xNumCols}) {
                  xTexelR${r}C${c} = getX(batch, xR, xC, d1);
                } else {
                  xTexelR${r}C${c} = vec4(0.);
                }

                xCOffset = xC + ${strideWidth};
                if(xCOffset >= 0 && xCOffset < ${xNumCols}) {
                  xTexelR${r}C${c+2} = getX(batch, xR, xCOffset, d1);
                } else {
                  xTexelR${r}C${c+2} = vec4(0.);
                }

                xR${r}C${c} = vec4(
                  xTexelR${r}C${c}.xy, xTexelR${r}C${c+2}.xy);
              `,c+1<filterWidth&&(mainLoop+=`
                  xR${r}C${c+1} = vec4(
                    xTexelR${r}C${c}.zw, xTexelR${r}C${c+2}.zw);
                `)),mainLoop+="}");c<filterWidth&&(mainLoop+=`
            vec4 wTexelR${r}C${c} = getW(${r}, ${c}, d1, q);
            wR${r}C${c} = vec4(wTexelR${r}C${c}.xz, wTexelR${r}C${c}.xz);
          `,c+1<filterWidth&&(mainLoop+=`
              vec4 wTexelR${r}C${c+1} = getW(${r}, ${c+1}, d1, q);
              wR${r}C${c+1} =
                vec4(wTexelR${r}C${c+1}.xz, wTexelR${r}C${c+1}.xz);`))}for(let r=0;r<filterHeight;r++)for(let c=0;c<filterWidth;c++)mainLoop+=`dotProd += xR${r}C${c} * wR${r}C${c};`;let activationSnippet="",applyActivationSnippet="";activation&&(hasPreluActivation?activationSnippet=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${activation}
        }`:activationSnippet=`vec4 activation(vec4 x) {
          ${activation}
        }`,applyActivationSnippet="result = activation(result);");let addBiasSnippet=addBias?"result += getBiasAtOutCoords();":"";addBias&&this.variableNames.push("bias"),hasPreluActivation&&this.variableNames.push("preluActivationWeights"),this.userCode=`
      ${activationSnippet}

      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {

        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2;
        int q = 0;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        vec4 dotProd = vec4(0.);

        ${mainLoop}

        vec4 result = dotProd;
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `}};var CropAndResizeProgram=class{constructor(imageShape,boxShape,cropSize,method,extrapolationValue){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[batch,imageHeight,imageWidth,depth]=imageShape,[numBoxes]=boxShape,[cropHeight,cropWidth]=cropSize;this.outputShape=[numBoxes,cropHeight,cropWidth,depth];let methodId=method==="bilinear"?1:0,[inputHeightFloat,inputWidthFloat]=[`${imageHeight-1}.0`,`${imageWidth-1}.0`],[heightRatio,heightScale,inY]=cropHeight>1?[`${(imageHeight-1)/(cropHeight-1)}`,"(y2-y1) * height_ratio",`y1*${inputHeightFloat} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${inputHeightFloat}`],[widthRatio,widthScale,inX]=cropWidth>1?[`${(imageWidth-1)/(cropWidth-1)}`,"(x2-x1) * width_ratio",`x1*${inputWidthFloat} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${inputWidthFloat}`];this.userCode=`
      const float height_ratio = float(${heightRatio});
      const float width_ratio = float(${widthRatio});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${batch}) {
          return;
        }

        float height_scale = ${heightScale};
        float width_scale = ${widthScale};

        float in_y = ${inY};
        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {
          setOutput(float(${extrapolationValue}));
          return;
        }
        float in_x = ${inX};
        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {
          setOutput(float(${extrapolationValue}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${methodId} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}},CumSumProgram=class{constructor(shape,exclusive,reverse7){this.variableNames=["x"],this.outputShape=shape;let rank=shape.length,val=exclusive?"0.0":`getX(${getCoords(rank,"coords")})`,length=shape[shape.length-1],condition="",idxString="";exclusive?(condition=reverse7?`end != ${length-1}`:"end != 0",idxString=reverse7?"end + 1":"end - 1"):(condition=reverse7?`end + pow2 < ${length}`:"end >= pow2",idxString=reverse7?"end + pow2":"end - pow2"),this.userCode=`
      uniform float index;
      void main() {
        ${getCoordsDataType(rank)} coords = getOutputCoords();
        int end = ${getFinalCoord(rank,"coords")};
        float val = ${val};
        int pow2 = int(pow(2.0, index));
        if (${condition}) {
          int idx = ${idxString};
          ${getFinalCoord(rank,"coords")} = idx;
          val += getX(${getCoords(rank,"coords")});
        }
        setOutput(val);
      }
    `}getCustomSetupFunc(index){return(gpgpu,webGLProgram)=>{this.index==null&&(this.index=gpgpu.getUniformLocation(webGLProgram,"index")),gpgpu.gl.uniform1f(this.index,index)}}};function getCoords(rank,name){if(rank===1)return`${name}`;if(rank===2)return`${name}.x, ${name}.y`;if(rank===3)return`${name}.x, ${name}.y, ${name}.z`;if(rank===4)return`${name}.x, ${name}.y, ${name}.z, ${name}.w`;throw Error(`Cumulative sum for rank ${rank} is not yet supported`)}function getFinalCoord(rank,name){if(rank===1)return`${name}`;if(rank===2)return`${name}.y`;if(rank===3)return`${name}.z`;if(rank===4)return`${name}.w`;throw Error(`Cumulative sum for rank ${rank} is not yet supported`)}var DecodeMatrixProgram=class{constructor(outputShape){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=PackingScheme.DENSE;let texShape=getDenseTexShape(outputShape),glsl=getGlslDifferences();this.outputShape=outputShape,this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${getLogicalCoordinatesFromFlatIndex(["r","c","d"],outputShape)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx *
          vec2(${texShape[0]}, ${texShape[1]}));
        int index = 4 * (resTexRC.x * ${texShape[1]} + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${glsl.output} = result;
      }
    `}};var DecodeMatrixPackedProgram=class{constructor(outputShape){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=PackingScheme.DENSE;let texShape=getDenseTexShape(outputShape),glsl=getGlslDifferences();this.outputShape=outputShape,this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${getLogicalCoordinatesFromFlatIndex(["r","c","d"],outputShape)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx *
          vec2(${texShape[0]}, ${texShape[1]}));
        int index = 4 * (resTexRC.x * ${texShape[1]} + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${glsl.output} = result;
      }
    `}};var DepthToSpaceProgram=class{constructor(outputShape,blockSize,dataFormat){this.variableNames=["x"],this.outputShape=[],this.outputShape=outputShape,this.blockSize=blockSize,this.dataFormat=dataFormat,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${blockSize};
      int offset_h = imod(h, ${blockSize});
      int in_w = w / ${blockSize};
      int offset_w = imod(w, ${blockSize});
      int offset_d = (offset_h * ${blockSize} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};var DiagProgram=class{constructor(size){this.variableNames=["X"],this.outputShape=[size,size],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};var EncodeFloatProgram=class{constructor(outputShape){this.variableNames=["A"],this.outTexUsage=TextureUsage.DOWNLOAD;let glsl=getGlslDifferences();this.outputShape=outputShape,this.userCode=`
      ${ENCODE_FLOAT_SNIPPET}

      void main() {
        float x = getAAtOutCoords();
        ${glsl.output} = encode_float(x);
      }
    `}};var EncodeFloatPackedProgram=class{constructor(outputShape){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=TextureUsage.DOWNLOAD;let glsl=getGlslDifferences();this.outputShape=outputShape,this.userCode=`
      ${ENCODE_FLOAT_SNIPPET}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${glsl.output} = encode_float(x);
      }
    `}};var EncodeMatrixProgram=class{constructor(outputShape,texShape,inputIsUnsignedByte=!1){this.variableNames=["A"];let glsl=getGlslDifferences(),[height,width]=texShape;this.outputShape=outputShape;let output="result";inputIsUnsignedByte&&(output="floor(result * 255. + 0.5)"),this.userCode=`
      ${getFlatIndexFrom3D(outputShape)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / ${width};
        int c = imod(flatIndex, ${width});
        vec2 uv = (vec2(c, r) + halfCR) / vec2(${width}.0, ${height}.0);
        vec4 values = ${glsl.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${glsl.output} = vec4(${output}, 0., 0., 0.);
      }
    `}};var EncodeMatrixPackedProgram=class{constructor(outputShape,texShape,inputIsUnsignedByte=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let glsl=getGlslDifferences(),[height,width]=texShape;this.outputShape=outputShape;let mainLoop="",output="result";inputIsUnsignedByte&&(output="floor(result * 255. + 0.5)");for(let row=0;row<=1;row++)for(let col=0;col<=1;col++){let channel=row*2+col;mainLoop+=`
          localCoords = coords;
          if(localCoords[2] + ${col} < ${outputShape[2]}) {
            localCoords[2] += ${col};
            if(localCoords[1] + ${row} < ${outputShape[1]}) {
              localCoords[1] += ${row};

              flatIndex = getFlatIndex(localCoords);
              offset = imod(flatIndex, 4);

              flatIndex = idiv(flatIndex, 4, 1.);

              r = flatIndex / ${width};
              c = imod(flatIndex, ${width});
              uv = (vec2(c, r) + halfCR) / vec2(${width}.0, ${height}.0);
              values = ${glsl.texture2D}(A, uv);

              if(offset == 0) {
                result[${channel}] = values[0];
              } else if(offset == 1) {
                result[${channel}] = values[1];
              } else if(offset == 2) {
                result[${channel}] = values[2];
              } else {
                result[${channel}] = values[3];
              }
            }
          }
        `}this.userCode=`
      ${getFlatIndexFrom3D(outputShape)}

      void main() {
        ivec3 coords = getOutputCoords();

        vec4 result = vec4(0.);
        int flatIndex, r, c, offset;
        ivec3 localCoords;
        vec2 uv;
        vec4 values;

        ${mainLoop}

        ${glsl.output} = ${output};
      }
    `}};var FillProgram=class{constructor(shape,value){this.outputShape=[],this.variableNames=["x"],this.outputShape=shape,this.userCode=`
      uniform float value;
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}getCustomSetupFunc(value){return(gpgpu,webGLProgram)=>{this.valueLoc==null&&(this.valueLoc=gpgpu.getUniformLocationNoThrow(webGLProgram,"value")),gpgpu.gl.uniform1f(this.valueLoc,value)}}};var GatherProgram=class{constructor(aShape,indicesLength,axis){this.variableNames=["A","indices"];let outputShape=aShape.slice();outputShape[axis]=indicesLength,this.outputShape=outputShape,this.rank=outputShape.length;let dtype=getCoordsDataType(this.rank),sourceCoords=getSourceCoords2(aShape,axis);this.userCode=`
      void main() {
        ${dtype} resRC = getOutputCoords();
        setOutput(getA(${sourceCoords}));
      }
    `}};function getSourceCoords2(aShape,axis){let rank=aShape.length;if(rank>4)throw Error(`Gather for rank ${rank} is not yet supported`);if(rank===1)return"int(getIndices(resRC))";let currentCoords=["resRC.x","resRC.y","resRC.z","resRC.w"],sourceCoords=[];for(let i=0;i<aShape.length;i++)i===axis?sourceCoords.push(`int(getIndices(${currentCoords[i]}))`):sourceCoords.push(`${currentCoords[i]}`);return sourceCoords.join()}var GatherNDProgram=class{constructor(sliceDim,strides,shape){this.sliceDim=sliceDim,this.strides=strides,this.variableNames=["x","indices"],this.outputShape=shape;let stridesType=getCoordsDataType(strides.length),dtype=getCoordsDataType(shape.length),strideString=this.sliceDim>1?"strides[j]":"strides";this.userCode=`
        ${stridesType} strides = ${stridesType}(${this.strides});
         void main() {
          ${dtype} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${strideString};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `}};function createVertexShader2(gl){let glsl=getGlslDifferences(),vertexShaderSource=`${glsl.version}
    precision highp float;
    ${glsl.attribute} vec3 clipSpacePos;
    ${glsl.attribute} vec2 uv;
    ${glsl.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return createVertexShader(gl,vertexShaderSource)}function createVertexBuffer(gl){let vertexArray=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return createStaticVertexBuffer(gl,vertexArray)}function createIndexBuffer(gl){let triangleVertexIndices=new Uint16Array([0,1,2,2,1,3]);return createStaticIndexBuffer(gl,triangleVertexIndices)}function createAndConfigureTexture(gl,width,height,internalFormat,textureFormat,textureType){validateTextureSize(width,height);let texture=createTexture(gl),tex2d=gl.TEXTURE_2D;return callAndCheck(gl,()=>gl.bindTexture(tex2d,texture)),callAndCheck(gl,()=>gl.texParameteri(tex2d,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE)),callAndCheck(gl,()=>gl.texParameteri(tex2d,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE)),callAndCheck(gl,()=>gl.texParameteri(tex2d,gl.TEXTURE_MIN_FILTER,gl.NEAREST)),callAndCheck(gl,()=>gl.texParameteri(tex2d,gl.TEXTURE_MAG_FILTER,gl.NEAREST)),callAndCheck(gl,()=>gl.texImage2D(tex2d,0,internalFormat,width,height,0,textureFormat,textureType,null)),callAndCheck(gl,()=>gl.bindTexture(gl.TEXTURE_2D,null)),texture}function getInternalFormatForFloat32MatrixTexture(textureConfig){return textureConfig.internalFormatFloat}function createFloat32MatrixTexture(gl,rows,columns,textureConfig){let[width,height]=getUnpackedMatrixTextureShapeWidthHeight(rows,columns);return createAndConfigureTexture(gl,width,height,getInternalFormatForFloat32MatrixTexture(textureConfig),textureConfig.textureFormatFloat,gl.FLOAT)}function getInternalFormatForFloat16MatrixTexture(textureConfig){return textureConfig.internalFormatHalfFloat}function createFloat16MatrixTexture(gl,rows,columns,textureConfig){let[width,height]=getUnpackedMatrixTextureShapeWidthHeight(rows,columns);return createAndConfigureTexture(gl,width,height,getInternalFormatForFloat16MatrixTexture(textureConfig),textureConfig.textureFormatFloat,textureConfig.textureTypeHalfFloat)}function getInternalFormatForUnsignedBytesMatrixTexture(textureConfig){return textureConfig.downloadTextureFormat}function createUnsignedBytesMatrixTexture(gl,rows,columns,textureConfig){let[width,height]=getUnpackedMatrixTextureShapeWidthHeight(rows,columns);return createAndConfigureTexture(gl,width,height,getInternalFormatForUnsignedBytesMatrixTexture(textureConfig),gl.RGBA,gl.UNSIGNED_BYTE)}function getInternalFormatForPackedMatrixTexture(textureConfig){return textureConfig.internalFormatPackedFloat}function createPackedMatrixTexture(gl,rows,columns,textureConfig){let[width,height]=getPackedMatrixTextureShapeWidthHeight(rows,columns);return createAndConfigureTexture(gl,width,height,getInternalFormatForPackedMatrixTexture(textureConfig),gl.RGBA,gl.FLOAT)}function getInternalFormatForFloat16PackedMatrixTexture(textureConfig){return textureConfig.internalFormatPackedHalfFloat}function createFloat16PackedMatrixTexture(gl,rows,columns,textureConfig){let[width,height]=getPackedMatrixTextureShapeWidthHeight(rows,columns);return createAndConfigureTexture(gl,width,height,getInternalFormatForFloat16PackedMatrixTexture(textureConfig),gl.RGBA,textureConfig.textureTypeHalfFloat)}function bindVertexProgramAttributeStreams(gl,program,vertexBuffer){let posOffset=0,uvOffset=3*4,stride=3*4+2*4;callAndCheck(gl,()=>gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer));let success=bindVertexBufferToProgramAttribute(gl,program,"clipSpacePos",vertexBuffer,3,stride,posOffset);return success&&bindVertexBufferToProgramAttribute(gl,program,"uv",vertexBuffer,2,stride,uvOffset)}function uploadDenseMatrixToTexture(gl,texture,width,height,data,textureConfig){callAndCheck(gl,()=>gl.bindTexture(gl.TEXTURE_2D,texture));let dataForUpload,texelDataType,internalFormat;data instanceof Uint8Array?(dataForUpload=new Uint8Array(width*height*4),texelDataType=gl.UNSIGNED_BYTE,internalFormat=gl.RGBA):(dataForUpload=new Float32Array(width*height*4),texelDataType=gl.FLOAT,internalFormat=textureConfig.internalFormatPackedFloat),dataForUpload.set(data),callAndCheck(gl,()=>gl.texImage2D(gl.TEXTURE_2D,0,internalFormat,width,height,0,gl.RGBA,texelDataType,dataForUpload)),callAndCheck(gl,()=>gl.bindTexture(gl.TEXTURE_2D,null))}function uploadPixelDataToTexture(gl,texture,pixels){callAndCheck(gl,()=>gl.bindTexture(gl.TEXTURE_2D,texture)),pixels.data instanceof Uint8Array?callAndCheck(gl,()=>gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,pixels.width,pixels.height,0,gl.RGBA,gl.UNSIGNED_BYTE,pixels.data)):callAndCheck(gl,()=>gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,pixels)),callAndCheck(gl,()=>gl.bindTexture(gl.TEXTURE_2D,null))}function createBufferFromOutputTexture(gl2,rows,columns,textureConfig){let buffer10=gl2.createBuffer();callAndCheck(gl2,()=>gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER,buffer10));let bytesPerFloat=4,valuesPerTexel=4,bufferSizeBytes=bytesPerFloat*valuesPerTexel*rows*columns;return callAndCheck(gl2,()=>gl2.bufferData(gl2.PIXEL_PACK_BUFFER,bufferSizeBytes,gl2.STREAM_READ)),callAndCheck(gl2,()=>gl2.readPixels(0,0,columns,rows,gl2.RGBA,gl2.FLOAT,0)),callAndCheck(gl2,()=>gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER,null)),buffer10}function downloadFloat32MatrixFromBuffer(gl,buffer10,size){let gl2=gl,downloadTarget=new Float32Array(size);return gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER,buffer10),gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER,0,downloadTarget),gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER,null),downloadTarget}function downloadByteEncodedFloatMatrixFromOutputTexture(gl,rows,columns,textureConfig){let[w,h]=getUnpackedMatrixTextureShapeWidthHeight(rows,columns),numChannels=4,downloadTarget=new Uint8Array(getUnpackedArraySizeFromMatrixSize(rows*columns,numChannels));return callAndCheck(gl,()=>gl.readPixels(0,0,w,h,textureConfig.downloadTextureFormat,gl.UNSIGNED_BYTE,downloadTarget)),new Float32Array(downloadTarget.buffer)}function downloadPackedMatrixFromBuffer(gl,buffer10,batch,rows,cols,physicalRows,physicalCols,textureConfig){let gl2=gl,downloadTarget=new Float32Array(getPackedRGBAArraySizeFromMatrixShape(physicalRows,physicalCols));return gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER,buffer10),gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER,0,downloadTarget),gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER,null),downloadTarget}function downloadMatrixFromPackedOutputTexture(gl,physicalRows,physicalCols){let packedRGBA=new Float32Array(physicalRows*physicalCols*4);return callAndCheck(gl,()=>gl.readPixels(0,0,physicalCols,physicalRows,gl.RGBA,gl.FLOAT,packedRGBA)),packedRGBA}var GPGPUContext=class{constructor(gl){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];let glVersion=env().getNumber("WEBGL_VERSION");gl!=null?(this.gl=gl,setWebGLContext(glVersion,gl)):this.gl=getWebGLContext(glVersion);let COLOR_BUFFER_FLOAT="WEBGL_color_buffer_float",COLOR_BUFFER_HALF_FLOAT="EXT_color_buffer_half_float";if(env().getNumber("WEBGL_VERSION")===1){let TEXTURE_FLOAT="OES_texture_float",TEXTURE_HALF_FLOAT="OES_texture_half_float";if(this.textureFloatExtension=getExtensionOrThrow(this.gl,TEXTURE_FLOAT),hasExtension(this.gl,TEXTURE_HALF_FLOAT))this.textureHalfFloatExtension=getExtensionOrThrow(this.gl,TEXTURE_HALF_FLOAT);else if(env().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(COLOR_BUFFER_FLOAT),hasExtension(this.gl,COLOR_BUFFER_HALF_FLOAT))this.colorBufferHalfFloatExtension=getExtensionOrThrow(this.gl,COLOR_BUFFER_HALF_FLOAT);else if(env().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(COLOR_BUFFER_FLOAT="EXT_color_buffer_float",hasExtension(this.gl,COLOR_BUFFER_FLOAT))this.colorBufferFloatExtension=this.gl.getExtension(COLOR_BUFFER_FLOAT);else if(hasExtension(this.gl,COLOR_BUFFER_HALF_FLOAT))this.colorBufferHalfFloatExtension=this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=createVertexBuffer(this.gl),this.indexBuffer=createIndexBuffer(this.gl),this.framebuffer=createFramebuffer(this.gl),this.textureConfig=getTextureConfig(this.gl,this.textureHalfFloatExtension)}get debug(){return env().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let gl=this.gl;callAndCheck(gl,()=>gl.finish()),callAndCheck(gl,()=>gl.bindFramebuffer(gl.FRAMEBUFFER,null)),callAndCheck(gl,()=>gl.deleteFramebuffer(this.framebuffer)),callAndCheck(gl,()=>gl.bindBuffer(gl.ARRAY_BUFFER,null)),callAndCheck(gl,()=>gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,null)),callAndCheck(gl,()=>gl.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(rows,columns){return this.throwIfDisposed(),createFloat32MatrixTexture(this.gl,rows,columns,this.textureConfig)}createFloat16MatrixTexture(rows,columns){return this.throwIfDisposed(),createFloat16MatrixTexture(this.gl,rows,columns,this.textureConfig)}createUnsignedBytesMatrixTexture(rows,columns){return this.throwIfDisposed(),createUnsignedBytesMatrixTexture(this.gl,rows,columns,this.textureConfig)}uploadPixelDataToTexture(texture,pixels){this.throwIfDisposed(),uploadPixelDataToTexture(this.gl,texture,pixels)}uploadDenseMatrixToTexture(texture,width,height,data){this.throwIfDisposed(),uploadDenseMatrixToTexture(this.gl,texture,width,height,data,this.textureConfig)}createFloat16PackedMatrixTexture(rows,columns){return this.throwIfDisposed(),createFloat16PackedMatrixTexture(this.gl,rows,columns,this.textureConfig)}createPackedMatrixTexture(rows,columns){return this.throwIfDisposed(),createPackedMatrixTexture(this.gl,rows,columns,this.textureConfig)}deleteMatrixTexture(texture){this.throwIfDisposed(),this.outputTexture===texture&&(unbindColorTextureFromFramebuffer(this.gl,this.framebuffer),this.outputTexture=null),callAndCheck(this.gl,()=>this.gl.deleteTexture(texture))}downloadByteEncodedFloatMatrixFromOutputTexture(texture,rows,columns){return this.downloadMatrixDriver(texture,()=>downloadByteEncodedFloatMatrixFromOutputTexture(this.gl,rows,columns,this.textureConfig))}downloadPackedMatrixFromBuffer(buffer10,batch,rows,columns,physicalRows,physicalCols){return downloadPackedMatrixFromBuffer(this.gl,buffer10,batch,rows,columns,physicalRows,physicalCols,this.textureConfig)}downloadFloat32MatrixFromBuffer(buffer10,size){return downloadFloat32MatrixFromBuffer(this.gl,buffer10,size)}createBufferFromTexture(texture,rows,columns){this.bindTextureToFrameBuffer(texture);let result=createBufferFromOutputTexture(this.gl,rows,columns,this.textureConfig);return this.unbindTextureToFrameBuffer(),result}createAndWaitForFence(){let fenceContext=this.createFence(this.gl);return this.pollFence(fenceContext)}createFence(gl){let query,isFencePassed;if(env().getBool("WEBGL_FENCE_API_ENABLED")){let gl2=gl,sync=gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE,0);gl.flush(),isFencePassed=()=>{let status=gl2.clientWaitSync(sync,0,0);return status===gl2.ALREADY_SIGNALED||status===gl2.CONDITION_SATISFIED},query=sync}else env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(query=this.beginQuery(),this.endQuery(),isFencePassed=()=>this.isQueryAvailable(query,env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):isFencePassed=()=>!0;return{query,isFencePassed}}downloadMatrixFromPackedTexture(texture,physicalRows,physicalCols){return this.downloadMatrixDriver(texture,()=>downloadMatrixFromPackedOutputTexture(this.gl,physicalRows,physicalCols))}createProgram(fragmentShaderSource){this.throwIfDisposed();let gl=this.gl,fragmentShader=createFragmentShader(gl,fragmentShaderSource),vertexShader=createVertexShader2(gl),program=createProgram(gl);return callAndCheck(gl,()=>gl.attachShader(program,vertexShader)),callAndCheck(gl,()=>gl.attachShader(program,fragmentShader)),linkProgram(gl,program),this.debug&&validateProgram(gl,program),this.vertexAttrsAreBound||(this.setProgram(program),this.vertexAttrsAreBound=bindVertexProgramAttributeStreams(gl,this.program,this.vertexBuffer)),program}deleteProgram(program){this.throwIfDisposed(),program===this.program&&(this.program=null),program!=null&&callAndCheck(this.gl,()=>this.gl.deleteProgram(program))}setProgram(program){this.throwIfDisposed(),this.program=program,this.program!=null&&this.debug&&validateProgram(this.gl,this.program),callAndCheck(this.gl,()=>this.gl.useProgram(program))}getUniformLocation(program,uniformName,shouldThrow=!0){return this.throwIfDisposed(),shouldThrow?getProgramUniformLocationOrThrow(this.gl,program,uniformName):getProgramUniformLocation(this.gl,program,uniformName)}getAttributeLocation(program,attribute){return this.throwIfDisposed(),callAndCheck(this.gl,()=>this.gl.getAttribLocation(program,attribute))}getUniformLocationNoThrow(program,uniformName){return this.throwIfDisposed(),this.gl.getUniformLocation(program,uniformName)}setInputMatrixTexture(inputMatrixTexture,uniformLocation,textureUnit){this.throwIfDisposed(),this.throwIfNoProgram(),bindTextureToProgramUniformSampler(this.gl,inputMatrixTexture,uniformLocation,textureUnit)}setOutputMatrixTexture(outputMatrixTexture,rows,columns){this.setOutputMatrixTextureDriver(outputMatrixTexture,columns,rows)}setOutputPackedMatrixTexture(outputPackedMatrixTexture,rows,columns){this.throwIfDisposed();let[width,height]=getPackedMatrixTextureShapeWidthHeight(rows,columns);this.setOutputMatrixTextureDriver(outputPackedMatrixTexture,width,height)}setOutputMatrixWriteRegion(startRow,numRows,startColumn,numColumns){this.setOutputMatrixWriteRegionDriver(startColumn,startRow,numColumns,numRows)}setOutputPackedMatrixWriteRegion(startRow,numRows,startColumn,numColumns){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&validateProgram(this.gl,this.program),validateFramebuffer(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let gl=this.gl;this.debug&&this.debugValidate(),callAndCheck(gl,()=>gl.drawElements(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),callAndCheck(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=getExtensionOrThrow(this.gl,env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let gl2=this.gl,ext2=this.getQueryTimerExtensionWebGL2(),query2=gl2.createQuery();return gl2.beginQuery(ext2.TIME_ELAPSED_EXT,query2),query2}let ext=this.getQueryTimerExtensionWebGL1(),query=ext.createQueryEXT();return ext.beginQueryEXT(ext.TIME_ELAPSED_EXT,query),query}endQuery(){if(env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let gl2=this.gl,ext2=this.getQueryTimerExtensionWebGL2();gl2.endQuery(ext2.TIME_ELAPSED_EXT);return}let ext=this.getQueryTimerExtensionWebGL1();ext.endQueryEXT(ext.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(query){return await util_exports.repeatedTry(()=>this.disposed||this.isQueryAvailable(query,env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(query,env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(query,queryTimerVersion){if(queryTimerVersion===0)return null;if(queryTimerVersion===2){let gl2=this.gl,timeElapsedNanos=gl2.getQueryParameter(query,gl2.QUERY_RESULT);return timeElapsedNanos/1e6}else{let ext=this.getQueryTimerExtensionWebGL1(),timeElapsedNanos=ext.getQueryObjectEXT(query,ext.QUERY_RESULT_EXT);return timeElapsedNanos/1e6}}isQueryAvailable(query,queryTimerVersion){if(queryTimerVersion===0)return!0;if(queryTimerVersion===2){let gl2=this.gl,ext=this.getQueryTimerExtensionWebGL2(),available=gl2.getQueryParameter(query,gl2.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(ext.GPU_DISJOINT_EXT)),available&&!this.disjoint}else{let ext=this.getQueryTimerExtensionWebGL1(),available=ext.getQueryObjectEXT(query,ext.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(ext.GPU_DISJOINT_EXT)),available&&!this.disjoint}}pollFence(fenceContext){return new Promise(resolve=>{this.addItemToPoll(()=>fenceContext.isFencePassed(),()=>resolve())})}pollItems(){let index=linearSearchLastTrue(this.itemsToPoll.map(x=>x.isDoneFn));for(let i=0;i<=index;++i){let{resolveFn}=this.itemsToPoll[i];resolveFn()}this.itemsToPoll=this.itemsToPoll.slice(index+1)}addItemToPoll(isDoneFn,resolveFn){if(this.itemsToPoll.push({isDoneFn,resolveFn}),this.itemsToPoll.length>1)return;util_exports.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(texture){this.throwIfDisposed(),bindColorTextureToFramebuffer(this.gl,texture,this.framebuffer),this.debug&&validateFramebuffer(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(bindColorTextureToFramebuffer(this.gl,this.outputTexture,this.framebuffer),this.debug&&validateFramebuffer(this.gl)):unbindColorTextureFromFramebuffer(this.gl,this.framebuffer)}downloadMatrixDriver(texture,downloadAndDecode){this.bindTextureToFrameBuffer(texture);let result=downloadAndDecode();return this.unbindTextureToFrameBuffer(),result}setOutputMatrixTextureDriver(outputMatrixTextureMaybePacked,width,height){this.throwIfDisposed();let gl=this.gl;bindColorTextureToFramebuffer(gl,outputMatrixTextureMaybePacked,this.framebuffer),this.debug&&validateFramebuffer(gl),this.outputTexture=outputMatrixTextureMaybePacked,callAndCheck(gl,()=>gl.viewport(0,0,width,height)),callAndCheck(gl,()=>gl.scissor(0,0,width,height))}setOutputMatrixWriteRegionDriver(x,y,width,height){this.throwIfDisposed(),callAndCheck(this.gl,()=>this.gl.scissor(x,y,width,height))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function linearSearchLastTrue(arr){let i=0;for(;i<arr.length;++i){let isDone=arr[i]();if(!isDone)break}return i-1}function compileProgram(gpgpu,program,inputs,output){let userCode=program.userCode,inputInfos=inputs.map((input2,i)=>{let shapeInfo={logicalShape:input2.shape,texShape:input2.isUniform?null:input2.texData.texShape,isUniform:input2.isUniform,isPacked:input2.isUniform?!1:input2.texData.isPacked,flatOffset:null};return input2.texData!=null&&input2.texData.slice!=null&&input2.texData.slice.flatOffset>0&&(shapeInfo.flatOffset=input2.texData.slice.flatOffset),{name:program.variableNames[i],shapeInfo}}),inShapeInfos=inputInfos.map(x=>x.shapeInfo),outShapeInfo={logicalShape:output.shape,texShape:output.texData.texShape,isUniform:!1,isPacked:output.texData.isPacked,flatOffset:null},source=makeShader(inputInfos,outShapeInfo,userCode,program.packedInputs),webGLProgram=gpgpu.createProgram(source),infLoc=null,nanLoc=gpgpu.getUniformLocation(webGLProgram,"NAN",!1);env().getNumber("WEBGL_VERSION")===1&&(infLoc=gpgpu.getUniformLocation(webGLProgram,"INFINITY",!1));let uniformLocations={};for(let i=0;i<program.variableNames.length;i++){let varName=program.variableNames[i],shouldThrow=!1;uniformLocations[varName]=gpgpu.getUniformLocation(webGLProgram,varName,shouldThrow),uniformLocations[`offset${varName}`]=gpgpu.getUniformLocation(webGLProgram,`offset${varName}`,shouldThrow)}return{program,source,webGLProgram,uniformLocations,inShapeInfos,outShapeInfo,infLoc,nanLoc}}function validateBinaryAndProgram(shapeInfos,inputs){if(shapeInfos.length!==inputs.length)throw Error(`Binary was compiled with ${shapeInfos.length} inputs, but was executed with ${inputs.length} inputs`);shapeInfos.forEach((s,i)=>{let shapeA=s.logicalShape,input2=inputs[i],shapeB=input2.shape;if(!util_exports.arraysEqual(shapeA,shapeB))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${shapeA} and ${shapeB} must match`);if(s.isUniform&&input2.isUniform)return;let texShapeA=s.texShape,texShapeB=input2.isUniform?null:input2.texData.texShape;if(!util_exports.arraysEqual(texShapeA,texShapeB))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${texShapeA} and ${texShapeB} must match`)})}function runProgram(gpgpu,binary,inputs,output,customSetup){validateBinaryAndProgram(binary.inShapeInfos,inputs),validateBinaryAndProgram([binary.outShapeInfo],[output]);let outTex=output.texData.texture,outTexShape=output.texData.texShape;output.texData.isPacked?gpgpu.setOutputPackedMatrixTexture(outTex,outTexShape[0],outTexShape[1]):gpgpu.setOutputMatrixTexture(outTex,outTexShape[0],outTexShape[1]),gpgpu.setProgram(binary.webGLProgram),env().getNumber("WEBGL_VERSION")===1&&(binary.infLoc!==null&&gpgpu.gl.uniform1f(binary.infLoc,Infinity)),binary.nanLoc!==null&&gpgpu.gl.uniform1f(binary.nanLoc,NaN),inputs.forEach((input2,i)=>{let varName=binary.program.variableNames[i],varLoc=binary.uniformLocations[varName],varOffsetLoc=binary.uniformLocations[`offset${varName}`];if(varLoc==null)return;if(input2.isUniform){if(util_exports.sizeFromShape(input2.shape)<2)gpgpu.gl.uniform1f(varLoc,input2.uniformValues[0]);else{let vals=input2.uniformValues;vals instanceof Float32Array||(vals=new Float32Array(vals)),gpgpu.gl.uniform1fv(varLoc,vals)}return}input2.texData.slice!=null&&varOffsetLoc!=null&&gpgpu.gl.uniform1i(varOffsetLoc,input2.texData.slice.flatOffset),gpgpu.setInputMatrixTexture(input2.texData.texture,varLoc,i)}),customSetup!=null&&customSetup(gpgpu,binary.webGLProgram),gpgpu.executeProgram()}function makeShaderKey(program,inputs,output){let keyInputs="";inputs.concat(output).forEach(x=>{let hasOffset=x.texData!=null&&x.texData.slice!=null&&x.texData.slice.flatOffset>0,texShape=x.isUniform?"uniform":x.texData.texShape;keyInputs+=`${x.shape}_${texShape}_${hasOffset}`});let keyUserCode=program.userCode,key=program.constructor.name;return key+="_"+keyInputs+"_"+keyUserCode,key}var Im2ColPackedProgram=class{constructor(outputShape,inputShape,convInfo){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=outputShape;let{filterWidth,inChannels,strideWidth,strideHeight,padInfo,outWidth,dilationWidth,dilationHeight,dataFormat}=convInfo,{left,top}=padInfo,itemsPerBlockRow=inChannels*filterWidth,glsl=getGlslDifferences(),isChannelsLast=dataFormat==="channelsLast",rowDim=isChannelsLast?0:1,colDim=isChannelsLast?1:2,unrolled="";for(let row=0;row<=1;row++)for(let col=0;col<=1;col++)unrolled+=`
          blockIndex = rc.y + ${col};
          pos = rc.x + ${row};

          if(blockIndex < ${outputShape[1]} && pos < ${outputShape[0]}) {
            offsetY = int(blockIndex / (${outWidth})) * ${strideHeight} - ${top};
            d0 = offsetY + ${dilationHeight} * (pos / ${itemsPerBlockRow});

            if(d0 < ${inputShape[rowDim]} && d0 >= 0) {

              offsetX = int(mod(float(blockIndex), ${outWidth}.) * ${strideWidth}. - ${left}.);
              d1 = offsetX + ${dilationWidth} * (int(mod(float(pos), ${itemsPerBlockRow}.) / ${inChannels}.));

              if(d1 < ${inputShape[colDim]} && d1 >= 0) {

                ch = int(mod(float(pos), ${inChannels}.));

                if (${isChannelsLast}) {
                  innerDims = vec2(d1, ch);
                  result[${row*2+col}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${row*2+col}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${unrolled}

        ${glsl.output} = result;
      }
    `}};var LRNProgram=class{constructor(xShape,radius,bias,alpha,beta){this.variableNames=["x"],this.outputShape=[];let rad=radius,maxD=xShape[3]-1;this.outputShape=xShape;let powOperator,basis=`float(${bias}) + float(${alpha}) * sum`;beta===.5?powOperator=`inversesqrt(${basis})`:beta===1?powOperator=`1.0/(${basis})`:powOperator=`exp(log(${basis}) * float(-${beta}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${rad}; j <= ${rad}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${maxD}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${powOperator};
        setOutput(val);
      }
    `}};var LRNGradProgram=class{constructor(inputShape,depthRadius,bias,alpha,beta){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=inputShape,this.depth=inputShape[3],this.depthRadius=depthRadius,this.bias=bias,this.alpha=alpha,this.beta=beta,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${depthRadius})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${depthRadius} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${alpha}) * norm + float(${bias});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${alpha})
                * float(${beta})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${beta});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};var LRNPackedProgram=class{constructor(xShape,radius,bias,alpha,beta){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let rad=radius,maxD=xShape[3]-1;this.outputShape=xShape;let powOperator,basis=`float(${bias}) + float(${alpha}) * sum`;beta===.5?powOperator=`inversesqrt(${basis})`:beta===1?powOperator=`1.0/(${basis})`:powOperator=`exp(log(${basis}) * float(-${beta}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${rad};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${rad}; j <= ${rad}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${maxD}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${powOperator};
        setOutput(result);
      }
    `}};var MaxPool2DBackpropProgram=class{constructor(convInfo){this.variableNames=["dy","maxPos"],this.outputShape=convInfo.inShape;let strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationHeight=convInfo.dilationHeight,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padTop=effectiveFilterHeight-1-convInfo.padInfo.top,padLeft=effectiveFilterWidth-1-convInfo.padInfo.left,lastIndex=effectiveFilterHeight*effectiveFilterWidth-1;this.userCode=`
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${effectiveFilterHeight};
          wR += ${dilationHeight}) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${effectiveFilterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${lastIndex} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${effectiveFilterWidth} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},MaxPool3DBackpropProgram=class{constructor(convInfo){this.variableNames=["dy","maxPos"],this.outputShape=convInfo.inShape;let strideDepth=convInfo.strideDepth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationDepth=convInfo.dilationDepth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterDepth=convInfo.effectiveFilterDepth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padFront=effectiveFilterDepth-1-convInfo.padInfo.front,padTop=effectiveFilterHeight-1-convInfo.padInfo.top,padLeft=effectiveFilterWidth-1-convInfo.padInfo.left,lastIndex=effectiveFilterDepth*effectiveFilterHeight*effectiveFilterWidth-1;this.userCode=`
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
           wD += ${dilationDepth}) {
          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;

          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${lastIndex} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +
                  wR * ${effectiveFilterWidth} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var MatMulPackedProgram=class{constructor(aShape,bShape,outputShape,transposeA=!1,transposeB=!1,addBias=!1,activation=null,hasPreluActivation=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=outputShape;let sharedDim=transposeA?aShape[1]:aShape[2],sharedDimensionPacked=Math.ceil(sharedDim/2),aSample=transposeA?"i * 2, rc.y":"rc.y, i * 2",bSample=transposeB?"rc.z, i * 2":"i * 2, rc.z",aSwizzle=transposeA?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],bSwizzle=transposeB?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],activationSnippet="",applyActivationSnippet="";activation&&(hasPreluActivation?activationSnippet=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${activation}
        }`:activationSnippet=`vec4 activation(vec4 x) {
          ${activation}
        }`,applyActivationSnippet="result = activation(result);");let addBiasSnippet=addBias?"result += getBiasAtOutCoords();":"";addBias&&this.variableNames.push("bias"),hasPreluActivation&&this.variableNames.push("preluActivationWeights");let batchASnippet="rc.x",batchBSnippet="rc.x";aShape[0]<bShape[0]?batchASnippet=`int(min(float(rc.x), ${aShape[0]-1}.))`:bShape[0]<aShape[0]&&(batchBSnippet=`int(min(float(rc.x), ${bShape[0]-1}.))`),this.userCode=`
      ${activationSnippet}

      const float sharedDimension = ${sharedDimensionPacked}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${sharedDimensionPacked}; i++) {
          int batchA = ${batchASnippet};
          int batchB = ${batchBSnippet};
          vec4 a = getMatrixA(batchA, ${aSample});
          vec4 b = getMatrixB(batchB, ${bSample});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${aSwizzle[0]} * ${bSwizzle[0]});
          result += (${aSwizzle[1]} * ${bSwizzle[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${addBiasSnippet}

        ${applyActivationSnippet}

        setOutput(result);
      }
    `}};var MultinomialProgram=class{constructor(batchSize,numOutcomes,numSamples){this.variableNames=["probs"],this.outputShape=[batchSize,numSamples],this.userCode=`
      uniform float seed;

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${numOutcomes-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${numOutcomes-1}));
      }
    `}getCustomSetupFunc(seed){return(gpgpu,webGLProgram)=>{this.seedLoc==null&&(this.seedLoc=gpgpu.getUniformLocation(webGLProgram,"seed")),gpgpu.gl.uniform1f(this.seedLoc,seed)}}};var OneHotProgram=class{constructor(numIndices,depth,onValue,offValue){this.variableNames=["indices"],this.outputShape=[numIndices,depth],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${offValue}), float(${onValue}),
                      float(index == coords.y)));
      }
    `}};var PackProgram=class{constructor(outputShape){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=outputShape;let rank=outputShape.length;if(rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let channels=getChannels("rc",rank),dtype=getCoordsDataType(rank),outOfBoundsCondition=getOutOfBoundsCondition(rank,outputShape,channels),setup=getSetup(rank,outputShape[outputShape.length-1],outputShape[outputShape.length-2],channels),output=getOutput(outputShape,channels);this.userCode=`
        void main() {
          ${dtype} rc = getOutputCoords();

          if(${outOfBoundsCondition}) {
            setOutput(vec4(0));
          } else {
            ${setup}

            setOutput(vec4(${output}));
          }
        }
      `}}};function getSourceCoordsArr(rank,dims){let coords2=[];for(let row=0;row<=1;row++)for(let col=0;col<=1;col++){let coord=`${row===0?"r":"rp1"}, ${col===0?"c":"cp1"}`;for(let d=2;d<rank;d++)coord=`${dims[dims.length-1-d]},`+coord;coords2.push(coord)}return coords2}function getOutOfBoundsCondition(rank,shape,dims){if(rank===1)return`rc > ${shape[0]}`;let cond="";for(let i=rank-2;i<rank;i++)cond+=`${dims[i]} >= ${shape[i]}`,i<rank-1&&(cond+="||");return cond}function getSetup(rank,cols,rows,dims){if(rank===1)return"";let innerDims=dims.slice(-2);return`
    int r = ${innerDims[0]};
    int c = ${innerDims[1]};
    int rp1 = r + 1;
    int cp1 = c + 1;

    bool cEdge = cp1 >= ${cols};
    bool rEdge = rp1 >= ${rows};
  `}function getOutput(shape,dims){let rank=shape.length,sourceCoords=getSourceCoordsArr(rank,dims);return rank===1?`getA(rc),
            rc + 1 >= ${shape[0]} ? 0. : getA(rc + 1),
            0, 0`:`getA(${sourceCoords[0]}),
          cEdge ? 0. : getA(${sourceCoords[1]}),
          rEdge ? 0. : getA(${sourceCoords[2]}),
          rEdge || cEdge ? 0. : getA(${sourceCoords[3]})`}var PadProgram=class{constructor(xShape,paddings,constantValue){this.variableNames=["x"],this.outputShape=paddings.map((p2,i)=>p2[0]+xShape[i]+p2[1]);let rank=xShape.length,type=getCoordsDataType(rank),start=paddings.map(p2=>p2[0]).join(","),end=paddings.map((p2,i)=>p2[0]+xShape[i]).join(","),unpackedCoords=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,rank);if(rank===1){this.userCode=`
        int start = ${start};
        int end = ${end};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(float(${constantValue}));
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${type} start = ${type}(${start});
      ${type} end = ${type}(${end});

      void main() {
        ${type} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(float(${constantValue}));
        } else {
          ${type} coords = outC - start;
          setOutput(getX(${unpackedCoords}));
        }
      }
    `}};var PadPackedProgram=class{constructor(xShape,paddings,constantValue){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=paddings.map((p2,i)=>p2[0]+xShape[i]+p2[1]);let rank=xShape.length,dtype=getCoordsDataType(rank),start=paddings.map(p2=>p2[0]).join(","),end=paddings.map((p2,i)=>p2[0]+xShape[i]).join(","),coords2=getChannels("rc",rank),source=getChannels("source",rank),cLimit=`${coords2[rank-1]} < ${this.outputShape[rank-1]}`,innerDims=rank===1?"source":`vec2(${source.slice(-2).join()})`,componentSetup=[`${dtype} rc = outputLoc;`,`${coords2[rank-1]} += 1;
       if(${cLimit}) {
      `,rank===1?"":`}
       rc = outputLoc;
       ${coords2[rank-2]} += 1;
       if(${coords2[rank-2]} < ${this.outputShape[rank-2]}) {`,rank===1?"":`  ${coords2[rank-1]} += 1;
         if(${cLimit}) {`],paddingArea=rank===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",mainLoop="";for(let i=0,j=rank===1?2:4;i<j;i++)mainLoop+=`
        ${componentSetup[i]}
        if (${paddingArea}) {
          result[${i}] = float(${constantValue});
        } else {
          ${dtype} source = rc - start;
          result[${i}] = getChannel(getX(${source.join()}), ${innerDims});
        }
      `;mainLoop+=rank===1?"} ":"}}",this.userCode=`
      const ${dtype} start = ${dtype}(${start});
      const ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${mainLoop}
        setOutput(result);
      }
    `}};var Pool2DProgram=class{constructor(convInfo,poolType,computePositions,flattenPositions=!1,includeBatchInIndex=!1){if(this.variableNames=["x"],poolType==="avg"&&computePositions)throw new Error("Cannot compute positions for average pool.");let filterWidth=convInfo.filterWidth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left;this.outputShape=convInfo.outShape;let isAvgPool=poolType==="avg",batchFlattenPositionStr=`((batch  * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`,flattenPositionStr=`(xR * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`,initializationValue="0.0";if(isAvgPool||(initializationValue="-1.0 / 1e-20"),computePositions){let compareOp2=">=";this.userCode=`
        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
        const ivec2 pads = ivec2(${padTop}, ${padLeft});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${compareOp2} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${flattenPositions?includeBatchInIndex?batchFlattenPositionStr:flattenPositionStr:`wR * ${effectiveFilterWidth} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let compareOp="max",returnValue=`${poolType}(${poolType}(${poolType}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;poolType==="avg"&&(returnValue="avgValue / count");let filterWidthNearestVec4=Math.floor(filterWidth/4)*4,filterWidthVec4Remainder=filterWidth%4,updateSnippet=`
      if (${isAvgPool}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${convInfo.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${initializationValue});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${convInfo.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {
            int xC = xCCorner + wC * ${dilationWidth};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),
              getValue(batch, xR, xC + 3 * ${dilationWidth}, d)
            );

            ${updateSnippet}
          }

          int xC = xCCorner + ${filterWidthNearestVec4};
          if (${filterWidthVec4Remainder===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${updateSnippet}
          } else if (${filterWidthVec4Remainder===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              initializationValue,
              initializationValue
            );

            ${updateSnippet}
          } else if (${filterWidthVec4Remainder===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),
              initializationValue
            );

            ${updateSnippet}
          }
        }
        setOutput(${returnValue});
      }
    `}},Pool3DProgram=class{constructor(convInfo,poolType,computePositions,flattenPositions=!1,includeBatchInIndex=!1){if(this.variableNames=["x"],poolType==="avg"&&computePositions)throw new Error("Cannot compute positions for average pool.");let filterWidth=convInfo.filterWidth,strideDepth=convInfo.strideDepth,strideHeight=convInfo.strideHeight,strideWidth=convInfo.strideWidth,dilationDepth=convInfo.dilationDepth,dilationHeight=convInfo.dilationHeight,dilationWidth=convInfo.dilationWidth,effectiveFilterDepth=convInfo.effectiveFilterDepth,effectiveFilterHeight=convInfo.effectiveFilterHeight,effectiveFilterWidth=convInfo.effectiveFilterWidth,padFront=convInfo.padInfo.front,padTop=convInfo.padInfo.top,padLeft=convInfo.padInfo.left;this.outputShape=convInfo.outShape;let isAvgPool=poolType==="avg",initializationValue="0.0";if(isAvgPool||(initializationValue="-1.0 / 1e-20"),computePositions){let compareOp2=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${effectiveFilterDepth};
              wD += ${dilationDepth}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${convInfo.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${effectiveFilterHeight};
                wR += ${dilationHeight}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${convInfo.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${effectiveFilterWidth};
                  wC += ${dilationWidth}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${convInfo.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${compareOp2} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${flattenPositions?includeBatchInIndex?`(((batch * ${convInfo.inDepth} + xD) * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch`:`((xD * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch`:`wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +
                      wR * ${effectiveFilterWidth} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let compareOp="max",returnValue=`${poolType}(${poolType}(${poolType}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;poolType==="avg"&&(returnValue="avgValue / count");let filterWidthNearestVec4=Math.floor(filterWidth/4)*4,filterWidthVec4Remainder=filterWidth%4,updateSnippet=`
      if (${isAvgPool}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${convInfo.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${initializationValue});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
            wD += ${dilationDepth}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${convInfo.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {
              int xC = xCCorner + wC * ${dilationWidth};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 3 * ${dilationWidth}, ch)
              );

              ${updateSnippet}
            }

            int xC = xCCorner + ${filterWidthNearestVec4};
            if (${filterWidthVec4Remainder===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${updateSnippet}
            } else if (${filterWidthVec4Remainder===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                initializationValue,
                initializationValue
              );

              ${updateSnippet}
            } else if (${filterWidthVec4Remainder===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),
                initializationValue
              );

              ${updateSnippet}
            }
          }
          setOutput(${returnValue});
        }
      }
    `}};var ReduceProgram=class{constructor(reduceInfo,reduceType){this.variableNames=["x"];let{windowSize,batchSize,inSize,outSize}=reduceInfo;this.outputShape=[batchSize,outSize];let initializationValue="0.0",compareOp="";reduceType==="prod"?initializationValue="1.0":reduceType==="min"?(initializationValue="1.0 / 1e-20",compareOp="min"):reduceType==="max"&&(initializationValue="-1.0 / 1e-20",compareOp="max");let returnValue=`${reduceType}(${reduceType}(${reduceType}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;reduceType==="sum"?returnValue="sumValue":reduceType==="prod"?returnValue="prodValue":reduceType==="all"?returnValue="allValue":reduceType==="any"&&(returnValue="anyValue");let windowSizeNearestVec4=Math.floor(windowSize/4)*4,windowSizeVec4Remainder=windowSize%4,updateSnippet=`
      if (${reduceType==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${reduceType==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
      }
    `,vecType="vec4";reduceType==="all"?(initializationValue="1.0",updateSnippet=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,vecType="bvec4"):reduceType==="any"&&(initializationValue="0.0",updateSnippet=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,vecType="bvec4");let checkOutOfBounds="";inSize%windowSize>0&&(checkOutOfBounds=`
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${checkOutOfBounds}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        vec4 minMaxValue = vec4(${initializationValue});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder===1}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder===2}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder===3}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${updateSnippet}
        }
        setOutput(${returnValue});
      }
    `}};var ReshapePackedProgram=class{constructor(outputShape,inputShape){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=outputShape;let mainLoop="";for(let i=0;i<4;i++){let thisRC="thisRC = rc;";i%2===1&&(thisRC+="thisRC.z += 1;"),i>1&&(thisRC+="thisRC.y += 1;"),mainLoop+=`
        ${thisRC}
        ${i>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${i>0?"}":""}
      `}this.userCode=`
      ${getReshapedInputCoords(inputShape)}
      ${getFlatIndexFrom3D(outputShape)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${outputShape[1]};
        int cols = ${outputShape[2]};

        ${mainLoop}

        setOutput(result);
      }
    `}};function getReshapedInputCoords(shape){let coordsFromIndexSnippet=getLogicalCoordinatesFromFlatIndex(["r","c","d"],shape);return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${coordsFromIndexSnippet}
      return ivec3(r, c, d);
    }
  `}var ResizeBilinearBackpropProgram=class{constructor(dy,x,alignCorners){this.variableNames=["dy"],this.outputShape=[],this.outputShape=x.shape;let[,xHeight,xWidth]=x.shape,[,yHeight,yWidth]=dy.shape,effectiveXSize=[alignCorners&&yHeight>1?xHeight-1:xHeight,alignCorners&&yWidth>1?xWidth-1:xWidth],effectiveYSize=[alignCorners&&yHeight>1?yHeight-1:yHeight,alignCorners&&yWidth>1?yWidth-1:yWidth],heightScale=effectiveXSize[0]/effectiveYSize[0],widthScale=effectiveXSize[1]/effectiveYSize[1],invHeightScale=1/heightScale,invWidthScale=1/widthScale,winHeight=Math.ceil(invHeightScale)*2+2,winWidth=Math.ceil(invWidthScale)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${heightScale});
        const float widthScale = float(${widthScale});

        const float invHeightScale = float(${invHeightScale});
        const float invWidthScale = float(${invWidthScale});

        const int winHeight = int(${winHeight});
        const int winWidth = int(${winWidth});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${yHeight}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${yWidth}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${xHeight-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${xWidth-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};var ResizeBilinearProgram=class{constructor(inputShape,newHeight,newWidth,alignCorners){this.variableNames=["A"],this.outputShape=[];let[batch,oldHeight,oldWidth,depth]=inputShape;this.outputShape=[batch,newHeight,newWidth,depth];let effectiveInSize=[alignCorners&&newHeight>1?oldHeight-1:oldHeight,alignCorners&&newWidth>1?oldWidth-1:oldWidth],effectiveOutSize=[alignCorners&&newHeight>1?newHeight-1:newHeight,alignCorners&&newWidth>1?newWidth-1:newWidth];this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${effectiveInSize[0]/effectiveOutSize[0]},
          ${effectiveInSize[1]/effectiveOutSize[1]});
      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};var ResizeBilinearPackedProgram=class{constructor(inputShape,newHeight,newWidth,alignCorners){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[batch,oldHeight,oldWidth,depth]=inputShape;this.outputShape=[batch,newHeight,newWidth,depth];let effectiveInSize=[alignCorners&&newHeight>1?oldHeight-1:oldHeight,alignCorners&&newWidth>1?oldWidth-1:oldWidth],effectiveOutSize=[alignCorners&&newHeight>1?newHeight-1:newHeight,alignCorners&&newWidth>1?newWidth-1:newWidth];this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${effectiveInSize[0]/effectiveOutSize[0]},
          ${effectiveInSize[1]/effectiveOutSize[1]},
          ${effectiveInSize[1]/effectiveOutSize[1]});
      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,
                                     ${oldWidth}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${depth-1};
        bool hasNextRow = coords.z < ${newWidth-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};var ResizeNearestNeigborBackpropProgram=class{constructor(dy,x,alignCorners){this.variableNames=["dy"],this.outputShape=[],this.outputShape=x.shape;let[,xHeight,xWidth]=x.shape,[,yHeight,yWidth]=dy.shape,effectiveXSize=[alignCorners&&yHeight>1?xHeight-1:xHeight,alignCorners&&yWidth>1?xWidth-1:xWidth],effectiveYSize=[alignCorners&&yHeight>1?yHeight-1:yHeight,alignCorners&&yWidth>1?yWidth-1:yWidth],heightScale=effectiveXSize[0]/effectiveYSize[0],widthScale=effectiveXSize[1]/effectiveYSize[1],invHeightScale=1/heightScale,invWidthScale=1/widthScale,winHeight=Math.ceil(invHeightScale)*2+2,winWidth=Math.ceil(invWidthScale)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${heightScale});
        const float widthScale = float(${widthScale});

        const float invHeightScale = float(${invHeightScale});
        const float invWidthScale = float(${invWidthScale});

        const int winHeight = int(${winHeight});
        const int winWidth = int(${winWidth});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${yHeight}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${yWidth}) {
              continue;
            }

            float sourceFracRow =
              float(${effectiveXSize[0]}) *
                (float(dyR) / float(${effectiveYSize[0]}));

            float sourceFracCol =
                float(${effectiveXSize[1]}) *
                  (float(dyC) / float(${effectiveYSize[1]}));

            int sourceNearestRow = int(min(
                float(int(${xHeight}) - 1),
                ${alignCorners} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${xWidth}) - 1),
                ${alignCorners} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};var ResizeNearestNeighborProgram=class{constructor(inputShape,newHeight,newWidth,alignCorners){this.variableNames=["A"],this.outputShape=[];let[batch,oldHeight,oldWidth,depth]=inputShape;this.outputShape=[batch,newHeight,newWidth,depth];let effectiveInSize=[alignCorners&&newHeight>1?oldHeight-1:oldHeight,alignCorners&&newWidth>1?oldWidth-1:oldWidth],effectiveOutSize=[alignCorners&&newHeight>1?newHeight-1:newHeight,alignCorners&&newWidth>1?newWidth-1:newWidth],roundBase=alignCorners?"0.5":"0.0";this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${effectiveInSize[0]/effectiveOutSize[0]},
          ${effectiveInSize[1]/effectiveOutSize[1]});
      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));

        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};var ReverseProgram=class{constructor(xShape,axis){this.variableNames=["x"];let rank=xShape.length;if(rank>4)throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);if(this.outputShape=xShape,rank===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${xShape[0]} - coord - 1));
        }
      `;return}let getInCoord=i=>axis.indexOf(i)!==-1&&xShape[i]!==1?`${xShape[i]} - coords[${i}] - 1`:`coords[${i}]`,inCoords=xShape.map((_,i)=>getInCoord(i)).join(","),type=getCoordsDataType(rank);this.userCode=`
      void main() {
        ${type} coords = getOutputCoords();
        setOutput(getX(${inCoords}));
      }
    `}};var ReversePackedProgram=class{constructor(xShape,axis){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let rank=xShape.length;if(rank>4)throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);this.outputShape=xShape;let channels=getChannels("rc",rank),nextColumn=`${channels[rank-1]} + 1 < ${this.outputShape[rank-1]}`,nextRow=`${channels[rank-2]} + 1 < ${this.outputShape[rank-2]}`,type=getCoordsDataType(rank);rank===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${xShape[0]} - rc - 1),
            ${xShape[0]} - rc - 1);
          if(${nextColumn}){
              result.g = getChannel(getX(${xShape[0]} - (rc  + 1) - 1),
                ${xShape[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${type} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${getR(channels.slice())};
          if(${nextColumn}){
            result.g = ${getG(channels.slice())};
          }
          if(${nextRow}) {
            result.b = ${getB(channels.slice())};
            if(${nextColumn}) {
              result.a = ${getA(channels.slice())};
            }
          }
          setOutput(result);
        }
    `;function getR(channels2){return getChannel(channels2)}function getG(channels2){return channels2[rank-1]="("+channels2[rank-1]+" + 1)",getChannel(channels2)}function getB(channels2){return channels2[rank-2]="("+channels2[rank-2]+" + 1)",getChannel(channels2)}function getA(channels2){return channels2[rank-1]="("+channels2[rank-1]+" + 1)",channels2[rank-2]="("+channels2[rank-2]+" + 1)",getChannel(channels2)}function getChannel(channels2){let inCoordsArray=xShape.map((_,i)=>getInCoord(i,channels2)),inCoords=inCoordsArray.join(","),innerDims=inCoordsArray.slice(-2).join(",");return`getChannel(getX(${inCoords}), vec2(${innerDims}))`}function getInCoord(i,channels1){return axis.indexOf(i)!==-1&&xShape[i]!==1?`${xShape[i]} - ${channels1[i]} - 1`:`${channels1[i]}`}}};var ScatterProgram=class{constructor(updateSize,sliceDim,indicesRank,updatesRank,strides,shape,summingDupeIndex=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=shape;let stridesType=getCoordsDataType(strides.length),dtype=getCoordsDataType(shape.length),indicesString="";indicesRank===1?indicesString="i":indicesRank===2&&(indicesString="i, j");let indicesSnippet=`getIndices(${indicesString})`,updatesString="";updatesRank===1?updatesString="i":updatesRank===2&&(updatesString="i, coords[1]");let updatesSnippet=`getUpdates(${updatesString})`,strideString=sliceDim>1?"strides[j]":"strides";this.userCode=`
        ${stridesType} strides = ${stridesType}(${strides});

        void main() {
          ${dtype} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${updateSize}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${sliceDim}; j++) {
              int index = round(${indicesSnippet});
              flattenedIndex += index * ${strideString};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${updatesSnippet};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}};var SegmentOpProgram=class{constructor(segOpInfo,segOpType){this.variableNames=["x","segmentIds"];let windowSize=segOpInfo.windowSize,batchSize=segOpInfo.batchSize,inSize=segOpInfo.inSize,numSegments=segOpInfo.numSegments,outSize=numSegments*Math.ceil(inSize/windowSize);this.outputShape=[batchSize,outSize];let initializationValue="0.0",returnValue="sumValue",windowSizeNearestVec4=Math.floor(windowSize/4)*4,windowSizeVec4Remainder=windowSize%4,updateSnippet=`
        sumValue += dot(values, segFilter);
    `,checkValueOutOfBounds="";inSize%windowSize>0&&(checkValueOutOfBounds=`
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return initializationValue;
        }
      `);let checkSegmentIdOutOfBounds="";inSize%windowSize>0&&(checkSegmentIdOutOfBounds=`
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${initializationValue};

      float getValue(int batch, int inIdx) {
        ${checkValueOutOfBounds}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${checkSegmentIdOutOfBounds}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${numSegments})) * float(${windowSize}));
        int currentSeg = int(mod(float(outIdx), float(${numSegments})));

        float sumValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${updateSnippet}
        }
        setOutput(${returnValue});
      }
    `}};var SelectProgram=class{constructor(cRank,shape,rank){this.variableNames=["c","a","b"],this.outputShape=shape;let cCoords,abCoords;if(rank>4)throw Error(`Where for rank ${rank} is not yet supported`);if(rank===1)abCoords="resRC",cCoords="resRC";else{let currentCoords=["resRC.x","resRC.y","resRC.z","resRC.w"],cCoordVars=[],abCoordVars=[];for(let i=0;i<shape.length;i++)abCoordVars.push(`${currentCoords[i]}`),i<cRank&&cCoordVars.push(`${currentCoords[i]}`);cCoords=cCoordVars.join(),abCoords=abCoordVars.join()}let dtype=getCoordsDataType(rank);this.userCode=`
      void main() {
        ${dtype} resRC = getOutputCoords();
        float cVal = getC(${cCoords});
        if (cVal >= 1.0) {
          setOutput(getA(${abCoords}));
        } else {
          setOutput(getB(${abCoords}));
        }
      }
    `}};var SliceProgram=class{constructor(destSize){this.variableNames=["source"],this.outputShape=destSize,this.rank=destSize.length;let dtype=getCoordsDataType(this.rank),uniformPart=`uniform int start[${this.rank}];`,sourceCoords=getCoords2(this.rank),body,coordSum=destSize.map((_,i)=>`sourceLoc.${coords[i]} = start[${i}] + coords.${coords[i]};`);body=`
        ${dtype} sourceLoc;
        ${dtype} coords = getOutputCoords();
        ${coordSum.join(`
`)}
      `,this.userCode=`
      ${uniformPart}
      void main() {
        ${body}
        setOutput(getSource(${sourceCoords}));
      }
    `}getCustomSetupFunc(start){if(start.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${start.length})`);return(gpgpu,webGLProgram)=>{if(this.startLoc==null&&(this.startLoc=gpgpu.getUniformLocationNoThrow(webGLProgram,"start"),this.startLoc==null))return;gpgpu.gl.uniform1iv(this.startLoc,start)}}},coords=["x","y","z","w","u","v"];function getCoords2(rank){if(rank===1)return"sourceLoc";if(rank<=6)return coords.slice(0,rank).map(x=>"sourceLoc."+x).join(",");throw Error(`Slicing for rank ${rank} is not yet supported`)}var SlicePackedProgram=class{constructor(destSize){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=destSize,this.rank=destSize.length;let dtype=getCoordsDataType(this.rank),coords2=getChannels("coords",this.rank),sourceLoc=getChannels("sourceLoc",this.rank),innerDims=this.rank===1?"sourceLoc":`vec2(${sourceLoc.slice(-2).join()})`,getChannel=`getChannel(getSource(${sourceLoc.join()}), ${innerDims})`,upperRow=`
      result.x = ${getChannel};
      if (++${coords2[this.rank-1]} < ${destSize[this.rank-1]}) {
        ++${sourceLoc[this.rank-1]};
        result.y = ${getChannel};
        --${sourceLoc[this.rank-1]};
      }
    `,lowerRow=this.rank===1?"":`
      --${coords2[this.rank-1]};
      if (++${coords2[this.rank-2]} < ${destSize[this.rank-2]}) {
        ++${sourceLoc[this.rank-2]};
        result.z = ${getChannel};
        if (++${coords2[this.rank-1]} < ${destSize[this.rank-1]}) {
          ++${sourceLoc[this.rank-1]};
          result.w = ${getChannel};
        }
      }
    `,sourceLocSetup=this.rank<=4?`sourceLoc = coords +
            ${dtype}(${destSize.map((_,i)=>`start[${i}]`).join()});`:destSize.map((_,i)=>`${sourceLoc[i]} = ${coords2[i]} + start[${i}];`).join(`
`);this.userCode=`
      uniform int start[${this.rank}];
      void main() {
        ${dtype} coords = getOutputCoords();
        ${dtype} sourceLoc;
        ${sourceLocSetup}
        vec4 result = vec4(0.);
        ${upperRow}
        ${lowerRow}
        setOutput(result);
      }
    `}getCustomSetupFunc(start){if(start.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${start.length})`);return(gpgpu,webGLProgram)=>{if(this.startLoc==null&&(this.startLoc=gpgpu.getUniformLocationNoThrow(webGLProgram,"start"),this.startLoc==null))return;gpgpu.gl.uniform1iv(this.startLoc,start)}}};var StridedSliceProgram=class{constructor(begin,strides,size){this.variableNames=["x"],this.outputShape=size;let rank=size.length,inputDtype=getCoordsDataType(size.length),dtype=getCoordsDataType(size.length),newCoords="";if(rank===1)newCoords="coords * strides + begin";else{let outputAxis=0;newCoords=size.map((_,i)=>(outputAxis++,size.length===1?`coords * strides[${i}] + begin[${i}]`:`coords[${outputAxis-1}] * strides[${i}] + begin[${i}]`)).join(",")}this.userCode=`
      ${inputDtype} begin = ${inputDtype}(${begin});
      ${inputDtype} strides = ${inputDtype}(${strides});

      void main() {
        ${dtype} coords = getOutputCoords();
        setOutput(getX(${newCoords}));
      }
    `}};var TextureManager=class{constructor(gpgpu){this.gpgpu=gpgpu,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(shapeRC,usage,isPacked){let physicalTexType=getPhysicalFromLogicalTextureType(usage,isPacked),shapeKey=getKeyFromTextureShape(shapeRC,physicalTexType,isPacked);shapeKey in this.freeTextures||(this.freeTextures[shapeKey]=[]),shapeKey in this.usedTextures||(this.usedTextures[shapeKey]=[]);let texBytes=computeBytes(shapeRC,physicalTexType,this.gpgpu.gl,this.gpgpu.textureConfig,isPacked);if(this.freeTextures[shapeKey].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=texBytes,this.log();let newTexture2=this.freeTextures[shapeKey].shift();return this.usedTextures[shapeKey].push(newTexture2),newTexture2}let newTexture;return physicalTexType===PhysicalTextureType.PACKED_2X2_FLOAT32?newTexture=this.gpgpu.createPackedMatrixTexture(shapeRC[0],shapeRC[1]):physicalTexType===PhysicalTextureType.PACKED_2X2_FLOAT16?newTexture=this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0],shapeRC[1]):physicalTexType===PhysicalTextureType.UNPACKED_FLOAT32?newTexture=this.gpgpu.createFloat32MatrixTexture(shapeRC[0],shapeRC[1]):physicalTexType===PhysicalTextureType.UNPACKED_FLOAT16?newTexture=this.gpgpu.createFloat16MatrixTexture(shapeRC[0],shapeRC[1]):physicalTexType===PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE&&(newTexture=this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0],shapeRC[1])),this.usedTextures[shapeKey].push(newTexture),this.numUsedTextures++,this._numBytesAllocated+=texBytes,this.log(),newTexture}releaseTexture(texture,shape,logicalTexType,isPacked){if(this.freeTextures==null)return;let physicalTexType=getPhysicalFromLogicalTextureType(logicalTexType,isPacked),shapeKey=getKeyFromTextureShape(shape,physicalTexType,isPacked);shapeKey in this.freeTextures||(this.freeTextures[shapeKey]=[]);let texBytes=computeBytes(shape,physicalTexType,this.gpgpu.gl,this.gpgpu.textureConfig,isPacked),deleteTexThreshold=env().get("WEBGL_DELETE_TEXTURE_THRESHOLD");deleteTexThreshold!==-1&&this._numBytesAllocated>deleteTexThreshold?(this.gpgpu.deleteMatrixTexture(texture),this._numBytesAllocated-=texBytes):(this.freeTextures[shapeKey].push(texture),this.numFreeTextures++,this._numBytesFree+=texBytes),this.numUsedTextures--;let texList=this.usedTextures[shapeKey],texIndex=texList.indexOf(texture);if(texIndex<0)throw new Error("Cannot release a texture that was never provided by this texture manager");texList.splice(texIndex,1),this.log()}log(){if(!this.logEnabled)return;let total=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${total})`);let freeRatio=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*freeRatio)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures==null)return;for(let texShape in this.freeTextures)this.freeTextures[texShape].forEach(tex=>{this.gpgpu.deleteMatrixTexture(tex)});for(let texShape in this.usedTextures)this.usedTextures[texShape].forEach(tex=>{this.gpgpu.deleteMatrixTexture(tex)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}};function numBytesForInternalFormat(gl,internalFormat){let glany=gl;if(internalFormat===glany.R32F)return 4;if(internalFormat===glany.R16F)return 2;if(internalFormat===glany.RGBA32F)return 16;if(internalFormat===gl.RGBA)return 16;if(internalFormat===glany.RGBA16F)return 8;throw new Error(`Unknown internal format ${internalFormat}`)}function computeBytes(shape,physicalTexType,gl,textureConfig,isPacked){let internalFormat=internalFormatForPhysicalTexType(physicalTexType,textureConfig),numElements;if(isPacked){let[packedWidth,packedHeight]=getPackedMatrixTextureShapeWidthHeight(shape[0],shape[1]);numElements=packedWidth*packedHeight}else{let[width,height]=getUnpackedMatrixTextureShapeWidthHeight(shape[0],shape[1]);numElements=width*height}let bytesPerElement2=numBytesForInternalFormat(gl,internalFormat);return numElements*bytesPerElement2}function internalFormatForPhysicalTexType(physicalTexType,textureConfig){switch(physicalTexType){case PhysicalTextureType.PACKED_2X2_FLOAT32:return getInternalFormatForPackedMatrixTexture(textureConfig);case PhysicalTextureType.PACKED_2X2_FLOAT16:return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);case PhysicalTextureType.UNPACKED_FLOAT32:return getInternalFormatForFloat32MatrixTexture(textureConfig);case PhysicalTextureType.UNPACKED_FLOAT16:return getInternalFormatForFloat16MatrixTexture(textureConfig);case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);default:throw new Error(`Unknown physical texture type ${physicalTexType}`)}}function getPhysicalTextureForRendering(isPacked){return env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?isPacked?PhysicalTextureType.PACKED_2X2_FLOAT32:PhysicalTextureType.UNPACKED_FLOAT32:isPacked?PhysicalTextureType.PACKED_2X2_FLOAT16:PhysicalTextureType.UNPACKED_FLOAT16}function getPhysicalFromLogicalTextureType(logicalTexType,isPacked){if(logicalTexType===TextureUsage.UPLOAD)return PhysicalTextureType.PACKED_2X2_FLOAT32;if(logicalTexType===TextureUsage.RENDER||logicalTexType==null)return getPhysicalTextureForRendering(isPacked);if(logicalTexType===TextureUsage.DOWNLOAD||logicalTexType===TextureUsage.PIXELS)return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${logicalTexType}`)}function getKeyFromTextureShape(shapeRowsCol,physicalTexType,isPacked){return`${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`}var TileProgram=class{constructor(aShape,reps){this.variableNames=["A"];let outputShape=new Array(aShape.length);for(let i=0;i<outputShape.length;i++)outputShape[i]=aShape[i]*reps[i];this.outputShape=outputShape,this.rank=outputShape.length;let dtype=getCoordsDataType(this.rank),sourceCoords=getSourceCoords3(aShape);this.userCode=`
      void main() {
        ${dtype} resRC = getOutputCoords();
        setOutput(getA(${sourceCoords}));
      }
    `}};function getSourceCoords3(aShape){let rank=aShape.length;if(rank>5)throw Error(`Tile for rank ${rank} is not yet supported`);if(rank===1)return`imod(resRC, ${aShape[0]})`;let currentCoords=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],sourceCoords=[];for(let i=0;i<aShape.length;i++)sourceCoords.push(`imod(${currentCoords[i]}, ${aShape[i]})`);return sourceCoords.join()}var UnaryOpProgram=class{constructor(aShape,opSnippet){this.variableNames=["A"],this.outputShape=aShape,this.userCode=`
      float unaryOperation(float x) {
        ${opSnippet}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},CHECK_NAN_SNIPPET3="if (isnan(x)) return x;",LINEAR="return x;",ABS="return abs(x);",RELU=CHECK_NAN_SNIPPET3+`
  return (x < 0.0) ? 0.0 : x;
`,RELU6=CHECK_NAN_SNIPPET3+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,ELU2="return (x >= 0.0) ? x : (exp(x) - 1.0);",SELU=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${backend_util_exports.SELU_SCALEALPHA};
  float scale = ${backend_util_exports.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`;function STEP(alpha=0){return CHECK_NAN_SNIPPET3+`
    return x > 0.0 ? 1.0 : float(${alpha});
  `}var NEG="return -x;",CEIL="return ceil(x);",FLOOR="return floor(x);",SIGN=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,IS_NAN="return float(isnan(x));",IS_INF="return float(isinf(x));",IS_FINITE="return float(!isnan(x) && !isinf(x));",ROUND=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,EXP="return exp(x);",EXPM1="return exp(x) - 1.0;",LOG=`if (x < 0.0) return NAN;
  return log(x);`,LOG1P="return log(1.0 + x);",SQRT="return sqrt(x);",RSQRT="return inversesqrt(x);",SIGMOID="return 1.0 / (1.0 + exp(-1.0 * x));",SOFTPLUS=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,ASIN=CHECK_NAN_SNIPPET3+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,ACOS=CHECK_NAN_SNIPPET3+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,ATAN=CHECK_NAN_SNIPPET3+`
  return atan(x);
`,SINH=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,COSH=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,TANH=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,ASINH=CHECK_NAN_SNIPPET3+"return log(x + sqrt(x * x + 1.0));",ACOSH=CHECK_NAN_SNIPPET3+`
  if (x < 1.0) return NAN;
  return log(x + sqrt(x * x - 1.0));`,ATANH=CHECK_NAN_SNIPPET3+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
  return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,ERF=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${backend_util_exports.ERF_P};
  float a1 = ${backend_util_exports.ERF_A1};
  float a2 = ${backend_util_exports.ERF_A2};
  float a3 = ${backend_util_exports.ERF_A3};
  float a4 = ${backend_util_exports.ERF_A4};
  float a5 = ${backend_util_exports.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,RECIPROCAL="return 1.0 / x;",LOGICAL_NOT="return float(!(x >= 1.0));",CLONE="return x;";var LINEAR2="return x;",LOG2=`
  vec4 result = log(x);
  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));
  result.r = isNaN.r == 1.0 ? NAN : result.r;
  result.g = isNaN.g == 1.0 ? NAN : result.g;
  result.b = isNaN.b == 1.0 ? NAN : result.b;
  result.a = isNaN.a == 1.0 ? NAN : result.a;

  return result;
`,RELU2=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,RELU62=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ELU3=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,UnaryOpPackedProgram=class{constructor(aShape,opSnippet){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=aShape,this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${opSnippet}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}};var UnpackProgram=class{constructor(outputShape){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=outputShape;let rank=outputShape.length,channels=getChannels("rc",rank),dtype=getCoordsDataType(rank),sourceCoords=getSourceCoords(rank,channels),innerDims=channels.slice(-2),coords2=rank<=1?"rc":`vec2(${innerDims.join(",")})`;this.userCode=`
      void main() {
        ${dtype} rc = getOutputCoords();
        vec4 packedInput = getA(${sourceCoords});

        setOutput(getChannel(packedInput, ${coords2}));
      }
    `}};var{segment_util:segment_util2}=backend_util_exports,split11=kernel_impls_exports.split,tile10=kernel_impls_exports.tile,topkImpl3=kernel_impls_exports.topkImpl,whereImpl3=kernel_impls_exports.whereImpl,EPSILON_FLOAT322=1e-7,EPSILON_FLOAT162=1e-4,binaryCaches={};function getBinaryCache(webGLVersion){return webGLVersion in binaryCaches||(binaryCaches[webGLVersion]={}),binaryCaches[webGLVersion]}function mapActivationToShaderProgram(activation,packed=!1){if(activation==="linear")return packed?LINEAR2:LINEAR;if(activation==="relu")return packed?RELU2:RELU;if(activation==="elu")return packed?ELU3:ELU2;if(activation==="relu6")return packed?RELU62:RELU6;if(activation==="prelu")return packed?PRELU2:PRELU;throw new Error(`Activation ${activation} has not been implemented for the WebGL backend.`)}var CPU_HANDOFF_SIZE_THRESHOLD=128,BEFORE_PAGING_CONSTANT=600;function numMBBeforeWarning(){return env().global.screen==null?1024:env().global.screen.height*env().global.screen.width*window.devicePixelRatio*BEFORE_PAGING_CONSTANT/1024/1024}var MATMUL_SHARED_DIM_THRESHOLD=1e3,MathBackendWebGL=class extends KernelBackend{constructor(gpgpu){super();if(this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.warnedAboutMemory=!1,this.warnedAboutCPUBackend=!1,this.pendingDeletes=0,this.disposed=!1,!env().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(gpgpu==null){let gl=getWebGLContext(env().getNumber("WEBGL_VERSION"));this.binaryCache=getBinaryCache(env().getNumber("WEBGL_VERSION")),this.gpgpu=new GPGPUContext(gl),this.canvas=gl.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=gpgpu,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=gpgpu.gl.canvas;this.textureManager=new TextureManager(this.gpgpu),this.numMBBeforeWarning=numMBBeforeWarning(),this.texData=new DataStorage(this,engine14())}numDataIds(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes}write(values,shape,dtype){if((env().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||env().getBool("DEBUG"))&&this.checkNumericalProblems(values),dtype==="complex64"&&values!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let dataId={};return this.texData.set(dataId,{shape,dtype,values,usage:TextureUsage.UPLOAD,refCount:1,complexParentRefCount:0}),dataId}incRef(dataId){let texData=this.texData.get(dataId);texData.refCount++}decRef(dataId){if(this.texData.has(dataId)){let texData=this.texData.get(dataId);texData.refCount--}}move(dataId,values,shape,dtype){if(env().getBool("DEBUG")&&this.checkNumericalProblems(values),dtype==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(dataId,{shape,dtype,values,usage:TextureUsage.UPLOAD,refCount:1,complexParentRefCount:0})}disposeIntermediateTensorInfo(tensorInfo){let dataId=tensorInfo.dataId;if(this.texData.has(dataId)){let textureData=this.texData.get(dataId);textureData.refCount--,textureData.refCount<1&&this.disposeData(dataId)}}readSync(dataId){let texData=this.texData.get(dataId),{values,dtype,complexTensorInfos,slice:slice19,shape,isPacked}=texData;if(slice19!=null){let program;isPacked?program=new UnaryOpPackedProgram(shape,CLONE):program=new UnaryOpProgram(shape,CLONE);let res=this.runWebGLProgram(program,[{dataId,shape,dtype}],dtype),data=this.readSync(res.dataId);return this.disposeIntermediateTensorInfo(res),data}if(values!=null)return this.convertAndCacheOnCPU(dataId);if(dtype==="string")return values;let shouldTimeProgram=this.activeTimers!=null,start;shouldTimeProgram&&(start=util_exports.now());let result;if(dtype==="complex64"){let realValues=this.readSync(complexTensorInfos.real.dataId),imagValues=this.readSync(complexTensorInfos.imag.dataId);result=backend_util_exports.mergeRealAndImagArrays(realValues,imagValues)}else result=this.getValuesFromTexture(dataId);return shouldTimeProgram&&(this.downloadWaitMs+=util_exports.now()-start),this.convertAndCacheOnCPU(dataId,result)}async read(dataId){if(this.pendingRead.has(dataId)){let subscribers2=this.pendingRead.get(dataId);return new Promise(resolve=>subscribers2.push(resolve))}let texData=this.texData.get(dataId),{values,shape,slice:slice19,dtype,complexTensorInfos,isPacked}=texData;if(slice19!=null){let program;isPacked?program=new UnaryOpPackedProgram(shape,CLONE):program=new UnaryOpProgram(shape,CLONE);let res=this.runWebGLProgram(program,[{dataId,shape,dtype}],dtype),data=this.read(res.dataId);return this.disposeIntermediateTensorInfo(res),data}if(values!=null)return this.convertAndCacheOnCPU(dataId);if(!env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&env().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let buffer10=null,tmpDownloadTarget;if(dtype!=="complex64"&&env().get("WEBGL_BUFFER_SUPPORTED")){tmpDownloadTarget=this.decode(dataId);let tmpData=this.texData.get(tmpDownloadTarget.dataId);buffer10=this.gpgpu.createBufferFromTexture(tmpData.texture,...getDenseTexShape(shape))}this.pendingRead.set(dataId,[]),dtype!=="complex64"&&await this.gpgpu.createAndWaitForFence();let vals;if(dtype==="complex64"){let ps=await Promise.all([this.read(complexTensorInfos.real.dataId),this.read(complexTensorInfos.imag.dataId)]),realValues=ps[0],imagValues=ps[1];vals=backend_util_exports.mergeRealAndImagArrays(realValues,imagValues)}else if(buffer10==null)vals=this.getValuesFromTexture(dataId);else{let size=util_exports.sizeFromShape(shape);vals=this.gpgpu.downloadFloat32MatrixFromBuffer(buffer10,size)}tmpDownloadTarget!=null&&this.disposeIntermediateTensorInfo(tmpDownloadTarget);let dTypeVals=this.convertAndCacheOnCPU(dataId,vals),subscribers=this.pendingRead.get(dataId);return this.pendingRead.delete(dataId),subscribers.forEach(resolve=>resolve(dTypeVals)),this.pendingDisposal.has(dataId)&&(this.pendingDisposal.delete(dataId),this.disposeData(dataId),this.pendingDeletes--),dTypeVals}checkNumericalProblems(values){if(values==null)return;for(let i=0;i<values.length;i++){let num=values[i];if(!canBeRepresented(num))throw env().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${num} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${num} cannot be represented on this device.`)}}getValuesFromTexture(dataId){let{shape,dtype,isPacked}=this.texData.get(dataId),size=util_exports.sizeFromShape(shape);if(env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let tmpTarget=this.decode(dataId),tmpData2=this.texData.get(tmpTarget.dataId),vals2=this.gpgpu.downloadMatrixFromPackedTexture(tmpData2.texture,...getDenseTexShape(shape)).subarray(0,size);return this.disposeIntermediateTensorInfo(tmpTarget),vals2}let shouldUsePackedProgram=env().getBool("WEBGL_PACK")&&isPacked===!0,outputShape=shouldUsePackedProgram?getShapeAs3D(shape):shape,program=shouldUsePackedProgram?new EncodeFloatPackedProgram(outputShape):new EncodeFloatProgram(outputShape),output=this.runWebGLProgram(program,[{shape:outputShape,dtype,dataId}],"float32"),tmpData=this.texData.get(output.dataId),vals=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(tmpData.texture,tmpData.texShape[0],tmpData.texShape[1]).subarray(0,size);return this.disposeIntermediateTensorInfo(output),vals}async time(f){let oldActiveTimers=this.activeTimers,newActiveTimers=[],outerMostTime=!1;this.programTimersStack==null?(this.programTimersStack=newActiveTimers,outerMostTime=!0):this.activeTimers.push(newActiveTimers),this.activeTimers=newActiveTimers,f();let flattenedActiveTimerQueries=util_exports.flatten(this.activeTimers.map(d=>d.query)).filter(d=>d!=null),flattenedActiveTimerNames=util_exports.flatten(this.activeTimers.map(d=>d.name)).filter(d=>d!=null);this.activeTimers=oldActiveTimers,outerMostTime&&(this.programTimersStack=null);let res={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let kernelMs=await Promise.all(flattenedActiveTimerQueries);res.kernelMs=util_exports.sum(kernelMs),res.getExtraProfileInfo=()=>kernelMs.map((d,i)=>({name:flattenedActiveTimerNames[i],ms:d})).map(d=>`${d.name}: ${d.ms}`).join(", ")}else res.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,res}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:util_exports.now(),endMs:null}}endTimer(query){return env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),query):(query.endMs=util_exports.now(),query)}async getQueryTime(query){if(env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(query);let timerQuery=query;return timerQuery.endMs-timerQuery.startMs}disposeData(dataId){if(this.pendingDisposal.has(dataId))return;if(this.pendingRead.has(dataId)){this.pendingDisposal.add(dataId),this.pendingDeletes++;return}if(!this.texData.has(dataId))return;if(this.texData.get(dataId).complexParentRefCount>0){this.texData.get(dataId).refCount--;return}this.releaseGPUData(dataId);let{complexTensorInfos}=this.texData.get(dataId);complexTensorInfos!=null&&(this.texData.get(complexTensorInfos.real.dataId).complexParentRefCount--,this.disposeIntermediateTensorInfo(complexTensorInfos.real),this.texData.get(complexTensorInfos.imag.dataId).complexParentRefCount--,this.disposeIntermediateTensorInfo(complexTensorInfos.imag)),this.texData.delete(dataId)}releaseGPUData(dataId){let{texture,dtype,texShape,usage,isPacked,slice:slice19}=this.texData.get(dataId),key=slice19&&slice19.origDataId||dataId,refCount=this.dataRefCount.get(key);refCount>1?this.dataRefCount.set(key,refCount-1):(this.dataRefCount.delete(key),texture!=null&&(this.numBytesInGPU-=this.computeBytes(texShape,dtype),this.textureManager.releaseTexture(texture,texShape,usage,isPacked)));let texData=this.texData.get(dataId);texData.texture=null,texData.texShape=null,texData.isPacked=!1,texData.slice=null}getTexture(dataId){return this.uploadToGPU(dataId),this.texData.get(dataId).texture}getDataInfo(dataId){return this.texData.get(dataId)}getCPUBackend(){return env().getBool("WEBGL_CPU_FORWARD")?(this.cpuBackend==null&&(this.cpuBackend=engine14().findBackend("cpu")),this.cpuBackend):null}shouldExecuteOnCPU(inputs,sizeThreshold=CPU_HANDOFF_SIZE_THRESHOLD){let cpuBackend=this.getCPUBackend();return!this.warnedAboutCPUBackend&&cpuBackend==null&&(console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance."),this.warnedAboutCPUBackend=!0),cpuBackend!=null&&inputs.every(input2=>this.texData.get(input2.dataId).texture==null&&util_exports.sizeFromShape(input2.shape)<sizeThreshold)}getGPGPUContext(){return this.gpgpu}slice(x,begin,size){if(this.shouldExecuteOnCPU([x])){let outValues=sliceImplCPU(this.texData.get(x.dataId).values,begin,size,x.shape,x.dtype);return this.makeOutput(size,x.dtype,outValues)}if(util_exports.sizeFromShape(size)===0)return tensor4([],size,x.dtype);let{isPacked}=this.texData.get(x.dataId),isContinous=slice_util_exports.isSliceContinous(x.shape,begin,size);if(isPacked||!isContinous){let program=env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new SlicePackedProgram(size):new SliceProgram(size),customSetup=program.getCustomSetupFunc(begin);return this.compileAndRun(program,[x],null,customSetup)}return this.uploadToGPU(x.dataId),this.shallowSlice(x,begin,size)}shallowSlice(x,begin,size){let xTexData=this.texData.get(x.dataId),t=this.makeOutput(size,x.dtype),newTexData=this.texData.get(t.dataId);Object.assign(newTexData,xTexData),newTexData.shape=size,newTexData.dtype=x.dtype;let flatOffset=slice_util_exports.computeFlatOffset(begin,x.strides);xTexData.slice&&(flatOffset+=xTexData.slice.flatOffset),newTexData.slice={flatOffset,origDataId:xTexData.slice&&xTexData.slice.origDataId||x.dataId};let refCount=this.dataRefCount.get(newTexData.slice.origDataId)||1;return this.dataRefCount.set(newTexData.slice.origDataId,refCount+1),t}stridedSlice(x,begin,end,strides){let cpuRes=this.tryRunOnCpuOrThrow([x],()=>this.cpuBackend.stridedSlice(x,begin,end,strides));if(cpuRes)return cpuRes;let outShape=slice_util_exports.computeOutShape(begin,end,strides);if(outShape.some(axis=>axis===0))return tensor4([],outShape);let program=new StridedSliceProgram(begin,strides,outShape);return this.compileAndRun(program,[x])}reverse(x,axis){let program=env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ReversePackedProgram(x.shape,axis):new ReverseProgram(x.shape,axis);return this.compileAndRun(program,[x])}neg(x){let cpuRes=this.tryRunOnCpuOrThrow([x],()=>this.cpuBackend.neg(x));if(cpuRes)return cpuRes;if(env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(x,NEG,x.dtype);let program=new UnaryOpProgram(x.shape,NEG);return this.compileAndRun(program,[x])}batchMatMul(a,b,transposeA,transposeB){let outerShapeA=transposeA?a.shape[2]:a.shape[1],outerShapeB=transposeB?b.shape[1]:b.shape[2],sharedDim=transposeA?a.shape[1]:a.shape[2],batch=Math.max(a.shape[0],b.shape[0]);if((outerShapeA===1||outerShapeB===1)&&sharedDim>MATMUL_SHARED_DIM_THRESHOLD){transposeA&&(a=transpose(a,[0,2,1])),transposeB&&(b=transpose(b,[0,2,1]));let a3D=outerShapeB===1?a:a.as3D(batch,sharedDim,1),axis=outerShapeB===1?2:1,b3D=outerShapeB===1?b.as3D(batch,1,sharedDim):b,product=mul(a3D,b3D);return product.sum(axis,!0)}let dtype=upcastType(a.dtype,b.dtype),program=new MatMulPackedProgram(a.shape,b.shape,[batch,outerShapeA,outerShapeB],transposeA,transposeB);return this.compileAndRun(program,[a,b],dtype)}fusedBatchMatMul({a,b,transposeA,transposeB,bias,activation,preluActivationWeights}){let outerShapeA=transposeA?a.shape[2]:a.shape[1],outerShapeB=transposeB?b.shape[1]:b.shape[2],batch=Math.max(a.shape[0],b.shape[0]),dtype=upcastType(a.dtype,b.dtype),hasBias=bias!=null,hasPreluActivationWeights=preluActivationWeights!=null,fusedActivation=activation?mapActivationToShaderProgram(activation,!0):null,program=new MatMulPackedProgram(a.shape,b.shape,[batch,outerShapeA,outerShapeB],transposeA,transposeB,hasBias,fusedActivation,hasPreluActivationWeights),inputs=[a,b];return bias&&inputs.push(bias),preluActivationWeights&&inputs.push(preluActivationWeights),this.compileAndRun(program,inputs,dtype)}localResponseNormalization4D(x,radius,bias,alpha,beta){let program=env().getBool("WEBGL_PACK_NORMALIZATION")?new LRNPackedProgram(x.shape,radius,bias,alpha,beta):new LRNProgram(x.shape,radius,bias,alpha,beta);return this.compileAndRun(program,[x])}LRNGrad(dy,inputImage,outputImage,depthRadius,bias,alpha,beta){let program=new LRNGradProgram(inputImage.shape,depthRadius,bias,alpha,beta);return this.compileAndRun(program,[inputImage,outputImage,dy])}tile(x,reps){if(x.dtype==="string"){let data=this.readSync(x.dataId),decodedData=data.map(d=>util_exports.decodeString(d)),buf=buffer(x.shape,x.dtype,decodedData);return tile10(buf,reps)}let program=new TileProgram(x.shape,reps);return this.compileAndRun(program,[x])}pad(x,paddings,constantValue){let program=env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new PadPackedProgram(x.shape,paddings,constantValue):new PadProgram(x.shape,paddings,constantValue);return this.compileAndRun(program,[x])}gather(x,indices,axis){let cpuRes=this.tryRunOnCpuOrThrow([x,indices],()=>this.cpuBackend.gather(x,indices,axis));if(cpuRes)return cpuRes;let program=new GatherProgram(x.shape,indices.size,axis);return this.compileAndRun(program,[x,indices])}batchToSpaceND(x,blockShape,crops){util_exports.assert(x.rank<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let prod5=blockShape.reduce((a,b)=>a*b),reshaped=backend_util_exports.getReshaped(x.shape,blockShape,prod5),permuted=backend_util_exports.getPermuted(reshaped.length,blockShape.length),reshapedPermuted=backend_util_exports.getReshapedPermuted(x.shape,blockShape,prod5),sliceBeginCoords=backend_util_exports.getSliceBeginCoords(crops,blockShape.length),sliceSize=backend_util_exports.getSliceSize(reshapedPermuted,crops,blockShape.length);return transpose(x.reshape(reshaped),permuted).reshape(reshapedPermuted).slice(sliceBeginCoords,sliceSize)}spaceToBatchND(x,blockShape,paddings){util_exports.assert(x.rank<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let prod5=blockShape.reduce((a,b)=>a*b),completePaddings=[[0,0]];completePaddings.push(...paddings);for(let i=1+blockShape.length;i<x.shape.length;++i)completePaddings.push([0,0]);let paddedX=x.pad(completePaddings),reshapedPaddedShape=backend_util_exports.getReshaped(paddedX.shape,blockShape,prod5,!1),permutedReshapedPaddedPermutation=backend_util_exports.getPermuted(reshapedPaddedShape.length,blockShape.length,!1),flattenShape=backend_util_exports.getReshapedPermuted(paddedX.shape,blockShape,prod5,!1),paddedXT=transpose(paddedX.reshape(reshapedPaddedShape),permutedReshapedPaddedPermutation);return reshape(paddedXT,flattenShape)}reduce(x,reduceType,dtype){let batchSize=x.shape[0],inSize=x.shape[1],windowSize=backend_util_exports.computeOptimalWindowSize(inSize),outSize=Math.ceil(inSize/windowSize),reduceInfo={windowSize,inSize,batchSize,outSize},program=new ReduceProgram(reduceInfo,reduceType),output=this.compileAndRun(program,[x],dtype);return output.shape[1]===1?output:this.reduce(output,reduceType,dtype)}argReduce(x,reduceType,bestIndicesA=null){let batchSize=x.shape[0],inSize=x.shape[1];bestIndicesA!=null&&(batchSize=bestIndicesA.shape[0],inSize=bestIndicesA.shape[1]);let windowSize=backend_util_exports.computeOptimalWindowSize(inSize),reduceInfo={windowSize,inSize,batchSize,outSize:Math.ceil(inSize/windowSize)},program=new ArgMinMaxProgram(reduceInfo,reduceType,bestIndicesA==null),inputs=[x];bestIndicesA!=null&&inputs.push(bestIndicesA);let output=this.compileAndRun(program,inputs,"int32");return output.shape[1]===1?output:this.argReduce(x,reduceType,output)}argReducePacked(x,reduceType,bestIndicesA=null){let inShape=bestIndicesA!=null?bestIndicesA.shape:x.shape,inSize=inShape[inShape.length-1],windowSize=backend_util_exports.computeOptimalWindowSize(inSize),program=new ArgMinMaxPackedProgram(inShape,windowSize,reduceType,bestIndicesA==null),inputs=bestIndicesA==null?[x]:[x,bestIndicesA],output=this.compileAndRun(program,inputs,"int32");return output.rank===x.rank?this.argReducePacked(x,reduceType,output):output}sum(x,axes){backend_util_exports.assertAxesAreInnerMostDims("sum",axes,x.rank);let[outShape,reduceShape]=backend_util_exports.computeOutAndReduceShapes(x.shape,axes),inSize=util_exports.sizeFromShape(reduceShape),a2D=x.as2D(-1,inSize),outputDType=sumOutType(x.dtype);return this.reduce(a2D,"sum",outputDType).reshape(outShape)}prod(x,axes){let cpuRes=this.tryRunOnCpuOrThrow([x],()=>this.cpuBackend.prod(x,axes));if(cpuRes)return cpuRes;let[outShape,reduceShape]=backend_util_exports.computeOutAndReduceShapes(x.shape,axes),inSize=util_exports.sizeFromShape(reduceShape),a2D=x.as2D(-1,inSize),outputDType=sumOutType(x.dtype);return this.reduce(a2D,"prod",outputDType).reshape(outShape)}unsortedSegmentSum(x,segmentIds,numSegments){let axis=0,permutation=backend_util_exports.getAxesPermutation([axis],x.rank),permutedX=x;permutation!=null&&(permutedX=transpose(x,permutation),axis=backend_util_exports.getInnerMostAxes(1,x.rank)[0]);let outShape=segment_util2.computeOutShape(permutedX.shape,axis,numSegments),inSize=util_exports.sizeFromShape([permutedX.shape[axis]]),a2D=permutedX.as2D(-1,inSize),outputDType=sumOutType(x.dtype),result=this.segOpCompute(a2D,"unsortedSegmentSum",segmentIds,outputDType,numSegments).reshape(outShape);return permutation!=null&&(result=transpose(result,backend_util_exports.getUndoAxesPermutation(permutation))),result}segOpCompute(x,segOpType,segmentIds,dtype,numSegments){let batchSize=x.shape[0],inSize=x.shape[1],windowSize=segment_util2.segOpComputeOptimalWindowSize(inSize,numSegments),segOpInfo={windowSize,inSize,batchSize,numSegments},program=new SegmentOpProgram(segOpInfo,segOpType),output=this.compileAndRun(program,[x,segmentIds],dtype);return output.shape[1]===numSegments?output:(segmentIds=range(0,numSegments).tile([inSize/windowSize]),this.segOpCompute(output,segOpType,segmentIds,dtype,numSegments))}argMinMaxReduce(x,axis,reduceType){let axes=[axis];if(backend_util_exports.assertAxesAreInnerMostDims("arg"+reduceType.charAt(0).toUpperCase()+reduceType.slice(1),axes,x.rank),!env().getBool("WEBGL_PACK_REDUCE")||x.rank<=2){let[outShape,reduceShape]=backend_util_exports.computeOutAndReduceShapes(x.shape,axes),inSize=util_exports.sizeFromShape(reduceShape),a2D=x.as2D(-1,inSize);return this.argReduce(a2D,reduceType).reshape(outShape)}return this.argReducePacked(x,reduceType)}argMin(x,axis){return this.argMinMaxReduce(x,axis,"min")}argMax(x,axis){return this.argMinMaxReduce(x,axis,"max")}cumsum(x,axis,exclusive,reverse7){if(axis!==x.rank-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${x.rank-1} but got axis=${axis}`);let size=x.shape[axis],result=x;for(let i=0;i<=Math.ceil(Math.log2(size))-1;i++){let program=new CumSumProgram(x.shape,!1,reverse7),customSetup=program.getCustomSetupFunc(i),prevResult=result;result=this.compileAndRun(program,[result],result.dtype,customSetup),prevResult.dispose()}if(exclusive){let program=new CumSumProgram(x.shape,exclusive,reverse7),prevResult=result;result=this.compileAndRun(program,[result]),prevResult.dispose()}return result}equal(a,b){if(env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,EQUAL2,"bool");let program=new BinaryOpProgram(EQUAL,a.shape,b.shape);return this.compileAndRun(program,[a,b],"bool")}less(a,b){let cpuRes=this.tryRunOnCpuOrThrow([a,b],()=>this.cpuBackend.less(a,b));if(cpuRes)return cpuRes;if(env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,LESS2,"bool");let program=new BinaryOpProgram(LESS,a.shape,b.shape);return this.compileAndRun(program,[a,b],"bool")}lessEqual(a,b){if(env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,LESS_EQUAL2,"bool");let program=new BinaryOpProgram(LESS_EQUAL,a.shape,b.shape);return this.compileAndRun(program,[a,b],"bool")}greater(a,b){let cpuRes=this.tryRunOnCpuOrThrow([a,b],()=>this.cpuBackend.greater(a,b));if(cpuRes)return cpuRes;if(env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,GREATER2,"bool");let program=new BinaryOpProgram(GREATER,a.shape,b.shape);return this.compileAndRun(program,[a,b],"bool")}greaterEqual(a,b){if(env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,GREATER_EQUAL2,"bool");let program=new BinaryOpProgram(GREATER_EQUAL,a.shape,b.shape);return this.compileAndRun(program,[a,b],"bool")}logicalNot(x){let program=new UnaryOpProgram(x.shape,LOGICAL_NOT);return this.compileAndRun(program,[x])}logicalAnd(a,b){if(env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,LOGICAL_AND2,"bool");let program=new BinaryOpProgram(LOGICAL_AND,a.shape,b.shape);return this.compileAndRun(program,[a,b],"bool")}logicalOr(a,b){if(env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,LOGICAL_OR2,"bool");let program=new BinaryOpProgram(LOGICAL_OR,a.shape,b.shape);return this.compileAndRun(program,[a,b],"bool")}select(condition,a,b){let program=new SelectProgram(condition.rank,a.shape,a.rank);return this.compileAndRun(program,[condition,a,b],upcastType(a.dtype,b.dtype))}where(condition){backend_util_exports.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let condVals=condition.dataSync();return whereImpl3(condition.shape,condVals)}topk(x,k,sorted){let xVals=x.dataSync();return topkImpl3(xVals,x.shape,x.dtype,k,sorted)}min(x,axes){backend_util_exports.assertAxesAreInnerMostDims("min",axes,x.rank);let[outShape,reduceShape]=backend_util_exports.computeOutAndReduceShapes(x.shape,axes),inSize=util_exports.sizeFromShape(reduceShape),a2D=x.as2D(-1,inSize);return this.reduce(a2D,"min",a2D.dtype).reshape(outShape)}minimum(a,b){let cpuRes=this.tryRunOnCpuOrThrow([a,b],()=>this.cpuBackend.minimum(a,b));if(cpuRes)return cpuRes;let program=env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(MIN2,a.shape,b.shape):new BinaryOpProgram(MIN,a.shape,b.shape);return this.compileAndRun(program,[a,b])}mod(a,b){let program=env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(MOD2,a.shape,b.shape):new BinaryOpProgram(MOD,a.shape,b.shape);return this.compileAndRun(program,[a,b])}maximum(a,b){let cpuRes=this.tryRunOnCpuOrThrow([a,b],()=>this.cpuBackend.maximum(a,b));if(cpuRes)return cpuRes;let program=env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(MAX2,a.shape,b.shape):new BinaryOpProgram(MAX,a.shape,b.shape);return this.compileAndRun(program,[a,b])}all(x,axes){backend_util_exports.assertAxesAreInnerMostDims("all",axes,x.rank);let[outShape,reduceShape]=backend_util_exports.computeOutAndReduceShapes(x.shape,axes),inSize=util_exports.sizeFromShape(reduceShape),a2D=x.as2D(-1,inSize);return this.reduce(a2D,"all",a2D.dtype).reshape(outShape)}any(x,axes){backend_util_exports.assertAxesAreInnerMostDims("any",axes,x.rank);let[outShape,reduceShape]=backend_util_exports.computeOutAndReduceShapes(x.shape,axes),inSize=util_exports.sizeFromShape(reduceShape),a2D=x.as2D(-1,inSize);return this.reduce(a2D,"any",a2D.dtype).reshape(outShape)}floorDiv(a,b){let op2=INT_DIV,outputDtype="int32";if(env().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(a,b,INT_DIV2,outputDtype);let program=new BinaryOpProgram(op2,a.shape,b.shape);return this.compileAndRun(program,[a,b],outputDtype)}packedUnaryOp(x,op2,dtype){let program=new UnaryOpPackedProgram(x.shape,op2);return this.compileAndRun(program,[x],dtype)}packedBinaryOp(a,b,op2,dtype,checkOutOfBounds=!1){let program=new BinaryOpPackedProgram(op2,a.shape,b.shape,checkOutOfBounds);return this.compileAndRun(program,[a,b],dtype)}makeComplexComponentTensorInfo(complexTensor,complexPart){return{dataId:complexPart.dataId,dtype:complexPart.dtype,shape:complexTensor.shape}}addN(tensors){if(tensors.length===1)return tensors[0];if(tensors.length>env().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let midIndex=Math.floor(tensors.length/2),leftSide=this.addN(tensors.slice(0,midIndex)),rightSide=this.addN(tensors.slice(midIndex));return this.addN([leftSide,rightSide])}let dtype=tensors.map(t=>t.dtype).reduce((d1,d2)=>upcastType(d1,d2)),shapes=tensors.map(t=>t.shape),usePackedOp=env().getBool("WEBGL_PACK"),program=usePackedOp?new AddNPackedProgram(tensors[0].shape,shapes):new AddNProgram(tensors[0].shape,shapes);return this.compileAndRun(program,tensors,dtype)}pow(a,b){let usePackedOp=env().getBool("WEBGL_PACK_BINARY_OPERATIONS"),program=usePackedOp?new BinaryOpPackedProgram(POW2,a.shape,b.shape):new BinaryOpProgram(POW,a.shape,b.shape),dtype=upcastType(a.dtype,b.dtype);return this.compileAndRun(program,[a,b],dtype)}ceil(x){if(this.shouldExecuteOnCPU([x])){let outValues=ceilImplCPU(this.texData.get(x.dataId).values,x.dtype);return this.makeOutput(x.shape,x.dtype,outValues)}if(env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(x,CEIL,x.dtype);let program=new UnaryOpProgram(x.shape,CEIL);return this.compileAndRun(program,[x])}floor(x){if(this.shouldExecuteOnCPU([x])){let outValues=floorImplCPU(this.texData.get(x.dataId).values,x.dtype);return this.makeOutput(x.shape,x.dtype,outValues)}if(env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(x,FLOOR,x.dtype);let program=new UnaryOpProgram(x.shape,FLOOR);return this.compileAndRun(program,[x])}sign(x){let program=new UnaryOpProgram(x.shape,SIGN);return this.compileAndRun(program,[x])}isNaN(x){let program=new UnaryOpProgram(x.shape,IS_NAN);return this.compileAndRun(program,[x],"bool")}isInf(x){let program=new UnaryOpProgram(x.shape,IS_INF);return this.compileAndRun(program,[x],"bool")}isFinite(x){let program=new UnaryOpProgram(x.shape,IS_FINITE);return this.compileAndRun(program,[x],"bool")}round(x){let program=new UnaryOpProgram(x.shape,ROUND);return this.compileAndRun(program,[x])}exp(x){if(this.shouldExecuteOnCPU([x])){let outValues=expImplCPU(this.texData.get(x.dataId).values,x.dtype);return this.makeOutput(x.shape,x.dtype,outValues)}if(env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(x,EXP,x.dtype);let program=new UnaryOpProgram(x.shape,EXP);return this.compileAndRun(program,[x])}expm1(x){if(this.shouldExecuteOnCPU([x])){let outValues=expm1ImplCPU(this.texData.get(x.dataId).values,x.dtype);return this.makeOutput(x.shape,x.dtype,outValues)}if(env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(x,EXPM1,x.dtype);let program=new UnaryOpProgram(x.shape,EXPM1);return this.compileAndRun(program,[x])}softmax(logits,dim){let axes=util_exports.parseAxisParam([dim],logits.shape),maxLogit=max(logits,axes),expandedShape=backend_util_exports.expandShapeToKeepDim(maxLogit.shape,axes),a=sub(logits,maxLogit.reshape(expandedShape)),b=this.exp(a),sumExp=this.sum(b,axes).reshape(expandedShape);return div(b,sumExp)}log(x){if(this.shouldExecuteOnCPU([x])){let outValues=logImplCPU(this.texData.get(x.dataId).values,x.dtype);return this.makeOutput(x.shape,x.dtype,outValues)}if(env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(x,LOG2,x.dtype);let program=new UnaryOpProgram(x.shape,LOG);return this.compileAndRun(program,[x])}log1p(x){let program=new UnaryOpProgram(x.shape,LOG1P);return this.compileAndRun(program,[x])}sqrt(x){let program=new UnaryOpProgram(x.shape,SQRT);return this.compileAndRun(program,[x])}rsqrt(x){if(this.shouldExecuteOnCPU([x])){let outValues=rsqrtImplCPU(this.texData.get(x.dataId).values,x.dtype);return this.makeOutput(x.shape,x.dtype,outValues)}let program=new UnaryOpProgram(x.shape,RSQRT);return this.compileAndRun(program,[x])}reciprocal(x){let program=new UnaryOpProgram(x.shape,RECIPROCAL);return this.compileAndRun(program,[x])}relu(x){let program;return env().getBool("WEBGL_PACK")?program=new UnaryOpPackedProgram(x.shape,RELU2):program=new UnaryOpProgram(x.shape,RELU),this.compileAndRun(program,[x])}relu6(x){let program;return env().getBool("WEBGL_PACK")?program=new UnaryOpPackedProgram(x.shape,RELU62):program=new UnaryOpProgram(x.shape,RELU6),this.compileAndRun(program,[x])}prelu(x,alpha){let program=env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(PRELU2,x.shape,alpha.shape):new BinaryOpProgram(PRELU,x.shape,alpha.shape);return this.compileAndRun(program,[x,alpha])}elu(x){if(env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(x,ELU3,x.dtype);let program=new UnaryOpProgram(x.shape,ELU2);return this.compileAndRun(program,[x])}eluDer(dy,y){let program=env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(ELU_DER2,dy.shape,y.shape):new BinaryOpProgram(ELU_DER,dy.shape,y.shape);return this.compileAndRun(program,[dy,y])}selu(x){let program=new UnaryOpProgram(x.shape,SELU);return this.compileAndRun(program,[x])}clip(x,min7,max9){let program;env().getBool("WEBGL_PACK_CLIP")?program=new ClipPackedProgram(x.shape):program=new ClipProgram(x.shape);let customSetup=program.getCustomSetupFunc(min7,max9);return this.compileAndRun(program,[x],null,customSetup)}abs(x){if(this.shouldExecuteOnCPU([x])&&x.dtype!=="complex64"){let outValues=simpleAbsImplCPU(this.texData.get(x.dataId).values);return this.makeOutput(x.shape,x.dtype,outValues)}if(env().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(x,ABS,x.dtype);let program=new UnaryOpProgram(x.shape,ABS);return this.compileAndRun(program,[x])}complexAbs(x){let xData=this.texData.get(x.dataId),program=new ComplexAbsProgram(x.shape),inputs=[this.makeComplexComponentTensorInfo(x,xData.complexTensorInfos.real),this.makeComplexComponentTensorInfo(x,xData.complexTensorInfos.imag)];return this.compileAndRun(program,inputs)}sigmoid(x){let program=new UnaryOpProgram(x.shape,SIGMOID);return this.compileAndRun(program,[x])}softplus(x){let program=new UnaryOpProgram(x.shape,SOFTPLUS);return this.compileAndRun(program,[x])}asin(x){let program=new UnaryOpProgram(x.shape,ASIN);return this.compileAndRun(program,[x])}acos(x){let program=new UnaryOpProgram(x.shape,ACOS);return this.compileAndRun(program,[x])}atan(x){let program=new UnaryOpProgram(x.shape,ATAN);return this.compileAndRun(program,[x])}sinh(x){let program=new UnaryOpProgram(x.shape,SINH);return this.compileAndRun(program,[x])}cosh(x){let program=new UnaryOpProgram(x.shape,COSH);return this.compileAndRun(program,[x])}tanh(x){let program=new UnaryOpProgram(x.shape,TANH);return this.compileAndRun(program,[x])}asinh(x){let program=new UnaryOpProgram(x.shape,ASINH);return this.compileAndRun(program,[x])}acosh(x){let program=new UnaryOpProgram(x.shape,ACOSH);return this.compileAndRun(program,[x])}atanh(x){let program=new UnaryOpProgram(x.shape,ATANH);return this.compileAndRun(program,[x])}erf(x){let program=new UnaryOpProgram(x.shape,ERF);return this.compileAndRun(program,[x])}step(x,alpha){let program=new UnaryOpProgram(x.shape,STEP(alpha));return this.compileAndRun(program,[x])}conv2dByMatMul(x,filter,convInfo,bias,activation,preluActivationWeights){let xShape=x.shape,xTexData=this.texData.get(x.dataId),sharedMatMulDim=convInfo.inChannels,outerShapeX=xShape[0]*xShape[1]*xShape[2],outerShapeFilter=convInfo.outChannels,isChannelsLast=convInfo.dataFormat==="channelsLast",transposeA=!1,transposeB=!1,batchMatMulWillBeUnpacked=(outerShapeX===1||outerShapeFilter===1)&&sharedMatMulDim>MATMUL_SHARED_DIM_THRESHOLD,reshapeWillBeExpensive=xShape[2]%2!==0&&!!xTexData.isPacked;if(batchMatMulWillBeUnpacked||!env().getBool("WEBGL_LAZILY_UNPACK")||!env().getBool("WEBGL_PACK_BINARY_OPERATIONS")||!reshapeWillBeExpensive){let targetShape2=isChannelsLast?xShape[0]*xShape[1]*xShape[2]:xShape[0]*xShape[2]*xShape[3],xReshaped2=reshape(x,[1,targetShape2,convInfo.inChannels]),filterReshaped2=reshape(filter,[1,convInfo.inChannels,convInfo.outChannels]),result=this.fusedBatchMatMul({a:xReshaped2,b:filterReshaped2,transposeA,transposeB,bias,activation,preluActivationWeights});return reshape(result,convInfo.outShape)}let targetShape=isChannelsLast?xShape[0]*xShape[1]*(xShape[2]+1):xShape[0]*xShape[2]*(xShape[3]+1),xReshaped={dataId:x.dataId,shape:[1,targetShape,convInfo.inChannels],dtype:x.dtype},originalXTexDataShape=xTexData.shape;xTexData.shape=xTexData.shape.slice(),xTexData.shape[xTexData.shape.length-2]++,util_exports.assert(isReshapeFree(xTexData.shape,xReshaped.shape),()=>`packed reshape ${xTexData.shape} to ${xReshaped.shape} isn't free`);let filterReshaped=reshape(filter,[1,convInfo.inChannels,convInfo.outChannels]),pointwiseConv=this.fusedBatchMatMul({a:xReshaped,b:filterReshaped,transposeA,transposeB,bias,activation,preluActivationWeights}),pointwiseConvTexData=this.texData.get(pointwiseConv.dataId);return util_exports.assert(pointwiseConvTexData.isPacked,()=>"batchMatMul result is expected to be packed"),xTexData.shape=originalXTexDataShape,pointwiseConvTexData.shape=convInfo.outShape,engine14().makeTensorFromDataId(pointwiseConv.dataId,convInfo.outShape,pointwiseConv.dtype)}conv2dWithIm2Row(x,filter,convInfo,bias,activation,preluActivationWeights){let{filterWidth,filterHeight,inChannels,outWidth,outHeight,dataFormat}=convInfo,isChannelsLast=dataFormat==="channelsLast",sharedDim=filterWidth*filterHeight*inChannels,numCols=outHeight*outWidth,x2ColShape=[sharedDim,numCols],transposeA=!0,transposeB=!1,xSqueezed=x.squeeze([0]),w2Row=filter.reshape([1,sharedDim,-1]),im2ColProgram=new Im2ColPackedProgram(x2ColShape,xSqueezed.shape,convInfo),im2Col=this.compileAndRun(im2ColProgram,[xSqueezed]).reshape([1,x2ColShape[0],x2ColShape[1]]),hasBias=bias!=null,hasPreluActivationWeights=preluActivationWeights!=null,fusedActivation=activation?mapActivationToShaderProgram(activation,!0):null,matmulProgram=new MatMulPackedProgram(im2Col.shape,w2Row.shape,[1,numCols,convInfo.outChannels],transposeA,transposeB,hasBias,fusedActivation,hasPreluActivationWeights),inputs=[im2Col,w2Row];bias&&inputs.push(bias),hasPreluActivationWeights&&inputs.push(preluActivationWeights);let product=this.compileAndRun(matmulProgram,inputs);return isChannelsLast?product.reshape([1,outHeight,outWidth,convInfo.outChannels]):product.reshape([1,convInfo.outChannels,outHeight,outWidth])}fusedConv2d({input:input2,filter,convInfo,bias,activation,preluActivationWeights}){if(convInfo.filterHeight===1&&convInfo.filterWidth===1&&convInfo.dilationHeight===1&&convInfo.dilationWidth===1&&convInfo.strideHeight===1&&convInfo.strideWidth===1&&(convInfo.padInfo.type==="SAME"||convInfo.padInfo.type==="VALID"))return this.conv2dByMatMul(input2,filter,convInfo,bias,activation,preluActivationWeights);if(env().getBool("WEBGL_CONV_IM2COL")&&input2.shape[0]===1)return this.conv2dWithIm2Row(input2,filter,convInfo,bias,activation,preluActivationWeights);let hasBias=bias!=null,hasPreluActivationWeights=preluActivationWeights!=null,fusedActivation=activation?mapActivationToShaderProgram(activation,!1):null,program=new Conv2DProgram(convInfo,hasBias,fusedActivation,hasPreluActivationWeights),inputs=[input2,filter];return bias&&inputs.push(bias),preluActivationWeights&&inputs.push(preluActivationWeights),this.compileAndRun(program,inputs)}conv2d(x,filter,convInfo){if(convInfo.filterHeight===1&&convInfo.filterWidth===1&&convInfo.dilationHeight===1&&convInfo.dilationWidth===1&&convInfo.strideHeight===1&&convInfo.strideWidth===1&&(convInfo.padInfo.type==="SAME"||convInfo.padInfo.type==="VALID"))return this.conv2dByMatMul(x,filter,convInfo);if(env().getBool("WEBGL_CONV_IM2COL")&&x.shape[0]===1)return this.conv2dWithIm2Row(x,filter,convInfo);let program=new Conv2DProgram(convInfo);return this.compileAndRun(program,[x,filter])}conv2dDerInput(dy,filter,convInfo){let program=new Conv2DDerInputProgram(convInfo);return this.compileAndRun(program,[dy,filter])}conv2dDerFilter(x,dy,convInfo){let program=new Conv2DDerFilterProgram(convInfo);return this.compileAndRun(program,[x,dy])}fusedDepthwiseConv2D({input:input2,filter,convInfo,bias,activation,preluActivationWeights}){let shouldPackDepthwiseConv=env().getBool("WEBGL_PACK_DEPTHWISECONV")&&convInfo.strideWidth<=2&&convInfo.outChannels/convInfo.inChannels===1,fusedActivation=activation?mapActivationToShaderProgram(activation,shouldPackDepthwiseConv):null,inputs=[input2,filter],hasBias=bias!=null,hasPreluActivationWeights=preluActivationWeights!=null;hasBias&&inputs.push(bias),hasPreluActivationWeights&&inputs.push(preluActivationWeights);let program;return shouldPackDepthwiseConv?(program=new DepthwiseConvPacked2DProgram(convInfo,hasBias,fusedActivation,hasPreluActivationWeights),this.compileAndRun(program,inputs)):(program=new DepthwiseConv2DProgram(convInfo,hasBias,fusedActivation,hasPreluActivationWeights),this.compileAndRun(program,inputs))}depthwiseConv2D(x,filter,convInfo){let program;return env().getBool("WEBGL_PACK_DEPTHWISECONV")&&convInfo.strideWidth<=2&&convInfo.outChannels/convInfo.inChannels===1?(program=new DepthwiseConvPacked2DProgram(convInfo),this.compileAndRun(program,[x,filter])):(program=new DepthwiseConv2DProgram(convInfo),this.compileAndRun(program,[x,filter]))}depthwiseConv2DDerInput(dy,filter,convInfo){let program=new DepthwiseConv2DDerInputProgram(convInfo);return this.compileAndRun(program,[dy,filter])}depthwiseConv2DDerFilter(x,dy,convInfo){let program=new DepthwiseConv2DDerFilterProgram(convInfo);return this.compileAndRun(program,[x,dy])}conv3d(x,filter,convInfo){let program=new Conv3DProgram(convInfo);return this.compileAndRun(program,[x,filter])}conv3dDerInput(dy,filter,convInfo){let program=new Conv3DDerInputProgram(convInfo);return this.compileAndRun(program,[dy,filter])}conv3dDerFilter(x,dy,convInfo){let program=new Conv3DDerFilterProgram(convInfo);return this.compileAndRun(program,[x,dy])}unstack(x,axis){let num=x.shape[axis],outShape=new Array(x.rank-1),outIndex=0;for(let i=0;i<x.rank;i++)i!==axis&&(outShape[outIndex++]=x.shape[i]);let begin=new Array(x.rank).fill(0),size=x.shape.slice();size[axis]=1;let res=new Array(num);for(let i=0;i<res.length;i++)begin[axis]=i,res[i]=this.slice(x,begin,size).reshape(outShape);return res}avgPool3d(x,convInfo){let program=new Pool3DProgram(convInfo,"avg",!1);return this.compileAndRun(program,[x],"float32")}avgPool3dBackprop(dy,x,convInfo){let avgPool3dBackpropProgram=new AvgPool3DBackpropProgram(convInfo);return this.compileAndRun(avgPool3dBackpropProgram,[dy],x.dtype)}maxPool3d(x,convInfo){let program=new Pool3DProgram(convInfo,"max",!1);return this.compileAndRun(program,[x],"float32")}maxPool3dBackprop(dy,x,y,convInfo){let getPositions=!0,maxPool3dPositionsProgram=new Pool3DProgram(convInfo,"max",getPositions),maxPool3dPositions=this.compileAndRun(maxPool3dPositionsProgram,[x]),maxPool3dBackPropProgram=new MaxPool3DBackpropProgram(convInfo),result=this.compileAndRun(maxPool3dBackPropProgram,[dy,maxPool3dPositions],x.dtype);return maxPool3dPositions.dispose(),result}resizeBilinear(x,newHeight,newWidth,alignCorners){let program=env().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ResizeBilinearPackedProgram(x.shape,newHeight,newWidth,alignCorners):new ResizeBilinearProgram(x.shape,newHeight,newWidth,alignCorners);return this.compileAndRun(program,[x],"float32")}resizeBilinearBackprop(dy,x,alignCorners){let program=new ResizeBilinearBackpropProgram(dy,x,alignCorners);return this.compileAndRun(program,[dy])}resizeNearestNeighbor(x,newHeight,newWidth,alignCorners){let program=new ResizeNearestNeighborProgram(x.shape,newHeight,newWidth,alignCorners);return this.compileAndRun(program,[x])}resizeNearestNeighborBackprop(dy,x,alignCorners){let program=new ResizeNearestNeigborBackpropProgram(dy,x,alignCorners);return this.compileAndRun(program,[dy])}multinomial(logits,normalized,numSamples,seed){let probs=normalized?logits:softmax(logits),batchSize=probs.shape[0],numOutcomes=probs.shape[1],program=new MultinomialProgram(batchSize,numOutcomes,numSamples),customSetup=program.getCustomSetupFunc(seed);return this.compileAndRun(program,[probs],"int32",customSetup)}oneHot(indices,depth,onValue,offValue){let program=new OneHotProgram(indices.size,depth,onValue,offValue);return this.compileAndRun(program,[indices])}diag(x){let program=new DiagProgram(x.size);return this.compileAndRun(program,[x])}cropAndResize(image3,boxes,boxIndex,cropSize,method,extrapolationValue){let program=new CropAndResizeProgram(image3.shape,boxes.shape,cropSize,method,extrapolationValue);return this.compileAndRun(program,[image3,boxes,boxIndex],"float32")}depthToSpace(x,blockSize,dataFormat){util_exports.assert(blockSize>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);let batchSize=x.shape[0],inputHeight=dataFormat==="NHWC"?x.shape[1]:x.shape[2],inputWidth=dataFormat==="NHWC"?x.shape[2]:x.shape[3],inputDepth=dataFormat==="NHWC"?x.shape[3]:x.shape[1],outputHeight=inputHeight*blockSize,outputWidth=inputWidth*blockSize,outputDepth=inputDepth/(blockSize*blockSize),outputShape=dataFormat==="NHWC"?[batchSize,outputHeight,outputWidth,outputDepth]:[batchSize,outputDepth,outputHeight,outputWidth],program=new DepthToSpaceProgram(outputShape,blockSize,dataFormat);return this.compileAndRun(program,[x])}split(x,sizeSplits,axis){return split11(x,sizeSplits,axis)}scatterND(indices,updates,shape){let{sliceRank,numUpdates,sliceSize,strides,outputSize}=backend_util_exports.calculateShapes(updates,indices,shape),flattenShape=[outputSize/sliceSize,sliceSize],flattenIndices=indices.reshape([numUpdates,sliceRank]),flattenX=updates.reshape([numUpdates,sliceSize]);if(outputSize===0)return backend_util_exports.reshapeTensor(tensor4([]),shape);let defaultValue=scalar(0),program=new ScatterProgram(numUpdates,sliceRank,flattenIndices.rank,flattenX.rank,strides,flattenShape),res=this.compileAndRun(program,[flattenX,flattenIndices,defaultValue]);return res.reshape(shape)}sparseToDense(sparseIndices,sparseValues,outputShape,defaultValue){let{sliceRank,numUpdates,strides,outputSize}=backend_util_exports.calculateShapes(sparseValues,sparseIndices,outputShape),sumDupeIndices=!1,program=new ScatterProgram(numUpdates,sliceRank,sparseIndices.rank,sparseValues.rank,strides,[outputSize,1],sumDupeIndices),res=this.compileAndRun(program,[sparseValues,sparseIndices,defaultValue]);return res.reshape(outputShape)}gatherND(x,indices){let indicesShape=indices.shape,sliceRank=indicesShape[indicesShape.length-1],[resultShape,numSlices,sliceSize,strides]=backend_util_exports.prepareAndValidate(x,indices),flattenIndices=indices.reshape([numSlices,sliceRank]),flattenX=x.reshape([x.size/sliceSize,sliceSize]),program=new GatherNDProgram(sliceRank,strides,[numSlices,sliceSize]),res=this.compileAndRun(program,[flattenX,flattenIndices]);return res.reshape(resultShape)}fill(shape,value,dtype){if(dtype=dtype||util_exports.inferDtype(value),dtype==="string"){let values=util_exports.getArrayFromDType(dtype,util_exports.sizeFromShape(shape));return values.fill(value),engine14().makeTensor(values,shape,dtype,this)}else{let program=new FillProgram(shape,value),customSetup=program.getCustomSetupFunc(value);return this.compileAndRun(program,[],dtype,customSetup)}}onesLike(x){if(x.dtype==="string")throw new Error("onesLike is not supported under string dtype");return this.fill(x.shape,1,x.dtype)}zerosLike(x){return this.fill(x.shape,x.dtype==="string"?"":0,x.dtype)}linspace(start,stop,num){return backend_util_exports.linspaceImpl(start,stop,num)}makeTensorInfo(shape,dtype,values){let dataId=this.write(values,shape,dtype);return this.texData.get(dataId).usage=null,{dataId,shape,dtype}}makeOutput(shape,dtype,values){let{dataId}=this.makeTensorInfo(shape,dtype,values);return engine14().makeTensorFromDataId(dataId,shape,dtype,this)}unpackTensor(input2){let program=new UnpackProgram(input2.shape);return this.runWebGLProgram(program,[input2],input2.dtype)}packTensor(input2){let program=new PackProgram(input2.shape),preventEagerUnpackingOutput=!0;return this.runWebGLProgram(program,[input2],input2.dtype,null,preventEagerUnpackingOutput)}packedReshape(input2,afterShape){let input3DShape=[getBatchDim(input2.shape),...getRowsCols(input2.shape)],input3D={dtype:input2.dtype,shape:input3DShape,dataId:input2.dataId},afterShapeAs3D=[getBatchDim(afterShape),...getRowsCols(afterShape)],program=new ReshapePackedProgram(afterShapeAs3D,input3DShape),preventEagerUnpackingOfOutput=!0,output=this.runWebGLProgram(program,[input3D],input2.dtype,null,preventEagerUnpackingOfOutput);return{dataId:output.dataId,shape:afterShape,dtype:output.dtype}}decode(dataId){let texData=this.texData.get(dataId),{isPacked,shape,dtype}=texData,shapeAs3D=getShapeAs3D(shape),program;isPacked?program=new DecodeMatrixPackedProgram(shapeAs3D):program=new DecodeMatrixProgram(shapeAs3D);let preventEagerUnpackingOfOutput=!0,out=this.runWebGLProgram(program,[{shape:shapeAs3D,dtype,dataId}],dtype,null,preventEagerUnpackingOfOutput);return{dtype,shape,dataId:out.dataId}}runWebGLProgram(program,inputs,outputDtype,customSetup,preventEagerUnpackingOfOutput=!1){let output=this.makeTensorInfo(program.outputShape,outputDtype),outData=this.texData.get(output.dataId);if(program.packedOutput&&(outData.isPacked=!0),program.outPackingScheme===PackingScheme.DENSE){let texelShape=getDenseTexShape(program.outputShape);outData.texShape=texelShape.map(d=>d*2)}if(program.outTexUsage!=null&&(outData.usage=program.outTexUsage),util_exports.sizeFromShape(output.shape)===0)return outData.values=util_exports.getTypedArrayFromDType(output.dtype,0),output;let dataToDispose=[],inputsData=inputs.map(input2=>{if(input2.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let texData=this.texData.get(input2.dataId);if(texData.texture==null){if(!program.packedInputs&&util_exports.sizeFromShape(input2.shape)<=env().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:input2.shape,texData:null,isUniform:!0,uniformValues:texData.values};program.packedInputs&&(texData.isPacked=!0,texData.shape=input2.shape)}else if(!!texData.isPacked!==!!program.packedInputs)input2=texData.isPacked?this.unpackTensor(input2):this.packTensor(input2),dataToDispose.push(input2),texData=this.texData.get(input2.dataId);else if(texData.isPacked&&!isReshapeFree(texData.shape,input2.shape)){let savedInput=input2,targetShape=input2.shape;input2.shape=texData.shape,input2=this.packedReshape(input2,targetShape),dataToDispose.push(input2),texData=this.texData.get(input2.dataId),savedInput.shape=targetShape}return this.uploadToGPU(input2.dataId),{shape:input2.shape,texData,isUniform:!1}});this.uploadToGPU(output.dataId);let outputData={shape:output.shape,texData:outData,isUniform:!1},key=makeShaderKey(program,inputsData,outputData),binary=this.getAndSaveBinary(key,()=>compileProgram(this.gpgpu,program,inputsData,outputData)),shouldTimeProgram=this.activeTimers!=null,query;if(shouldTimeProgram&&(query=this.startTimer()),runProgram(this.gpgpu,binary,inputsData,outputData,customSetup),dataToDispose.forEach(info=>this.disposeIntermediateTensorInfo(info)),shouldTimeProgram&&(query=this.endTimer(query),this.activeTimers.push({name:program.constructor.name,query:this.getQueryTime(query)})),!env().getBool("WEBGL_LAZILY_UNPACK")&&outData.isPacked&&preventEagerUnpackingOfOutput===!1){let unpacked=this.unpackTensor(output);return this.disposeIntermediateTensorInfo(output),unpacked}return output}compileAndRun(program,inputs,outputDtype,customSetup,preventEagerUnpackingOfOutput=!1){outputDtype=outputDtype||inputs[0].dtype;let outInfo=this.runWebGLProgram(program,inputs,outputDtype,customSetup,preventEagerUnpackingOfOutput);return engine14().makeTensorFromDataId(outInfo.dataId,outInfo.shape,outInfo.dtype)}getAndSaveBinary(key,getBinary){return key in this.binaryCache||(this.binaryCache[key]=getBinary()),this.binaryCache[key]}getTextureManager(){return this.textureManager}dispose(){if(this.disposed)return;if(!env().getBool("IS_TEST")){let allKeys=Object.keys(this.binaryCache);allKeys.forEach(key=>{this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram),delete this.binaryCache[key]})}this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=tidy(()=>{if(!env().get("WEBGL_RENDER_FLOAT32_ENABLED")){let debugFlag=env().getBool("DEBUG");env().set("DEBUG",!1);let underflowCheckValue=this.abs(scalar(1e-8)).dataSync()[0];if(env().set("DEBUG",debugFlag),underflowCheckValue>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?EPSILON_FLOAT322:EPSILON_FLOAT162}uploadToGPU(dataId){let texData=this.texData.get(dataId),{shape,dtype,values,texture,usage,isPacked}=texData;if(texture!=null)return;let shouldTimeProgram=this.activeTimers!=null,start;shouldTimeProgram&&(start=util_exports.now());let texShape=texData.texShape;if(texShape==null&&(texShape=getTextureShapeFromLogicalShape(shape,isPacked),texData.texShape=texShape),values!=null){let shapeAs3D=getShapeAs3D(shape),program,width=texShape[1],height=texShape[0],isByteArray=values instanceof Uint8Array;isPacked?([width,height]=getPackedMatrixTextureShapeWidthHeight(texShape[0],texShape[1]),program=new EncodeMatrixPackedProgram(shapeAs3D,[height,width],isByteArray)):program=new EncodeMatrixProgram(shapeAs3D,[height,width],isByteArray);let tempDenseInputHandle=this.makeTensorInfo([height,width],dtype);isByteArray?this.texData.get(tempDenseInputHandle.dataId).usage=TextureUsage.PIXELS:this.texData.get(tempDenseInputHandle.dataId).usage=TextureUsage.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(tempDenseInputHandle.dataId),width,height,values);let preventEagerUnpacking=!0,encodedOutputTarget=this.runWebGLProgram(program,[tempDenseInputHandle],dtype,null,preventEagerUnpacking),outputTexData=this.texData.get(encodedOutputTarget.dataId);texData.texture=outputTexData.texture,texData.texShape=outputTexData.texShape,texData.isPacked=outputTexData.isPacked,texData.usage=outputTexData.usage,this.disposeIntermediateTensorInfo(tempDenseInputHandle),this.texData.delete(encodedOutputTarget.dataId),texData.values=null,shouldTimeProgram&&(this.uploadWaitMs+=util_exports.now()-start)}else{let newTexture=this.acquireTexture(texShape,usage,dtype,isPacked);texData.texture=newTexture}}convertAndCacheOnCPU(dataId,float32Values){let texData=this.texData.get(dataId),{dtype}=texData;return this.releaseGPUData(dataId),float32Values!=null&&(texData.values=float32ToTypedArray(float32Values,dtype)),texData.values}acquireTexture(texShape,texType,dtype,isPacked){if(this.numBytesInGPU+=this.computeBytes(texShape,dtype),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let mb=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${mb} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(texShape,texType,isPacked)}computeBytes(shape,dtype){return shape[0]*shape[1]*util_exports.bytesPerElement(dtype)}tryRunOnCpuOrThrow(inputs,fn){if(this.shouldExecuteOnCPU(inputs))try{return fn()}catch(e){if(env().getBool("IS_TEST"))throw new Error("CPU forwarding failed")}return null}};function float32ToTypedArray(a,dtype){if(dtype==="float32"||dtype==="complex64")return a;if(dtype==="int32"||dtype==="bool"){let result=dtype==="int32"?new Int32Array(a.length):new Uint8Array(a.length);for(let i=0;i<result.length;++i)result[i]=Math.round(a[i]);return result}else throw new Error(`Unknown dtype ${dtype}`)}var version12="2.7.0";function forceHalfFloat(){env().set("WEBGL_FORCE_F16_TEXTURES",!0)}device_util_exports.isBrowser()&&registerBackend("webgl",()=>new MathBackendWebGL,2);var webgl2={forceHalfFloat};function identity2(args){let{inputs,backend:backend3}=args,{x}=inputs;return backend3.incRef(x.dataId),{dataId:x.dataId,shape:x.shape,dtype:x.dtype}}var identityConfig2={kernelName:Identity,backendName:"webgl",kernelFunc:identity2};function complex10(args){let{inputs,backend:backend3}=args,{real:real8,imag:imag8}=inputs,complexInfo=backend3.makeTensorInfo(real8.shape,"complex64"),complex11=backend3.texData.get(complexInfo.dataId),realTensorInfo=identity2({inputs:{x:real8},backend:backend3}),realData=backend3.texData.get(realTensorInfo.dataId);realData.complexParentRefCount++;let imagTensorInfo=identity2({inputs:{x:imag8},backend:backend3}),imagData=backend3.texData.get(imagTensorInfo.dataId);return imagData.complexParentRefCount++,complex11.complexTensorInfos={real:realTensorInfo,imag:imagTensorInfo},complexInfo}var complexConfig2={kernelName:Complex,backendName:"webgl",kernelFunc:complex10};var CHECK_NAN_SNIPPET_UNARY="if (isnan(x)) return x;",CHECK_NAN_SNIPPET_BINARY=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,CHECK_NAN_SNIPPET_BINARY_PACKED=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;function unaryKernelFunc2(opSnippet){return({inputs,backend:backend3})=>{let{x}=inputs,webglBackend=backend3,program=new UnaryOpProgram(x.shape,opSnippet);return webglBackend.runWebGLProgram(program,[x],x.dtype)}}function binaryKernelFunc2({opSnippet,packedOpSnippet,checkOutOfBounds=!1,supportsComplex=!1,cpuKernelImpl,dtype}){return({inputs,backend:backend3})=>{let{a,b}=inputs,webglBackend=backend3;if(supportsComplex&&a.dtype==="complex64"){let aData=webglBackend.texData.get(a.dataId),bData=webglBackend.texData.get(b.dataId),[real8,imag8]=[[aData.complexTensorInfos.real,bData.complexTensorInfos.real],[aData.complexTensorInfos.imag,bData.complexTensorInfos.imag]].map(complexParts=>{let[aPart,bPart]=complexParts,aHandle={dataId:aPart.dataId,dtype:aPart.dtype,shape:a.shape},bHandle={dataId:bPart.dataId,dtype:bPart.dtype,shape:b.shape},program2=new BinaryOpProgram(opSnippet,a.shape,b.shape);return webglBackend.runWebGLProgram(program2,[aHandle,bHandle],upcastType(aPart.dtype,bPart.dtype))}),complexOutput=complex10({inputs:{real:real8,imag:imag8},backend:webglBackend});return webglBackend.disposeIntermediateTensorInfo(real8),webglBackend.disposeIntermediateTensorInfo(imag8),complexOutput}let $dtype=dtype||upcastType(a.dtype,b.dtype);if(webglBackend.shouldExecuteOnCPU([a,b])&&cpuKernelImpl!=null){let aData=webglBackend.texData.get(a.dataId),bData=webglBackend.texData.get(b.dataId),[outValues,outShape]=cpuKernelImpl(a.shape,b.shape,aData.values,bData.values,$dtype),out=webglBackend.makeTensorInfo(outShape,$dtype),outData=webglBackend.texData.get(out.dataId);return outData.values=outValues,out}let shouldUsePackedProgram=env().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&packedOpSnippet!=null,program;return shouldUsePackedProgram?program=new BinaryOpPackedProgram(packedOpSnippet,a.shape,b.shape,checkOutOfBounds):program=new BinaryOpProgram(opSnippet,a.shape,b.shape),webglBackend.runWebGLProgram(program,[a,b],$dtype)}}var ADD="return a + b;",addKernelFunc=binaryKernelFunc2({opSnippet:ADD,packedOpSnippet:ADD,supportsComplex:!0,cpuKernelImpl:addImplCPU}),addConfig2={kernelName:Add,backendName:"webgl",kernelFunc:addKernelFunc};var ATAN2=CHECK_NAN_SNIPPET_BINARY+`
  return atan(a, b);
`,ATAN2_PACKED=`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+CHECK_NAN_SNIPPET_BINARY_PACKED+`
  return result;
`,atan25=binaryKernelFunc2({opSnippet:ATAN2,packedOpSnippet:ATAN2_PACKED}),atan2Config={kernelName:Atan2,backendName:"webgl",kernelFunc:atan25};function avgPool3(args){let{inputs,backend:backend3,attrs}=args,{x}=inputs;assertNotComplex2(x,"avgPool");let{filterSize,strides,pad:pad6,dimRoundingMode}=attrs,dilations=1;util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides,dilations),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);let convInfo=backend_util_exports.computePool2DInfo(x.shape,filterSize,strides,dilations,pad6,dimRoundingMode);if(convInfo.filterWidth===1&&convInfo.filterHeight===1&&util_exports.arraysEqual(convInfo.inShape,convInfo.outShape))return identity2({inputs:{x},backend:backend3});let avgPoolProgram=new Pool2DProgram(convInfo,"avg",!1);return backend3.runWebGLProgram(avgPoolProgram,[x],"float32")}var avgPoolConfig2={kernelName:AvgPool,backendName:"webgl",kernelFunc:avgPool3};function avgPoolBackprop3(args){let{inputs,backend:backend3,attrs}=args,{dy,input:input2}=inputs,x=input2;assertNotComplex2([dy,input2],"avgPoolBackprop");let{filterSize,strides,pad:pad6}=attrs,convInfo=backend_util_exports.computePool2DInfo(x.shape,filterSize,strides,1,pad6),avgPoolBackpropProgram=new AvgPool2DBackpropProgram(convInfo);return backend3.runWebGLProgram(avgPoolBackpropProgram,[dy],x.dtype)}var avgPoolBackpropConfig2={kernelName:AvgPoolBackprop,backendName:"webgl",kernelFunc:avgPoolBackprop3};var BatchNormProgram=class{constructor(xShape,meanShape,varianceShape,offsetShape,scaleShape,varianceEpsilon){this.outputShape=[],this.variableNames=["x","mean","variance"],backend_util_exports.assertAndGetBroadcastShape(xShape,meanShape),backend_util_exports.assertAndGetBroadcastShape(xShape,varianceShape);let offsetSnippet="0.0";offsetShape!=null&&(backend_util_exports.assertAndGetBroadcastShape(xShape,offsetShape),this.variableNames.push("offset"),offsetSnippet="getOffsetAtOutCoords()");let scaleSnippet="1.0";scaleShape!=null&&(backend_util_exports.assertAndGetBroadcastShape(xShape,scaleShape),this.variableNames.push("scale"),scaleSnippet="getScaleAtOutCoords()"),this.outputShape=xShape,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${offsetSnippet};
        float scale = ${scaleSnippet};
        float inv = scale * inversesqrt(variance + float(${varianceEpsilon}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};var BatchNormPackedProgram=class{constructor(xShape,meanShape,varianceShape,offsetShape,scaleShape,varianceEpsilon){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],backend_util_exports.assertAndGetBroadcastShape(xShape,meanShape),backend_util_exports.assertAndGetBroadcastShape(xShape,varianceShape);let offsetSnippet="vec4(0.0)";offsetShape!=null&&(backend_util_exports.assertAndGetBroadcastShape(xShape,offsetShape),this.variableNames.push("offset"),offsetSnippet="getOffsetAtOutCoords()");let scaleSnippet="vec4(1.0)";scaleShape!=null&&(backend_util_exports.assertAndGetBroadcastShape(xShape,scaleShape),this.variableNames.push("scale"),scaleSnippet="getScaleAtOutCoords()"),this.outputShape=xShape,this.userCode=`
      void main() {
        vec4 offset = ${offsetSnippet};
        vec4 scale = ${scaleSnippet};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${varianceEpsilon}));

        setOutput((x - mean) * inv + offset);
      }
    `}};var batchNorm3=({inputs,backend:backend3,attrs})=>{let{x,mean:mean7,variance,offset,scale:scale2}=inputs;util_exports.assert(mean7.shape.length===variance.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),util_exports.assert(offset==null||mean7.shape.length===offset.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),util_exports.assert(scale2==null||mean7.shape.length===scale2.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon}=attrs;varianceEpsilon==null&&(varianceEpsilon=.001);let finalInputs=[x,mean7,variance],offsetShape=null;offset!=null&&(offsetShape=offset.shape,finalInputs.push(offset));let scaleShape=null;scale2!=null&&(scaleShape=scale2.shape,finalInputs.push(scale2));let program=env().getBool("WEBGL_PACK_NORMALIZATION")?new BatchNormPackedProgram(x.shape,mean7.shape,variance.shape,offsetShape,scaleShape,varianceEpsilon):new BatchNormProgram(x.shape,mean7.shape,variance.shape,offsetShape,scaleShape,varianceEpsilon),output=backend3.runWebGLProgram(program,finalInputs,finalInputs[0].dtype);return output},batchNormConfig2={kernelName:FusedBatchNorm,backendName:"webgl",kernelFunc:batchNorm3};var NOT_EQUAL="return float(a != b);",notEqual3=binaryKernelFunc2({opSnippet:NOT_EQUAL,dtype:"bool"}),notEqualConfig2={kernelName:NotEqual,backendName:"webgl",kernelFunc:notEqual3};function real7(args){let{inputs,backend:backend3}=args,{input:input2}=inputs,inputData=backend3.texData.get(input2.dataId);return identity2({inputs:{x:inputData.complexTensorInfos.real},backend:backend3})}var realConfig2={kernelName:Real,backendName:"webgl",kernelFunc:real7};var TO_INT="return float(int(x));";function int(input2,backend3){let program=new UnaryOpProgram(input2.shape,TO_INT),output=backend3.runWebGLProgram(program,[input2],"int32");return{dataId:output.dataId,shape:output.shape,dtype:output.dtype}}function cast49(args){let{inputs,backend:backend3,attrs}=args,{x}=inputs,{dtype}=attrs;if(dtype==="complex64"){if(x.dtype==="complex64")return identity2({inputs:{x},backend:backend3});let zerosTensor=zeros(x.shape),floatX=cast49({inputs:{x},backend:backend3,attrs:{dtype:"float32"}}),result=complex10({inputs:{real:floatX,imag:zerosTensor},backend:backend3});return zerosTensor.dispose(),backend3.disposeIntermediateTensorInfo(floatX),result}if(x.dtype==="complex64"){let realPart=real7({inputs:{input:x},backend:backend3}),result=cast49({inputs:{x:realPart},backend:backend3,attrs:{dtype}});return backend3.disposeIntermediateTensorInfo(realPart),result}if(!util_exports.hasEncodingLoss(x.dtype,dtype)){let result=identity2({inputs:{x},backend:backend3});return{dataId:result.dataId,shape:result.shape,dtype}}if(dtype==="int32")return int(x,backend3);if(dtype==="bool"){let zerosTensorInfo=backend3.makeTensorInfo([],"bool",util_exports.getTypedArrayFromDType("bool",1)),binaryInputs={a:x,b:zerosTensorInfo},result=notEqual3({inputs:binaryInputs,backend:backend3});return backend3.disposeIntermediateTensorInfo(zerosTensorInfo),result}throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`)}var castConfig2={kernelName:Cast,backendName:"webgl",kernelFunc:cast49};var ConcatProgram=class{constructor(shapes){this.outputShape=[],this.outputShape=backend_util_exports.computeOutShape(shapes,1),this.variableNames=shapes.map((_,i)=>`T${i}`);let offsets=new Array(shapes.length-1);offsets[0]=shapes[0][1];for(let i=1;i<offsets.length;i++)offsets[i]=offsets[i-1]+shapes[i][1];let snippets=[`if (yC < ${offsets[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<offsets.length;i++){let shift=offsets[i-1];snippets.push(`else if (yC < ${offsets[i]}) setOutput(getT${i}(yR, yC-${shift}));`)}let lastIndex=offsets.length,lastShift=offsets[offsets.length-1];snippets.push(`else setOutput(getT${lastIndex}(yR, yC-${lastShift}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${snippets.join(`
        `)}
      }
    `}};var ConcatPackedProgram=class{constructor(shapes,axis){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=backend_util_exports.computeOutShape(shapes,axis);let shape=this.outputShape,rank=shape.length,dtype=getCoordsDataType(rank),coords2=getChannels("coords",rank),channels=["x","y","z","w","u","v"].slice(0,rank);this.variableNames=shapes.map((_,i)=>`T${i}`);let offsets=new Array(shapes.length-1);offsets[0]=shapes[0][axis];for(let i=1;i<offsets.length;i++)offsets[i]=offsets[i-1]+shapes[i][axis];let channel=channels[axis],lastChannels=channels.slice(-2),allChannels=channels.join(),getValueSnippet=`if (${channel} < ${offsets[0]}) {
        return getChannel(
            getT0(${allChannels}), vec2(${lastChannels.join()}));
        }`;for(let i=1;i<offsets.length;i++){let shift2=offsets[i-1];getValueSnippet+=`
        if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i-1]}) {
          return getChannel(
            getT${i}(${shiftedChannels(channels,channel,shift2)}),
            vec2(${shiftedChannels(lastChannels,channel,shift2)}));
        }`}let lastIndex=offsets.length,shift=offsets[offsets.length-1];getValueSnippet+=`
        return getChannel(
          getT${lastIndex}(${shiftedChannels(channels,channel,shift)}),
          vec2(${shiftedChannels(lastChannels,channel,shift)}));`,this.userCode=`
      float getValue(${channels.map(x=>"int "+x)}) {
        ${getValueSnippet}
      }

      void main() {
        ${dtype} coords = getOutputCoords();
        vec4 result = vec4(getValue(${coords2}), 0., 0., 0.);

        ${coords2[rank-1]} = ${coords2[rank-1]} + 1;
        if (${coords2[rank-1]} < ${shape[rank-1]}) {
          result.g = getValue(${coords2});
        }

        ${coords2[rank-2]} = ${coords2[rank-2]} + 1;
        if (${coords2[rank-2]} < ${shape[rank-2]}) {
          result.a = getValue(${coords2});
        }

        ${coords2[rank-1]} = ${coords2[rank-1]} - 1;
        if (${coords2[rank-2]} < ${shape[rank-2]} &&
            ${coords2[rank-1]} < ${shape[rank-1]}) {
          result.b = getValue(${coords2});
        }
        setOutput(result);
      }
    `}};function shiftedChannels(channels,channel,shift){let channelIdx=channels.indexOf(channel),res=channels.map((c,idx)=>idx===channelIdx?`${c} - ${shift}`:c);return res.join()}function imag7(args){let{inputs,backend:backend3}=args,{input:input2}=inputs,inputData=backend3.texData.get(input2.dataId);return identity2({inputs:{x:inputData.complexTensorInfos.imag},backend:backend3})}var imagConfig2={kernelName:Imag,backendName:"webgl",kernelFunc:imag7};function packedReshape(input2,afterShape,backend3){let input3DShape=[getBatchDim(input2.shape),...getRowsCols(input2.shape)],input3D={dtype:input2.dtype,shape:input3DShape,dataId:input2.dataId},afterShapeAs3D=[getBatchDim(afterShape),...getRowsCols(afterShape)],program=new ReshapePackedProgram(afterShapeAs3D,input3DShape),preventEagerUnpackingOfOutput=!0,output=backend3.runWebGLProgram(program,[input3D],input2.dtype,null,preventEagerUnpackingOfOutput);return{dataId:output.dataId,shape:afterShape,dtype:output.dtype}}function reshape85(args){let{inputs,backend:backend3,attrs}=args,{x}=inputs,{shape}=attrs,webglBackend=backend3,xSize=util_exports.sizeFromShape(x.shape),$shape=util_exports.inferFromImplicitShape(shape,xSize),$xSize=util_exports.sizeFromShape($shape);util_exports.assert(xSize===$xSize,()=>`The new shape (${$shape}) has ${$xSize} elements and the old shape (${x.shape}) has ${xSize} elements. The new shape and old shape must have the same number of elements.`);let xTexData=webglBackend.texData.get(x.dataId);return xTexData.isPacked&&!isReshapeFree(x.shape,$shape)&&!(xTexData.texture!==null&&isReshapeFree(xTexData.shape,$shape))?packedReshape(x,$shape,webglBackend):(webglBackend.incRef(x.dataId),{dataId:x.dataId,shape:$shape,dtype:x.dtype})}var reshapeConfig2={kernelName:Reshape,backendName:"webgl",kernelFunc:reshape85};function concatImpl(inputs,axis,backend3){let dtype=inputs[0].dtype;if(dtype==="complex64"){let reals=inputs.map(t=>real7({inputs:{input:t},backend:backend3})),imags=inputs.map(t=>imag7({inputs:{input:t},backend:backend3})),realConcated=concatImpl(reals,axis,backend3),imagConcated=concatImpl(imags,axis,backend3),result2=complex10({inputs:{real:realConcated,imag:imagConcated},backend:backend3});return reals.forEach(r=>backend3.disposeIntermediateTensorInfo(r)),imags.forEach(i=>backend3.disposeIntermediateTensorInfo(i)),backend3.disposeIntermediateTensorInfo(realConcated),backend3.disposeIntermediateTensorInfo(imagConcated),result2}if(inputs.length>env().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let midIndex=Math.floor(inputs.length/2),leftSide=concatImpl(inputs.slice(0,midIndex),axis,backend3),rightSide=concatImpl(inputs.slice(midIndex),axis,backend3),result2=concatImpl([leftSide,rightSide],axis,backend3);return backend3.disposeIntermediateTensorInfo(leftSide),backend3.disposeIntermediateTensorInfo(rightSide),result2}if(env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&inputs[0].shape.length>1){let program2=new ConcatPackedProgram(inputs.map(t=>t.shape),axis);return backend3.runWebGLProgram(program2,inputs,dtype)}let outShape=backend_util_exports.computeOutShape(inputs.map(t=>t.shape),axis),tensors2D=inputs.map(x=>reshape85({inputs:{x},attrs:{shape:[-1,util_exports.sizeFromShape(x.shape.slice(axis))]},backend:backend3})),program=new ConcatProgram(tensors2D.map(t=>t.shape)),result=backend3.runWebGLProgram(program,tensors2D,dtype);tensors2D.forEach(r=>backend3.disposeIntermediateTensorInfo(r));let reshapedResult=reshape85({inputs:{x:result},attrs:{shape:outShape},backend:backend3});return backend3.disposeIntermediateTensorInfo(result),reshapedResult}function concat17(args){let{inputs,backend:backend3,attrs}=args,{axis}=attrs,$axis=util_exports.parseAxisParam(axis,inputs[0].shape)[0],outShape=backend_util_exports.computeOutShape(inputs.map(t=>t.shape),$axis);if(util_exports.sizeFromShape(outShape)===0)return backend3.makeTensorInfo(outShape,inputs[0].dtype,[]);let $inputs=inputs.filter(t=>util_exports.sizeFromShape(t.shape)>0);if($inputs.length===1)return $inputs[0];let shapes=$inputs.map(t=>t.shape);return backend_util_exports.assertParamsConsistent(shapes,$axis),concatImpl($inputs,$axis,backend3)}var concatConfig2={kernelName:Concat,backendName:"webgl",kernelFunc:concat17};var COS=CHECK_NAN_SNIPPET_UNARY+`
  return cos(x);
`,cos7=unaryKernelFunc2(COS),cosConfig2={kernelName:Cos,backendName:"webgl",kernelFunc:cos7};var DIV=`
if (a == b) {
  return 1.0;
};
return a / b;`,DIV_PACKED=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,div35=binaryKernelFunc2({opSnippet:DIV,packedOpSnippet:DIV_PACKED,checkOutOfBounds:!0}),divConfig2={kernelName:Div,backendName:"webgl",kernelFunc:div35};var FFTProgram=class{constructor(component,inputShape,inverse){this.variableNames=["real","imag"];let innerDim=inputShape[1];this.outputShape=inputShape;let exponentMultiplierSnippet=inverse?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,resultDenominator=inverse?`${innerDim}.0`:"1.0",opString;if(component==="real")opString="return real * expR - imag * expI;";else if(component==="imag")opString="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${component}.`);this.userCode=`
      const float exponentMultiplier = ${exponentMultiplierSnippet};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${opString}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${innerDim});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${innerDim}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${resultDenominator};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function fftImpl2(x,inverse,backend3){let xData=backend3.texData.get(x.dataId),inputSize=util_exports.sizeFromShape(x.shape),innerDimensionSize=x.shape[x.shape.length-1],batch=inputSize/innerDimensionSize,input2D=reshape85({inputs:{x},backend:backend3,attrs:{shape:[batch,innerDimensionSize]}}),xShape=input2D.shape,realProgram=new FFTProgram("real",xShape,inverse),imagProgram=new FFTProgram("imag",xShape,inverse),inputs=[{dataId:xData.complexTensorInfos.real.dataId,dtype:xData.complexTensorInfos.real.dtype,shape:xShape},{dataId:xData.complexTensorInfos.imag.dataId,dtype:xData.complexTensorInfos.imag.dtype,shape:xShape}],realPart=backend3.runWebGLProgram(realProgram,inputs,"float32"),imagPart=backend3.runWebGLProgram(imagProgram,inputs,"float32"),complexOutput=complex10({inputs:{real:realPart,imag:imagPart},backend:backend3});backend3.disposeIntermediateTensorInfo(realPart),backend3.disposeIntermediateTensorInfo(imagPart);let complexOutputReshaped=reshape85({inputs:{x:complexOutput},backend:backend3,attrs:{shape:x.shape}});return backend3.disposeIntermediateTensorInfo(complexOutputReshaped),complexOutputReshaped}function fft7(args){let{inputs,backend:backend3}=args,{input:input2}=inputs;return fftImpl2(input2,!1,backend3)}var fftConfig2={kernelName:FFT,backendName:"webgl",kernelFunc:fft7};var FlipLeftRightProgram=class{constructor(imageShape){this.variableNames=["Image"],this.outputShape=[];let imageWidth=imageShape[2];this.outputShape=imageShape,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${imageWidth} - x;
          float outputValue;
          if(coordX >= 0 && coordX < ${imageWidth}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var flipLeftRightConfig2={kernelName:FlipLeftRight,backendName:"webgl",kernelFunc:({inputs,backend:backend3})=>{let{image:image3}=inputs,webglBackend=backend3,program=new FlipLeftRightProgram(image3.shape),output=webglBackend.runWebGLProgram(program,[image3],image3.dtype);return output}};var FromPixelsProgram=class{constructor(outputShape){this.variableNames=["A"];let glsl=getGlslDifferences(),[height,width]=outputShape;this.outputShape=outputShape,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${width}.0, ${height}.0);

        vec4 values = ${glsl.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};var FromPixelsPackedProgram=class{constructor(outputShape){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let glsl=getGlslDifferences(),[height,width]=outputShape;this.outputShape=outputShape,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${width}.0, ${height}.0);
            vec4 values = ${glsl.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${glsl.output} = result;
      }
    `}};var fromPixelsConfig={kernelName:FromPixels,backendName:"webgl",kernelFunc:fromPixels2},fromPixels2DContext2;function fromPixels2(args){let{inputs,backend:backend3,attrs}=args,{pixels}=inputs,{numChannels}=attrs,isVideo=typeof HTMLVideoElement!="undefined"&&pixels instanceof HTMLVideoElement,isImage=typeof HTMLImageElement!="undefined"&&pixels instanceof HTMLImageElement,[width,height]=isVideo?[pixels.videoWidth,pixels.videoHeight]:[pixels.width,pixels.height],texShape=[height,width],outShape=[height,width,numChannels];(isImage||isVideo)&&(fromPixels2DContext2==null&&(fromPixels2DContext2=document.createElement("canvas").getContext("2d")),fromPixels2DContext2.canvas.width=width,fromPixels2DContext2.canvas.height=height,fromPixels2DContext2.drawImage(pixels,0,0,width,height),pixels=fromPixels2DContext2.canvas);let tempPixelHandle=backend3.makeTensorInfo(texShape,"int32");backend3.texData.get(tempPixelHandle.dataId).usage=TextureUsage.PIXELS,backend3.gpgpu.uploadPixelDataToTexture(backend3.getTexture(tempPixelHandle.dataId),pixels);let program=env().getBool("WEBGL_PACK")?new FromPixelsPackedProgram(outShape):new FromPixelsProgram(outShape),res=backend3.runWebGLProgram(program,[tempPixelHandle],"int32");return backend3.disposeData(tempPixelHandle.dataId),res}function ifft7(args){let{inputs,backend:backend3}=args,{input:input2}=inputs;return fftImpl2(input2,!0,backend3)}var ifftConfig2={kernelName:IFFT,backendName:"webgl",kernelFunc:ifft7};var MeanProgram=class{constructor(reduceInfo,divisor){this.variableNames=["x"];let{windowSize,batchSize,inSize,outSize}=reduceInfo;this.outputShape=[batchSize,outSize];let windowSizeNearestVec4=Math.floor(windowSize/4)*4,windowSizeVec4Remainder=windowSize%4,updateSnippet="sumValue += dot(values, ones);";if(divisor!=null){let denominator=1/divisor;updateSnippet=`sumValue += dot(values * ${util_exports.isInt(denominator)?denominator.toPrecision(2):denominator}, ones);`}let checkOutOfBounds="";inSize%windowSize>0&&(checkOutOfBounds=`
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${checkOutOfBounds}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        float sumValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${updateSnippet}
        }
        setOutput(sumValue);
      }
    `}};function getReductionStages(inShape){let stages=[];for(;stages.length===0||stages[stages.length-1].outSize!==1;){let outSize=stages.length?stages[stages.length-1].outSize:inShape[1],windowSize=backend_util_exports.computeOptimalWindowSize(outSize);stages.push({inSize:outSize,windowSize,outSize:Math.ceil(outSize/windowSize)})}return stages}function reduce(x,dtype,reductionType,backend3){let reductionStages=getReductionStages(x.shape),result=x;for(let i=0;i<reductionStages.length;i++){let{inSize,windowSize,outSize}=reductionStages[i],program,previousResult;reductionType==="mean"?program=i===0?new MeanProgram({windowSize,inSize,batchSize:x.shape[0],outSize},inSize):new MeanProgram({windowSize,inSize,batchSize:x.shape[0],outSize}):program=new ReduceProgram({windowSize,inSize,batchSize:x.shape[0],outSize},reductionType),previousResult=result,result=backend3.runWebGLProgram(program,[result],dtype),previousResult.dataId!==x.dataId&&backend3.disposeIntermediateTensorInfo(previousResult)}return result}function maxImpl2(x,reduceShape,outShape,backend3){let inSize=util_exports.sizeFromShape(reduceShape),xSize=util_exports.sizeFromShape(x.shape),batchSize=xSize/inSize,reshapedInput=reshape85({inputs:{x},attrs:{shape:[batchSize,inSize]},backend:backend3}),reduced=reduce(reshapedInput,x.dtype,"max",backend3),reshapedOutput=reshape85({inputs:{x:reduced},attrs:{shape:outShape},backend:backend3});return backend3.disposeIntermediateTensorInfo(reshapedInput),backend3.disposeIntermediateTensorInfo(reduced),reshapedOutput}var TransposeProgram=class{constructor(aShape,newDim){this.variableNames=["A"];let outputShape=new Array(aShape.length);for(let i=0;i<outputShape.length;i++)outputShape[i]=aShape[newDim[i]];this.outputShape=outputShape,this.rank=outputShape.length;let dtype=getCoordsDataType(this.rank),switched=getSwitchedCoords(newDim);this.userCode=`
    void main() {
      ${dtype} resRC = getOutputCoords();
      setOutput(getA(${switched}));
    }
    `}};function getSwitchedCoords(newDim){let rank=newDim.length;if(rank>6)throw Error(`Transpose for rank ${rank} is not yet supported`);let originalOrder=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],switchedCoords=new Array(rank);for(let i=0;i<newDim.length;i++)switchedCoords[newDim[i]]=originalOrder[i];return switchedCoords.join()}var TransposePackedProgram=class{constructor(aShape,newDim){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let outputShape=new Array(aShape.length);for(let i=0;i<outputShape.length;i++)outputShape[i]=aShape[newDim[i]];if(this.outputShape=outputShape,this.rank=outputShape.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let dtype=getCoordsDataType(this.rank),outputOrder=getVecChannels("rc",this.rank),switchedOrder=new Array(this.rank);for(let i=0;i<newDim.length;i++)switchedOrder[newDim[i]]=outputOrder[i];let innerDims=`vec2(${switchedOrder.slice(-2).join()})`,nextColumn=`++${outputOrder[this.rank-1]} < ${outputShape[this.rank-1]}`,getc=`getChannel(getA(${switchedOrder.join()}), ${innerDims})`;this.userCode=`
    void main() {
      ${dtype} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${getc};
      if(${nextColumn}) {
        result[1] = ${getc};
      }
      --${outputOrder[this.rank-1]};
      if(++${outputOrder[this.rank-2]} < ${outputShape[this.rank-2]}) {
        result[2] = ${getc};
        if(${nextColumn}) {
          result[3] = ${getc};
        }
      }
      setOutput(result);
    }
    `}};function transposeImpl2(x,perm,backend3){let program=env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new TransposePackedProgram(x.shape,perm):new TransposeProgram(x.shape,perm);return backend3.runWebGLProgram(program,[x],x.dtype)}var maxConfig2={kernelName:Max,backendName:"webgl",kernelFunc:({inputs,attrs,backend:backend3})=>{let{x}=inputs,{reductionIndices,keepDims}=attrs,webglBackend=backend3,xRank=x.shape.length,origAxes=util_exports.parseAxisParam(reductionIndices,x.shape),axes=origAxes,permutedAxes=backend_util_exports.getAxesPermutation(axes,xRank),maxInputIsTransposed=permutedAxes!=null,shouldExecuteOnCPU=webglBackend.shouldExecuteOnCPU([x]),maxInput=x;if(maxInputIsTransposed){if(shouldExecuteOnCPU){let xTexData=webglBackend.texData.get(maxInput.dataId),values=xTexData.values,newShape=new Array(xRank);for(let i=0;i<newShape.length;i++)newShape[i]=x.shape[permutedAxes[i]];let maxInputValues=transposeImplCPU(values,x.shape,x.dtype,permutedAxes,newShape);maxInput=webglBackend.makeTensorInfo(newShape,x.dtype);let maxInputData=webglBackend.texData.get(maxInput.dataId);maxInputData.values=maxInputValues}else maxInput=transposeImpl2(x,permutedAxes,webglBackend);axes=backend_util_exports.getInnerMostAxes(axes.length,xRank)}backend_util_exports.assertAxesAreInnerMostDims("max",axes,xRank);let[maxOutShape,reduceShape]=backend_util_exports.computeOutAndReduceShapes(maxInput.shape,axes),outShape=maxOutShape;keepDims&&(outShape=backend_util_exports.expandShapeToKeepDim(maxOutShape,origAxes));let out;if(shouldExecuteOnCPU){let xTexData=webglBackend.texData.get(maxInput.dataId),values=xTexData.values,outValues=maxImplCPU(values,util_exports.sizeFromShape(reduceShape),outShape,x.dtype);out=webglBackend.makeTensorInfo(outShape,x.dtype);let outData=webglBackend.texData.get(out.dataId);outData.values=outValues}else out=maxImpl2(maxInput,reduceShape,outShape,webglBackend);return maxInputIsTransposed&&webglBackend.disposeIntermediateTensorInfo(maxInput),out}};function maxPool3(args){let{inputs,backend:backend3,attrs}=args,{x}=inputs;assertNotComplex2(x,"maxPool");let{filterSize,strides,pad:pad6,dimRoundingMode}=attrs,dilations=1;util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides,dilations),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);let convInfo=backend_util_exports.computePool2DInfo(x.shape,filterSize,strides,dilations,pad6,dimRoundingMode);if(convInfo.filterWidth===1&&convInfo.filterHeight===1&&util_exports.arraysEqual(convInfo.inShape,convInfo.outShape))return identity2({inputs:{x},backend:backend3});let maxPoolProgram=new Pool2DProgram(convInfo,"max",!1);return backend3.runWebGLProgram(maxPoolProgram,[x],x.dtype)}var maxPoolConfig2={kernelName:MaxPool,backendName:"webgl",kernelFunc:maxPool3};function maxPoolBackprop3(args){let{inputs,backend:backend3,attrs}=args,{dy,input:input2,output}=inputs,x=input2;assertNotComplex2([input2,output],"maxPoolBackprop");let{filterSize,strides,pad:pad6,dimRoundingMode}=attrs,convInfo=backend_util_exports.computePool2DInfo(x.shape,filterSize,strides,1,pad6,dimRoundingMode),getPositions=!0,maxPoolPositionsProgram=new Pool2DProgram(convInfo,"max",getPositions),maxPoolPositions2=backend3.runWebGLProgram(maxPoolPositionsProgram,[x],x.dtype),maxPoolBackPropProgram=new MaxPool2DBackpropProgram(convInfo),result=backend3.runWebGLProgram(maxPoolBackPropProgram,[dy,maxPoolPositions2],x.dtype);return backend3.disposeIntermediateTensorInfo(maxPoolPositions2),result}var maxPoolBackpropConfig2={kernelName:MaxPoolBackprop,backendName:"webgl",kernelFunc:maxPoolBackprop3};function maxPoolWithArgmaxImpl2(x,includeBatchInIndex,convInfo,backend3){let program=new Pool2DProgram(convInfo,"max",!1),poolOutput=backend3.runWebGLProgram(program,[x],"float32");program=new Pool2DProgram(convInfo,"max",!0,!0,includeBatchInIndex);let indexOutput=backend3.runWebGLProgram(program,[x],"float32");return[poolOutput,indexOutput]}var maxPoolWithArgmaxConfig2={kernelName:MaxPoolWithArgmax,backendName:"webgl",kernelFunc:({inputs,attrs,backend:backend3})=>{let{x}=inputs,{filterSize,strides,pad:pad6,includeBatchInIndex}=attrs,webglBackend=backend3;util_exports.assert(x.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${x.shape.length}.`);let dilations=[1,1];util_exports.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides,dilations),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);let convInfo=backend_util_exports.computePool2DInfo(x.shape,filterSize,strides,dilations,pad6),[result,indexes]=maxPoolWithArgmaxImpl2(x,includeBatchInIndex,convInfo,webglBackend);return[result,indexes]}};function meanImpl(x,reduceShape,outShape,backend3){let inSize=util_exports.sizeFromShape(reduceShape),xSize=util_exports.sizeFromShape(x.shape),batchSize=xSize/inSize,reshapedInput=reshape85({inputs:{x},attrs:{shape:[batchSize,inSize]},backend:backend3}),reduced=reduce(reshapedInput,"float32","mean",backend3),reshapedOutput=reshape85({inputs:{x:reduced},attrs:{shape:outShape},backend:backend3});return backend3.disposeIntermediateTensorInfo(reshapedInput),backend3.disposeIntermediateTensorInfo(reduced),reshapedOutput}var meanConfig={kernelName:Mean,backendName:"webgl",kernelFunc:({inputs,attrs,backend:backend3})=>{let{x}=inputs,{keepDims,axis}=attrs,webglBackend=backend3,xRank=x.shape.length,origAxes=util_exports.parseAxisParam(axis,x.shape),axes=origAxes,permutedAxes=backend_util_exports.getAxesPermutation(axes,xRank),meanInputIsTransposed=permutedAxes!=null,shouldExecuteOnCPU=webglBackend.shouldExecuteOnCPU([x]),intermediates=[],meanInput=x;if(meanInputIsTransposed){if(shouldExecuteOnCPU){let xTexData=webglBackend.texData.get(meanInput.dataId),values=xTexData.values,newShape=new Array(xRank);for(let i=0;i<newShape.length;i++)newShape[i]=x.shape[permutedAxes[i]];let meanInputValues=transposeImplCPU(values,x.shape,x.dtype,permutedAxes,newShape);meanInput=webglBackend.makeTensorInfo(newShape,x.dtype);let meanInputData=webglBackend.texData.get(meanInput.dataId);meanInputData.values=meanInputValues}else meanInput=transposeImpl2(x,permutedAxes,webglBackend);intermediates.push(meanInput),axes=backend_util_exports.getInnerMostAxes(axes.length,xRank)}backend_util_exports.assertAxesAreInnerMostDims("sum",axes,xRank);let[meanOutShape,reduceShape]=backend_util_exports.computeOutAndReduceShapes(meanInput.shape,axes),outShape=meanOutShape;keepDims&&(outShape=backend_util_exports.expandShapeToKeepDim(meanOutShape,origAxes));let out=meanImpl(meanInput,reduceShape,outShape,webglBackend);for(let i of intermediates)webglBackend.disposeIntermediateTensorInfo(i);return out}};var MirrorPadProgram=class{constructor(xShape,paddings,mode){this.variableNames=["x"],this.outputShape=paddings.map((p2,i)=>p2[0]+xShape[i]+p2[1]);let rank=xShape.length,dtype=getCoordsDataType(rank),start=paddings.map(p2=>p2[0]).join(","),end=paddings.map((p2,i)=>p2[0]+xShape[i]).join(","),unpackedCoords=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,rank),offset=mode==="reflect"?0:1;if(rank===1){this.userCode=`
        int start = ${start};
        int end = ${end};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${offset};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${offset};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${dtype} start = ${dtype}(${start});
      ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outC = getOutputCoords();
        for (int i = 0; i < ${rank}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${offset};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${offset};
          }
        }
        ${dtype} coords = outC - start;
        setOutput(getX(${unpackedCoords}));
      }
    `}};var MirrorPadPackedProgram=class{constructor(xShape,paddings,mode){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=paddings.map((p2,i)=>p2[0]+xShape[i]+p2[1]);let rank=xShape.length,dtype=getCoordsDataType(rank),start=paddings.map(p2=>p2[0]).join(","),end=paddings.map((p2,i)=>p2[0]+xShape[i]).join(","),coords2=getChannels("rc",rank),source=getChannels("source",rank),cLimit=`${coords2[rank-1]} < ${this.outputShape[rank-1]}`,innerDims=rank===1?"source":`vec2(${source.slice(-2).join()})`,offset=mode==="reflect"?0:1,mainLoop="";if(rank===1){let padSetup=`
        ${dtype} source = rc;
        if (source < start) {
          source = start * 2 - source - ${offset};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${offset};
        }
        source -= start;
      `;mainLoop=`
        ${dtype} rc = outputLoc;
        ${padSetup}
        result[0] = getChannel(getX(${source.join()}), ${innerDims});
        ${coords2[rank-1]} += 1;
        if(${cLimit}) {
          ${padSetup}
          result[1] = getChannel(getX(${source.join()}), ${innerDims});
        }
      `}else{let padSetup=`
        ${dtype} source = rc;
        ${dtype} lt = ${dtype}(lessThan(source, start));
        ${dtype} gte = ${dtype}(greaterThanEqual(source, end));
        ${dtype} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${offset}) +
                gte * ((end - 1) * 2 - source + ${offset});
        source -= start;
      `;mainLoop=`
        ${dtype} rc = outputLoc;
        ${padSetup}
        result[0] = getChannel(getX(${source.join()}), ${innerDims});
        ${coords2[rank-1]} += 1;
        if(${cLimit}) {
          ${padSetup}
          result[1] = getChannel(getX(${source.join()}), ${innerDims});
        }
        rc = outputLoc;
        ${coords2[rank-2]} += 1;
        if(${coords2[rank-2]} < ${this.outputShape[rank-2]}) {
          ${padSetup}
          result[2] = getChannel(getX(${source.join()}), ${innerDims});
          ${coords2[rank-1]} += 1;
          if(${cLimit}) {
            ${padSetup}
            result[3] = getChannel(getX(${source.join()}), ${innerDims});
          }
        }
      `}this.userCode=`
      const ${dtype} start = ${dtype}(${start});
      const ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${mainLoop}
        setOutput(result);
      }
    `}};var mirrorPadKernelFunc=({inputs,backend:backend3,attrs})=>{let{x}=inputs,{paddings,mode}=attrs,program=env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new MirrorPadPackedProgram(x.shape,paddings,mode):new MirrorPadProgram(x.shape,paddings,mode),output=backend3.runWebGLProgram(program,[x],x.dtype);return output},mirrorPadConfig2={kernelName:MirrorPad,backendName:"webgl",kernelFunc:mirrorPadKernelFunc};var COMPLEX_MULTIPLY={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},BinaryOpComplexProgram=class{constructor(op2,aShape,bShape){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=backend_util_exports.assertAndGetBroadcastShape(aShape,bShape),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${op2}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var MUL="return a * b;";function multiply2(args){let{inputs,backend:backend3}=args,{a,b}=inputs,dtype=backend_util_exports.upcastType(a.dtype,b.dtype);if(a.dtype==="complex64"){let aData=backend3.texData.get(a.dataId),bData=backend3.texData.get(b.dataId),realProgram=new BinaryOpComplexProgram(COMPLEX_MULTIPLY.REAL,a.shape,b.shape),imagProgram=new BinaryOpComplexProgram(COMPLEX_MULTIPLY.IMAG,a.shape,b.shape),inputs2=[{dataId:aData.complexTensorInfos.real.dataId,dtype:aData.complexTensorInfos.real.dtype,shape:a.shape},{dataId:aData.complexTensorInfos.imag.dataId,dtype:aData.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:bData.complexTensorInfos.real.dataId,dtype:bData.complexTensorInfos.real.dtype,shape:b.shape},{dataId:bData.complexTensorInfos.imag.dataId,dtype:bData.complexTensorInfos.imag.dtype,shape:b.shape}],realPart=backend3.runWebGLProgram(realProgram,inputs2,"float32"),imagPart=backend3.runWebGLProgram(imagProgram,inputs2,"float32"),complexOutput=complex10({inputs:{real:realPart,imag:imagPart},backend:backend3});return backend3.disposeIntermediateTensorInfo(realPart),backend3.disposeIntermediateTensorInfo(imagPart),complexOutput}if(backend3.shouldExecuteOnCPU([a,b])){let aData=backend3.texData.get(a.dataId),bData=backend3.texData.get(b.dataId),[outValues,outShape]=multiplyImplCPU(a.shape,b.shape,aData.values,bData.values,dtype),out=backend3.makeTensorInfo(outShape,dtype),outData=backend3.texData.get(out.dataId);return outData.values=outValues,out}let program;return env().getBool("WEBGL_PACK_BINARY_OPERATIONS")?program=new BinaryOpPackedProgram(MUL,a.shape,b.shape):program=new BinaryOpProgram(MUL,a.shape,b.shape),backend3.runWebGLProgram(program,[a,b],dtype)}var multiplyConfig2={kernelName:Multiply,backendName:"webgl",kernelFunc:multiply2};var nonMaxSuppressionV3Config={kernelName:NonMaxSuppressionV3,backendName:"webgl",kernelFunc:({inputs,backend:backend3,attrs})=>{backend_util_exports.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{boxes,scores}=inputs,{maxOutputSize,iouThreshold,scoreThreshold}=attrs,gpuBackend=backend3,boxesVals=gpuBackend.readSync(boxes.dataId),scoresVals=gpuBackend.readSync(scores.dataId),maxOutputSizeVal=maxOutputSize,iouThresholdVal=iouThreshold,scoreThresholdVal=scoreThreshold;return kernel_impls_exports.nonMaxSuppressionV3Impl(boxesVals,scoresVals,maxOutputSizeVal,iouThresholdVal,scoreThresholdVal)}};var nonMaxSuppressionV4Impl3=kernel_impls_exports.nonMaxSuppressionV4Impl,nonMaxSuppressionV4Config2={kernelName:NonMaxSuppressionV4,backendName:"webgl",kernelFunc:({inputs,backend:backend3,attrs})=>{backend_util_exports.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{boxes,scores}=inputs,{maxOutputSize,iouThreshold,scoreThreshold,padToMaxOutputSize}=attrs,gpuBackend=backend3,boxesVals=gpuBackend.readSync(boxes.dataId),scoresVals=gpuBackend.readSync(scores.dataId),{selectedIndices,validOutputs}=nonMaxSuppressionV4Impl3(boxesVals,scoresVals,maxOutputSize,iouThreshold,scoreThreshold,padToMaxOutputSize);return[selectedIndices,validOutputs]}};var nonMaxSuppressionV5Impl3=kernel_impls_exports.nonMaxSuppressionV5Impl,nonMaxSuppressionV5Config2={kernelName:NonMaxSuppressionV5,backendName:"webgl",kernelFunc:({inputs,backend:backend3,attrs})=>{backend_util_exports.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{boxes,scores}=inputs,{maxOutputSize,iouThreshold,scoreThreshold,softNmsSigma}=attrs,gpuBackend=backend3,boxesVals=gpuBackend.readSync(boxes.dataId),scoresVals=gpuBackend.readSync(scores.dataId),maxOutputSizeVal=maxOutputSize,iouThresholdVal=iouThreshold,scoreThresholdVal=scoreThreshold,softNmsSigmaVal=softNmsSigma,{selectedIndices,selectedScores}=nonMaxSuppressionV5Impl3(boxesVals,scoresVals,maxOutputSizeVal,iouThresholdVal,scoreThresholdVal,softNmsSigmaVal);return[selectedIndices,selectedScores]}};var RotateProgram=class{constructor(imageShape,radians,fillValue,center){this.variableNames=["Image"],this.outputShape=[];let imageHeight=imageShape[1],imageWidth=imageShape[2],sinFactor=Math.sin(radians).toFixed(3),cosFactor=Math.cos(radians).toFixed(3);this.outputShape=imageShape;let[centerX,centerY]=backend_util_exports.getImageCenter(center,imageHeight,imageWidth),centerXString=centerX.toFixed(3),centerYString=centerY.toFixed(3),fillSnippet="";typeof fillValue=="number"?fillSnippet=`float outputValue = ${fillValue.toFixed(2)};`:fillSnippet=`
        vec3 fill = vec3(${fillValue.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - ${centerXString}) * ${cosFactor} - (float(y) - ${centerYString}) * ${sinFactor};
          float coordYFloat = (float(x) - ${centerXString}) * ${sinFactor} + (float(y) - ${centerYString}) * ${cosFactor};
          int coordX = int(round(coordXFloat + ${centerXString}));
          int coordY = int(round(coordYFloat + ${centerYString}));
          ${fillSnippet}
          if(coordX >= 0 && coordX < ${imageWidth} && coordY >= 0 && coordY < ${imageHeight}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var rotateWithOffsetConfig2={kernelName:RotateWithOffset,backendName:"webgl",kernelFunc:({inputs,attrs,backend:backend3})=>{let{image:image3}=inputs,{radians,fillValue,center}=attrs,webglBackend=backend3,program=new RotateProgram(image3.shape,radians,fillValue,center),output=webglBackend.runWebGLProgram(program,[image3],image3.dtype);return output}};var SIN=CHECK_NAN_SNIPPET_UNARY+`
  return sin(x);
`,sin6=unaryKernelFunc2(SIN),sinConfig2={kernelName:Sin,backendName:"webgl",kernelFunc:sin6};var SQUARE="return x * x;",square25=unaryKernelFunc2(SQUARE),squareConfig2={kernelName:Square,backendName:"webgl",kernelFunc:square25};var SQUARED_DIFFERENCE="return (a - b) * (a - b);",squaredDifference3=binaryKernelFunc2({opSnippet:SQUARED_DIFFERENCE,packedOpSnippet:SQUARED_DIFFERENCE}),squaredDifferenceConfig2={kernelName:SquaredDifference,backendName:"webgl",kernelFunc:squaredDifference3};var SUB="return a - b;",subKernelFunc=binaryKernelFunc2({opSnippet:SUB,packedOpSnippet:SUB,supportsComplex:!0,cpuKernelImpl:subImplCPU}),subConfig2={kernelName:Sub,backendName:"webgl",kernelFunc:subKernelFunc};var TAN="return tan(x);",tan5=unaryKernelFunc2(TAN),tanConfig2={kernelName:Tan,backendName:"webgl",kernelFunc:tan5};var transposeConfig2={kernelName:Transpose,backendName:"webgl",kernelFunc:({inputs,attrs,backend:backend3})=>{let{x}=inputs,{perm}=attrs,webglBackend=backend3,xRank=x.shape.length,newShape=new Array(xRank);for(let i=0;i<newShape.length;i++)newShape[i]=x.shape[perm[i]];let out;if(webglBackend.shouldExecuteOnCPU([x])){let xTexData=webglBackend.texData.get(x.dataId),values=xTexData.values,outValues=transposeImplCPU(values,x.shape,x.dtype,perm,newShape);out=webglBackend.makeTensorInfo(newShape,x.dtype);let outData=webglBackend.texData.get(out.dataId);outData.values=outValues}else out=transposeImpl2(x,perm,webglBackend);return out}};function unique7(args){let{inputs,attrs,backend:backend3}=args,{axis}=attrs,{x}=inputs;assertNotComplex2(x,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let values=backend3.readSync(x.dataId),{outputValues,outputShape,indices}=uniqueImplCPU(values,axis,x.shape,x.dtype);return[backend3.makeTensorInfo(outputShape,x.dtype,outputValues),backend3.makeTensorInfo([indices.length],"int32",indices)]}var uniqueConfig2={kernelName:Unique,backendName:"webgl",kernelFunc:unique7};var kernelConfigs2=[addConfig2,atan2Config,avgPoolConfig2,avgPoolBackpropConfig2,batchNormConfig2,castConfig2,complexConfig2,concatConfig2,cosConfig2,divConfig2,fftConfig2,flipLeftRightConfig2,fromPixelsConfig,identityConfig2,ifftConfig2,imagConfig2,maxConfig2,maxPoolConfig2,maxPoolBackpropConfig2,maxPoolWithArgmaxConfig2,meanConfig,mirrorPadConfig2,multiplyConfig2,nonMaxSuppressionV3Config,nonMaxSuppressionV4Config2,nonMaxSuppressionV5Config2,notEqualConfig2,realConfig2,reshapeConfig2,rotateWithOffsetConfig2,sinConfig2,squareConfig2,subConfig2,squaredDifferenceConfig2,tanConfig2,transposeConfig2,uniqueConfig2];for(let kernelConfig of kernelConfigs2)registerKernel(kernelConfig);var version14="2.7.0";var version16={"tfjs-core":version,"tfjs-backend-cpu":version10,"tfjs-backend-webgl":version12,"tfjs-data":version8,"tfjs-layers":version2,"tfjs-converter":version6,tfjs:version14};function str(...msg){if(!Array.isArray(msg))return msg;let line="";for(let entry of msg)typeof entry=="object"?line+=JSON.stringify(entry).replace(/{|}|"|\[|\]/g,"").replace(/,/g," "):line+=entry;return line}function log10(...msg){let dt=new Date,ts=`${dt.getHours().toString().padStart(2,"0")}:${dt.getMinutes().toString().padStart(2,"0")}:${dt.getSeconds().toString().padStart(2,"0")}.${dt.getMilliseconds().toString().padStart(3,"0")}`;console.log(ts,...msg),document.getElementById("log").innerHTML+=`${ts} &nbsp ${str(msg)}<br>`}async function main(){log10("ltsm initializing"),await setBackend("webgl"),await enableProdMode();let gl=await backend2().getGPGPUContext().gl;log10("tfjs version:",version,"backend:",getBackend(),"flags:",ENV.flags),log10(`gl version:${gl.getParameter(gl.VERSION)} renderer:${gl.getParameter(gl.RENDERER)}`),await ready()}window.onload=main;
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/** @license See the LICENSE file. */
//# sourceMappingURL=ltsm.js.map
